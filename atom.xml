<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>rovo98&#39;s Blog</title>
  
  <subtitle>Leave your comfort zone!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://rovo98.github.io/"/>
  <updated>2018-11-15T10:48:33.060Z</updated>
  <id>http://rovo98.github.io/</id>
  
  <author>
    <name>rovo98</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>GPG入门使用</title>
    <link href="http://rovo98.github.io/posts/7ea77913/"/>
    <id>http://rovo98.github.io/posts/7ea77913/</id>
    <published>2018-11-14T11:08:30.000Z</published>
    <updated>2018-11-15T10:48:33.060Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><blockquote><p>gpg  is the OpenPGP part of the GNU Privacy Guard (GnuPG). It is a tool to provide digital encryption and signing services using the OpenPGP standard.<br>gpg features: complete key management and all the bells and whistles you would expect from a full OpenPGP implementation.</p></blockquote><div class="note info"><p><code>GnuPG</code>(GPG) 是 基于<code>OpenPGP</code>(由<a href="https://www.ietf.org/rfc/rfc4880.txt" target="_blank" rel="noopener">RFC4880</a>定义,也被称为<code>PGP</code>)的一个完整的和免费的实现.我们可以使用<code>GPG</code>来对我们的数据和通信进行加密(encrypt)和签名(sign), 它具有通用的密钥管理系统，以及各种公钥目录的访问模块. 我们可以很容易地使用<code>GPG</code>提供的命令行工具(当前它还提供不同平台下的图形界面工具<em>frontends</em>,以及库文件<em>libraries</em>)与其他的应用进行结合.同时还对<code>S/MIME</code>和<code>SSH(Security Shell)</code>提供支持.</p></div><a id="more"></a><p>本文使用环境为Linux命令行，掌握命令行，Window(<code>Gpg4win</code>)等<a href="https://www.gnupg.org/download/index.html" target="_blank" rel="noopener">其他客户端</a>也很容易掌握。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><code>GPG</code>有两种安装方式。可以<a href="https://www.gnupg.org/download/index.html" target="_blank" rel="noopener">下载源码</a>, 自己编译安装:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure></div><p>更方便的方式是直接安装编译好的二进制包:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Arch 环境</span><br><span class="line">sudo pacman -S gnupg</span><br><span class="line"></span><br><span class="line"># Debian / Ubuntu 环境</span><br><span class="line">sudo apt-get install gnupg</span><br><span class="line"></span><br><span class="line"># Fedora 环境</span><br><span class="line">yum install gnupg</span><br></pre></td></tr></table></figure></div><p>安装完成后，键入下面的命令:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --help</span><br></pre></td></tr></table></figure></div><p>如果屏幕显示GPG的帮助信息，就表示安装成功。<br><img src="gpg-help.png" alt=""></p><h3 id="密钥管理"><a href="#密钥管理" class="headerlink" title="密钥管理"></a>密钥管理</h3><p>在使用<code>GPG</code>进行加密和签名之前，我们应该清楚的知道，它还是一个优秀的密钥管理工具(key Manager).</p><p>可以使用<code>gpg --list-keys</code>查看当前管理的所有密钥.</p><h4 id="生成密钥对"><a href="#生成密钥对" class="headerlink" title="生成密钥对"></a>生成密钥对</h4><p>使用<code>gpg --gen-key</code>或<code>gpg --full-gen-key</code>(设置完整的参数配置来生成密钥对)</p><p>以完整的生成密钥对为例,<code>gpg --full-gen-key</code></p><p>(1).选择加密的算法(默认<code>RSA</code>):<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">gpg (GnuPG) 2.2.11; Copyright (C) 2018 Free Software Foundation, Inc.</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.</span><br><span class="line"></span><br><span class="line">Please select what kind of key you want:</span><br><span class="line">   (1) RSA and RSA (default)</span><br><span class="line">   (2) DSA and Elgamal</span><br><span class="line">   (3) DSA (sign only)</span><br><span class="line">   (4) RSA (sign only)</span><br><span class="line">Your selection?</span><br></pre></td></tr></table></figure></div></p><p>(2).选择密钥的大小(默认2048位):</p><div class="note warning"><p>密钥的位数越大，对于防范暴力破解攻击就越安全,但是对于各种用途，使用默认的大小已经足够了，因为绕过加密比试图破解代价反而更少一些。此外，随着密钥大小的增加，加密和解密将变慢，较大的密钥位数可能会影响签名的长度。</p></div><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RSA keys may be between 1024 and 4096 bits long.</span><br><span class="line">What keysize do you want? (2048)</span><br></pre></td></tr></table></figure></div><p>(3). 配置密钥的失效时间(默认0, 永不失效)</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Please specify how long the key should be valid.</span><br><span class="line">         0 = key does not expire</span><br><span class="line">      &lt;n&gt;  = key expires in n days</span><br><span class="line">      &lt;n&gt;w = key expires in n weeks</span><br><span class="line">      &lt;n&gt;m = key expires in n months</span><br><span class="line">      &lt;n&gt;y = key expires in n years</span><br><span class="line">Key is valid for? (0) </span><br><span class="line">Key does not expire at all</span><br><span class="line">Is this correct? (y/N) y</span><br></pre></td></tr></table></figure></div><p>(4). 配置用户信息</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GnuPG needs to construct a user ID to identify your key.</span><br><span class="line"></span><br><span class="line">Real name: alice</span><br><span class="line">Email address: alice@gmail.com</span><br><span class="line">Comment: A Test case</span><br><span class="line">You selected this USER-ID:</span><br><span class="line">    &quot;alice (A Test case) &lt;alice@gmail.com&gt;&quot;</span><br><span class="line"></span><br><span class="line">Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? </span><br><span class="line"></span><br><span class="line"># 最后确认信息，若需要修改可进行更新，按O确认</span><br></pre></td></tr></table></figure></div><p>(5). 最后输入加密密码，完成密钥对的生成</p><p><img src="gpg-passphrase.png" alt=""></p><p>查看当前的所有密钥对:</p><p><img src="gpg-list-keys.png" alt=""></p><h4 id="密钥的导出和导入"><a href="#密钥的导出和导入" class="headerlink" title="密钥的导出和导入"></a>密钥的导出和导入</h4><p>导入公钥/私钥:</p><p>公钥和私钥的导入都是使用一样的命令<code>gpg --import</code></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#导入公钥</span><br><span class="line">gpg --import rovo98.pub</span><br><span class="line"># 导入私钥</span><br><span class="line">gpg --import rovo98.pri</span><br></pre></td></tr></table></figure></div><p>导入公钥之后，应进行验证。<code>GnuPG</code>提供了功能强大的信任模型，不需要我们亲自验证导入的每一个公钥。但是一些公钥还是需要亲自进行验证的，下面简单了解一下如何对导入的公钥进行验证。</p><div class="note danger"><p>通过验证公钥的指纹，然后签名(Sign)公钥以将其证明为有效公钥来验证密钥。可以使用<code>--fingerprint</code>命令行选项快速查看公钥的指纹，但为了验证公钥，必须对其进行编辑。</p></div><p>编辑公钥示例:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gpg --edit-key blake@cyb.org</span><br><span class="line"></span><br><span class="line">pub  1024D/9E98BC16  created: 1999-06-04 expires: never      trust: -/q</span><br><span class="line">sub  1024g/5C8CBD41  created: 1999-06-04 expires: never     </span><br><span class="line">(1)  Blake (Executioner) &lt;blake@cyb.org&gt;</span><br><span class="line"></span><br><span class="line">Command&gt; fpr</span><br><span class="line">pub  1024D/9E98BC16 1999-06-04 Blake (Executioner) &lt;blake@cyb.org&gt;</span><br><span class="line">             Fingerprint: 268F 448F CCD7 AF34 183E  52D8 9BDE 1A08 9E98 BC16</span><br></pre></td></tr></table></figure></div><blockquote><p>公钥的指纹验证需要通过公钥的所有者进行验证。可以通过电话或任何其他方式亲自完成，只要能够和公钥的真正所有者进行联系就行。<br><strong>如果获得指纹与公钥所有者的指纹相同，才可以确定我们得到是正确的公钥副本</strong></p></blockquote><p>检查指纹之后，最后进行公钥的签名(Sign)完成验证。由于公钥签名是公钥加密中的一个弱点，因此在进行签名验证之前，必须确保指纹验证是正确的。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Command&gt;&gt; sign</span><br><span class="line">             </span><br><span class="line">pub  1024D/9E98BC16  created: 1999-06-04 expires: never      trust: -/q</span><br><span class="line">             Fingerprint: 268F 448F CCD7 AF34 183E  52D8 9BDE 1A08 9E98 BC16</span><br><span class="line"></span><br><span class="line">     Blake (Executioner) &lt;blake@cyb.org&gt;</span><br><span class="line"></span><br><span class="line">Are you really sure that you want to sign this key</span><br><span class="line">with your key: <span class="string">"Alice (Judge) &lt;alice@cyb.org&gt;"</span></span><br><span class="line"></span><br><span class="line">Really sign?</span><br></pre></td></tr></table></figure></div><blockquote><p>签名之后，可以检查公钥，以列出其上面的签名，并查看我们添加的签名。公钥上的每个用户ID都可以具有一个或多个自签名以及已经通过公钥验证的签名。</p></blockquote><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Command&gt; check</span><br><span class="line">uid  Blake (Executioner) &lt;blake@cyb.org&gt;</span><br><span class="line">sig!       9E98BC16 1999-06-04   [self-signature]</span><br><span class="line">sig!       BB7576AC 1999-06-04   Alice (Judge) &lt;alice@cyb.org&gt;</span><br></pre></td></tr></table></figure></div><p><strong>导出公钥(Public key)</strong></p><p>要将公钥发送给对应的用户之前，我们需要将密钥对的公钥导出，在<code>GPG</code>中使用<code>gpg --export</code>命令导出</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --output alice.gpg --<span class="built_in">export</span> alice@gmail.com</span><br></pre></td></tr></table></figure></div><p>默认导出的文件是以<strong>二进制格式</strong>保存的，非常不方便进行传输，因此<code>GPG</code>还提供了<code>--armor</code>参数来指定以<code>ASCII</code>码形式导出。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --armor --output alice.gpg --<span class="built_in">export</span> alice@gmail.com</span><br></pre></td></tr></table></figure></div><p><img src="gpg-export-pub-key.png" alt=""></p><p><strong>导出私钥(Private key)</strong>:</p><p><code>GPG</code>还支持导出私钥，不过是对所有的私钥进行导出，同样可以二进制格式或<code>ASCII</code>格式导出.</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --<span class="built_in">export</span>-secret-keys --armor</span><br></pre></td></tr></table></figure></div><h4 id="上传公钥"><a href="#上传公钥" class="headerlink" title="上传公钥"></a>上传公钥</h4><p>公钥服务器是网络上专门储存用户公钥的服务器。send-keys参数可以将公钥上传到服务器。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --send-keys [用户ID] --keyserver [服务器域名]</span><br></pre></td></tr></table></figure></div><p>使用上面的命令，你的公钥就被传到了服务器，然后通过交换机制，所有的公钥服务器最终都会包含你的公钥。</p><p>由于公钥服务器没有检查机制，任何人都可以用你的名义上传公钥，所以没有办法保证服务器上的公钥的可靠性。通常，你可以在网站上公布一个公钥指纹，让其他人核对下载到的公钥是否为真。fingerprint参数生成公钥指纹。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --fingerprint [用户ID]</span><br></pre></td></tr></table></figure></div><p>从公钥服务器上获取公钥:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --receive-keys</span><br></pre></td></tr></table></figure></div><p>获取到的公钥需要进行验证,参考上面提到的导入公钥的验证方式。</p><h3 id="加密和解密文件"><a href="#加密和解密文件" class="headerlink" title="加密和解密文件"></a>加密和解密文件</h3><p>在加密和解密文件时，公钥和私钥各自具有特定的作用。</p><blockquote><p>公钥可以被认为是开放式保险箱。当通过公钥加密文件时，该文件被放入保险箱，安全关闭，并且组合锁经过多次旋转和组合。<br>相对应的私钥是可以重新打开保险箱并检索文件的组合(组合锁组合)。换句话说，之后持有私钥的人才能恢复和使用相关公钥加密文件。</p></blockquote><div class="note info"><p>因此加解密过程应该是这样的，假设你要给<code>alice</code>发送加密信息，使用<code>alice</code>的公钥对信息进行加密，则<code>alice</code>可以使用她的私钥对加密信息进行解密，而当她向你发送加密信息，加密信息时使用的应该是你的公钥。</p></div><p>加密例子: 使用<code>alice</code>的公钥对<code>sourceListforKali</code>进行加密</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --output sourceListforKali.en --encrypt sourceListforKali --recipient alice@gmail.com</span><br></pre></td></tr></table></figure></div><p><code>--recipient</code>指定使用的公钥</p><p>解密:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --output sourceListforKali.de --decrypt sourceListforKali.en</span><br></pre></td></tr></table></figure></div><p>输入之前创建该密钥对的密码就可以对文件进行解密。</p><p><img src="gpg-encrypt-decrypt.png" alt=""></p><div class="note warning"><p>我们还可以在不使用公钥的情况下，对文件进行加密，使用的是对称密码(symmetric chiper).使用<code>--symmetric</code>参数即可</p><p>手动输入加密密码即可。</p></div><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --output sourceListforKali.gpg --symmetric sourceListforKali</span><br></pre></td></tr></table></figure></div><h3 id="签名-signatures"><a href="#签名-signatures" class="headerlink" title="签名(signatures)"></a>签名(signatures)</h3><p>数字签名证明文档并为其加上时间戳。如果随后以任何方式修改了文档，则签名验证将失败。数字签名可以起到与手写签名相同的作用，并具有防篡改的额外好处。</p><p>例如：当你将文件签名并发布后，则接受到该文件的用户可以验证签名来查看文件是否被修改过。</p><h4 id="创建和验证签名"><a href="#创建和验证签名" class="headerlink" title="创建和验证签名"></a>创建和验证签名</h4><p>创建和验证签名使用公/私钥对的方式不同于加解密操作。使用签名者的私钥创建签名，使用相应的公钥验证签名。</p><p>使用数字签名的好处是一般情况下，签名人是确定的，除非签名者的私钥被泄露了。</p><p>使用<code>--sign</code>参数创建数字签名，例:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gpg --output doc.sig --sign doc</span><br><span class="line">You need a passphrase to unlock the private key <span class="keyword">for</span></span><br><span class="line">user: <span class="string">"Alice (Judge) &lt;alice@cyb.org&gt;"</span></span><br><span class="line">1024-bit DSA key, ID BB7576AC, created 1999-06-04</span><br><span class="line"></span><br><span class="line">Enter passphrase:</span><br></pre></td></tr></table></figure></div><p>签名的文件在签名之前会被进行压缩处理，并输出一个二进制格式的签名文件。根据给定的签名文件，可以检查签名或检查签名并恢复原始文件。</p><p>检查和验证签名使用<code>--verify</code>参数选项,验证签名并恢复原始文件使用<code>--decrypt</code>选项:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gpg --output doc --decrypt doc.sig</span><br><span class="line">gpg: Signature made Fri Jun  4 12:02:38 1999 CDT using DSA key ID BB7576AC</span><br><span class="line">gpg: Good signature from <span class="string">"Alice (Judge) &lt;alice@cyb.org&gt;"</span></span><br></pre></td></tr></table></figure></div><div class="note danger"><p>一般情况下，数字签名多数应用于对互联网上的帖子<em>post</em>以及<em>email</em>进行签名。这种情况下，我们一般不希望对需要签名的文件进行压缩处理，因此可以使用<code>--clearsign</code>选项，在不修改文件的情况下，将文件以<code>ASCII</code>的形式包装在签名文件中。</p></div><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">gpg --clearsign doc</span><br><span class="line"></span><br><span class="line">You need a passphrase to unlock the secret key <span class="keyword">for</span></span><br><span class="line">user: <span class="string">"Alice (Judge) &lt;alice@cyb.org&gt;"</span></span><br><span class="line">1024-bit DSA key, ID BB7576AC, created 1999-06-04</span><br><span class="line"></span><br><span class="line">-----BEGIN PGP SIGNED MESSAGE-----</span><br><span class="line">Hash: SHA1</span><br><span class="line"></span><br><span class="line">[...]</span><br><span class="line">-----BEGIN PGP SIGNATURE-----</span><br><span class="line">Version: GnuPG v0.9.7 (GNU/Linux)</span><br><span class="line">Comment: For info see http://www.gnupg.org</span><br><span class="line"></span><br><span class="line">iEYEARECAAYFAjdYCQoACgkQJ9S6ULt1dqz6IwCfQ7wP6i/i8HhbcOSKF4ELyQB1</span><br><span class="line">oCoAoOuqpRqEzr4kOkQqHRLE/b8/Rw2k</span><br><span class="line">=y6kj</span><br><span class="line">-----END PGP SIGNATURE-----</span><br></pre></td></tr></table></figure></div><div class="note primary"><p>分离的、独立的签名文件(<em>Detached signatures</em>): 一个签名过的文件的用途一般是很少的。</p><p>其他用户必须从签名文件中恢复原始文档，即使使用未压缩处理的签名文件(Clearsigned)，也必须编辑签名文档以恢复原始文档。</p><p>因此，<code>GPG</code>还提供用于对文档创建分离签名第三种签名方法，该签名是单独的文件。使用<code>--detach-sig</code>选项创建分离签名。</p></div><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gpg --output doc.sig --detach-sig doc</span><br><span class="line"></span><br><span class="line">You need a passphrase to unlock the secret key <span class="keyword">for</span></span><br><span class="line">user: <span class="string">"Alice (Judge) &lt;alice@cyb.org&gt;"</span></span><br><span class="line">1024-bit DSA key, ID BB7576AC, created 1999-06-04</span><br><span class="line"></span><br><span class="line">Enter passphrase:</span><br></pre></td></tr></table></figure></div><p>通过此方法创建的签名，在验证时就需要同时使用签名和对应原文件:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gpg --verify doc.sig doc</span><br><span class="line"></span><br><span class="line">gpg: Signature made Fri Jun  4 12:38:46 1999 CDT using DSA key ID BB7576AC</span><br><span class="line">gpg: Good signature from <span class="string">"Alice (Judge) &lt;alice@cyb.org&gt;"</span></span><br></pre></td></tr></table></figure></div><h3 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h3><p>以上就是<code>GnuPG</code>的简单入门使用，更多的可以详细阅读<code>GnuPG</code>提供的<a href="https://www.gnupg.org/documentation/index.html" target="_blank" rel="noopener">用户手册和文档</a>.</p><p>例如: 我们可以在加密文件的同时对文件进行签名(使用三种签名方法的其中一种)</p><div class="note primary"><p>参看链接:</p><ul><li><a href="https://www.gnupg.org/gph/en/manual.html" target="_blank" rel="noopener">https://www.gnupg.org/gph/en/manual.html</a></li><li><a href="https://futureboy.us/pgp.html" target="_blank" rel="noopener">https://futureboy.us/pgp.html</a></li></ul></div>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;引入&quot;&gt;&lt;a href=&quot;#引入&quot; class=&quot;headerlink&quot; title=&quot;引入&quot;&gt;&lt;/a&gt;引入&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;gpg  is the OpenPGP part of the GNU Privacy Guard (GnuPG). It is a tool to provide digital encryption and signing services using the OpenPGP standard.&lt;br&gt;gpg features: complete key management and all the bells and whistles you would expect from a full OpenPGP implementation.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;&lt;code&gt;GnuPG&lt;/code&gt;(GPG) 是 基于&lt;code&gt;OpenPGP&lt;/code&gt;(由&lt;a href=&quot;https://www.ietf.org/rfc/rfc4880.txt&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;RFC4880&lt;/a&gt;定义,也被称为&lt;code&gt;PGP&lt;/code&gt;)的一个完整的和免费的实现.我们可以使用&lt;code&gt;GPG&lt;/code&gt;来对我们的数据和通信进行加密(encrypt)和签名(sign), 它具有通用的密钥管理系统，以及各种公钥目录的访问模块. 我们可以很容易地使用&lt;code&gt;GPG&lt;/code&gt;提供的命令行工具(当前它还提供不同平台下的图形界面工具&lt;em&gt;frontends&lt;/em&gt;,以及库文件&lt;em&gt;libraries&lt;/em&gt;)与其他的应用进行结合.同时还对&lt;code&gt;S/MIME&lt;/code&gt;和&lt;code&gt;SSH(Security Shell)&lt;/code&gt;提供支持.&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://rovo98.github.io/categories/Linux/"/>
    
      <category term="softwares" scheme="http://rovo98.github.io/categories/Linux/softwares/"/>
    
    
      <category term="linux" scheme="http://rovo98.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>记录一次linux系统迁移过程</title>
    <link href="http://rovo98.github.io/posts/3babee60/"/>
    <id>http://rovo98.github.io/posts/3babee60/</id>
    <published>2018-10-07T06:00:00.000Z</published>
    <updated>2018-11-14T15:21:00.995Z</updated>
    
    <content type="html"><![CDATA[<p>就在最近，终于为自己的电脑加装了固态。在装完固态之后，首先面临的问题就是如何将原先安装在机械硬盘上的<code>linux</code>系统迁移到固态上。还要考虑后续配置的问题。</p><p>本文主要讲述在迁移<code>Linux</code>系统到新的固态硬盘上所遇到的问题以及找到的相应的解决方法。</p><p>这里先给出系统迁移以及相关配置完成之后的机械硬盘和固态硬盘的简单测速对比:</p><p><img src="/images/linux/hdparam.png" alt=""></p><a id="more"></a><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><div class="note info"><p>拆开电脑，直接加装固态,顺便清清灰尘，换一下硅脂(ps: 这不知道是我第几次拆电脑了…,表示以后再也不买GPU风扇了，这已经是第二次失败的购买经历了(<code>除非得到与原来匹配的风扇一致的风扇，不然我是不再换了</code>).</p></div><p>清尘换硅脂:</p><p><img src="install_ssd01.jpg" alt="install-ssd-01"><br>加装固态和散热板:</p><p><img src="install_ssd02.jpg" alt="install-ssd-01"></p><div class="note primary"><p>关于固态如何购买挑选，需要很好的了解自己电脑能够支持的固态类型和市场所提供的固态类型，并综合各种因素才能做出最好的选择。这里我推荐几篇个人觉得不错的文章:</p><ul><li><a href="https://www.laptopmag.com/articles/laptop-ssd-guide" target="_blank" rel="noopener">https://www.laptopmag.com/articles/laptop-ssd-guide</a></li><li><a href="https://www.tomshardware.com/reviews/ssd-buying-guide,5602.html" target="_blank" rel="noopener">https://www.tomshardware.com/reviews/ssd-buying-guide,5602.html</a></li><li><a href="https://www.velocitymicro.com/blog/nvme-vs-m-2-vs-sata-whats-the-difference/" target="_blank" rel="noopener">https://www.velocitymicro.com/blog/nvme-vs-m-2-vs-sata-whats-the-difference/</a></li><li><a href="https://blog.csdn.net/u010109732/article/details/79032845" target="_blank" rel="noopener">https://blog.csdn.net/u010109732/article/details/79032845</a></li><li><a href="https://www.zhihu.com/question/48972075" target="_blank" rel="noopener">https://www.zhihu.com/question/48972075</a></li><li><a href="https://www.pc841.com/article/20180914-92342_all.html" target="_blank" rel="noopener">https://www.pc841.com/article/20180914-92342_all.html</a></li><li><a href="https://www.techadvisor.co.uk/test-centre/storage/best-ssd-2018-3235200/" target="_blank" rel="noopener">https://www.techadvisor.co.uk/test-centre/storage/best-ssd-2018-3235200/</a></li></ul><p>以上推荐文章仅作为参考。</p></div><h3 id="迁移系统"><a href="#迁移系统" class="headerlink" title="迁移系统"></a>迁移系统</h3><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>进入原先的<code>linux</code>系统，对已经安装上的固态硬盘进行分区。因为我之前在没有固态之前，在机械硬盘上就已经安装了三个系统(<code>win10</code>, <code>manjaro</code>, <code>kali</code>),因此在分区时，我是考虑只把两个<code>linux</code>迁移到固态上，毕竟<code>win10</code>现在已经基本不使用了，并将机械硬盘上的<code>EFI</code>分区也迁移到固态上。分区这里，可以按照自己的需求对固态硬盘进行分区。</p><p>分区工具的选择，随意，哪个顺手用哪个，例如:<code>gparted</code>, <code>fdisk</code>, <code>parted</code>,还有各种桌面自带的分区工具。我是使用的是<code>fdisk</code>:<br>例如:<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo fdisk /dev/nvme0n1</span><br></pre></td></tr></table></figure></div></p><p><img src="fdisk_parted.png" alt="diskparted"></p><p>这里我已经分好区了的，具体的操作在<code>fdisk</code>中进行:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Generic</span><br><span class="line">   d   delete a partition</span><br><span class="line">   F   list free unpartitioned space</span><br><span class="line">   l   list known partition types</span><br><span class="line">   n   add a new partition</span><br><span class="line">   p   print the partition table</span><br><span class="line">   t   change a partition type</span><br><span class="line">   v   verify the partition table</span><br><span class="line">   i   print information about a partition</span><br><span class="line"></span><br><span class="line">  Misc</span><br><span class="line">   m   print this menu</span><br><span class="line">   x   extra functionality (experts only)</span><br><span class="line"></span><br><span class="line">  Script</span><br><span class="line">   I   load disk layout from sfdisk script file</span><br><span class="line">   O   dump disk layout to sfdisk script file</span><br><span class="line"></span><br><span class="line">  Save &amp; Exit</span><br><span class="line">   w   write table to disk and exit</span><br><span class="line">   q   quit without saving changes</span><br><span class="line"></span><br><span class="line">  Create a new label</span><br><span class="line">   g   create a new empty GPT partition table</span><br><span class="line">   G   create a new empty SGI (IRIX) partition table</span><br><span class="line">   o   create a new empty DOS partition table</span><br><span class="line">   s   create a new empty Sun partition table</span><br></pre></td></tr></table></figure></div><p>例如创建<code>EFI</code>分区:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Command (m for help): n</span><br><span class="line">Partition number (2-128, default 2): 2 # 创建一个分区作为EFI分区</span><br><span class="line">First sector (xxxxx-xxxxxxxxxxx, default xxxxx): </span><br><span class="line">Last sector, +sectors or +size&#123;K,M,G,T,P&#125; (34-2047, default xxxxxxx): +200M</span><br><span class="line">Created a new partition 2 of type &apos;Linux filesystem&apos; and of size 200 Mb.</span><br><span class="line">Command (m for help): t  # 修改EFI分区的分区类型为EFI系统分区</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"># 最后保存设置</span><br><span class="line">Command (m for help): w</span><br></pre></td></tr></table></figure></div><div class="note danger"><p>请注意先查看所执行的分区操作是不是你想要的再进行最后的保存设置</p></div><p>其他的分区创建类似<code>EFI</code>的创建，<code>swap</code>分区需要指定为<code>Linux swap</code>分区，作为<code>linux</code>数据分区的分区在创建时默认就是<code>linux filesystem</code>类型了，不需要更改，之后对创建的分区进行格式化:将<code>EFI</code>格式化为<code>fat32</code>，将<code>linux</code>数据分区格式化<code>ext4</code>； 先通过<code>sudo fdisk -l</code>或<code>lsblk</code>查看已经创建分区对应的设备名,例如:<br><code>sudo fdisk -l</code>:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Disk /dev/nvme0n1: 238.5 GiB, 256060514304 bytes, 500118192 sectors</span><br><span class="line">Units: sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disklabel type: gpt</span><br><span class="line">Disk identifier: 6D071E80-FF82-420B-A2D8-7A0BC4759F06</span><br><span class="line"></span><br><span class="line">Device             Start       End   Sectors  Size Type</span><br><span class="line">/dev/nvme0n1p1        34    262177    262144  128M Microsoft reserved</span><br><span class="line">/dev/nvme0n1p2    264192    673791    409600  200M EFI System</span><br><span class="line">/dev/nvme0n1p3    673792   9062399   8388608    4G Linux swap</span><br><span class="line">/dev/nvme0n1p4   9062400 428492799 419430400  200G Linux filesystem</span><br><span class="line">/dev/nvme0n1p5 428492800 500117503  71624704 34.2G Linux filesystem</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disk /dev/sda: 931.5 GiB, 1000204886016 bytes, 1953525168 sectors</span><br><span class="line">Units: sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 4096 bytes</span><br><span class="line">I/O size (minimum/optimal): 4096 bytes / 4096 bytes</span><br><span class="line">Disklabel type: gpt</span><br><span class="line">Disk identifier: D5CB68A7-96DA-4C61-84E2-61C98489BFF1</span><br><span class="line"></span><br><span class="line">Device          Start        End   Sectors   Size Type</span><br><span class="line">/dev/sda1          64  125829183 125829120    60G Microsoft basic data</span><br><span class="line">/dev/sda2   125829184  880802416 754973233   360G Microsoft basic data</span><br><span class="line">/dev/sda3   880803904 1596575151 715771248 341.3G Microsoft basic data</span><br><span class="line">/dev/sda4  1596575744 1953521663 356945920 170.2G Microsoft basic data</span><br></pre></td></tr></table></figure></div><p><code>lsblk</code> 查看分好的磁盘分区:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">NAME        MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sda           8:0    0 931.5G  0 disk </span><br><span class="line">├─sda1        8:1    0    60G  0 part /run/media/rovo98/System</span><br><span class="line">├─sda2        8:2    0   360G  0 part /run/media/rovo98/Mshinoda</span><br><span class="line">├─sda3        8:3    0 341.3G  0 part /run/media/rovo98/Chester bennington</span><br><span class="line">└─sda4        8:4    0 170.2G  0 part /run/media/rovo98/LSR</span><br><span class="line">sr0          11:0    1  1024M  0 rom  </span><br><span class="line">nvme0n1     259:0    0 238.5G  0 disk </span><br><span class="line">├─nvme0n1p1 259:1    0   128M  0 part </span><br><span class="line">├─nvme0n1p2 259:2    0   200M  0 part /boot/efi</span><br><span class="line">├─nvme0n1p3 259:3    0     4G  0 part [SWAP]</span><br><span class="line">├─nvme0n1p4 259:4    0   200G  0 part /</span><br><span class="line">└─nvme0n1p5 259:5    0  34.2G  0 part /run/media/rovo98/a002d542-c8c4-4c98-85af-8a4446dbaa1b</span><br></pre></td></tr></table></figure></div><p>对特定的分区进行格式化,例如:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 对于linux数据分区</span><br><span class="line">mkfs.ext4 /dev/nvme0n1p4</span><br><span class="line">mkfs.ext4 /dev/nvme0n1p5</span><br><span class="line"># EFI分区</span><br><span class="line">mkfs.fat /dev/nvme0n1p2</span><br></pre></td></tr></table></figure></div><div class="note danger"><p><strong>注意</strong>: 执行每条格式化命令前，必须确认指定的分区是否是你想要格式化的分区</p></div><p>做好这些准备之后，就可以进行系统的迁移了</p><h4 id="系统迁移操作"><a href="#系统迁移操作" class="headerlink" title="系统迁移操作"></a>系统迁移操作</h4><p>对于<code>Linux</code>系统，我们只需要知道<strong>Linux一切皆文件</strong>就行了。因此对于系统的迁移就变得简单了，可以使用<code>dd</code>,打包压缩然后解压缩，有关系统备份和恢复可以参看<code>Arch wiki</code>给出的:<a href="https://wiki.archlinux.org/index.php/System_backup" target="_blank" rel="noopener">https://wiki.archlinux.org/index.php/System_backup</a>.这里我是使用的是<code>tar</code>结合<code>pigz</code>(<a href="http://www.ywnds.com/?p=10332" target="_blank" rel="noopener">什么是pigz?</a>)解压缩工具进行备份和恢复:</p><p>备份(打包压缩)<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tar --use-compress-program=pigz -cvpf /run/media/rovo98/Chester\ bennington/LP/GHOST/manjaro_backup_2018.10.7.tgz --exclude=/proc --exclude=/sys --exclude=/mnt --exclude=/run/media --exclude=/lost+found /</span><br></pre></td></tr></table></figure></div></p><p>恢复到目标硬盘分区上(解包解压缩):<br>先目标分区挂载到<code>/mnt</code>下，如:<code>/mnt/manjaro</code></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount /dev/nvme0n1p4 /mnt/manjaro</span><br></pre></td></tr></table></figure></div><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tar --use-compress-program=pigz -xvpf /run/media/rovo98/Chester\ bennington/LP/GHOST/manjaro_backup_2018.10.7.tgz -C /mnt/manjaro</span><br></pre></td></tr></table></figure></div><p>完成后需要手动创建，上面打包压缩是排除的文件夹:<code>/proc</code>, <code>/sys</code>, <code>/mnt</code>, <code>/run</code>, <code>/lost+found</code>.</p><div class="note primary"><p>详细备份和恢复过程可以参考查看:<a href="https://www.jianshu.com/p/b03a51c682a5" target="_blank" rel="noopener">Arch上的备份还原</a></p></div><h4 id="修复Grub、fstab文件以及refind引导管理"><a href="#修复Grub、fstab文件以及refind引导管理" class="headerlink" title="修复Grub、fstab文件以及refind引导管理"></a>修复Grub、fstab文件以及refind引导管理</h4><p>首先将<code>/proc</code>,<code>/run</code>,<code>/dev</code>,<code>/sys</code>重新挂载，让目标分区上的系统也拥有这些内容:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mount /proc /mnt/manjaro/proc</span><br><span class="line">mount /sys /mnt/manjaro/sys</span><br><span class="line">mount /run /mnt/manjaro/run</span><br><span class="line">mount /dev /mnt/manjaro/dev</span><br></pre></td></tr></table></figure></div><div class="note warning"><p>这些目录必须重新挂载，不然，当<code>chroot</code>切换进入目标系统之后，将无法获取一些系统信息，如：设备, 磁盘分区信息等. </p></div><p><img src="mount-bind.png" alt=""></p><p>在<code>chroot</code>到目标系统之前，需要挂载<code>EFI</code>分区到<code>/mnt/manjaro/boot/efi</code>（refind管理文件默认位置）下：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount /dev/nvme0n1p2 /mnt/manjaro/boot/efi</span><br></pre></td></tr></table></figure></div><p><img src="efi_root.png" alt=""></p><p><code>chroot</code>到目标系统中，进行之后的操作</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chroot /mnt/manjaro</span><br></pre></td></tr></table></figure></div><h4 id="更新fstab文件"><a href="#更新fstab文件" class="headerlink" title="更新fstab文件"></a>更新fstab文件</h4><p>获取相应分区的<code>UUID</code>，以更新<code>fstab</code>文件和<code>/etc/default/grub</code>文件:<br><code>blkid</code>:</p><p><img src="blkid.png" alt=""></p><p>或</p><p><code>ls -l /dev/disk/by-uuid</code>:</p><p><img src="byuuid.png" alt=""></p><p>更新<code>fstab</code>文件:</p><p><img src="updated-fstab.png" alt=""></p><div class="note primary"><p>主要修改挂载项以及对应的<code>UUID</code>，有关<code>fstab</code>文件的详细内容可以参考<a href="https://wiki.archlinux.org/index.php/Fstab" target="_blank" rel="noopener">https://wiki.archlinux.org/index.php/Fstab</a></p></div><h4 id="修复Grub"><a href="#修复Grub" class="headerlink" title="修复Grub"></a>修复Grub</h4><ol><li><p>重新生成Grub</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo grub-install --target=x86_64-efi --efi-directory=/boot/efi --bootloader=Manjaro --recheck</span><br></pre></td></tr></table></figure></div></li><li><p>更新Grub配置文件</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo update-grub</span><br><span class="line">或</span><br><span class="line">sudo grub-mkconfig -o /boot/grub/grub.cfg</span><br></pre></td></tr></table></figure></div></li></ol><div class="note warning"><p><strong>注意</strong>：如果此过程中出现以下提示信息:</p><p><code>EFI variables are not supported on this system.</code></p><p>需要先安装<code>efibootmgr</code>, <code>dosfstools</code>以及<code>grub</code>包，然后重新尝试重新生成<code>Grub</code>并更新其配置文件.</p></div><p>若仍出现该信息，则先退出<code>chroot</code>环境，并加载<code>efivarfs</code>模块:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo modprobe efivarfs</span><br></pre></td></tr></table></figure></div><p>然后再进入<code>chroot</code>环境，执行:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -t efivarfs efivarfs /sys/firmware/efi/efivars</span><br></pre></td></tr></table></figure></div><p>再重新生成<code>Grub</code>并更新<code>Grub</code>配置文件就好了。</p><div class="note primary"><p>参考链接:<a href="https://wiki.manjaro.org/index.php/Restore_the_GRUB_Bootloader" target="_blank" rel="noopener">https://wiki.manjaro.org/index.php/Restore_the_GRUB_Bootloader</a></p></div><h4 id="重新配置refind"><a href="#重新配置refind" class="headerlink" title="重新配置refind"></a>重新配置refind</h4><p>对之前的<code>refind</code>配置文件进行备份，保留主题文件<code>themes</code>及<code>refind.conf</code>就好了，其余的文件在执行<code>refind-install</code>时会自动生成.</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 已经生成过了的,打印信息如下</span><br><span class="line">ShimSource is none</span><br><span class="line">Installing rEFInd on Linux....</span><br><span class="line">ESP was found at /boot/efi using vfat</span><br><span class="line">Found rEFInd installation in /boot/efi/EFI/refind; upgrading it.</span><br><span class="line">Installing driver for ext4 (ext4_x64.efi)</span><br><span class="line">Copied rEFInd binary files</span><br><span class="line"></span><br><span class="line">Notice: Backed up existing icons directory as icons-backup.</span><br><span class="line">Existing refind.conf file found; copying sample file as refind.conf-sample</span><br><span class="line">to avoid overwriting your customizations.</span><br><span class="line"></span><br><span class="line">Keeping existing NVRAM entry</span><br><span class="line">rEFInd is set as the default boot manager.</span><br><span class="line">Existing //boot/refind_linux.conf found; not overwriting.</span><br></pre></td></tr></table></figure></div><p><img src="refind.png" alt=""></p><p>可以使用<code>efibootmgr</code>管理启动项，例如:<br><code>efibootmgr</code>查看当前所有的启动项，<code>efibootmgr -Bb xxxx</code>来删除不要的启动项，详细使用可以<code>man efibootmgr</code>来查看。</p><p><img src="efibootmgr.png" alt=""></p><p>其中的<code>windows</code>系统启动项通过<code>PE</code>用<code>UEFI</code>引导修复生成即可(需要注意的是老旧的PE识别不了<code>nvme</code>固态)。</p><p>以上就是迁移Linux系统的完整过程了</p><h4 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h4><p>在做完上面的所有操作，并将之前机械硬盘上的<code>EFI</code>分区等等(除<code>Win10</code>系统之外)都删除之后，重新启动进入固态盘上的系统，在<code>Grub</code>引导过程出现<code>UUID=***************</code>找不到的信息，经过查看之后发现，在<code>Grub</code>引导时居然没有挂载我那块<code>nvme</code>固态。</p><p>通过了解发现<code>Grub2.2</code>版本并不支持<code>nvme</code>的固态，可以使用安装<code>bootloader</code>来进行引导。PS: 但我<code>Manjaro</code>安装的<code>Grub</code>是<code>2.3</code>版本的，理论上是支持的。</p><div class="note primary"><p>参考链接: <a href="https://bbs.archlinux.org/viewtopic.php?id=209653" target="_blank" rel="noopener">https://bbs.archlinux.org/viewtopic.php?id=209653</a></p></div><p>通过一番查找之后，终于找到了解决方法:</p><ol><li><p>添加加载模块 <code>sudo vim /etc/mkinitcpio.conf</code></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="DIFF"><figure class="iseeu highlight /diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="deletion">- MODULES = ""</span></span><br><span class="line"><span class="addition">+ MODULES="nvme"</span></span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure></div></li><li><p>更新<code>mkinitcpio</code></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#参数说明，详细可以通过man查看</span><br><span class="line">-p, --preset preset</span><br><span class="line">Build initramfs image(s) according to specified preset. This may be a file in /etc/mkinitcpio.d (without the .preset extension) or a full, absolute path to a file. This option may be specified multiple times to process multiple presets.</span><br></pre></td></tr></table></figure></div></li><li><p>更新Grub</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo update-grub</span><br><span class="line">或</span><br><span class="line">sudo grub-mkocnfig -o /boot/grub/grub.cfg</span><br></pre></td></tr></table></figure></div></li></ol><p>再次重启之后，便可以成功进入系统了。</p><div class="note primary"><p>参考链接:<a href="http://blog.51cto.com/shenfly231/1918426" target="_blank" rel="noopener">http://blog.51cto.com/shenfly231/1918426</a>, 若要安装<code>bootloader</code>也可以参考该链接。</p></div><h3 id="SSD优化"><a href="#SSD优化" class="headerlink" title="SSD优化"></a>SSD优化</h3><h4 id="开启Trim功能"><a href="#开启Trim功能" class="headerlink" title="开启Trim功能"></a>开启Trim功能</h4><p>关于什么是<code>TRIM</code>?：</p><blockquote><p>SSD TRIM is an Advanced Technology Attachment (ATA) command that enables an operating system to inform a NAND flash solid-state drive (SSD) which data blocks it can erase because they are no longer in use. The use of TRIM can improve the performance of writing data to SSDs and contribute to longer SSD life.</p></blockquote><div class="note primary"><p>了解可以参考: <a href="https://searchstorage.techtarget.com/definition/TRIM" target="_blank" rel="noopener">https://searchstorage.techtarget.com/definition/TRIM</a>，以及<code>Arch wiki</code>上的:<br><a href="https://wiki.archlinux.org/index.php/Solid_state_drive#TRIM" target="_blank" rel="noopener">https://wiki.archlinux.org/index.php/Solid_state_drive#TRIM</a></p></div><blockquote><p>Most SSDs support the <strong>ATA_TRIM command</strong> for <strong>sustained long-term performance and wear-leveling</strong>. A techspot article shows performance benchmark examples of before and after filling an SSD with data.</p><p>As of Linux kernel version 3.8 onwards, support for TRIM was continually added for the different filesystems. See the following table for an indicative overview:</p></blockquote><p><img src="trim-supported.png" alt=""></p><p>在使用<code>Trim</code>功能之前需要查看固态硬盘是否支持，否则可能造成数据丢失:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsblk --discard</span><br></pre></td></tr></table></figure></div><p><img src="lsblk-discard.png" alt=""></p><p><code>DISC-GRAN</code>和<code>DISC-MAX</code>不为<code>0</code>则表示支持，详细查看上面的<code>Arch Wiki</code>给出的文章。</p><p>关于使用的<code>Trim</code>方式，我使用的<code>Continuous TRIM</code>(详见<code>Arch Wiki</code>)<br>即在<code>/etc/fstab</code>文件的挂载项中添加参数<code>discard</code><br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="DIFF"><figure class="iseeu highlight /diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">- UUID=D942-EEB0                            /boot/efi      vfat    defaults,noatime 0 2</span></span><br><span class="line"><span class="deletion">- UUID=67180790-92d0-48d3-8f00-448161019f2d swap           swap    defaults,noatime 0 2</span></span><br><span class="line"><span class="deletion">- UUID=e2708091-5a07-47a6-bc26-5fdaa044c5f3 /              ext4    defaults,noatime 0 1</span></span><br><span class="line"><span class="addition">+ UUID=D942-EEB0                            /boot/efi      vfat    defaults,discard,noatime 0 2</span></span><br><span class="line"><span class="addition">+ UUID=67180790-92d0-48d3-8f00-448161019f2d swap           swap    defaults,discard,noatime 0 2</span></span><br><span class="line"><span class="addition">+ UUID=e2708091-5a07-47a6-bc26-5fdaa044c5f3 /              ext4    defaults,discard,noatime 0 1</span></span><br></pre></td></tr></table></figure></div></p><h4 id="IO调度器选择"><a href="#IO调度器选择" class="headerlink" title="IO调度器选择"></a>IO调度器选择</h4><p>一般来说，IO调度算法是为低速硬盘准备的，对于固态，最好是不使用任何IO调度器，或使用对硬盘干预程度最低的调度算法。</p><ol><li>查看当前固态的IO调度器:<br><img src="io-schedulers.png" alt=""><br>可以看到我当前固态没有使用任何调度器，而机械硬盘使用的是<code>bfq-sq</code>.</li><li><p>修改IO调度器(临时的):</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo noop &gt; /sys/block/sda/queue/scheduler</span><br></pre></td></tr></table></figure></div></li><li><p>要永久生效则需要添加编写开机自启动脚本<br>详见参考链接.</p></li></ol><div class="note primary"><p>更多信息以及详细的内容可以参考下面给出的参考链接.<br>参考链接:</p><ul><li><a href="https://wiki.archlinux.org/index.php/Improving_performance#Storage_devices" target="_blank" rel="noopener">https://wiki.archlinux.org/index.php/Improving_performance#Storage_devices</a></li><li><a href="https://blog.codeship.com/linux-io-scheduler-tuning/" target="_blank" rel="noopener">https://blog.codeship.com/linux-io-scheduler-tuning/</a></li><li><a href="https://www.ibm.com/developerworks/cn/linux/l-lo-io-scheduler-optimize-performance/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/linux/l-lo-io-scheduler-optimize-performance/index.html</a></li></ul></div><h4 id="另外"><a href="#另外" class="headerlink" title="另外"></a>另外</h4><div class="note primary"><p>更多有关<code>Linux VM</code>性能调优的可以参考:<br><a href="https://lonesysadmin.net/tag/linux-vm-performance-tuning/" target="_blank" rel="noopener">https://lonesysadmin.net/tag/linux-vm-performance-tuning/</a></p></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;就在最近，终于为自己的电脑加装了固态。在装完固态之后，首先面临的问题就是如何将原先安装在机械硬盘上的&lt;code&gt;linux&lt;/code&gt;系统迁移到固态上。还要考虑后续配置的问题。&lt;/p&gt;
&lt;p&gt;本文主要讲述在迁移&lt;code&gt;Linux&lt;/code&gt;系统到新的固态硬盘上所遇到的问题以及找到的相应的解决方法。&lt;/p&gt;
&lt;p&gt;这里先给出系统迁移以及相关配置完成之后的机械硬盘和固态硬盘的简单测速对比:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/linux/hdparam.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://rovo98.github.io/categories/Linux/"/>
    
    
      <category term="ssd" scheme="http://rovo98.github.io/tags/ssd/"/>
    
  </entry>
  
  <entry>
    <title>编译自己的Vim8.1</title>
    <link href="http://rovo98.github.io/posts/97c4fd12/"/>
    <id>http://rovo98.github.io/posts/97c4fd12/</id>
    <published>2018-08-27T12:12:13.000Z</published>
    <updated>2018-10-31T08:49:27.251Z</updated>
    
    <content type="html"><![CDATA[<p>最近换了<code>Manjaro</code> linux系统，发现通过系统<code>pacman -S vim</code>安装的无图形版本<code>vim</code>不支持<code>clipboard</code>功能。</p><p><img src="/images/linux/vim-version-original.png" alt=""></p><p>本想看能不能通过某种方式，来扩展现有安装好的<code>vim</code>,但是通过<code>google</code>了解到：<br><blockquote class="blockquote-center"><p>VIM is intended to be a portable editor that “just works” on all systems. By having the default version use the clipboard functionality, it will need to link against X11 libraries, and a separate version of VIM would need to be compiled for desktop versus server (no pre-installed X11/xorg) builds. This is why the vim and vim-gtk packages are provided.</p><p>VIM旨在成为一个可在所有系统上“正常工作”的便携式编辑器。通过使默认版本使用剪贴板功能，它将需要链接到X11库，并且需要针对桌面与服务器（没有预安装的X11 / xorg）构建编译单独版本的VIM。这就是提供vim和vim-gtk软件包的原因。</p></blockquote></p><a id="more"></a><p>虽然知道<code>gvim</code>带有支持<code>clipboard</code>的<code>vim</code>，但是我又不想装<code>gvim</code>。自己的系统又有<code>X11</code>库和 <code>Xorg</code>，所以决定自己编译一个<code>vim</code>.</p><div class="note warning"><p><strong>注意</strong>： 对于没有<code>X11</code>和<code>Xorg</code>的需要在编译前配置好，否则编译会出错.</p></div><h3 id="一、从github上获取vim的源码"><a href="#一、从github上获取vim的源码" class="headerlink" title="一、从github上获取vim的源码"></a>一、从github上获取vim的源码</h3><p>直接使用<code>git</code> clone <code>vim</code>仓库：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/vim/vim.git vim_source</span><br></pre></td></tr></table></figure></div><h3 id="二、配置、编译并安装"><a href="#二、配置、编译并安装" class="headerlink" title="二、配置、编译并安装"></a>二、配置、编译并安装</h3><p>我的编译配置：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">make clean</span><br><span class="line">./configure \</span><br><span class="line">    --enable-cscope \ </span><br><span class="line">    --enable-largefile \ </span><br><span class="line">    --enable-multibyte \ </span><br><span class="line">    --enable-mzschemeinterp \ </span><br><span class="line">    --enable-xim \ </span><br><span class="line">    --enable-tclinterp=dynamic \ </span><br><span class="line">    --enable-perlinterp=dynamic \ </span><br><span class="line">    --enable-python3interp=dynamic\ </span><br><span class="line">    --enable-pythoninterp=dynamic \ </span><br><span class="line">    --enable-rubyinterp=dynamic \ </span><br><span class="line">    --enable-luainterp=dynamic \</span><br><span class="line">    --enable-gui=no \</span><br><span class="line">    --enable-fontset \</span><br><span class="line">    --enable-terminal \</span><br><span class="line">    --with-features=huge \</span><br><span class="line">    --with-x \</span><br><span class="line">    --with-compiledby=&quot;rovo98&quot; \</span><br><span class="line">    --with-python-config-dir=/usr/lib/python2.7/config-$(uname-m)-linux-gnu</span><br><span class="line">    --with-python3-config-dir=/usr/lib/python3.7/config-$(uname -m)-linux-gnu</span><br></pre></td></tr></table></figure></div><p>编译并安装:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make &amp;&amp; sudo make install</span><br></pre></td></tr></table></figure></div><p><strong>编译配置的说明</strong>:</p><p>上面的参数中启用了对tcl、perl、python、ruby、lua的支持。同时为了使用系统的剪切板还启用了对X的支持， 安装位置默认是<code>/usr/local</code>下， 由<code>--perfix=PREFIX</code>参数指定。</p><p>更多详细可以使用<code>./configure --help</code>查看:</p><p><strong>删除编译产生的中间文件</strong> :</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make clean &amp;&amp; make distclean</span><br></pre></td></tr></table></figure></div><p><strong>成果:</strong></p><p><img src="vim_installed.png" alt=""></p><p><strong>为<code>vim</code>创建一个桌面图标</strong>:</p><p><code>vim.desktop</code>:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[Desktop Entry]</span><br><span class="line">Name=Vim[compiled by rovo98]</span><br><span class="line">Version=8.1</span><br><span class="line">Exec=vim %f</span><br><span class="line">Comment=Vim is a highly configurable text editor for efficiently creating and changing any kind of text.</span><br><span class="line">Icon=/usr/share/vim/vim81/src/vim.ico</span><br><span class="line">Type=Application</span><br><span class="line">MimeType=text/plain;</span><br><span class="line">Terminal=true</span><br><span class="line">Encoding=UTF-8</span><br><span class="line">Categories=Utility;</span><br></pre></td></tr></table></figure></div><p>把<code>vim.desktop</code>放到<code>/usr/share/applications/</code>下就行了。</p><p>现在可以享受你自己编译的vim了。</p><div class="note primary"><p>参考链接: </p><ul><li><a href="https://vi.stackexchange.com/questions/13564/why-is-vim-for-debian-compiled-without-clipboard" target="_blank" rel="noopener">https://vi.stackexchange.com/questions/13564/why-is-vim-for-debian-compiled-without-clipboard</a></li><li><a href="https://stackoverflow.com/questions/11416069/compile-vim-with-clipboard-and-xterm" target="_blank" rel="noopener">https://stackoverflow.com/questions/11416069/compile-vim-with-clipboard-and-xterm</a></li></ul></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近换了&lt;code&gt;Manjaro&lt;/code&gt; linux系统，发现通过系统&lt;code&gt;pacman -S vim&lt;/code&gt;安装的无图形版本&lt;code&gt;vim&lt;/code&gt;不支持&lt;code&gt;clipboard&lt;/code&gt;功能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/linux/vim-version-original.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;本想看能不能通过某种方式，来扩展现有安装好的&lt;code&gt;vim&lt;/code&gt;,但是通过&lt;code&gt;google&lt;/code&gt;了解到：&lt;br&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;VIM is intended to be a portable editor that “just works” on all systems. By having the default version use the clipboard functionality, it will need to link against X11 libraries, and a separate version of VIM would need to be compiled for desktop versus server (no pre-installed X11/xorg) builds. This is why the vim and vim-gtk packages are provided.&lt;/p&gt;
&lt;p&gt;VIM旨在成为一个可在所有系统上“正常工作”的便携式编辑器。通过使默认版本使用剪贴板功能，它将需要链接到X11库，并且需要针对桌面与服务器（没有预安装的X11 / xorg）构建编译单独版本的VIM。这就是提供vim和vim-gtk软件包的原因。&lt;/p&gt;
&lt;/blockquote&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://rovo98.github.io/categories/Linux/"/>
    
      <category term="softwares" scheme="http://rovo98.github.io/categories/Linux/softwares/"/>
    
    
      <category term="linux" scheme="http://rovo98.github.io/tags/linux/"/>
    
      <category term="vim" scheme="http://rovo98.github.io/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>Arch linux系列 安装 haroopad markdown 编辑器</title>
    <link href="http://rovo98.github.io/posts/63e58ebb/"/>
    <id>http://rovo98.github.io/posts/63e58ebb/</id>
    <published>2018-08-26T05:12:00.000Z</published>
    <updated>2018-10-08T05:08:41.445Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Haroopad 是一个优秀的 Markdown 编辑器，是一个用于创建适宜 Web 的文档的处理器。使用 Haroopad 可以创作各种格式的文档，比如博客文章、幻灯片、演示文稿、报告和电子邮件等。Haroopad 在 Windows、Mac OS X 和 Linux 上均可用。它有 Debian/Ubuntu 的软件包，也有 Windows 和 Mac 的二进制文件。该应用程序使用 node-webkit、CodeMirror，marked，以及 Twitter 的 Bootstrap 。</p><p>Haroo 在韩语中的意思是“一天”。</p></blockquote><p>本文主要介绍通过压缩包<code>**.tar.gz</code>的方式安装 <code>Haroopad</code>.</p><a id="more"></a><h3 id="一、下载-Haroopad"><a href="#一、下载-Haroopad" class="headerlink" title="一、下载 Haroopad"></a>一、下载 Haroopad</h3><p>我们可以从官网直接下载我们需要的压缩包，官网地址: <a href="http://pad.haroopress.com/user.html" target="_blank" rel="noopener">Haroopad官网地址</a></p><p><img src="haroopad_website.png" alt=""></p><p>这里我选择的是linux binary 64 位的压缩包。</p><h3 id="二、解压并安装Haroopad"><a href="#二、解压并安装Haroopad" class="headerlink" title="二、解压并安装Haroopad"></a>二、解压并安装Haroopad</h3><p>根据下载的压缩包格式进行解压： 例如 **.tar.gz格式</p><p>解压并放到<code>/opt/</code>目录下:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tar zxvf haroopad-v0.13.1.x64.tar.gz -C haroopad</span><br><span class="line">sudo cp -r haroopad /opt/</span><br><span class="line"></span><br><span class="line">tar zxvf data.tar.gz</span><br><span class="line">tar zxvf control.tar.gz</span><br></pre></td></tr></table></figure></div><p>把解压出来的 usr中的文件放到<code>/usr/</code>下：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo cp -r ./usr /</span><br><span class="line"><span class="comment"># 执行 postinst</span></span><br><span class="line">chmod 755 postinst</span><br><span class="line">sudo ./postinst</span><br></pre></td></tr></table></figure></div><p><img src="haroopad_install.png" alt=""></p><h3 id="三、修复桌面图标"><a href="#三、修复桌面图标" class="headerlink" title="三、修复桌面图标"></a>三、修复桌面图标</h3><p>为haroopad 换一个合适的桌面图标:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /usr/share/applications/Haroopad.desktop</span><br></pre></td></tr></table></figure></div><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[Desktop Entry]</span><br><span class="line">Name=haroopad</span><br><span class="line">Version=0.13.1</span><br><span class="line">Exec=haroopad</span><br><span class="line">Comment=The Next Document processor based on Markdown</span><br><span class="line">#Icon=haroopad</span><br><span class="line">Icon=/usr/share/icons/hicolor/128x128/apps/haroopad.png</span><br><span class="line">Type=Application</span><br><span class="line">Terminal=false</span><br><span class="line">StartupNotify=true</span><br><span class="line">Encoding=UTF-8</span><br><span class="line">Categories=Development;GTK;GNOME;</span><br></pre></td></tr></table></figure></div><h3 id="四、配置Haroopad"><a href="#四、配置Haroopad" class="headerlink" title="四、配置Haroopad"></a>四、配置Haroopad</h3><p>相关的Haroopad设置，可以打开 <code>偏好设置</code>进行配置:</p><p><img src="haroopad_settings.png" alt=""></p><p>到此，Haroopad 安装就完成了。</p><p>参考链接: <a href="https://www.jianshu.com/p/dba9acabf0a7" target="_blank" rel="noopener">https://www.jianshu.com/p/dba9acabf0a7</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Haroopad 是一个优秀的 Markdown 编辑器，是一个用于创建适宜 Web 的文档的处理器。使用 Haroopad 可以创作各种格式的文档，比如博客文章、幻灯片、演示文稿、报告和电子邮件等。Haroopad 在 Windows、Mac OS X 和 Linux 上均可用。它有 Debian/Ubuntu 的软件包，也有 Windows 和 Mac 的二进制文件。该应用程序使用 node-webkit、CodeMirror，marked，以及 Twitter 的 Bootstrap 。&lt;/p&gt;
&lt;p&gt;Haroo 在韩语中的意思是“一天”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文主要介绍通过压缩包&lt;code&gt;**.tar.gz&lt;/code&gt;的方式安装 &lt;code&gt;Haroopad&lt;/code&gt;.&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://rovo98.github.io/categories/Linux/"/>
    
      <category term="softwares" scheme="http://rovo98.github.io/categories/Linux/softwares/"/>
    
    
      <category term="linux" scheme="http://rovo98.github.io/tags/linux/"/>
    
      <category term="markdown" scheme="http://rovo98.github.io/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>Manjaro linux 安装与配置</title>
    <link href="http://rovo98.github.io/posts/a1898ce2/"/>
    <id>http://rovo98.github.io/posts/a1898ce2/</id>
    <published>2018-08-22T04:00:00.000Z</published>
    <updated>2018-11-03T08:50:24.120Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/linux/manjaro-installed.png" alt=""></p><blockquote><p>Manjaro是一款基于Arch Linux、对用户友好、全球排名第一的Linux发行版。（排名数据源于<a href="http://distrowatch.com/" target="_blank" rel="noopener">DistroWatch</a>，统计日期2018.08.22，时间段3个月。）<br>在Linux圈，Arch的确是一个异常强大的发行版。它有3个无与伦比的优势：</p><ol><li>滚动更新可以使软件保持最新；</li><li>AUR软件仓库有着世界上最齐全的Linux软件（<a href="https://www.lulinux.com/archives/2787" target="_blank" rel="noopener">参考《一张列表展示ArchLinux系软件有多丰富——看哭百万Debian、RedHat系同学》</a>）；</li><li>丰富的wiki和活跃的社区让所有问题都可以快速得到满意的答案。</li></ol></blockquote><p>相比于<code>Arch linux</code>, 不得感叹, <a href="http://www.manjaro.cn/451" target="_blank" rel="noopener">人生苦短,我用 <strong>Manjaro</strong>啊!</a></p><a id="more"></a><h3 id="一、Manjaro的安装"><a href="#一、Manjaro的安装" class="headerlink" title="一、Manjaro的安装"></a>一、Manjaro的安装</h3><h4 id="镜像下载"><a href="#镜像下载" class="headerlink" title="镜像下载"></a>镜像下载</h4><p>官方网站：<a href="https://manjaro.org/get-manjaro/" target="_blank" rel="noopener">https://manjaro.org/get-manjaro/</a><br>选择自己喜欢的桌面环境就好，目前官方支持包括xfce、kde、gnome三种桌面环境。而在官方的社区版本中提供更多桌面环境的支持，比如国产的deepin桌面环境</p><p>但是官方服务器在海外，所以我们也可以选择国内开源镜像进行下载<br>清华大学开源镜像：<a href="https://mirrors.tuna.tsinghua.edu.cn/manjaro-cd/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/manjaro-cd/</a></p><blockquote><p>由于我基本都把上述的版本和一些社区版本安装过(出于各种原因&gt;_&lt;)，我建议是从官方网站下载最新的官方版本进行安装(好像清华大学源的镜像并不是最新的)，至于桌面环境的选择，看个人，我选择的是<code>KDE</code>(其实，桌面环境在安装之后也是可以换的)。</p></blockquote><h4 id="制作U盘启动盘"><a href="#制作U盘启动盘" class="headerlink" title="制作U盘启动盘"></a>制作U盘启动盘</h4><p>manjaro官方提供的<a href="https://manjaro.github.io/homepage/public/support/userguide/" target="_blank" rel="noopener">Manjaro User Guide</a>手册里面介绍了使用 来制作镜像的方法许多方法，例如：</p><ul><li>Linux系统下，使用 <code>dd</code>命令来制作：<br><code>sudo dd if=manjaro-xfce-17.1-stable-x86_64.iso of=/dev/sdcbs=4M</code>, <code>of</code>指定烧录U盘的挂载位置;</li><li>在windows系统下使用烧录软件<code>Rufus</code>来进行烧录:<br> <img src="Rufus.png" alt=""></li></ul><p><strong>[注意]</strong>： 烧录完成后，在进入<code>Live</code>系统前，需要对<code>BIOS</code>进行一些设置，关闭安全启动。之后即可顺利进入这个界面(至于BIOS vs UEFI的启动进入的<code>Live</code>系统的方式，详见手册。由于我安装的是多个系统，所以是<code>GPT+UEFI</code>引导):</p><p><img src="manjaro-boot-menu.png" alt=""></p><h4 id="安装系统"><a href="#安装系统" class="headerlink" title="安装系统"></a>安装系统</h4><p>进入启动菜单界面后，可以对一些基本的选项进行配置，如，时区，语言，键盘布局等。</p><p>具体的安装步骤请直接参考官网的<code>Manjaro User Guide.pdf</code>,这里主要说说安装系统时可能遇到的问题(我基本踩过的坑…)。</p><ol><li><strong>对于双显卡的电脑,特别是有Nvidia卡的</strong>: 在进入<code>live</code>系统之前,可以将<code>Driver</code>选项设置为<code>no-free</code>(让系统自动安装合适的闭源驱动),并在<code>boot</code>项那里按<code>E</code>编辑, 在<code>boot</code>那一行将<code>nouveau.modeset=1</code>设置为<code>nouveau.modeset=0</code>来禁用开源<code>nouveau</code>驱动,然后进入<code>Live</code>安装系统。<br><strong>但是,安装完系统后重启还有可能进不去桌面</strong>,可以尝试在<code>Grub</code>菜单启动界面按[E]编辑,找到<code>quite</code>并在后面加入(注意空格):<blockquote><p><code>acpi_osi=! acpi_osi=&#39;Windows 2009&#39;</code><br>或者<br><code>acpi_osi=! acpi_osi=Linux acpi_osi=&#39;Windows 2015&#39; pcie_port_pm=off</code><br><strong>(很多硬件厂商的BIOS驱动都对Linux不友好(我的电脑就是这样的…)，无法顺利加载ACPI模块，而导致无法驱动独立显卡,acpi_osi=’Windows 2009’的意思是告诉ACPI模块，我是‘Windows 7’，别闹情绪了，赶紧工作吧。)</strong><br>接着按 F10 进入系统。<br><br>顺利进入系统后,将这些内核启动参数配置永久生效(修改grub的配置文件):<br><code>sudo vim /etc/default/grub</code><br>在<code>GRUB_CMDLINE_LINUX</code>中添加参数:<br><img src="manjaro-grub.png" alt=""><br>之后更新 <code>grub</code>文件:<br><code>sudo update-grub</code><br>或<br><code>sudo grub-mkconfig -o /boot/grub/grub.cfg</code><br><img src="update-grub.png" alt=""><br>参考链接: </p><ol><li><a href="https://forum.manjaro.org/t/a-start-job-is-running-for-livemedia-mhwd-script/3395/15" target="_blank" rel="noopener">https://forum.manjaro.org/t/a-start-job-is-running-for-livemedia-mhwd-script/3395/15</a></li><li><a href="https://wiki.archlinux.org/index.php/Kernel_parameters" target="_blank" rel="noopener">https://wiki.archlinux.org/index.php/Kernel_parameters</a></li><li><a href="https://www.kernel.org/doc/Documentation/admin-guide/kernel-parameters.txt" target="_blank" rel="noopener">https://www.kernel.org/doc/Documentation/admin-guide/kernel-parameters.txt</a></li></ol></blockquote></li><li>启动时出现的<code>ACPI ERROR</code>问题，很多都说是内核版本的原因，有尝试过添加内核启动参数<code>acpi=off</code>，启动正常进入系统，但键盘无法使用，所以这个提示<code>ACPI</code>错误的问题，由于不影响使用，所以可以不管(强迫症的可以再看看)<blockquote><p><img src="boot-acpi-error.png" alt=""><br>参考链接: <a href="https://forum.manjaro.org/t/acpi-error-during-boot/35125" target="_blank" rel="noopener">https://forum.manjaro.org/t/acpi-error-during-boot/35125</a></p></blockquote></li><li>屏幕亮度无法调节或异常的问题： <code>Arch Wiki</code>已经给出很详细的解决方法:<br>链接: <a href="https://wiki.archlinux.org/index.php/backlight" target="_blank" rel="noopener">https://wiki.archlinux.org/index.php/backlight</a><br>例如：开机亮度设置: <code>vim /etc/rc.local</code>:<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh -e</span><br><span class="line">#</span><br><span class="line"># rc.local</span><br><span class="line">#</span><br><span class="line"># This script is executed at the end of the each multiuser runlevel.</span><br><span class="line"># Make sure that the script will &quot;exit 0&quot; on successs or any other value on error</span><br><span class="line"># </span><br><span class="line"># In order to enable or disable this script just change the execution bits.</span><br><span class="line"># </span><br><span class="line"># By default this script does nothing.</span><br><span class="line"></span><br><span class="line">echo 127 &gt;&gt; /sys/class/backlight/intel_backlight/brightness</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure></div></li></ol><div class="note primary"><p>对于安装<code>Manjaro</code>系统出现的问题，大多数都可以在官方的论坛<a href="https://forum.manjaro.org/" target="_blank" rel="noopener">Manjaro Forum</a>以及<a href="https://wiki.manjaro.org/index.php?title=Main_Page" target="_blank" rel="noopener">Manjaro Wiki</a>，还有<code>Arch Linux</code>的<a href="https://wiki.manjaro.org" target="_blank" rel="noopener">Arch Wiki</a>以及上找到解决方法。</p></div><h3 id="二、Manjaro-配置"><a href="#二、Manjaro-配置" class="headerlink" title="二、Manjaro 配置"></a>二、Manjaro 配置</h3><p>简单说一下一些安装系统之后的一些常规配置。</p><h4 id="配置更新源并更新系统"><a href="#配置更新源并更新系统" class="headerlink" title="配置更新源并更新系统"></a>配置更新源并更新系统</h4><ol><li><p>配置中国的mirrors：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman-mirrors -i -c China -m rank</span><br></pre></td></tr></table></figure></div></li><li><p>在 <code>/etc/pacman.conf</code>中添加<code>archlinuxcn</code>源:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[archlinuxcn]</span><br><span class="line">SigLevel= TrustedOnly</span><br><span class="line">Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch</span><br></pre></td></tr></table></figure></div></li><li><p>安装<code>archlinuxcn-keyring</code>:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S archlinuxcn-keyring</span><br></pre></td></tr></table></figure></div></li><li><p>同步并更新系统；</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -Syyu</span><br></pre></td></tr></table></figure></div></li></ol><h4 id="安装配置中文输入法"><a href="#安装配置中文输入法" class="headerlink" title="安装配置中文输入法"></a>安装配置中文输入法</h4><ol><li><p>安装中文输入法和<code>fcitx</code>管理工具:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S fcitx-sougoupinyin # 输入法看个人</span><br><span class="line">sudo pacman -S fcitx-im</span><br><span class="line">sudo pacman -S fcitx-configtool</span><br></pre></td></tr></table></figure></div></li><li><p>解决中文输入法无法切换问题: 添加文件<code>~/.xprofile</code>:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export GTK_MODULE=fcitx</span><br><span class="line">export QT_IM_MODULE=fcitx</span><br><span class="line">export XMODIFIERS=&quot;@im=fcitx&quot;</span><br></pre></td></tr></table></figure></div></li></ol><p>重启即可。</p><h4 id="配置Intel-和-Nvidia-双显卡切换"><a href="#配置Intel-和-Nvidia-双显卡切换" class="headerlink" title="配置Intel 和 Nvidia 双显卡切换"></a>配置Intel 和 Nvidia 双显卡切换</h4><p>Manjaro 提供了强大的硬件检测模块<code>mhwd</code>，可以很方便的安装各种驱动，要实现Intel 和 Nvidia 双显卡切换，我们需要安装video-hybrid-intel-nvidia-bumblebee <code>nvidia</code>闭源驱动和intel驱动的混合版<code>bumblebee</code>。对于之前安装系统是在<code>Live</code>启动菜单选择<code>Driver=no-free</code>的可以看看这个驱动是否已经安装：<br>系统设置中的硬件设置:<br><img src="manjaro-graphic-cards.png" alt=""><br>或<br><br><img src="manjaro-mhwd-installed-pci.png" alt=""></p><p>对于未安装的，这里提供一个最为简单的方式，<strong>直接在硬件设置中，右键安装即可，这样可以省去自己去添加用户组和开机启动，以及切换状态初始化</strong></p><div class="note warning"><p><strong>[注意：]</strong> 下面的这些依赖必须安装，否则会出现独立显卡无法正常工作的问题(fps跟集成显卡差不多)：</p></div><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S virtualgl lib32-virtualgl</span><br></pre></td></tr></table></figure></div><p>对于独立显卡的使用，可以使用<code>bbswitch</code>来进行切换开关，然后使用<code>optirun</code>来运行程序:</p><blockquote><ol><li>首先查看显卡的状态: <code>lspci | grep -i nvidia</code>(rev ff 表示关闭状态)<br><img src="nvidia-off.png" alt=""></li><li>打开独立显卡，并进行测试，对比集成显卡的fps：<ul><li>集成显卡 FPS:<br><img src="intel-fps.png" alt=""></li><li>打开独立显卡<code>sudo tee /proc/acpi/bbswitch &lt;&lt;&lt; &quot;ON&quot;</code>,测试FPS:<br><img src="nvidia-fps.png" alt=""></li></ul></li><li>独立显卡设置 nvidia-settings 需要用<code>optirun nvidia-setting -c :8</code>才能打开:<br><img src="nvidia-settings.png" alt=""></li></ol></blockquote><h4 id="使用-zsh-和-oh-my-zsh-配置终端"><a href="#使用-zsh-和-oh-my-zsh-配置终端" class="headerlink" title="使用 zsh 和 oh-my-zsh 配置终端"></a>使用 zsh 和 oh-my-zsh 配置终端</h4><p>我的 zsh 终端模拟器(theme: rjkirch_mod)：</p><p><img src="my-zsh.png" alt=""></p><p>基本配置过程：</p><ul><li>查看系统安装了多少shell <code>cat /etc/shells</code></li><li>查看当前shell : <code>echo $SHELL</code></li><li>使用 <code>chsh</code>切换默认<code>shell</code>.</li></ul><p>配置 zsh，直接使用<strong>oh-my-zsh</strong>来进行配置: <a href="https://github.com/robbyrussell/oh-my-zsh" target="_blank" rel="noopener">Oh-my-zsh</a>.<br>zsh 主题可以自行按个人喜好配置，当然也可以随机(每次打开终端都随机选择一个主题).</p><p>插件推荐: (插件配置太多的话，会使shell启动速度变慢，适当就好)</p><p><img src="zsh-plugins.png" alt=""></p><ul><li><a href="https://github.com/wting/autojump" target="_blank" rel="noopener">Autojump</a></li><li><a href="https://github.com/zsh-users/zsh-syntax-highlighting" target="_blank" rel="noopener">zsh-syntax-highlighting</a></li><li><a href="https://github.com/zsh-users/zsh-autosuggestions" target="_blank" rel="noopener">zsh-autosuggestions</a></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>Manjaro</code>的安装和基本配置就到此结束。最后，简单说一下我安装此系统的缘由。在安装<code>manjaro</code>之前，我使用的是<code>win10 LTSB 2016</code>，之前接触过的的Linux发行版是<code>CentOS</code>, <code>Unbuntu</code>以及 <code>kali</code>， 前两者我不怎么想要，本来想直接换成<code>kali</code>，但是考虑到<code>kali</code>一般是作为一个工具来使用，并不适合我平时开发和日常使用，就再次寻找适合的Linux发行版，最后看上了<code>Arch Linux</code>，但是又因为<code>Arch</code>上手难度较高，退而求其次，选择了<code>Manjaro</code>。当然啦，<code>Win10</code>肯定是要保留的，<code>Kali</code>也是要的。</p><p>于是乎，在原先的<code>GPT+UEFI</code>引导方式的基础之上，我重新分配了我的磁盘，将原有的<code>Win10</code>系统盘缩小，把它当备用系统，<code>Manjaro</code>作为主要系统使用，而<code>Kali</code>只作为工具使用，其他的磁盘分区作为数据存放的分区，各个系统共用。</p><p><img src="win-manjaro-kali.jpg" alt=""></p><p><img src="disk-structure.png" alt=""></p><p>然后使用 <code>REfind</code>来管理和引导系统:</p><p><img src="refind-menu.jpg" alt=""></p><div class="note primary"><p>对于Refind有兴趣的可以直接<code>google</code>或<code>baidu</code>了解一下，选择一个现有的主题然后自己稍微进行配置一下，就可以了。<br>参考:</p><ul><li><a href="http://www.rodsbooks.com/refind/" target="_blank" rel="noopener">http://www.rodsbooks.com/refind/</a></li><li><a href="https://wiki.archlinux.org/index.php/REFInd_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87" target="_blank" rel="noopener">Arch Wiki 上关于refind的内容</a>)</li></ul></div><h4 id="各个系统桌面"><a href="#各个系统桌面" class="headerlink" title="各个系统桌面"></a>各个系统桌面</h4><ul><li>Win10 LTSB</li></ul><p><img src="win10.png" alt=""></p><ul><li>Manjaro 17.1.12 (DE: KDE)</li></ul><p><img src="manjaro-desktop.png" alt=""></p><ul><li>Kali 2018.1(upgraded)</li></ul><p><img src="kali.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/linux/manjaro-installed.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Manjaro是一款基于Arch Linux、对用户友好、全球排名第一的Linux发行版。（排名数据源于&lt;a href=&quot;http://distrowatch.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;DistroWatch&lt;/a&gt;，统计日期2018.08.22，时间段3个月。）&lt;br&gt;在Linux圈，Arch的确是一个异常强大的发行版。它有3个无与伦比的优势：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;滚动更新可以使软件保持最新；&lt;/li&gt;
&lt;li&gt;AUR软件仓库有着世界上最齐全的Linux软件（&lt;a href=&quot;https://www.lulinux.com/archives/2787&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;参考《一张列表展示ArchLinux系软件有多丰富——看哭百万Debian、RedHat系同学》&lt;/a&gt;）；&lt;/li&gt;
&lt;li&gt;丰富的wiki和活跃的社区让所有问题都可以快速得到满意的答案。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;相比于&lt;code&gt;Arch linux&lt;/code&gt;, 不得感叹, &lt;a href=&quot;http://www.manjaro.cn/451&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;人生苦短,我用 &lt;strong&gt;Manjaro&lt;/strong&gt;啊!&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://rovo98.github.io/categories/Linux/"/>
    
    
      <category term="linux" scheme="http://rovo98.github.io/tags/linux/"/>
    
      <category term="manjaro" scheme="http://rovo98.github.io/tags/manjaro/"/>
    
  </entry>
  
  <entry>
    <title>爬取校内腾讯企业邮箱通信录</title>
    <link href="http://rovo98.github.io/posts/e675b5d9/"/>
    <id>http://rovo98.github.io/posts/e675b5d9/</id>
    <published>2018-07-25T06:07:00.000Z</published>
    <updated>2018-10-08T05:08:42.451Z</updated>
    
    <content type="html"><![CDATA[<p>简单使用python <code>request</code> + <code>re</code> 爬取校内邮箱通信录(腾讯企业邮箱)的用户信息数据。</p><a id="more"></a><h3 id="一、分析需要爬取的数据"><a href="#一、分析需要爬取的数据" class="headerlink" title="一、分析需要爬取的数据"></a>一、分析需要爬取的数据</h3><p>通过手动打开浏览器，正常访问网站，判断需要爬取的数据是静态还是动态数据，制定不同的爬取方案。</p><h4 id="1-静态-动态-数据类型判断"><a href="#1-静态-动态-数据类型判断" class="headerlink" title="1. 静态/动态 数据类型判断"></a>1. 静态/动态 数据类型判断</h4><p>登陆企业校内邮箱，可以看到需要获取的内容主要呈现在该页面:<br><br><img src="step_01.png" alt=""></p><p><code>F12</code>打开控制台，查看<code>Elements</code>，可以很容易发现，用户数据在目录节点没有展开的情况下，html文档中并不会包含我们需要的数据，当点击展开目录节点后，才能获取到数据。<br><br><img src="step_02.png" alt=""><br>因此，可以判断，我们需要爬取的数据是动态生成的，可以初步认为是通过<code>AJAX</code>异步请求来从服务器端获取数据的。</p><h4 id="2-数据定位"><a href="#2-数据定位" class="headerlink" title="2. 数据定位"></a>2. 数据定位</h4><p>我们已经知道了需要爬取的数据是动态生成的，这时，同样<code>F12</code>打开控制台，到<code>Network</code>栏目下，查找类型为<code>XHR</code>(AJAX的请求链接)的请求链接，并按数据文件大小从到小排序，再次刷新页面，点击通讯录栏目，展开到具体的用户项，依次点击<code>XHR</code>以确定需要的数据是通过哪个链接获取的：<br><br><img src="step_03.png" alt=""></p><p>可以看到，请求链接格式为:<code>https://exmail.qq.com/cgi-bin/laddr_biz?t=memtree&amp;limit={limit}&amp;partyid={pid}&amp;action=show_party&amp;sid={sid}</code>,参数有 - <br></p><div class="table-container"><table><thead><tr><th style="text-align:center">Argument</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td style="text-align:center">t</td><td style="text-align:center">取值不变,<code>memtree</code>，具体含义就不管了</td></tr><tr><td style="text-align:center">limit</td><td style="text-align:center">链接中取值:<code>500</code>,单次获取用户的最大数量，<br>我们可以自己修改，再次发起请求来验证</td></tr><tr><td style="text-align:center">partyid</td><td style="text-align:center">变化值，为所属组的id,例如：<br>学生 -&gt; 专业 -&gt; 院系<br>学生所属专业<code>partyid</code>就是的专业的<code>id</code>,etc.</td></tr><tr><td style="text-align:center">action</td><td style="text-align:center">在此链接中不变，取值:<code>show_party</code></td></tr><tr><td style="text-align:center">sid</td><td style="text-align:center">用户登陆后生成的<code>sid</code>值，访问过程中不变</td></tr></tbody></table></div><p><img src="step_04.png" alt=""></p><p>通过上面的分析，我们可以知道，要获取所有学生的信息，主要是在获取所有的专业的<code>id</code>后，依次作为上面链接的<code>partyid</code>来发起请求即可。</p><p>尝试在html <code>Elements</code>文档中搜索，能够搜到相应的数据，但它也是动态生成的 - </p><p><img src="step_05.png" alt=""></p><p>继续在<code>Network</code>中将过滤类型设置为<code>doc</code>同时按文件大小排序，查找包含<code>oPartyList</code>的文件 -</p><p><img src="step_06.png" alt=""></p><p>到此，我们所有的分析任务已经结束了，接下来只需要编写相应的爬虫程序即可。</p><h3 id="二、爬虫程序设计"><a href="#二、爬虫程序设计" class="headerlink" title="二、爬虫程序设计"></a>二、爬虫程序设计</h3><p>这里只是编写一个简单的爬虫程序，不使用IP代理，爬虫发起请求所需的<code>sid</code>通过用户自己登陆后手动获取，相应的<code>cookie</code>也是如此。</p><h4 id="1-获取所有专业的id"><a href="#1-获取所有专业的id" class="headerlink" title="1. 获取所有专业的id"></a>1. 获取所有专业的id</h4><p>上面分析提到的，要获取用户数据，主要是要先获取到用户所在的组id<code>partyid</code>。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getAllPID</span><span class="params">()</span>:</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">    获取所有的专业id,作为用户的pid.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    sid = <span class="string">'xxx'</span>   <span class="comment"># 用户登陆后的sid</span></span><br><span class="line">    all_parties_url = <span class="string">'https://exmail.qq.com/cgi-bin/laddr_biz?action=show_party_list&amp;sid=&#123;sid&#125;&amp;t=contact&amp;view=biz'</span>.format(sid=sid)</span><br><span class="line">    cookies = dict(...) <span class="comment"># cookie参数和值</span></span><br><span class="line">    request = request.get(all_parties_url,cookies=cookies)</span><br><span class="line">    </span><br><span class="line">    regexp = <span class="string">r'&#123;id:"(\S*?)", pid:"(\S*?)", name:"(\S*?)", order:"(\S*?)"&#125;'</span></span><br><span class="line">    results = re.findall(regexp,text)</span><br><span class="line">    all_parties_ids = []       <span class="comment"># 所有pid</span></span><br><span class="line">    all_parties_info = dict() <span class="comment"># 所有组信息</span></span><br><span class="line">    root_party = <span class="keyword">None</span>      <span class="comment"># 根通信组</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> results:</span><br><span class="line">    all_parties_id.append(p[<span class="number">0</span>])</span><br><span class="line">        party = dict(id=item[<span class="number">0</span>], pid=item[<span class="number">1</span>], name=item[<span class="number">2</span>], order=item[<span class="number">3</span>])</span><br><span class="line">        all_parties_info[item[<span class="number">0</span>]] = party</span><br><span class="line">        <span class="keyword">if</span> p[<span class="number">1</span>] == <span class="number">0</span> <span class="keyword">or</span> p[<span class="number">1</span>] == <span class="string">'0'</span>:</span><br><span class="line">        root_party = party</span><br></pre></td></tr></table></figure></div><h4 id="2-获取学生信息数据"><a href="#2-获取学生信息数据" class="headerlink" title="2. 获取学生信息数据"></a>2. 获取学生信息数据</h4><p>依次遍历<code>pid</code>列表，构造不同的<code>pid</code>不同的链接，来获取全部的通讯录内容。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getAllUserInfo</span><span class="params">()</span>:</span></span><br><span class="line">...</span><br><span class="line">    获取所有通讯录用户信息</span><br><span class="line">    ...</span><br><span class="line">    all_user_info = []  <span class="comment"># 用于保存所有用户数据信息</span></span><br><span class="line">    <span class="comment"># 获取用户数据的链接</span></span><br><span class="line">    party_user_url = <span class="string">'https://exmail.qq.com/cgi-bin/laddr_biz?t=memtree&amp;limit=&#123;limit&#125;'</span>\</span><br><span class="line">    <span class="string">'&amp;partyid=&#123;pid&#125;&amp;action=show_party&amp;sid=&#123;sid&#125;'</span></span><br><span class="line">    regexp = <span class="string">r'&#123;uin:"(\S*?)", pid:"(\S*?)", alias:"(\S*?)", sex:"(\S*?), pos:"(\S*?)", tel:"(\S*?)",'</span>\</span><br><span class="line">    <span class="string">' birth:"(\S*?)(\S*?)(\S*?)(\S*?)", slave_alias:"(\S*?)(\S*?)(\S*?)", department:"(\S*?)(\S*?)", mobile:"(\S*?)"&#125;'</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> pid <span class="keyword">in</span> all_parites_ids:</span><br><span class="line">        <span class="comment"># 依次构造不同pid的请求链接</span></span><br><span class="line">    url = party_user_url.format(limit=limit, pid=pid, sid=sid)</span><br><span class="line">        request = requests.get(url, cookies=cookies)</span><br><span class="line">        text = request.text</span><br><span class="line">        results = re.findall(regexp, text)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> results:</span><br><span class="line">        user = dict(uin=item[<span class="number">0</span>], pid=item[<span class="number">1</span>], name=item[<span class="number">2</span>], alias=item[<span class="number">3</span>], sex=item[<span class="number">4</span>],</span><br><span class="line">            pos=item[<span class="number">5</span>], tel=item[<span class="number">6</span>],birth=item[<span class="number">7</span>], slave_alias=item[<span class="number">8</span>], department=item[<span class="number">9</span>],</span><br><span class="line">                   mobile=item[<span class="number">10</span>])</span><br><span class="line">         all_user_info.append(user)</span><br></pre></td></tr></table></figure></div><p>完整的程序，请移步到<a href="https://github.com/rovo98/python-learning/blob/master/web-spiders/tx_email_spider/tx_email_spider.py" target="_blank" rel="noopener">Github</a>查看.</p><h3 id="三、爬取结果"><a href="#三、爬取结果" class="headerlink" title="三、爬取结果"></a>三、爬取结果</h3><p><img src="step_07.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单使用python &lt;code&gt;request&lt;/code&gt; + &lt;code&gt;re&lt;/code&gt; 爬取校内邮箱通信录(腾讯企业邮箱)的用户信息数据。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://rovo98.github.io/categories/Python/"/>
    
      <category term="python爬虫" scheme="http://rovo98.github.io/categories/Python/python%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="Spider demo" scheme="http://rovo98.github.io/tags/Spider-demo/"/>
    
  </entry>
  
  <entry>
    <title>解决Github国内访问出现的问题</title>
    <link href="http://rovo98.github.io/posts/7e3029b3/"/>
    <id>http://rovo98.github.io/posts/7e3029b3/</id>
    <published>2018-06-10T07:58:34.000Z</published>
    <updated>2018-11-01T13:38:38.745Z</updated>
    
    <content type="html"><![CDATA[<p>主要通过修改hosts文件解决Github在国内访问不了、访问慢和页面加载异常的问题(没钱买vpn~)。</p><p>简单了解一下github, github是目前全球最大的男性同性交友网站(~滑稽~), 使用示例如下：</p><p><img src="/images/解决Github访问问题/communication.png" alt=""></p><a id="more"></a><p>开个玩笑，回归正题。</p><h3 id="为什么访问不了以及访问速度会很慢？"><a href="#为什么访问不了以及访问速度会很慢？" class="headerlink" title="为什么访问不了以及访问速度会很慢？"></a>为什么访问不了以及访问速度会很慢？</h3><p>GitHub在中国大陆访问速度慢的问题原因有很多，但最直接和最主要的原因是GitHub的分发加速网络的域名遭到DNS污染。</p><p>由于GitHub的加速分发CDN域名assets-cdn.github.com遭到DNS污染，导致无法连接使用GitHub的加速分发服务器，才使得中国大陆访问速度很慢。</p><p><img src="github_problem.png" alt="problem"></p><h3 id="如何解决DNS污染？"><a href="#如何解决DNS污染？" class="headerlink" title="如何解决DNS污染？"></a>如何解决DNS污染？</h3><p>一般的DNS问题都可以通过修改Hosts文件来解决，GitHub的CDN域名被污染问题也不例外，同样可以通过修改Hosts文件解决。</p><p>将域名解析直接指向IP地址来绕过DNS的解析，以此解决污染问题。</p><h4 id="获取被污染域名的实际IP地址"><a href="#获取被污染域名的实际IP地址" class="headerlink" title="获取被污染域名的实际IP地址"></a>获取被污染域名的实际IP地址</h4><p>访问<a href="https://www.ipaddress.com" target="_blank" rel="noopener">ipaddress.com</a>,使用ip lookup 工具获得相关域名的ip地址。</p><p>例如： github.com</p><p><img src="github_ipaddress.png" alt="ip address"></p><p>可以看到，我查出的域名ip地址为： <code>192.30.253.112</code> 和 <code>192.30.253.113</code> (任取一个即可)</p><h4 id="修改host文件，在文件中添加一行："><a href="#修改host文件，在文件中添加一行：" class="headerlink" title="修改host文件，在文件中添加一行："></a>修改host文件，在文件中添加一行：</h4><p><strong>[注] ： windows的hosts文件位置为： </strong><br><code>C:/windows/system32/drivers/etc/hosts</code></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">192.30.253.112 github.com</span><br></pre></td></tr></table></figure></div><h4 id="刷新dns缓存"><a href="#刷新dns缓存" class="headerlink" title="刷新dns缓存"></a>刷新dns缓存</h4><p>打开命令行cmd,输入如下命令：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig /flushdns</span><br></pre></td></tr></table></figure></div><p>此时再刷新页面即可。此时可以正常访问github，但是访问速度还是很慢，我们接着做优化。</p><h4 id="Github-访问提速"><a href="#Github-访问提速" class="headerlink" title="Github 访问提速"></a>Github 访问提速</h4><p>在hosts文件中继续加入，如下代码：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># GitHub Start</span><br><span class="line">192.30.253.112 github.com</span><br><span class="line">192.30.253.119 gist.github.com</span><br><span class="line">151.101.228.133 assets-cdn.github.com</span><br><span class="line">151.101.228.133 raw.githubusercontent.com</span><br><span class="line">151.101.228.133 gist.githubusercontent.com</span><br><span class="line">151.101.228.133 cloud.githubusercontent.com</span><br><span class="line">151.101.228.133 camo.githubusercontent.com</span><br><span class="line">151.101.228.133 avatars0.githubusercontent.com</span><br><span class="line">151.101.228.133 avatars1.githubusercontent.com</span><br><span class="line">151.101.228.133 avatars2.githubusercontent.com</span><br><span class="line">151.101.228.133 avatars3.githubusercontent.com</span><br><span class="line">151.101.228.133 avatars4.githubusercontent.com</span><br><span class="line">151.101.228.133 avatars5.githubusercontent.com</span><br><span class="line">151.101.228.133 avatars6.githubusercontent.com</span><br><span class="line">151.101.228.133 avatars7.githubusercontent.com</span><br><span class="line">151.101.228.133 avatars8.githubusercontent.com</span><br><span class="line">192.30.253.116  api.github.com</span><br><span class="line"># GitHub End</span><br></pre></td></tr></table></figure></div><div class="note warning"><p><strong>注意</strong> : 这里域名对应的ip是通过dns查询工具查询得到的，你应当选择的是延时相对较小且比较稳定的ip。</p></div><p>例如，上面的<code>151.101.228.133</code>是对我来说较好的ip:</p><p><img src="ping_test.png" alt="dns 查询检测"></p><div class="note info"><p>推荐的dns查询检测工具：</p><ul><li><a href="https://tool.lu/dns/" target="_blank" rel="noopener">DNS查询 - 在线工具</a></li><li><a href="http://tool.chinaz.com/dns/" target="_blank" rel="noopener">DNS检测|DNS查询-站长工具</a></li></ul><p>你可对单个域名多查询几次，以挑选稳定且速度较快的ip。</p></div><h4 id="快速地访问github"><a href="#快速地访问github" class="headerlink" title="快速地访问github"></a>快速地访问github</h4><p>再次刷新dns缓存后，你已经可以快速地访问github了。</p><p><img src="github_test.gif" alt=""></p><div class="note primary"><p>参考：<a href="https://github.com/chenxuhua/issues-blog/issues/3" target="_blank" rel="noopener">https://github.com/chenxuhua/issues-blog/issues/3</a></p></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要通过修改hosts文件解决Github在国内访问不了、访问慢和页面加载异常的问题(没钱买vpn~)。&lt;/p&gt;
&lt;p&gt;简单了解一下github, github是目前全球最大的男性同性交友网站(~滑稽~), 使用示例如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/解决Github访问问题/communication.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="tips" scheme="http://rovo98.github.io/categories/tips/"/>
    
    
      <category term="github" scheme="http://rovo98.github.io/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>PPP 点对点通信验证</title>
    <link href="http://rovo98.github.io/posts/28ff89ad/"/>
    <id>http://rovo98.github.io/posts/28ff89ad/</id>
    <published>2018-06-09T16:10:00.000Z</published>
    <updated>2018-10-08T05:08:42.645Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/ppp通信验证/structure.png" alt=""></p><p>使用Cisco Packet Tracer7 (思科网络模拟器)验证ppp点对点通信。</p><a id="more"></a><h3 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h3><p>使用<code>packet Tracer</code> 模拟两台路由器，进行点对点通信测试。</p><h3 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h3><h4 id="配置路由器"><a href="#配置路由器" class="headerlink" title="配置路由器"></a>配置路由器</h4><p>由于只需要验证点对点通信，对路由器的配置，相对比较简单，<br>路由器之间使用的是serial DCE 串口线相连。</p><p>配置Router1的<code>serial 2/0</code>串口为ip: <code>11.0.0.1</code> mask: <code>255.0.0.0</code>,并配置时钟频率为<code>64000</code></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Router&gt; enable</span><br><span class="line">Router# configure terminal</span><br><span class="line">Router(config) # hostname RA</span><br><span class="line">RA (config) # interface serial 2/0</span><br><span class="line">RA (config) # no shutdown</span><br><span class="line">RA (config-if) # ip address 11.0.0.1 255.0.0.0</span><br><span class="line">RA (config-if) # clock rate 64000</span><br></pre></td></tr></table></figure></div><p>配置Router2的<code>serial 3/0</code> 串口为ip: <code>11.0.0.2</code> mask： <code>255.0.0.0</code></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Router&gt; enable</span><br><span class="line">Router# configure terminal</span><br><span class="line">Router(config) # hostname RB</span><br><span class="line">RB (config) # interface serial 3/0</span><br><span class="line">RB (config) # no shutdown</span><br><span class="line">RB (config-if) # ip address 11.0.0.2 255.0.0.0</span><br></pre></td></tr></table></figure></div><ul><li>查看两个路由的串口状态：</li></ul><p><code>RA</code>:</p><p><img src="hdsl_rt1.png" alt="RA serial 2/0"></p><p><code>RB</code>:</p><p><img src="hdsl_rt2.png" alt="RB serial 3/0"></p><p>可以看到，路由器这里点对点通信默认使用的<code>HDLC</code>(High Level Data Link Control, 面向比特的同步协议)协议。</p><h4 id="HDLC情况下验证ping："><a href="#HDLC情况下验证ping：" class="headerlink" title="HDLC情况下验证ping："></a>HDLC情况下验证ping：</h4><p><code>11.0.0.1</code> ping <code>11.0.0.2</code>:</p><p><img src="hdlc_ping_rt1.png" alt="RA ping Test"></p><p><code>11.0.0.2</code> ping <code>11.0.0.1</code>:</p><p><img src="hdlc_ping_rt2.png" alt="RB ping Test"></p><p>ping 测试成功。</p><h4 id="配置RA-RB使用ppp协议，再做ping测试："><a href="#配置RA-RB使用ppp协议，再做ping测试：" class="headerlink" title="配置RA,RB使用ppp协议，再做ping测试："></a>配置RA,RB使用ppp协议，再做ping测试：</h4><ul><li>先配置<code>RA</code> 使用 <code>ppp</code>协议：</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RA # configure terminal</span><br><span class="line">RA (config) # interface serial 2/0</span><br><span class="line">RA (config-if) # encapsulation ppp</span><br></pre></td></tr></table></figure></div><p><img src="RA_ppp_setting.png" alt="RA serial 2/0"></p><p>可以看到<code>RA</code>当前使用的是<code>ppp</code>写协议，<code>LCP</code>处于<code>Closed</code>,此时，路由器应当无法进行点对点通信。</p><p><img src="RA_ppp_fTest.png" alt="ping Test"></p><ul><li>配置<code>RB</code>使用<code>ppp</code>协议：</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RB # configure terminal</span><br><span class="line">RB (config) # interface serial 3/0</span><br><span class="line">RB (config-if) # encapsulation ppp</span><br></pre></td></tr></table></figure></div><p><img src="RB_ppp_setting.png" alt="RB serial 3/0"></p><p>这时，可以看到<code>RB</code>也是使用了<code>ppp</code>协议，且<code>LCP</code>也处于<code>Open</code>状态，路由器之间可以进行通信。</p><p><img src="RB_ppp_sTest.png" alt="ping Test"></p><h4 id="给ppp协议添加authentication鉴别"><a href="#给ppp协议添加authentication鉴别" class="headerlink" title="给ppp协议添加authentication鉴别"></a>给ppp协议添加authentication鉴别</h4><ul><li>先配置<code>RA</code>，使其开启<code>ppp chap</code> (Challenge Handshake Authentication Protocol), 给<code>RB</code> 添加身份验证</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RA # config terminal</span><br><span class="line">RA (config) # username RB password password</span><br><span class="line">RA (config) # interface serial 2/0</span><br><span class="line">RA (config-if) # ppp authentication chap</span><br></pre></td></tr></table></figure></div><p><img src="RA_ppp_au.png" alt="RA serial 2/0"></p><p>此时，虽然<code>RA</code>和<code>RB</code>都是使用<code>ppp</code>协议，但是<code>RA</code>给<code>RB</code>添加了身份认证，而<code>RB</code>则没有，此时<code>LCP</code>处于<code>Closed</code>状态，它们之间无法进行通信。</p><ul><li>配置<code>RB</code>, 添加对<code>RA</code>的身份验证：</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RB # config terminal</span><br><span class="line">RB (config) # username RA password password</span><br><span class="line">RB (config) # interface serial 2/0</span><br><span class="line">RB (config-if) # ppp authentication chap</span><br></pre></td></tr></table></figure></div><p><img src="RB_ppp_au.png" alt="RB serial 3/0"></p><p>可以看到此时，<code>LCP</code>已经打开，路由器之间可以进行点对点通信。</p><p><img src="RB_ping_final.png" alt="ping"></p><h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><p>通过该实验，简单地验证了<code>ppp</code>协议在点对点信道中的使用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/ppp通信验证/structure.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;使用Cisco Packet Tracer7 (思科网络模拟器)验证ppp点对点通信。&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://rovo98.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="ppp通信" scheme="http://rovo98.github.io/tags/ppp%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>使用ensp进行简单的路由器互连实验</title>
    <link href="http://rovo98.github.io/posts/cc46ce96/"/>
    <id>http://rovo98.github.io/posts/cc46ce96/</id>
    <published>2018-06-06T16:00:00.000Z</published>
    <updated>2018-10-08T05:08:42.558Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/ensp_路由连接实验/route-structure.png" alt=""></p><p>使用ensp做华为AR1220路由进行简单的互连实验。</p><a id="more"></a><h3 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h3><ul><li>路由器设置</li><li>手动设置静态路由</li></ul><h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><ul><li>华为路由器AR1220</li><li>主机</li><li>Serial设备连接串口线和Copper以太网和千兆以太网连接线</li></ul><p>备注：所有实验设备均由<strong>ensp</strong>模拟。</p><h4 id="路由连接实验设计"><a href="#路由连接实验设计" class="headerlink" title="路由连接实验设计"></a>路由连接实验设计</h4><p>整体设计结构如下：</p><ul><li>1.其中分为六个不同的局域网；</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">192.168.11.0 网段 -&gt;</span><br><span class="line">    主机:   192.168.11.11</span><br><span class="line">            192.168.11.12</span><br><span class="line">    路由器AR6一个GigabitEthernet接口作为该网段的默认网关(192.168.11.1)</span><br><span class="line"></span><br><span class="line">192.168.12.0 网段 -&gt;</span><br><span class="line">    主机:   192.168.12.11</span><br><span class="line">            192.168.12.12</span><br><span class="line">    路由器AR4的一个GigabitEthernet接口作为该网段的默认网关(192.168.12.1)</span><br><span class="line"></span><br><span class="line">192.168.13.0 网段 -&gt;</span><br><span class="line">    主机:    192.168.13.11</span><br><span class="line">            192.168.13.12</span><br><span class="line">            192.168.13.13</span><br><span class="line">   路由器AR7的一个GigabitEthernet接口作为该网段的默认网关(192.168.13.1)</span><br><span class="line">   </span><br><span class="line">1.1.2.0 网段 -&gt; 路由器AR6和路由器AR7之间的接口</span><br><span class="line">1.1.1.0 网段 -&gt; 路由器AR6和AR4之间的接口</span><br><span class="line">1.1.3.0 网段 -&gt; 路由器AR6和AR7之间的接口</span><br></pre></td></tr></table></figure></div><ul><li>2.设备的连接：</li></ul><blockquote><p>除了路由器之间连接使用serial串口连接线外，其他均使用Copper连接线。</p></blockquote><h3 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h3><h4 id="配置各个局域网的ip及其网关"><a href="#配置各个局域网的ip及其网关" class="headerlink" title="配置各个局域网的ip及其网关"></a>配置各个局域网的ip及其网关</h4><ul><li>例如：<code>192.168.11.0</code>网段下的<code>192.168.11.11</code>主机：</li></ul><p><img src="pc1_setting.png" alt="PC1"></p><ul><li>配置 <code>192.168.11.1</code>作为<code>192.168.11.0</code>网段的网关：</li></ul><p><img src="gateway1.png" alt="设置网关"></p><p>所有主机经过配置后，他们应该可以ping通自己网段下的所有主机，如：<code>192.168.11.12</code> ping <code>192.168.11.11</code></p><p><img src="pingTest.png" alt="局域网ping测试"></p><p><strong>[需要注意的是]</strong>： 由于路由器互连时使用的是serial串口，所以路由器之间配置的是serial串口的ip。</p><p>例如：配置AR6的两个serial串口的接口ip为：<code>1.1.1.1</code>和<code>1.1.2.1</code>：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;Huawei&gt; system-view</span><br><span class="line">[Huawei] inter serial 2/0/1</span><br><span class="line">[Huawei-Servial2/0/1] ip address 1.1.1.1 255.255.255.0</span><br><span class="line">[Huawei-Servial2/0/1] quit</span><br><span class="line">[Huawei] inter serial 2/0/0</span><br><span class="line">[Huawei-Serial2/0/0] ip address 1.1.2.1 255.255.255.0</span><br></pre></td></tr></table></figure></div><h4 id="各个路由器的静态路由："><a href="#各个路由器的静态路由：" class="headerlink" title="各个路由器的静态路由："></a>各个路由器的静态路由：</h4><p>对于路由器AR6,我们希望所有<strong>目的网络</strong>为<code>192.168.12.0</code>的数据包都交付给AR4,即下一跳为<code>1.1.1.2</code>;所有目的网络为<code>192.168.13.0</code>的都交给AR7,下一跳为<code>1.1.2.2</code>：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Huawei&gt; system-view</span><br><span class="line">[Huawei] ip route-static 192.168.12.0 255.255.255.0 1.1.1.2</span><br><span class="line">[Huawei] ip route-static 192.168.13.0 255.255.255.0 1.1.2.2</span><br></pre></td></tr></table></figure></div><p>对于路由器AR4，所有目的网络为<code>192.168.11.0</code>的数据包交给AR6，下一跳为：<code>1.1.1.1</code>，目的网络为<code>192.168.13.0</code>的数据包交给AR7，下一跳为：<code>1.1.3.1</code>：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Huawei&gt; system-view</span><br><span class="line">[Huawei] ip route-static 192.168.11.0 255.255.255.0 1.1.1.1</span><br><span class="line">[Huawei] ip route-static 192.168.13.0 255.255.255.0 1.1.3.1</span><br></pre></td></tr></table></figure></div><p>对于路由器AR7， 所有目的网络为<code>192.168.11.0</code>的数据包都交给AR6，下一跳为：<code>1.1.2.1</code>，所有目的网络为<code>192.168.12.0</code>的数据包都交给AR4，下一跳为：<code>1.1.3.2</code>：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Huawei&gt; system-view</span><br><span class="line">[Huawei] ip route-static 192.168.11.0 255.255.255.0 1.1.2.1</span><br><span class="line">[Huawei] ip route-static 192.168.12.0 255.255.255.0 1.1.3.2</span><br></pre></td></tr></table></figure></div><p>经过以上对各个路由器的静态路由的配置后，我们可以通过<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">display ip routing-table</span><br></pre></td></tr></table></figure></div></p><p>来查看各个路由器的路由表：</p><ul><li>AR6路由表：</li></ul><p><img src="route1_info.png" alt="AR6路由表"></p><ul><li>AR4路由表：</li></ul><p><img src="route2_info.png" alt="AR4路由表"></p><ul><li>AR7路由表：</li></ul><p><img src="route3_info.png" alt="AR7路由表"></p><h3 id="测试实验结果"><a href="#测试实验结果" class="headerlink" title="测试实验结果"></a>测试实验结果</h3><p>使用任意一个局域网下的主机ping不同局域网下的主机：</p><p><code>192.168.11.11</code> ping <code>192.168.13.12</code> 和 <code>192.168.12.12</code>:</p><p><img src="tracert1.png" alt="tracert测试1"></p><p><code>192.168.12.11</code> ping <code>192.168.11.12</code> 和 <code>192.168.13.13</code>:</p><p><img src="tracert2.png" alt="tracert测试2"></p><p><code>192.168.13.11</code> ping <code>192.168.11.11</code> 和 <code>192.168.12.11</code>：</p><p><img src="tracert3.png" alt="tracert测试3"></p><p>由以上测试可以看出简单的路由器连接实验成功。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/ensp_路由连接实验/route-structure.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;使用ensp做华为AR1220路由进行简单的互连实验。&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://rovo98.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="路由器" scheme="http://rovo98.github.io/tags/%E8%B7%AF%E7%94%B1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Computer Network | 计算机网络</title>
    <link href="http://rovo98.github.io/posts/7fc520f1/"/>
    <id>http://rovo98.github.io/posts/7fc520f1/</id>
    <published>2018-05-20T04:00:00.000Z</published>
    <updated>2018-10-08T05:08:42.328Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/computer-networking/computer-networking.jpg" alt=""></p><p>计算机科学核心内容学习，译自<em>GeeksforGeeks</em>. 计算机网络作为计算机科学核心课程之一，是认识计算机网络、了解网络应用程序开发技术、探索计算机网络深层机理、了解计算机网络安全威胁及其防护技术等内容的必须学习的课程。</p><a id="more"></a><h3 id="基础-Basics"><a href="#基础-Basics" class="headerlink" title="基础 | Basics"></a>基础 | Basics</h3><ol><li><a href="/posts/c88d46b1/">计算机网络基础</a></li><li><a href="/posts/28f758bc/">互联网和网络</a></li><li><a href="/posts/8a6daeb5/">计算机网络的目标</a></li><li><a href="/posts/0/">计算机网络的链路配置</a></li><li><a href="/posts/2ccb698e/">计算机网路的传输模式</a></li><li><a href="">传输媒体的类型</a></li><li><a href="">单播，广播，多播</a></li><li><a href="">网络拓扑</a></li><li><a href="">区域网类型-LAN，MAN，WAN</a></li><li><a href="">接入网</a></li><li><a href="">TCP/IP模型</a></li><li><a href="">OSI参考模型分层</a></li></ol><h3 id="数据链路层-Data-Link-Layer"><a href="#数据链路层-Data-Link-Layer" class="headerlink" title="数据链路层 | Data Link Layer"></a>数据链路层 | Data Link Layer</h3><ol><li><a href="">局域网(LAN)技术</a></li><li><a href="">网络互联</a></li><li><a href="">数据链路层中的帧</a></li><li><a href="">MAC地址介绍</a></li><li><a href="">MAC过滤</a></li><li><a href="">多点接入协议</a></li><li><a href="">以太网帧格式</a></li><li><a href="">以太网信道</a></li><li><a href="">字节填充和位填充之间的区别</a></li><li><a href="">用Java实现字节填充</a></li><li><a href="">电路交换</a></li><li><a href="">分组交换和时延</a></li><li><a href="">电路交换 VS 分组交换</a></li><li><a href="">虚电路网络和数据报网络之间的区别</a></li><li><a href="">报文交换</a></li><li><a href="">无噪声和噪声信道上的最大数据速率(信道容量)</a></li><li><a href="">无线网络中的冲突避免(Colision Avoidance)</a></li><li><a href="">载波监听多点接入(CSMA)</a></li><li><a href="">CSMA/CD中的碰撞检测(Colision Detection)</a></li><li><a href="">CSMA/CD的效率</a></li><li><a href="">CSMA/CD退避算法</a></li><li><a href="">控制访问协议</a></li><li><a href="">虚拟局域网(VLAN)</a></li></ol><h3 id="网络层-Network-Layer"><a href="#网络层-Network-Layer" class="headerlink" title="网络层 | Network Layer"></a>网络层 | Network Layer</h3><h3 id="传输层-Transport-Layer"><a href="#传输层-Transport-Layer" class="headerlink" title="传输层 | Transport Layer"></a>传输层 | Transport Layer</h3><h3 id="应用层-Application-Layer"><a href="#应用层-Application-Layer" class="headerlink" title="应用层 | Application Layer"></a>应用层 | Application Layer</h3><h3 id="网络安全与密码学-Network-Security-and-Cryptography"><a href="#网络安全与密码学-Network-Security-and-Cryptography" class="headerlink" title="网络安全与密码学 | Network Security and Cryptography"></a>网络安全与密码学 | Network Security and Cryptography</h3><h3 id="压缩技术-Compression-Techniques"><a href="#压缩技术-Compression-Techniques" class="headerlink" title="压缩技术 | Compression Techniques"></a>压缩技术 | Compression Techniques</h3><h3 id="网络实验-Network-Experiments"><a href="#网络实验-Network-Experiments" class="headerlink" title="网络实验 | Network Experiments"></a>网络实验 | Network Experiments</h3><h3 id="设备-Devices"><a href="#设备-Devices" class="headerlink" title="设备 | Devices"></a>设备 | Devices</h3><h3 id="杂项-Misc"><a href="#杂项-Misc" class="headerlink" title="杂项 | Misc"></a>杂项 | Misc</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/computer-networking/computer-networking.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;计算机科学核心内容学习，译自&lt;em&gt;GeeksforGeeks&lt;/em&gt;. 计算机网络作为计算机科学核心课程之一，是认识计算机网络、了解网络应用程序开发技术、探索计算机网络深层机理、了解计算机网络安全威胁及其防护技术等内容的必须学习的课程。&lt;/p&gt;
    
    </summary>
    
      <category term="GeeksforGeeks" scheme="http://rovo98.github.io/categories/GeeksforGeeks/"/>
    
      <category term="Computer Network" scheme="http://rovo98.github.io/categories/GeeksforGeeks/Computer-Network/"/>
    
    
      <category term="学习笔记" scheme="http://rovo98.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="计算机网络" scheme="http://rovo98.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络中的传输模式 | Transmission in Computer Network</title>
    <link href="http://rovo98.github.io/posts/2ccb698e/"/>
    <id>http://rovo98.github.io/posts/2ccb698e/</id>
    <published>2018-05-19T16:00:05.000Z</published>
    <updated>2018-10-08T05:08:42.155Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/computer-networking/transmission-modes-in-computer-network.png" alt=""></p><blockquote><p>了解计算机网络中的传输模式 — 译自<em>GeeksforGeeks</em>.</p></blockquote><a id="more"></a><p>传输模式(<em>transmission mode</em>)意味着在两个设备之间传输数据。它也被称为通信模式(<em>communication mode</em>)。总线和网络旨在允许互连的各个设备之间进行通信。传输模式有下面三种类型 - </p><ul><li>单工传输模式 (Simplex Mode)</li><li>半双工传输模式 (Half-Duplex Mode)</li><li>全双工传输模式 (Full-Duplex Mode)</li></ul><p><img src="transmissionmodes.png" alt=""></p><h3 id="单工传输模式-Simplex-Mode"><a href="#单工传输模式-Simplex-Mode" class="headerlink" title="单工传输模式 (Simplex Mode)"></a>单工传输模式 (Simplex Mode)</h3><p><img src="simplexduplex.png" alt=""></p><p>在单工模式下，通信是单向的，就像在单行道上一样。链路上的两个设备中只有一个可以传输，另一个只能接受。单工模式可以使用通道的整个容量在一个方向上发送数据。</p><p>示例： 键盘和传统显示器。键盘只能引入输入，显示器只能输出。</p><h3 id="半双工传输模式-Half-Duplex-Mode"><a href="#半双工传输模式-Half-Duplex-Mode" class="headerlink" title="半双工传输模式 (Half-Duplex Mode)"></a>半双工传输模式 (Half-Duplex Mode)</h3><p><img src="halfduplex.png" alt=""></p><p>在半双工模式下，每个站点都可以发送和接受数据，但是不能同时发送和接受数据。当一个设备发送时，另一个设备只能接受，反之亦然。半双工模式用于不需要同时在两个方向上进行通信的情况。可以为每个方向利用整个信道的容量。</p><p>示例：对讲机，其中每一次只能一方发送消息，一方接受消息。并且可以在两个方向上发送消息。</p><h3 id="全双工传输模式-Full-Duplex-Mode"><a href="#全双工传输模式-Full-Duplex-Mode" class="headerlink" title="全双工传输模式 (Full-Duplex Mode)"></a>全双工传输模式 (Full-Duplex Mode)</h3><p><img src="fullduplex.png" alt=""></p><p>在全双工模式下，两个站点可以同时发送和接受数据。一个方向上的信号与另一个方向上的信号共享信道链路容量，这种共享可以通过下面两种方式实现 - </p><ul><li>链路包含两个物理上独立的传输路径(物理划分信道容量资源)，一个用于发送，一个用于接受；</li><li>在两个方向上传播的信号之间分配容量(信道复用, Multiplexing)</li></ul><p>当始终需要双向通信时，使用全双工模式。但是，信道的容量必须在两个方向之间分配。</p><p>示例：电话网络，通过电话线两个人之间的通信，可以同时进行通话和接受。</p><p><a href="/posts/7fc520f1">返回到计算机网络主目录</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/computer-networking/transmission-modes-in-computer-network.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;了解计算机网络中的传输模式 — 译自&lt;em&gt;GeeksforGeeks&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="GeeksforGeeks" scheme="http://rovo98.github.io/categories/GeeksforGeeks/"/>
    
      <category term="Computer Network" scheme="http://rovo98.github.io/categories/GeeksforGeeks/Computer-Network/"/>
    
      <category term="Basics" scheme="http://rovo98.github.io/categories/GeeksforGeeks/Computer-Network/Basics/"/>
    
    
      <category term="学习笔记" scheme="http://rovo98.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="计算机网络" scheme="http://rovo98.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络中的链路配置 | Line configuration in computer network</title>
    <link href="http://rovo98.github.io/posts/0/"/>
    <id>http://rovo98.github.io/posts/0/</id>
    <published>2018-05-19T16:00:04.000Z</published>
    <updated>2018-10-08T05:08:42.145Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/computer-networking/line-configurations.png" alt=""></p><p>了解计算机网络中的链路配置，译自<em>GeeksforGeeks</em>.</p><a id="more"></a><p>网络是通过链路连接的两个或更多设备。<strong>链路</strong>是将数据从一个设备传输到另一个设备的通信路径。设备可以是计算机，打印机或任何其他能够发送和接受数据的设备。出于可视化的目的，将任何链路想象为两点之间绘制的线。</p><p>为了进行通信，必须以某种方式将两个设备同时连接到同一链路上。有两种可能的连接类型 - </p><ol><li><strong>点对点连接(Point to Point Connection)</strong></li><li><strong>多点连接(Multipoint Connection)</strong></li></ol><h3 id="点对点连接-Point-to-Point-Connection"><a href="#点对点连接-Point-to-Point-Connection" class="headerlink" title="点对点连接 (Point to Point Connection)"></a>点对点连接 (Point to Point Connection)</h3><ol><li>点对点连接提供两个设备之间的专用链接;</li><li>链路的整个容量都用于这两个设备之间的传输;</li><li>大多数点对点连接使用实际长度的电线或电缆连接两端，但也可以使用其他选项，如微波或卫星链路;</li><li>点对点网路拓扑被认为是最简单和最传统的网络之一;</li><li>点对点连接的建立和理解也是最简单的.</li></ol><p>例如： 远程控制和电视之间使用点对点连接来更改频道。</p><h3 id="多点连接-Multipoint-Connection"><a href="#多点连接-Multipoint-Connection" class="headerlink" title="多点连接 (Multipoint Connection)"></a>多点连接 (Multipoint Connection)</h3><ol><li>Multipoint也可以是Multidrop,使用该连接的两个设备共享一个单一的链路;</li><li>两个以上的设备共享信道的容量，通过共享容量，多点链路配置有两种类型 - <br><ul><li><strong>空间共享(Spatial Sharing):</strong>如果多个设备可以同时共享链路，则称为空间共享线路配置;<br>  </li><li><strong>时间共享(Temporal/Time Sharing):</strong>如果用户必须轮流使用该链路，则称其为时间共享链路配置.</li></ul></li></ol><p><a href="/posts/7fc520f1">返回到计算机网络主目录</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/computer-networking/line-configurations.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;了解计算机网络中的链路配置，译自&lt;em&gt;GeeksforGeeks&lt;/em&gt;.&lt;/p&gt;
    
    </summary>
    
      <category term="GeeksforGeeks" scheme="http://rovo98.github.io/categories/GeeksforGeeks/"/>
    
      <category term="Computer Network" scheme="http://rovo98.github.io/categories/GeeksforGeeks/Computer-Network/"/>
    
      <category term="Basics" scheme="http://rovo98.github.io/categories/GeeksforGeeks/Computer-Network/Basics/"/>
    
    
      <category term="学习笔记" scheme="http://rovo98.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="计算机网络" scheme="http://rovo98.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络目标 | Network goals</title>
    <link href="http://rovo98.github.io/posts/8a6daeb5/"/>
    <id>http://rovo98.github.io/posts/8a6daeb5/</id>
    <published>2018-05-19T16:00:03.000Z</published>
    <updated>2018-10-08T05:08:42.078Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/computer-networking/network-goals.jpg" alt=""></p><blockquote><p>计算机网络是指用于信息交换的自主(独立)计算机的互连。连接介质可以是铜线，光纤，微波或卫星。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; —— 了解计算机网络的目标。译自<em>GeeksforGeeks</em>.</p></blockquote><a id="more"></a><h3 id="网络元素-Networing-Elements"><a href="#网络元素-Networing-Elements" class="headerlink" title="网络元素 (Networing Elements)"></a>网络元素 (Networing Elements)</h3><p>计算机网络包括以下网络元素 - </p><ol><li>至少两个主机;</li><li>传输介质有线或无线;</li><li>管理通信的协议或规则;</li><li>网络软件，例如网络操作系统.</li></ol><h3 id="网络标准-Network-Criteria"><a href="#网络标准-Network-Criteria" class="headerlink" title="网络标准 (Network Criteria)"></a>网络标准 (Network Criteria)</h3><p>计算机网络必须满足的标准是 : </p><h4 id="1-性能-Performance"><a href="#1-性能-Performance" class="headerlink" title="1. 性能 (Performance)"></a>1. 性能 (Performance)</h4><p>性能根据传输时间和响应时间来衡量 - </p><ul><li>传输时间是消息(数据)从一个设备到另一个设备的时间;</li><li>响应时间是请求和响应之间经过的时间.</li></ul><p>性能取决以下的因素 - </p><ul><li>用户的数量</li><li>传输媒体的类型</li><li>连接网络的传输能力</li><li>软件的效率</li></ul><h4 id="2-可靠性-Reliability"><a href="#2-可靠性-Reliability" class="headerlink" title="2. 可靠性 (Reliability)"></a>2. 可靠性 (Reliability)</h4><p>它的衡量标准是 - </p><ul><li>失败的频率</li><li>从失败中恢复的能力</li><li>灾难期间的健壮性</li></ul><h4 id="3-安全性-Security"><a href="#3-安全性-Security" class="headerlink" title="3. 安全性 (Security)"></a>3. 安全性 (Security)</h4><p>安全性主要是保护数据避免未授权的请求访问。</p><h3 id="计算机网络的目标"><a href="#计算机网络的目标" class="headerlink" title="计算机网络的目标"></a>计算机网络的目标</h3><p>下面列出的是计算机网络的重要目标 - </p><ol><li><p><strong>资源共享(Resource Sharing)</strong> - <br> 许多组织在运营中拥有大量的计算机，而它们是分开的。例如：一组办公室工作人员可以共享通用的打印机，传真，调制解调器，扫描仪等。</p></li><li><p><strong>高可靠性(High Reliability)</strong> - <br>如果有备用供应源，则可以在两台或多台计算机上复制所有文件。如果硬件故障，其中一个不可用，则可以使用其他副本。</p></li><li><p><strong>进程间通信(Inter-process Communication)</strong> - <br>位于地理上分开的网络用户可以通过网络在交互式会话中进行交谈。为了实现这一点，网络必须提供几乎无差错的通信。</p></li><li><p><strong>灵活访问(Flexible access)</strong> - <br>可以从网络中的任何计算机访问文件。一个项目可以从一台计算机开始，在另一台计算机上完成。</p></li></ol><p>计算机网络的其他目标是实现处理功能的分配，网络资源的集中管理和分配，不同设备和软件的兼容性，良好的网络性能，省钱，可扩展性，访问远程信息，人与人之间通信等。</p><p>原地址:<a href="https://www.geeksforgeeks.org/computer-network-network-goals" target="_blank" rel="noopener">https://www.geeksforgeeks.org/computer-network-network-goals</a></p><p><a href="/posts/7fc520f1">返回到计算机网络主目录</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/computer-networking/network-goals.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;计算机网络是指用于信息交换的自主(独立)计算机的互连。连接介质可以是铜线，光纤，微波或卫星。&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; —— 了解计算机网络的目标。译自&lt;em&gt;GeeksforGeeks&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="GeeksforGeeks" scheme="http://rovo98.github.io/categories/GeeksforGeeks/"/>
    
      <category term="Computer Network" scheme="http://rovo98.github.io/categories/GeeksforGeeks/Computer-Network/"/>
    
      <category term="Basics" scheme="http://rovo98.github.io/categories/GeeksforGeeks/Computer-Network/Basics/"/>
    
    
      <category term="学习笔记" scheme="http://rovo98.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="计算机网络" scheme="http://rovo98.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>互联网与网络 | The Internet and the Web</title>
    <link href="http://rovo98.github.io/posts/28f758bc/"/>
    <id>http://rovo98.github.io/posts/28f758bc/</id>
    <published>2018-05-19T16:00:02.000Z</published>
    <updated>2018-10-08T05:08:42.315Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/computer-networking/internet-and-web.jpg" alt=""></p><p>了解互联网与网络的概念以及它们之间的区别，译自<em>GeeksforGeeks</em>。</p><a id="more"></a><h3 id="互联网-The-Internet"><a href="#互联网-The-Internet" class="headerlink" title="互联网 (The Internet)"></a>互联网 (The Internet)</h3><p>互联网，简而言之，它是使用标准化的通信协议的<strong>较小网络互连</strong>而成的<strong>全球网络</strong>。<code>Internet</code>标准描述了称为<code>Internet</code>协议栈的框架。该模型将方法分为分层的协议系统。</p><p>分层如下 - </p><ol><li><strong>应用层(Application layer, 最高层)</strong> - 关注数据(URL,类型等等)，其中包含<code>HTTP</code>, <code>HTTPS</code>等;</li><li><strong>传输层(Transport layer)</strong> - 负责网络上的端到端的通信;</li><li><strong>网络层(Network layer)</strong> - 提供数据路由.</li></ol><p>互联网提供各种信息和通信设施，包含论坛，数据库，电子邮件，超文本等。它由本地和全球范围内的私人，公共，学术，商业和政府网络组成，通过广泛的电子，无线和光纤网络技术相互联系。</p><h3 id="万维网-The-World-Wide-Web"><a href="#万维网-The-World-Wide-Web" class="headerlink" title="万维网 (The World Wide Web)"></a>万维网 (The World Wide Web)</h3><p>网络是互联网的一个子集。它是一个支持特殊格式文档的<code>Internet</code>服务器系统。文档采用称为<code>HTML</code>(支持链接，多媒体等)的标记语言格式化。这些文档使用超文本链接相互来链接，可通过<code>Internet</code>访问。</p><p>要将超文本链接到<code>Internet</code>，我们需要 - </p><ol><li>文本标记语言，例如， <code>HTML</code>;</li><li>传输协议，例如， <code>HTTP</code>;</li><li>统一资源定位器(<em>Uniform Resource Locator</em>, URL),资源的地址.</li></ol><p>可以使用Web浏览器访问Web.</p><h3 id="互联网与网络之间的区别"><a href="#互联网与网络之间的区别" class="headerlink" title="互联网与网络之间的区别"></a>互联网与网络之间的区别</h3><div class="table-container"><table><thead><tr><th style="text-align:center">Internet</th><th style="text-align:center">Web</th></tr></thead><tbody><tr><td style="text-align:center">互联网是库和网络的集合。互联网还包含数据库，电子邮件，论坛等。</td><td style="text-align:center">Web是互联网的一个子集。网络是互联网的很大一部分，但并不是全部。</td></tr><tr><td style="text-align:center">互联网是一个网络，一种传输内容和网络的方式。</td><td style="text-align:center">Web理想情况下是通过<code>Internet</code>介质访问信息的一种方式。<br>Web是可以托管<code>HTML</code>格式文档的<code>Internet</code>服务器集合。全球各地相互连接的信息页面的集合。<br>每个页面可以是文本和多媒体的组合。</td></tr></tbody></table></div><h3 id="URI"><a href="#URI" class="headerlink" title="URI"></a>URI</h3><p><code>URI</code>, 即<strong>Uniform Resource Identifier</strong>, 统一资源定位符，它像是一个地址，为Web上的资源提供一个唯一的全局标识符。统一资源定位器(<code>URL</code>)是最常用的<code>URI</code>形式。</p><p><code>URL</code>包含两个主要的部分 - </p><ol><li>传输使用的协议，例如，<code>HTTP</code>;</li><li>域名.</li></ol><h3 id="谁管理互联网"><a href="#谁管理互联网" class="headerlink" title="谁管理互联网?"></a>谁管理互联网?</h3><p>互联网不受管理，没有单一的权威机构。互联网协会的最终权威取决于互联网协会或<code>ISOC</code>(<em>Internet Society</em>)。</p><p><code>ISOC</code>是一个自愿成员组织，其目的是通过互联网技术促进全球信息交流。</p><ul><li><code>ISOC</code>任命为<code>IAB</code>(<em>Internet Architecture Board</em>,互联网架构委员会)。他们会定期会面以审查标准并分配资源，如地址;</li><li><code>IETF</code>(<em>Internet Engineering Task Force</em>,互联网工程任务组)。另一个志愿者组织定期开会讨论运营和技术问题.</li></ul><p>原地址:<a href="https://www.geeksforgeeks.org/the-internet-and-the-web" target="_blank" rel="noopener">https://www.geeksforgeeks.org/the-internet-and-the-web</a></p><p><a href="/posts/7fc520f1">返回到计算机网络主目录</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/computer-networking/internet-and-web.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;了解互联网与网络的概念以及它们之间的区别，译自&lt;em&gt;GeeksforGeeks&lt;/em&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="GeeksforGeeks" scheme="http://rovo98.github.io/categories/GeeksforGeeks/"/>
    
      <category term="Computer Network" scheme="http://rovo98.github.io/categories/GeeksforGeeks/Computer-Network/"/>
    
      <category term="Basics" scheme="http://rovo98.github.io/categories/GeeksforGeeks/Computer-Network/Basics/"/>
    
    
      <category term="学习笔记" scheme="http://rovo98.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="计算机网络" scheme="http://rovo98.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络基础 | Basics of Computer Network</title>
    <link href="http://rovo98.github.io/posts/c88d46b1/"/>
    <id>http://rovo98.github.io/posts/c88d46b1/</id>
    <published>2018-05-19T16:00:01.000Z</published>
    <updated>2018-10-08T05:08:42.088Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/computer-networking/networking-basics.jpg" alt=""></p><p>主要了解计算机网络中一些基本的概念，译自<em>GeeksforGeeks</em>.</p><a id="more"></a><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="开放系统-Open-system"><a href="#开放系统-Open-system" class="headerlink" title="开放系统 (Open system)"></a>开放系统 (Open system)</h4><p>连接到网络并准备好进行通信的系统。</p><h4 id="封闭系统-Closed-system"><a href="#封闭系统-Closed-system" class="headerlink" title="封闭系统 (Closed system)"></a>封闭系统 (Closed system)</h4><p>未连接到网络且无法与之通信的系统。</p><h4 id="计算机网络-Computer-Network"><a href="#计算机网络-Computer-Network" class="headerlink" title="计算机网络 (Computer Network)"></a>计算机网络 (Computer Network)</h4><p>计算机网络是多个设备进行互连，这些设备通常称为多路径连接的主机，用于发送/接受数据。</p><p>还有许多设备和介质是用于协助不同两个不同设备之间的通信的，这些设备就是<strong>网络设备</strong>(Network devices)。例如：路由器，交换机，集线器，网桥。</p><p><img src="Computer-Networking-Diagram.png" alt=""></p><p>使用<strong>哪些设备互连的布局模式</strong>称为<strong>网络拓扑</strong>。如:总线型(Bus), 星型(Star), 网状型(Mesh), 环形型(Ring), 以及链状型(Daisy chain)等。</p><p><img src="Network-Topology-Diagram.png" alt=""></p><h4 id="OSI"><a href="#OSI" class="headerlink" title="OSI"></a>OSI</h4><p><code>OSI</code>，即<strong>Open Systems Interconnection</strong>,开放系统互连。它是一个参考模型，指定了通信协议的标准以及每层的功能。</p><h4 id="协议-Protocol"><a href="#协议-Protocol" class="headerlink" title="协议 (Protocol)"></a>协议 (Protocol)</h4><p>协议是一组规则或算法，它们定义了两个实体如何通过网络进行通信的方式，并且在<code>OSI</code>模型的每一层都存在不同的协议。例如：<code>TCP</code>, <code>IP</code>, <code>UDP</code>, <code>ARP</code>, <code>DHCP</code>, <code>FTP</code>等等。</p><h3 id="网络的唯一标识"><a href="#网络的唯一标识" class="headerlink" title="网络的唯一标识"></a>网络的唯一标识</h3><h4 id="主机名-Host-name"><a href="#主机名-Host-name" class="headerlink" title="主机名 (Host name)"></a>主机名 (Host name)</h4><p>网络中的每一个设备都有与一个唯一设备名称相关联，称为主机名(Hostname)。</p><p>我们可以在命令行<code>cmd</code>界面中键入<code>hostname</code>，然后回车来查看主机名 - </p><p><img src="hostname.png" alt=""></p><h4 id="IP-地址-Internet-Protocol-address"><a href="#IP-地址-Internet-Protocol-address" class="headerlink" title="IP 地址 (Internet Protocol address)"></a>IP 地址 (Internet Protocol address)</h4><p>IP 地址也称为<strong>逻辑地址</strong>，是在整个网络中开放系统的网络地址。</p><p>为了识别万维网中的每个设备，<em>Internet Assigned Numbers Authority</em>(互联网号码分配局，<code>IANA</code>)将<code>IPV4</code>(版本4)地址分配为Internet上每个设备的唯一标识符。</p><p>IP地址的长度为: 32位(因此一共有$2^32$个ip地址可用)。在命令提示符<code>cmd</code>下键入<code>ipconfig</code>并按回车，可以查看设备的ip地址。</p><h4 id="MAC-地址-Media-Access-Control-address"><a href="#MAC-地址-Media-Access-Control-address" class="headerlink" title="MAC 地址 (Media Access Control address)"></a>MAC 地址 (Media Access Control address)</h4><p><code>MAC</code>地址也称为物理地址，是每个主机的唯一标识符，并于<code>NIC</code>(Network Interface Card，网络接口卡)相关联。</p><p>网卡的生产产商在制造网卡时将<code>MAC</code>地址分配给<code>NIC</code>。<code>MAC</code>地址的长度为： 48位。在命令行提示符<code>cmd</code>中键入<code>ipconfig /all</code>并回车，可以查看<code>MAC</code>地址。</p><h4 id="端口-Port"><a href="#端口-Port" class="headerlink" title="端口 (Port)"></a>端口 (Port)</h4><p>端口可以称为是逻辑信道，通过该信道可以将数据发送/接受到应用程序。任何主机都可能运行多个应用程序，并且每个应用程序都使用运行它们的端口号进行标识。</p><p>端口号是一个<code>16 bit</code>整数，因此一共有$2^16$(65535)个端口号可用,它们可以被分成以下几类 - </p><div class="table-container"><table><thead><tr><th style="text-align:center">端口类型</th><th style="text-align:center">范围</th></tr></thead><tbody><tr><td style="text-align:center">知名端口(Well known Ports)</td><td style="text-align:center">$0 - 1023$</td></tr><tr><td style="text-align:center">注册端口(Registered Ports)</td><td style="text-align:center">$1024 - 49151$</td></tr><tr><td style="text-align:center">临时端口(Ephemeral Ports)</td><td style="text-align:center">$49152 - 65535$</td></tr></tbody></table></div><p>在命令行中键入<code>netstat -a</code>可以查看目前主机正在使用的所有端口号 - </p><p><img src="ports.png" alt=""></p><h4 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h4><p>IP地址和端口号组成的唯一组合就是<code>Socket</code>。</p><h3 id="一些额外概念"><a href="#一些额外概念" class="headerlink" title="一些额外概念"></a>一些额外概念</h3><h4 id="DNS-服务器"><a href="#DNS-服务器" class="headerlink" title="DNS 服务器"></a>DNS 服务器</h4><p><code>DNS</code>,即<strong>Domain Name system</strong>,域名系统。<code>DNS</code>是将Web地址h或URL(例如： <code>www.google.com</code>)转换为相应的IP地址的服务器。这样我们就不必记住每个网站的所有IP地址。</p><p>命令<code>nslookup</code>可以查看所需域名的IP地址。同时也提供了所使用的<code>DNS</code>服务器的信息 - </p><p><img src="dns.png" alt=""></p><h4 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h4><p><code>ARP</code>，即<strong>Address Resolution Protocol</strong>(地址解析协议)。它用于将IP地址转换为与其对应的物理地址(即<code>MAC</code>地址)。数据链路层使用<code>ARP</code>来识别接受计算机的<code>MAC</code>地址。</p><h4 id="RARP"><a href="#RARP" class="headerlink" title="RARP"></a>RARP</h4><p><code>RARP</code>,即<strong>Reverse Address Resolution Protocol</strong>(逆地址解析协议)。顾名思义，它是逆向将给定的物理地址转换为设备的IP地址。但是自从<code>DHCP</code>出项以来，<code>RARP</code>已经过时了。</p><p>原地址: <a href="https://www.geeksforgeeks.org/basics-computer-networking" target="_blank" rel="noopener">https://www.geeksforgeeks.org/basics-computer-networking</a></p><p><a href="/posts/7fc520f1">返回到计算机网络主目录</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/computer-networking/networking-basics.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;主要了解计算机网络中一些基本的概念，译自&lt;em&gt;GeeksforGeeks&lt;/em&gt;.&lt;/p&gt;
    
    </summary>
    
      <category term="GeeksforGeeks" scheme="http://rovo98.github.io/categories/GeeksforGeeks/"/>
    
      <category term="Computer Network" scheme="http://rovo98.github.io/categories/GeeksforGeeks/Computer-Network/"/>
    
      <category term="Basics" scheme="http://rovo98.github.io/categories/GeeksforGeeks/Computer-Network/Basics/"/>
    
    
      <category term="学习笔记" scheme="http://rovo98.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="计算机网络" scheme="http://rovo98.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>CentOS7通过yum(yellow dog update modifier) 安装mysql5.7</title>
    <link href="http://rovo98.github.io/posts/86d29d2c/"/>
    <id>http://rovo98.github.io/posts/86d29d2c/</id>
    <published>2018-04-22T16:00:00.000Z</published>
    <updated>2018-10-08T05:08:42.765Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h3 id="配置yum源"><a href="#配置yum源" class="headerlink" title="配置yum源"></a>配置yum源</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载mysql安装源包</span></span><br><span class="line">root @~&gt; wget http://dev.mysql.com/get/mysql57-community-release-el7-8.noarch.rpm</span><br><span class="line"><span class="comment"># 安装mysql源</span></span><br><span class="line">root @~&gt; yum localinstall mysql57-community-release-el7-8.noarch.rpm</span><br></pre></td></tr></table></figure></div><p>检查mysql源是否安装成功:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root @~&gt; yum repolist enabled | grep <span class="string">"mysql.*-community.*"</span></span><br></pre></td></tr></table></figure></div><p>如下图则安装成功:</p><p><img src="repo-resource.png" alt="mysql_source"></p><h3 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ ~&gt; yum install -y mysql-community-server</span><br></pre></td></tr></table></figure></div><h3 id="启动MySQL服务并设置开机自动启动"><a href="#启动MySQL服务并设置开机自动启动" class="headerlink" title="启动MySQL服务并设置开机自动启动"></a>启动MySQL服务并设置开机自动启动</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ ~&gt; systemctl start mysqld</span><br></pre></td></tr></table></figure></div><p>查看MySQL启动状态</p><p><img src="mysql-status.png" alt="mysqld进程状态"></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ ~&gt; systemctl <span class="built_in">enable</span> mysqld</span><br><span class="line">root@ ~&gt; systemctl daemon-reload</span><br></pre></td></tr></table></figure></div><h3 id="修改默认密码"><a href="#修改默认密码" class="headerlink" title="修改默认密码"></a>修改默认密码</h3><p>刚安装完的mysql会自动给root用户分配一个临时密码，而且必须重新设置密码(从5.5版本开始)</p><ul><li>先查看root用户的临时密码</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ ~&gt; grep <span class="string">"temporary password"</span> /var/<span class="built_in">log</span>/mysqld.log</span><br></pre></td></tr></table></figure></div><ul><li>使用临时的密码登录进mysql来设置新的密码</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="built_in">set</span> PASSWORD = PASSWORD(<span class="string">'[YOUR_NEW_PASSWORD]'</span>)</span><br></pre></td></tr></table></figure></div><p><img src="temporary-password.png" alt="查看临时密码"></p><ul><li>可能遇到的问题：设置的密码过于简单mysql报错:</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Your password does not satisfy the current policy requirements.</span><br></pre></td></tr></table></figure></div><p>解决方法：由于刚安装的mysql的密码默认强度是最高的，若想要设置简单的密码就要修改<strong>validate_password_policy</strong>的值，</p><h4 id="validate-password-policy有以下取值："><a href="#validate-password-policy有以下取值：" class="headerlink" title="validate_password_policy有以下取值："></a>validate_password_policy有以下取值：</h4><div class="table-container"><table><thead><tr><th style="text-align:center">Policy</th><th style="text-align:center">Tests Performed</th></tr></thead><tbody><tr><td style="text-align:center">0 or LOW</td><td style="text-align:center">Length</td></tr><tr><td style="text-align:center">1 or MEDIUM</td><td style="text-align:center">Length;numeric,lowercase/uppercase,and special characters</td></tr><tr><td style="text-align:center">2 or STRONG</td><td style="text-align:center">Length;numeric,lowercase/uppercase,and special characters; dictionary file</td></tr></tbody></table></div><p>操作：</p><ul><li>设置安全级别</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="built_in">set</span> global validate_password_policy=0;</span><br></pre></td></tr></table></figure></div><ul><li>设置密码长度为8，可以设置为其他值，最小为4位</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="built_in">set</span> global validate_password_length=4;</span><br></pre></td></tr></table></figure></div><p>之后就可以设置简单的密码了。</p><h3 id="允许root远程登录"><a href="#允许root远程登录" class="headerlink" title="允许root远程登录"></a>允许root远程登录</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; GRANT ALL PRIVILEGES ON *.* TO <span class="string">'root'</span>@<span class="string">'%'</span> IDENTIFIED BY <span class="string">'[YOUR_PASSWORD]'</span> WITH GRANT OPTION;</span><br><span class="line">mysql&gt; flush privileges;</span><br></pre></td></tr></table></figure></div><h3 id="修改字符集编码为UTF-8"><a href="#修改字符集编码为UTF-8" class="headerlink" title="修改字符集编码为UTF-8"></a>修改字符集编码为UTF-8</h3><ul><li>查看当前字符编码</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like <span class="string">"char%';</span></span><br></pre></td></tr></table></figure></div><p>检测是否都是utf-8(filesystem除外)，如果不是就需要修改。 <strong>character_set_server</strong>一般是lantin1。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 停止mysqld服务</span></span><br><span class="line">systemctl stop mysqld</span><br><span class="line"><span class="comment"># 进入my.cnf文件，一般是/etc/路径下</span></span><br><span class="line">vim /etc/my.cnf</span><br><span class="line"><span class="comment"># 在[mysqld]下追加character-set-server=utf-8</span></span><br><span class="line"><span class="comment"># 在[mysql]下追加default-character-set=utf-8</span></span><br><span class="line"><span class="comment"># 启动mysqld</span></span><br><span class="line">systemctl start mysqld</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      CentOS7下安装mysql。
    
    </summary>
    
      <category term="mysql" scheme="http://rovo98.github.io/categories/mysql/"/>
    
    
      <category term="mysql5.7安装" scheme="http://rovo98.github.io/tags/mysql5-7%E5%AE%89%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>Hibernate基础学习</title>
    <link href="http://rovo98.github.io/posts/b19895ed/"/>
    <id>http://rovo98.github.io/posts/b19895ed/</id>
    <published>2018-04-13T11:41:44.000Z</published>
    <updated>2018-10-08T05:08:41.698Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/Hibernate基础学习/hibernate_logo.png" alt=""></p><p><strong>Hibernate</strong>是一个对象关系映射<span title="Object-Relational Mapping"><code>ORM</code></span>的JAVA解决方案。是在2001年由 <em>Gavin King</em>创建的开源持久化框架。适用于任何使用Java应用程序的功能强大的高性能<strong>对象关系持久化和查询服务</strong>。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>Hibernate</strong>将Java类映射到数据表并将Java数据类型映射到SQL数据类型，使开发人员从95%的常见数据持久化相关编程任务中解脱出来。</p><p><strong>Hibernate</strong>位于传统的Java对象和数据库服务器之间，以适应基于适当$O/R$机制和模式的持久化对象的保存工作。</p><p><img src="hibernate_position.jpg" alt=""></p><h3 id="一、Hibernate-优势"><a href="#一、Hibernate-优势" class="headerlink" title="一、Hibernate 优势"></a>一、Hibernate 优势</h3><ol><li>Hibernate使用XML文件来将Java类映射到数据表，不需要写任何代码。</li><li>提供简单的APIs直接将java对象保存到数据库中，或从数据库中检索出来。</li><li>数据库或数据表发生改变时，只需要修改XML文件。</li><li>不采用不熟悉的SQL类型，而提供一中方法来解决熟悉的Java对象。</li><li>Hibernate不需要应用服务器来操作。</li><li>可以操纵数据库对象的复杂关联。</li><li>使用智能检索策略来最小化数据库的访问。</li><li>提供简单的数据查询。</li></ol><h3 id="二、支持的数据库"><a href="#二、支持的数据库" class="headerlink" title="二、支持的数据库"></a>二、支持的数据库</h3><p><strong>Hibernate</strong>支持所有主流的关系型数据库(RDBMS)。下面简单地列出Hibernate支持的数据库:</p><ul><li>HSQL Database Engine</li><li>DB2/NT</li><li>MySQL</li><li>PostgreSQL</li><li>FrontBase</li><li>Oracle</li><li>Microsoft SQL Server Database</li><li>Sybase SQL Server</li><li>Infomix Dynamic Server</li></ul><h3 id="三、支持的技术"><a href="#三、支持的技术" class="headerlink" title="三、支持的技术"></a>三、支持的技术</h3><p><strong>Hibernate</strong>支持很多其他的技术，包括</p><ul><li>XDoclet Spring</li><li>J2EE</li><li>Eclipse plug-ins</li><li>Maven</li></ul><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p><strong>Hibernate</strong>拥有一个分层的架构，可以使用户在不了解底层APIs的情况下使用它。Hibernate使用数据库和配置数据来向应用提供持久化服务。</p><p>下面是从宏观角度看Hibernate的视图：</p><p><img src="hibernate_high_level.jpg" alt=""></p><p>从细节视角看Hibernate以及它的核心类：</p><p><img src="hibernate_architecture.jpg" alt=""></p><p><strong>Hibernate</strong>使用很多现有的Java API, 例如： <code>JDBC</code>, Java Transaction API(<code>JTA</code>)以及 Java Naming and Directory Interface(<code>JNDI</code>)。<code>JDBC</code>提供了关系数据库通用功能的基本抽象级别，使<strong>Hibernate</strong>支持几乎所有具有<code>JDBC</code>驱动程序的数据库。<code>JNDI</code>和<code>JTA</code>使<code>J2EE</code>可以集成<strong>Hibernate</strong>。</p><p>下面是针对上面架构图中出现的核心类给出的简单解释。</p><h3 id="一、Configuration-Object"><a href="#一、Configuration-Object" class="headerlink" title="一、Configuration Object"></a>一、Configuration Object</h3><p><code>Configuration</code>(配置对象)是在Hibernate应用中第一个被创建的对象，且在Hibernate应用初始化时，只创建一次。它通常代表着Hibernate所需的配置信息或属性。</p><p><code>Configuartion</code>包含一下两个关键的组件:</p><ul><li><code>Database Connection</code>(数据库连接) - 通过hibernate支持的一个或多个配置文件来处理的，例如： <code>hibernate.properties</code>和<code>hibernate.cfg.xml</code>。</li><li><code>Class Mapping Setup</code>(类映射设置) - 该组件负责创建Java类和数据表之间的连接。</li></ul><h3 id="二、SessionFactory-Object"><a href="#二、SessionFactory-Object" class="headerlink" title="二、SessionFactory Object"></a>二、SessionFactory Object</h3><p><code>SessionFactory</code>对象是通过使用<code>Configuration</code>对象创建生成的，该对象可以使用提供的配置文件为应用程序配置Hibernate，并能够实例化<code>Session</code>对象。<code>SessionFactory</code>是一个线程安全对象，并被应用程序的所有线程使用。</p><p><code>Sessionfactory</code>是一个重量级对象，通常在应用程序启动时创建并保留以备后续使用。每个数据库使用单独的配置文件都需要一个<code>SessionFactory</code>对象。因此，如果使用多个数据库，我们可能需要创建多个<code>SessionFactory</code>对象。</p><h3 id="三、Session-Object"><a href="#三、Session-Object" class="headerlink" title="三、Session Object"></a>三、Session Object</h3><p><code>Session</code>对象主要用来从数据库中获取物理连接。<code>Session</code>是轻量级对象，当每次需要与数据库交互时都可以实例化该对象。持久化对象(persistent Objects)就是通过它来实现保存和检索的。</p><p><code>Session</code>对象一般不会保留很长一段时间，因为它并不是线程安全对象，只能在需要使用的时候创建和销毁。</p><h3 id="四、Transaction-Object"><a href="#四、Transaction-Object" class="headerlink" title="四、Transaction Object"></a>四、Transaction Object</h3><p><code>Transaction</code>对象代表了数据库的一个工作单元，大多数RDBMS都支持事务功能。Hibernate中的事务由<code>underlying transaction manager</code>(基础事务管理器)以及<code>transaction</code>(事务，来自<code>JDBC</code>或者<code>JTA</code>)。</p><p>这是一个<strong>可选</strong>对象，Hibernate应用程序可以选择不使用此接口，而是使用自己的应用程序的代码来管理事务。</p><h3 id="五、Query-Object"><a href="#五、Query-Object" class="headerlink" title="五、Query Object"></a>五、Query Object</h3><p><code>Query</code>对象使用<code>SQL</code>或者Hibernate查询语言（<code>HQL</code>)字符串来从数据库中检索数据以及创建对象。一个<code>Query</code>实例一般是用来绑定查询参数，限制返回结果行数，并执行查询操作的。</p><h3 id="七、Criteria-Object"><a href="#七、Criteria-Object" class="headerlink" title="七、Criteria Object"></a>七、Criteria Object</h3><p><code>Criteria</code>对象用于创建和执行面向对象的条件查询来检索对象。</p><h2 id="Hibernate-配置"><a href="#Hibernate-配置" class="headerlink" title="Hibernate 配置"></a>Hibernate 配置</h2><p><strong>Hibernate需要事先知道在哪里可以找到定义Java类和数据表的关系的映射信息。</strong>Hibernate还需哟啊一组与数据库和其他相关参数相关的配置设置。所有这些信息通常由标准Java属性文件(<code>hibernate.properties</code>)或XML文件(<code>hibernate.cfg.xml</code>)提供。</p><p>这里我们只需要考虑<code>hibernate.cfg.xml</code>配置文件的配置。大多数的属性一般都采用默认值，并且不需要在属性文件(<code>hibernate.properties</code>)中制定它们，除非真的需要。配置文件只能保存在应用程序的类路径的根目录中。</p><h3 id="一、Hibernate-属性"><a href="#一、Hibernate-属性" class="headerlink" title="一、Hibernate 属性"></a>一、Hibernate 属性</h3><p>下面列出的使一些重要的属性，当我们在配置数据库时可能会用到：</p><div class="table-container"><table><thead><tr><th style="text-align:center">Properties</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td style="text-align:center">hibernate.dialect</td><td style="text-align:center">数据库方言，该属性能够是Hibernate为选择的数据库生成合适的SQL</td></tr><tr><td style="text-align:center">hibernate.connection.driver_class</td><td style="text-align:center">JDBC 驱动类</td></tr><tr><td style="text-align:center">hibernate.connection.url</td><td style="text-align:center">数据库实例的JDBC URL</td></tr><tr><td style="text-align:center">hibernate.connection.username</td><td style="text-align:center">数据库用户名</td></tr><tr><td style="text-align:center">hibernate.connection.password</td><td style="text-align:center">数据库密码</td></tr><tr><td style="text-align:center">hibernate.connection.pool_size</td><td style="text-align:center">限制Hibernate数据库连接池中等待的连接数</td></tr><tr><td style="text-align:center">hibernate.connection.autocommit</td><td style="text-align:center">允许JDBC连接自动提交</td></tr></tbody></table></div><p>如果使用应用程序服务器和<code>JNDI</code>,则必须配置以下属性：</p><div class="table-container"><table><thead><tr><th style="text-align:center">Properties</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td style="text-align:center">hibernate.connection.datasource</td><td style="text-align:center">在应用服务器上下文中定义<code>JNDI</code>名称</td></tr><tr><td style="text-align:center">hibernate.jndi.class</td><td style="text-align:center"><code>JNDI</code>的<code>InitialContext</code>类</td></tr><tr><td style="text-align:center">hibernate.jndi.&lt; JNDIpropertyname &gt;</td><td style="text-align:center">向<code>JNDI InitialContext</code>传递的属性</td></tr><tr><td style="text-align:center">hibernate.jndi.url</td><td style="text-align:center"><code>JNDI</code> URL</td></tr><tr><td style="text-align:center">hibernate.connection.username</td><td style="text-align:center">数据库用户名</td></tr><tr><td style="text-align:center">hibernate.connection.password</td><td style="text-align:center">数据库密码</td></tr></tbody></table></div><h3 id="二、在Hibernate中配置-MySQL-数据库"><a href="#二、在Hibernate中配置-MySQL-数据库" class="headerlink" title="二、在Hibernate中配置 MySQL 数据库"></a>二、在Hibernate中配置 MySQL 数据库</h3><p><code>MySQL</code>是目前最受欢的开源数据库系统之一。下面通过配置<code>hibernate.cfg.xml</code>文件来配置<code>MySQL</code>数据库，在此之前，确保在<code>MySQL</code>中创建一个<code>testdb</code>数据库，以及<code>test</code>用户。</p><p>[notice] : XML配置文件必须符合Hibernate 2 配置 DTD标准。</p><p><strong>hibernate.cfg.xml</strong>:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version = "1.0" encoding = "utf-8"?&gt;</span><br><span class="line"><span class="meta">&lt;!DOCTYPE hibernate-configuration SYSTEM </span></span><br><span class="line"><span class="meta">"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-configuration</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">session-factory</span>&gt;</span></span><br><span class="line">   </span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">"hibernate.dialect"</span>&gt;</span></span><br><span class="line">         org.hibernate.dialect.MySQL5Dialect</span><br><span class="line">      <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">      </span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">"hibernate.connection.driver_class"</span>&gt;</span></span><br><span class="line">         com.mysql.jdbc.Driver</span><br><span class="line">      <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">&lt;!-- Assume test is the database name --&gt;</span></span><br><span class="line">      </span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">"hibernate.connection.url"</span>&gt;</span></span><br><span class="line">         jdbc:mysql://localhost/test</span><br><span class="line">      <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">      </span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">"hibernate.connection.username"</span>&gt;</span></span><br><span class="line">         root</span><br><span class="line">      <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">      </span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">"hibernate.connection.password"</span>&gt;</span></span><br><span class="line">         root</span><br><span class="line">      <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">&lt;!-- List of XML mapping files --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">mapping</span> <span class="attr">resource</span> = <span class="string">"Employee.hbm.xml"</span>/&gt;</span></span><br><span class="line">      </span><br><span class="line">   <span class="tag">&lt;/<span class="name">session-factory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></div><p>上面配置文件中<code>&lt;mapping&gt;</code>标签与<code>hibernate mapping</code>(映射文件)相关。</p><p>以下是一些重要的数据库方言属性类型：</p><div class="table-container"><table><thead><tr><th style="text-align:center">Database</th><th style="text-align:center">Dialect Property</th></tr></thead><tbody><tr><td style="text-align:center">DB 2</td><td style="text-align:center">org.hibernate.dialect.DB2Dialect</td></tr><tr><td style="text-align:center">HSQLDB</td><td style="text-align:center">org.hibernate.dialect.HSQLDialect</td></tr><tr><td style="text-align:center">HypersonicSQL</td><td style="text-align:center">org.hibernate.dialect.HSQLDialect</td></tr><tr><td style="text-align:center">Informix</td><td style="text-align:center">org.hibernate.dialect.InformixDialect</td></tr><tr><td style="text-align:center">Ingres</td><td style="text-align:center">org.hibernate.dialect.IngresDialect</td></tr><tr><td style="text-align:center">Interbase</td><td style="text-align:center">org.hibernate.dialect.InterbaseDialect</td></tr><tr><td style="text-align:center">Microsoft SQL Server 2000</td><td style="text-align:center">org.hibernate.dialect.SQLServerDialect</td></tr><tr><td style="text-align:center">Microsoft SQL Server 2005</td><td style="text-align:center">org.hibernate.dialect.SQLServer2005Dialect</td></tr><tr><td style="text-align:center">Microsoft SQL Server 2008</td><td style="text-align:center">org.hibernate.dialect.SQLServer2008Dialect</td></tr><tr><td style="text-align:center">MySQL</td><td style="text-align:center">org.hibernate.dialect.MySQLDialect</td></tr><tr><td style="text-align:center">Oracle(any version</td><td style="text-align:center">org.hibernate.dialect.OracleDialect</td></tr><tr><td style="text-align:center">Oracle 11g</td><td style="text-align:center">org.hibernate.dialect.Oracle10gDialect</td></tr><tr><td style="text-align:center">Oracle 10g</td><td style="text-align:center">org.hibernate.dialect.Oracle10gDialect</td></tr><tr><td style="text-align:center">Oracle 9i</td><td style="text-align:center">org.hibernate.dialect.Oracle9iDialect</td></tr><tr><td style="text-align:center">PostgreSQL</td><td style="text-align:center">org.hibernate.dialect.PostgreSQLDialect</td></tr><tr><td style="text-align:center">Progress</td><td style="text-align:center">org.hibernate.dialect.ProgressDialect</td></tr><tr><td style="text-align:center">SAP DB</td><td style="text-align:center">org.hibernate.dialect.SAPDBDialect</td></tr><tr><td style="text-align:center">Sybase</td><td style="text-align:center">org.hibernate.dialect.SybaseDialect</td></tr><tr><td style="text-align:center">Sybase anywhere</td><td style="text-align:center">org.hibernate.dialect.SybaseAnywhereDialect</td></tr></tbody></table></div><h2 id="Sessions"><a href="#Sessions" class="headerlink" title="Sessions"></a>Sessions</h2><p>前面我们已经提到<code>Session</code>使用来获取数据库物理连接的，为轻量级对象，只有需要和数据库发生交互时才进行对象实例化。持久化对象的保存和检索就是通过它来完成的。</p><p><code>Session</code>不能维持太长时间，毕竟它们不是线程安全对象， 只能在需要的时候创建和销毁。<code>Session</code>的主要功能是为映射实体类提供创建、读取和删除操作。</p><p>在给定的时间点中，实例可能有下面的这些状态：</p><ul><li><code>transient</code>(暂时的) - 一个持久类的新实例，与<code>Session</code>没有关联，并且在数据库中没有表示以及没有标识符值，被Hibernate认为是暂时的。</li><li><code>persistent</code>(持久的) -  我们可以通过将暂时的实例(transient)与<code>Session</code>关联来将它进行持久化。</li><li><code>detached</code>(独立的) - 一旦关闭Hibernate <code>Session</code>对象，持久化对象将转化为独立的对象(detached instance)。</li></ul><p>当<code>Session</code>对象中的持久类(persistent classes)是可序列化时，<code>Session</code>也是可序列化的。下面是典型的事务处理代码：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Session session = factory.openSession();</span><br><span class="line">Transaction tx = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">tx = session.beginTransaction();</span><br><span class="line">    <span class="comment">// do some work</span></span><br><span class="line">    ...</span><br><span class="line">    tx.commit();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="keyword">if</span> (tx != <span class="keyword">null</span>) tx.rollback();</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>[notice]</strong> : 如果<code>Session</code>抛出异常，事务必须回滚(rollback)并且<code>Session</code>需要丢弃。</p><h3 id="一、Session-接口方法"><a href="#一、Session-接口方法" class="headerlink" title="一、Session 接口方法"></a>一、Session 接口方法</h3><p><code>Session</code>接口提供了很多方法，下面列出的是其中一些中重要的方法。更多的信息可以查看Hibernate文档中与<code>Session</code>以及<code>SessionFactory</code>相关的完整方法信息。</p><div class="table-container"><table><thead><tr><th style="text-align:center">Session Method</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td style="text-align:center"><code>Transaction beginTransaction()</code></td><td style="text-align:center">开启一个工作单元并返回已经关联的事务对象。</td></tr><tr><td style="text-align:center"><code>void cancelQuery()</code></td><td style="text-align:center">取消执行当前查询操作</td></tr><tr><td style="text-align:center"><code>void clear()</code></td><td style="text-align:center">完全清除回话(session)</td></tr><tr><td style="text-align:center"><code>Connection close()</code></td><td style="text-align:center">结束回话并释放<code>JDBC</code>连接资源</td></tr><tr><td style="text-align:center"><code>Criteria createCriteria(Class persistentClass)</code></td><td style="text-align:center">为指定的实体类或者实体类的超类创建一个条件查询(<code>Criteria</code>)对象</td></tr><tr><td style="text-align:center"><code>Criteria createCriteria(String entityName)</code></td><td style="text-align:center">根据实体类的名称创建<code>Criteria</code>对象</td></tr><tr><td style="text-align:center"><code>Serializable getIdentifier(Object Object)</code></td><td style="text-align:center">返回与此回话关联的给定实体的标识符值</td></tr><tr><td style="text-align:center"><code>Query createFilter(Object collection, String queryString)</code></td><td style="text-align:center">根据给定的集合(<code>collection</code>)以及过滤字符串创建一个新的<code>Query</code>实例</td></tr><tr><td style="text-align:center"><code>SQLQuery createSQLQuery(String queryString)</code></td><td style="text-align:center">根据给定的SQL查询语句创建一个<code>SQLQuery</code>对象</td></tr><tr><td style="text-align:center"><code>void delete(Object object)</code></td><td style="text-align:center">从数据存储(datastore)中移除持久实例</td></tr><tr><td style="text-align:center"><code>void delete(String entityName, Object object)</code></td><td style="text-align:center">从数据存储中移除持久实例</td></tr><tr><td style="text-align:center"><code>Session get(String entityName, Serializable id)</code></td><td style="text-align:center">根据给定的标识符(identifier)以及实体名返回持久化实例；如果没有该实例，则返回<code>null</code></td></tr><tr><td style="text-align:center"><code>SessionFactory getSessionFactory()</code></td><td style="text-align:center">获取创建该<code>Session</code>实例的<code>SessionFactory</code>对象</td></tr><tr><td style="text-align:center"><code>void refresh(Object object)</code></td><td style="text-align:center">从底层数据库重新读取给定实例的状态</td></tr><tr><td style="text-align:center"><code>Transaction getTransaction()</code></td><td style="text-align:center">获取与该<code>Session</code>关联的<code>Transaction</code>实例</td></tr><tr><td style="text-align:center"><code>boolean isConnected()</code></td><td style="text-align:center">返回当前<code>Session</code>的连接状态</td></tr><tr><td style="text-align:center"><code>boolean isDirty()</code></td><td style="text-align:center">判断<code>Session</code>中是否存在未同步到数据库的脏数据(已经修改过的数据)</td></tr><tr><td style="text-align:center"><code>boolean isOpen()</code></td><td style="text-align:center">判断<code>Session</code>是否打开</td></tr><tr><td style="text-align:center"><code>Serializable save(Object object)</code></td><td style="text-align:center">持久化给定的暂时实例，分配一个生成的标识符</td></tr><tr><td style="text-align:center"><code>void saveOrUpdate(Object object)</code></td><td style="text-align:center">对给定的实例执行<code>save(Object)</code>或者<code>update(Object)</code>操作</td></tr><tr><td style="text-align:center"><code>void update(Object object)</code></td><td style="text-align:center">根据给定的独立实例的标识符更新持久化实例</td></tr><tr><td style="text-align:center"><code>void update(String entityName, Object object)</code></td><td style="text-align:center">根据给定的独立实例的标识符更新持久化实例</td></tr></tbody></table></div><h2 id="Hibernate-持久化类"><a href="#Hibernate-持久化类" class="headerlink" title="Hibernate 持久化类"></a>Hibernate 持久化类</h2><p><strong>Hibernate</strong>的整体理念是从Java类属性中取值并将它们保存到数据表中。Hibernate使用给定的映射文件来获取Java类中的属性值，并将它们映射到数据表和相关字段。</p><p><strong>在Hibernate中，我们把那些对象或实例将被保存到数据表中的Java类成为持久化类，持久类。</strong>一般这些遵循这样的一些简单的规则，即符合<strong>Plain Ordinary Java Object</strong>(<code>POJO</code>)编程模型。</p><p>下面给出的就是持久化类需要遵循的规则，但这并不是硬性要求：</p><ul><li>所有的持久化类都需要有一个默认的构造方法；</li><li>所有类都需要包含一个ID属性，以便在Hibernate和数据库中轻松识别对象，该属性一般映射到数据表中的主键；</li><li>所有需要持久化的属性都应该声明为<code>private</code>并定义<code>getXXX</code>和<code>setXXX</code>方法；</li><li>Hibernate的一个中心特性是代理，因此依赖的持久化类不能是<code>final</code>类或者实现声明所有公共方法的接口；</li><li>所有类不继承或实现<code>EJB</code>框架所需的特定类和接口。</li></ul><p><code>POJO</code>是用来强调给定的对象是一个原始的Java对象，而不是一个特殊的类，也不是一个<code>Enterprise JavaBean</code>。</p><h3 id="一、简单POJO例子"><a href="#一、简单POJO例子" class="headerlink" title="一、简单POJO例子"></a>一、简单POJO例子</h3><p>基于上面提到的规则，定义了下面的一个简单<code>POJO</code>类：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">   <span class="keyword">private</span> String firstName; </span><br><span class="line">   <span class="keyword">private</span> String lastName;   </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> salary;  </span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String fname, String lname, <span class="keyword">int</span> salary)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.firstName = fname;</span><br><span class="line">      <span class="keyword">this</span>.lastName = lname;</span><br><span class="line">      <span class="keyword">this</span>.salary = salary;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> id;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">( <span class="keyword">int</span> id )</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.id = id;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getFirstName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> firstName;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirstName</span><span class="params">( String first_name )</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.firstName = first_name;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getLastName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> lastName;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLastName</span><span class="params">( String last_name )</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.lastName = last_name;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSalary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> salary;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSalary</span><span class="params">( <span class="keyword">int</span> salary )</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.salary = salary;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="Hibernate-映射文件"><a href="#Hibernate-映射文件" class="headerlink" title="Hibernate 映射文件"></a>Hibernate 映射文件</h2><p>对象关系映射通常都是定义在一个XML文档中。该映射文件告诉Hibernate如果将定义的Java类映射到数据库中的数据表。</p><p>尽管很多Hibernate用户都选择使用人工方式来写XML文档。但是现在有很多现有的工具可以用来生成映射文档，其中包含供Hibernate高级用户使用的<code>XDoclet</code>, <code>Middlegen</code>以及<code>AndroMDA</code>。</p><p>对于之前给出的简单的<code>POJO</code>类，假设它需要保存到下面的RDBMS数据表中，以及从中检索数据:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> EMPLOYEE (</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span> auto_increment,</span><br><span class="line">    first_name <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">default</span> <span class="literal">null</span>,</span><br><span class="line">    last_name <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">default</span> <span class="literal">null</span>,</span><br><span class="line">    salaary <span class="built_in">int</span> <span class="keyword">default</span> <span class="literal">null</span>,</span><br><span class="line">    primary <span class="keyword">key</span> (<span class="keyword">id</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div><p>定义映射文件:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version = "1.0" encoding = "utf-8"?&gt;</span><br><span class="line"><span class="meta">&lt;!DOCTYPE hibernate-mapping PUBLIC </span></span><br><span class="line"><span class="meta">"-//Hibernate/Hibernate Mapping DTD//EN"</span></span><br><span class="line"><span class="meta">"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span> = <span class="string">"Employee"</span> <span class="attr">table</span> = <span class="string">"EMPLOYEE"</span>&gt;</span></span><br><span class="line">      </span><br><span class="line">      <span class="tag">&lt;<span class="name">meta</span> <span class="attr">attribute</span> = <span class="string">"class-description"</span>&gt;</span></span><br><span class="line">         This class contains the employee detail. </span><br><span class="line">      <span class="tag">&lt;/<span class="name">meta</span>&gt;</span></span><br><span class="line">      </span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span> = <span class="string">"id"</span> <span class="attr">type</span> = <span class="string">"int"</span> <span class="attr">column</span> = <span class="string">"id"</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"native"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      </span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">"firstName"</span> <span class="attr">column</span> = <span class="string">"first_name"</span> <span class="attr">type</span> = <span class="string">"string"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">"lastName"</span> <span class="attr">column</span> = <span class="string">"last_name"</span> <span class="attr">type</span> = <span class="string">"string"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">"salary"</span> <span class="attr">column</span> = <span class="string">"salary"</span> <span class="attr">type</span> = <span class="string">"int"</span>/&gt;</span></span><br><span class="line">      </span><br><span class="line">   <span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></div><p>一般映射文件的文件名格式为: <code>&lt;classname&gt;.hbm.xml</code>。例如上面的映射文件我们可以命名为: <code>Employee.hbm.xml</code>。</p><p>下面是针对映射文件中涉及到的标签元素给出的具体解释:</p><ul><li>映射文件使用<code>&lt;hibernate-mapping&gt;</code>标签作为根标签元素，它包含所有的<code>&lt;class&gt;</code>标签元素；</li><li><code>&lt;class&gt;</code>标签是用来定义java类到数据表的映射关系的。Java类名和数据表名称分别由标签的<code>name</code>和<code>table</code>属性指定；</li><li><code>&lt;meta&gt;</code>标签用于创建类的描述信息，是可选标签；</li><li><code>&lt;id&gt;</code>标签映射Java类的唯一id属性到数据表的主键。该标签的<code>name</code>属性指定类的属性名，<code>column</code>则指定数据表的字段名。<code>type</code>属性为hibernate映射类型，将Java数据类型转化为SQL数据类型。</li><li><code>&lt;generator&gt;</code>标签元素是<code>&lt;id&gt;</code>标签的子元素，用来自动生成主键值。其中<code>class</code>属性设置为<code>native</code>，以使Hibernate根据底层数据库的功能选择<code>identity</code>,<code>sequence</code>或<code>hilo</code>算法来生成主键；</li><li><code>&lt;property&gt;</code>标签则用来将java类中的属性映射到数据表中的字段。<code>name</code>属性指定java类的属性名，相应的，<code>column</code>指定数据表对应的字段名称。<code>type</code>为hibernate映射类型。</li></ul><p>除了上面提到的这些标签元素和属性外，其实还有其他的标签元素和属性。这里只不过是简单地给出了常用的标签元素及其属性的解释。</p><h2 id="Hibernate-映射类型"><a href="#Hibernate-映射类型" class="headerlink" title="Hibernate 映射类型"></a>Hibernate 映射类型</h2><p>当我们配置<strong>Hibernate映射文件</strong>时，我们需要将Java数据类型映射转化为RDBMS数据类型。在映射文件中生命的<strong>类型(types)</strong>既不是java数据类型，也不是SQL 数据据数据类型。我们一般称其为<strong>Hibernate mapping types(hibernate映射类型)</strong>,它们能够将java数据类型转化为SQL数据类型，反之亦然。</p><p>下面给出了所有基本的，日期和时间，大对象以及其他各种内置映射类型。</p><h3 id="一、原始类型-Primitive-Types"><a href="#一、原始类型-Primitive-Types" class="headerlink" title="一、原始类型(Primitive Types)"></a>一、原始类型(Primitive Types)</h3><div class="table-container"><table><thead><tr><th style="text-align:center">Mapping type</th><th style="text-align:center">Java type</th><th style="text-align:center">ANSI  SQL Type</th></tr></thead><tbody><tr><td style="text-align:center">integer</td><td style="text-align:center">int or java.lang.Integer</td><td style="text-align:center">INTEGER</td></tr><tr><td style="text-align:center">long</td><td style="text-align:center">long or java.lang.Long</td><td style="text-align:center">BIGINT</td></tr><tr><td style="text-align:center">short</td><td style="text-align:center">short or java.lang.Short</td><td style="text-align:center">SMALLINT</td></tr><tr><td style="text-align:center">float</td><td style="text-align:center">float or java.lang.Float</td><td style="text-align:center">FLOAT</td></tr><tr><td style="text-align:center">double</td><td style="text-align:center">double or java.lang.Double</td><td style="text-align:center">DOUBLE</td></tr><tr><td style="text-align:center">big_decimal</td><td style="text-align:center">java.math.BigDecimal</td><td style="text-align:center">NUMERIC</td></tr><tr><td style="text-align:center">character</td><td style="text-align:center">java.lang.String</td><td style="text-align:center">CHAR(1)</td></tr><tr><td style="text-align:center">string</td><td style="text-align:center">java.lang.String</td><td style="text-align:center">VARCHAR</td></tr><tr><td style="text-align:center">byte</td><td style="text-align:center">byte or java.lang.Byte</td><td style="text-align:center">TINYINT</td></tr><tr><td style="text-align:center">boolean</td><td style="text-align:center">boolean or java.lang.Boolean</td><td style="text-align:center">BIT</td></tr><tr><td style="text-align:center">yes/no</td><td style="text-align:center">boolean or java.lang.Boolean</td><td style="text-align:center">CHAR(1)(‘Y’ or ‘N’)</td></tr><tr><td style="text-align:center">true/false</td><td style="text-align:center">boolean or java.lang.Boolean</td><td style="text-align:center">CHAR(1)(‘Y’ or ‘N’)</td></tr></tbody></table></div><h3 id="二、日期和时间类型"><a href="#二、日期和时间类型" class="headerlink" title="二、日期和时间类型"></a>二、日期和时间类型</h3><div class="table-container"><table><thead><tr><th style="text-align:center">Mapping Type</th><th style="text-align:center">Java Type</th><th style="text-align:center">ANSI SQL Type</th></tr></thead><tbody><tr><td style="text-align:center">date</td><td style="text-align:center">java..util.Date or java.sql.Date</td><td style="text-align:center">DATE</td></tr><tr><td style="text-align:center">time</td><td style="text-align:center">java.util.Date or java.sql.Date</td><td style="text-align:center">TIME</td></tr><tr><td style="text-align:center">timestamp</td><td style="text-align:center">java.util.Date or java.sql.Timestamp</td><td style="text-align:center">TIMESTAMP</td></tr><tr><td style="text-align:center">calendar</td><td style="text-align:center">java.util.Calendar</td><td style="text-align:center">TIMESTAMP</td></tr><tr><td style="text-align:center">calendar_date</td><td style="text-align:center">java.util.Calendar</td><td style="text-align:center">DATE</td></tr></tbody></table></div><h3 id="三、二进制和大对象类型"><a href="#三、二进制和大对象类型" class="headerlink" title="三、二进制和大对象类型"></a>三、二进制和大对象类型</h3><div class="table-container"><table><thead><tr><th style="text-align:center">Mapping Type</th><th style="text-align:center">Java Type</th><th style="text-align:center">ANSI SQL Type</th></tr></thead><tbody><tr><td style="text-align:center">binary</td><td style="text-align:center">byte[]</td><td style="text-align:center">VARBINARY(or BLOB)</td></tr><tr><td style="text-align:center">text</td><td style="text-align:center">java.lang.String</td><td style="text-align:center">CLOB</td></tr><tr><td style="text-align:center">serializable</td><td style="text-align:center">任何实现java.io.Serializable接口的类</td><td style="text-align:center">VARBIANRY(or BLOB</td></tr><tr><td style="text-align:center">clob</td><td style="text-align:center">java.sql.Clob</td><td style="text-align:center">CLOB</td></tr><tr><td style="text-align:center">blob</td><td style="text-align:center">java.sql.Blob</td><td style="text-align:center">BLOB</td></tr></tbody></table></div><h3 id="四、JDK相关类型"><a href="#四、JDK相关类型" class="headerlink" title="四、JDK相关类型"></a>四、JDK相关类型</h3><div class="table-container"><table><thead><tr><th style="text-align:center">Mapping Type</th><th style="text-align:center">Java Type</th><th style="text-align:center">ANSI SQL Type</th></tr></thead><tbody><tr><td style="text-align:center">class</td><td style="text-align:center">java.lang.Class</td><td style="text-align:center">VARCHAR</td></tr><tr><td style="text-align:center">locale</td><td style="text-align:center">java.util.Locale</td><td style="text-align:center">VARCHAR</td></tr><tr><td style="text-align:center">timezone</td><td style="text-align:center">java.util.TimeZone</td><td style="text-align:center">VARCHAR</td></tr><tr><td style="text-align:center">currency</td><td style="text-align:center">java.util.Currency</td><td style="text-align:center">VARCHAR</td></tr></tbody></table></div><h2 id="Hibernate-使用实例"><a href="#Hibernate-使用实例" class="headerlink" title="Hibernate 使用实例"></a>Hibernate 使用实例</h2><p>接下来我们将通过一个简单的例子来了解<strong>Hiberate</strong>是如何为独立应用程序提供持久化服务的。下面使用Hibernate技术分几个不同的步骤来创建一个Java应用程序。</p><h3 id="一、创建POJO类"><a href="#一、创建POJO类" class="headerlink" title="一、创建POJO类"></a>一、创建POJO类</h3><p>创建应用程序的第一步就是创建Java POJO类，这取决与应用程序中需要保留到数据库的类。这里我们创建一个拥有<code>getter</code>和<code>setter</code>方法的<code>Employee</code>类，并让它成为<code>JavaBean</code>兼容类。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">   <span class="keyword">private</span> String firstName; </span><br><span class="line">   <span class="keyword">private</span> String lastName;   </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> salary;  </span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String fname, String lname, <span class="keyword">int</span> salary)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.firstName = fname;</span><br><span class="line">      <span class="keyword">this</span>.lastName = lname;</span><br><span class="line">      <span class="keyword">this</span>.salary = salary;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> id;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">( <span class="keyword">int</span> id )</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.id = id;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getFirstName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> firstName;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirstName</span><span class="params">( String first_name )</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.firstName = first_name;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getLastName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> lastName;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLastName</span><span class="params">( String last_name )</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.lastName = last_name;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSalary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> salary;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSalary</span><span class="params">( <span class="keyword">int</span> salary )</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.salary = salary;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="二、创建数据表"><a href="#二、创建数据表" class="headerlink" title="二、创建数据表"></a>二、创建数据表</h3><p>第二步，就是要在数据库中创建数据表。一张数据表对应一个持久化类。定义<code>EMPLOYEE</code>表来对应<code>Employee</code>持久化类。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> EMPLOYEE (</span><br><span class="line">   <span class="keyword">id</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> auto_increment,</span><br><span class="line">   first_name <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">default</span> <span class="literal">NULL</span>,</span><br><span class="line">   last_name  <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">default</span> <span class="literal">NULL</span>,</span><br><span class="line">   salary     <span class="built_in">INT</span>  <span class="keyword">default</span> <span class="literal">NULL</span>,</span><br><span class="line">   PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div><h3 id="三、创建映射文件"><a href="#三、创建映射文件" class="headerlink" title="三、创建映射文件"></a>三、创建映射文件</h3><p>创建一个映射文件来告诉Hibernate如何将持久化类映射到数据表。</p><p><strong><code>Employee.hbm.xml</code></strong>:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version = "1.0" encoding = "utf-8"?&gt;</span><br><span class="line"><span class="meta">&lt;!DOCTYPE hibernate-mapping PUBLIC </span></span><br><span class="line"><span class="meta">"-//Hibernate/Hibernate Mapping DTD//EN"</span></span><br><span class="line"><span class="meta">"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span> = <span class="string">"Employee"</span> <span class="attr">table</span> = <span class="string">"EMPLOYEE"</span>&gt;</span></span><br><span class="line">      </span><br><span class="line">      <span class="tag">&lt;<span class="name">meta</span> <span class="attr">attribute</span> = <span class="string">"class-description"</span>&gt;</span></span><br><span class="line">         This class contains the employee detail. </span><br><span class="line">      <span class="tag">&lt;/<span class="name">meta</span>&gt;</span></span><br><span class="line">      </span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span> = <span class="string">"id"</span> <span class="attr">type</span> = <span class="string">"int"</span> <span class="attr">column</span> = <span class="string">"id"</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"native"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      </span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">"firstName"</span> <span class="attr">column</span> = <span class="string">"first_name"</span> <span class="attr">type</span> = <span class="string">"string"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">"lastName"</span> <span class="attr">column</span> = <span class="string">"last_name"</span> <span class="attr">type</span> = <span class="string">"string"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">"salary"</span> <span class="attr">column</span> = <span class="string">"salary"</span> <span class="attr">type</span> = <span class="string">"int"</span>/&gt;</span></span><br><span class="line">      </span><br><span class="line">   <span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></div><h3 id="四、创建应用程序类"><a href="#四、创建应用程序类" class="headerlink" title="四、创建应用程序类"></a>四、创建应用程序类</h3><p>最后，我们创建一个应用程序类来做简单的测试。例如：保存一些<code>Employee</code>数据，执行<code>CRUD</code>操作等。</p><p><strong><code>ManageEmployee.java</code></strong>:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List; </span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.hibernate.HibernateException; </span><br><span class="line"><span class="keyword">import</span> org.hibernate.Session; </span><br><span class="line"><span class="keyword">import</span> org.hibernate.Transaction;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.SessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.cfg.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ManageEmployee</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> SessionFactory factory; </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         factory = <span class="keyword">new</span> Configuration().configure().buildSessionFactory();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable ex) &#123; </span><br><span class="line">         System.err.println(<span class="string">"Failed to create sessionFactory object."</span> + ex);</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> ExceptionInInitializerError(ex); </span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      ManageEmployee ME = <span class="keyword">new</span> ManageEmployee();</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Add few employee records in database */</span></span><br><span class="line">      Integer empID1 = ME.addEmployee(<span class="string">"Zara"</span>, <span class="string">"Ali"</span>, <span class="number">1000</span>);</span><br><span class="line">      Integer empID2 = ME.addEmployee(<span class="string">"Daisy"</span>, <span class="string">"Das"</span>, <span class="number">5000</span>);</span><br><span class="line">      Integer empID3 = ME.addEmployee(<span class="string">"John"</span>, <span class="string">"Paul"</span>, <span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* List down all the employees */</span></span><br><span class="line">      ME.listEmployees();</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Update employee's records */</span></span><br><span class="line">      ME.updateEmployee(empID1, <span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Delete an employee from the database */</span></span><br><span class="line">      ME.deleteEmployee(empID2);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* List down new list of the employees */</span></span><br><span class="line">      ME.listEmployees();</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* Method to CREATE an employee in the database */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Integer <span class="title">addEmployee</span><span class="params">(String fname, String lname, <span class="keyword">int</span> salary)</span></span>&#123;</span><br><span class="line">      Session session = factory.openSession();</span><br><span class="line">      Transaction tx = <span class="keyword">null</span>;</span><br><span class="line">      Integer employeeID = <span class="keyword">null</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         tx = session.beginTransaction();</span><br><span class="line">         Employee employee = <span class="keyword">new</span> Employee(fname, lname, salary);</span><br><span class="line">         employeeID = (Integer) session.save(employee); </span><br><span class="line">         tx.commit();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (HibernateException e) &#123;</span><br><span class="line">         <span class="keyword">if</span> (tx!=<span class="keyword">null</span>) tx.rollback();</span><br><span class="line">         e.printStackTrace(); </span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         session.close(); </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> employeeID;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* Method to  READ all the employees */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listEmployees</span><span class="params">( )</span></span>&#123;</span><br><span class="line">      Session session = factory.openSession();</span><br><span class="line">      Transaction tx = <span class="keyword">null</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         tx = session.beginTransaction();</span><br><span class="line">         List employees = session.createQuery(<span class="string">"FROM Employee"</span>).list(); </span><br><span class="line">         <span class="keyword">for</span> (Iterator iterator = employees.iterator(); iterator.hasNext();)&#123;</span><br><span class="line">            Employee employee = (Employee) iterator.next(); </span><br><span class="line">            System.out.print(<span class="string">"First Name: "</span> + employee.getFirstName()); </span><br><span class="line">            System.out.print(<span class="string">"  Last Name: "</span> + employee.getLastName()); </span><br><span class="line">            System.out.println(<span class="string">"  Salary: "</span> + employee.getSalary()); </span><br><span class="line">         &#125;</span><br><span class="line">         tx.commit();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (HibernateException e) &#123;</span><br><span class="line">         <span class="keyword">if</span> (tx!=<span class="keyword">null</span>) tx.rollback();</span><br><span class="line">         e.printStackTrace(); </span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         session.close(); </span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* Method to UPDATE salary for an employee */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateEmployee</span><span class="params">(Integer EmployeeID, <span class="keyword">int</span> salary )</span></span>&#123;</span><br><span class="line">      Session session = factory.openSession();</span><br><span class="line">      Transaction tx = <span class="keyword">null</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         tx = session.beginTransaction();</span><br><span class="line">         Employee employee = (Employee)session.get(Employee.class, EmployeeID); </span><br><span class="line">         employee.setSalary( salary );</span><br><span class="line"> session.update(employee); </span><br><span class="line">         tx.commit();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (HibernateException e) &#123;</span><br><span class="line">         <span class="keyword">if</span> (tx!=<span class="keyword">null</span>) tx.rollback();</span><br><span class="line">         e.printStackTrace(); </span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         session.close(); </span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* Method to DELETE an employee from the records */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteEmployee</span><span class="params">(Integer EmployeeID)</span></span>&#123;</span><br><span class="line">      Session session = factory.openSession();</span><br><span class="line">      Transaction tx = <span class="keyword">null</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         tx = session.beginTransaction();</span><br><span class="line">         Employee employee = (Employee)session.get(Employee.class, EmployeeID); </span><br><span class="line">         session.delete(employee); </span><br><span class="line">         tx.commit();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (HibernateException e) &#123;</span><br><span class="line">         <span class="keyword">if</span> (tx!=<span class="keyword">null</span>) tx.rollback();</span><br><span class="line">         e.printStackTrace(); </span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         session.close(); </span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="五、编译执行"><a href="#五、编译执行" class="headerlink" title="五、编译执行"></a>五、编译执行</h3><p>通过编译执行，我们可以得到下面的测试结果：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$java</span> ManageEmployee</span><br><span class="line">.......VARIOUS LOG MESSAGES WILL DISPLAY HERE........</span><br><span class="line"></span><br><span class="line">First Name: Zara  Last Name: Ali  Salary: 1000</span><br><span class="line">First Name: Daisy  Last Name: Das  Salary: 5000</span><br><span class="line">First Name: John  Last Name: Paul  Salary: 10000</span><br><span class="line">First Name: Zara  Last Name: Ali  Salary: 5000</span><br><span class="line">First Name: John  Last Name: Paul  Salary: 10000</span><br></pre></td></tr></table></figure></div><p><code>EMPLOYEE</code>表中的数据：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from EMPLOYEE;</span><br><span class="line">+----+------------+-----------+--------+</span><br><span class="line">| id | first_name | last_name | salary |</span><br><span class="line">+----+------------+-----------+--------+</span><br><span class="line">| 29 | Zara       | Ali       |   5000 |</span><br><span class="line">| 31 | John       | Paul      |  10000 |</span><br><span class="line">+----+------------+-----------+--------+</span><br><span class="line">2 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure></div><h2 id="Hibernate-O-R-映射"><a href="#Hibernate-O-R-映射" class="headerlink" title="Hibernate O/R 映射"></a>Hibernate O/R 映射</h2><p>之前，我们已经熟悉了Hibernate的基本<code>O/R</code>映射的使用，但是还有很多映射我们还需要进一步的了解。如：</p><ul><li>集合的映射</li><li>实体类之间的关联映射</li><li>组件映射</li></ul><h3 id="一、集合映射"><a href="#一、集合映射" class="headerlink" title="一、集合映射"></a>一、集合映射</h3><p>如果持久化类中包含某个属性为集合类型，我们也需要将集合类型值映射到数据表中。<strong>Hibernate</strong>能够持久化的集合实例有<code>java.util.Map</code>、<code>java.util.Set</code>、<code>java.util.SortedMap</code>、<code>java.util.SortedSet</code>、<code>java.util.List</code>以及持久化实例中的数组(<code>array</code>)。</p><div class="table-container"><table><thead><tr><th style="text-align:center">Collection Type</th><th style="text-align:center">Mapping Description</th></tr></thead><tbody><tr><td style="text-align:center"><a href="#Set-Mapping">java.util.Set</a></td><td style="text-align:center">使用<code>&lt;set&gt;</code>标签元素进行映射并使用<code>java.util.HashSet</code>进行初始化</td></tr><tr><td style="text-align:center"><a href="#SortedSet-Mapping">java.util.SortedSet</a></td><td style="text-align:center">使用<code>&lt;set&gt;</code>标签进行映射并用<code>java.util.TreeSet</code>初始化，属性<code>sort</code>可以设置为<code>comparator</code>或者<code>natural ordering</code></td></tr><tr><td style="text-align:center"><a href="#List-Mapping">java.util.List</a></td><td style="text-align:center">使用<code>&lt;list&gt;</code>标签进行映射，并用<code>java.util.ArrayList</code>初始化</td></tr><tr><td style="text-align:center"><a href="#Collection-Mapping">java.util.Collection</a></td><td style="text-align:center">使用<code>&lt;bag&gt;</code>或<code>&lt;ibag&gt;</code>标签进行映射配置并使用<code>java.util.ArrayList</code>初始化</td></tr><tr><td style="text-align:center"><a href="#Map-Mapping">java.util.Map</a></td><td style="text-align:center">使用<code>&lt;map</code>标签进行映射并使用<code>java.util.HashMap</code>初始化</td></tr><tr><td style="text-align:center"><a href="#SortedMap-Mapping">java.util.SortedMap</a></td><td style="text-align:center">使用<code>&lt;map</code>标签进行映射并用<code>java.util.TreeMap</code>初始化。属性<code>sort</code>可以设置为<code>comparator</code>或<code>natural ordering</code></td></tr></tbody></table></div><p>对于数组类型的映射，针对Java原始值类型使用<code>&lt;primitive-array&gt;</code>标签，其他的数组类型则使用<code>&lt;array&gt;</code>。但是一般很少使用到。</p><p><strong>[notice]</strong>:如果需要映射用户自定义的集合接口，切该集合接口不是<strong>Hiberate</strong>直接支持的，就需要告诉Hibernate定义集合的语义，通常是很难实现的，一般不推荐使用。</p><h4 id="Set-Mapping"><a href="#Set-Mapping" class="headerlink" title="Set-Mapping"></a>Set-Mapping</h4><h4 id="SortedSet-Mapping"><a href="#SortedSet-Mapping" class="headerlink" title="SortedSet-Mapping"></a>SortedSet-Mapping</h4><h4 id="List-Mapping"><a href="#List-Mapping" class="headerlink" title="List-Mapping"></a>List-Mapping</h4><h4 id="Collection-Mapping"><a href="#Collection-Mapping" class="headerlink" title="Collection-Mapping"></a>Collection-Mapping</h4><h4 id="Map-Mapping"><a href="#Map-Mapping" class="headerlink" title="Map-Mapping"></a>Map-Mapping</h4><h4 id="SortedMap-Mapping"><a href="#SortedMap-Mapping" class="headerlink" title="SortedMap-Mapping"></a>SortedMap-Mapping</h4><h3 id="二、关联映射"><a href="#二、关联映射" class="headerlink" title="二、关联映射"></a>二、关联映射</h3><p>实体类和数据表之间的映射是<code>ORM</code>的灵魂。以下是可以表示对象之间关系的四种方式。关联映射可以是单向的，也可以是双向的。</p><div class="table-container"><table><thead><tr><th style="text-align:center">Mapping Type</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td style="text-align:center"><a href="#Many-to-One">Many-to-One</a></td><td style="text-align:center">多对一关系的映射</td></tr><tr><td style="text-align:center"><a href="#One-to-One">One-to-One</a></td><td style="text-align:center">一对一关系的映射</td></tr><tr><td style="text-align:center"><a href="#One-to-Many">One-to-Many</a></td><td style="text-align:center">一对多关系的映射</td></tr><tr><td style="text-align:center"><a href="#Many-to-Many">Many-to-Many</a></td><td style="text-align:center">多对多关系的映射</td></tr></tbody></table></div><h4 id="Many-to-One"><a href="#Many-to-One" class="headerlink" title="Many-to-One"></a>Many-to-One</h4><h4 id="One-to-One"><a href="#One-to-One" class="headerlink" title="One-to-One"></a>One-to-One</h4><h4 id="One-to-Many"><a href="#One-to-Many" class="headerlink" title="One-to-Many"></a>One-to-Many</h4><h4 id="Many-to-Many"><a href="#Many-to-Many" class="headerlink" title="Many-to-Many"></a>Many-to-Many</h4><h3 id="三、组件映射"><a href="#三、组件映射" class="headerlink" title="三、组件映射"></a>三、组件映射</h3><p>在应用程序中，有很大的可能性一个实体类会持有另一个实体的引用最为成员变量。如果别引用的类没有自己的申明周期并且完全依赖与拥有的实体类的生命周期，那么所引用的类称为<strong>组件类</strong>。</p><p>组件的映射可以以类似集合映射的方式进行，但有点不同与常规的集合映射：</p><div class="table-container"><table><thead><tr><th style="text-align:center">Mapping Type</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td style="text-align:center"><a href="">Component Mappings</a></td><td style="text-align:center">对持有另一个类作为成员变量的实体类进行映射</td></tr></tbody></table></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/Hibernate基础学习/hibernate_logo.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Hibernate&lt;/strong&gt;是一个对象关系映射&lt;span title=&quot;Object-Relational Mapping&quot;&gt;&lt;code&gt;ORM&lt;/code&gt;&lt;/span&gt;的JAVA解决方案。是在2001年由 &lt;em&gt;Gavin King&lt;/em&gt;创建的开源持久化框架。适用于任何使用Java应用程序的功能强大的高性能&lt;strong&gt;对象关系持久化和查询服务&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Java框架学习" scheme="http://rovo98.github.io/categories/Java%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Hibernate" scheme="http://rovo98.github.io/categories/Java%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/Hibernate/"/>
    
    
      <category term="学习笔记" scheme="http://rovo98.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Java框架基础" scheme="http://rovo98.github.io/tags/Java%E6%A1%86%E6%9E%B6%E5%9F%BA%E7%A1%80/"/>
    
      <category term="hibernate" scheme="http://rovo98.github.io/tags/hibernate/"/>
    
  </entry>
  
  <entry>
    <title>Java持久化框架基础学习笔记 - ORM</title>
    <link href="http://rovo98.github.io/posts/4e7f2cb9/"/>
    <id>http://rovo98.github.io/posts/4e7f2cb9/</id>
    <published>2018-04-12T11:41:44.000Z</published>
    <updated>2018-10-08T05:08:41.721Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>对象关系映射(Oject Relational Mapping, ORM)是一种程序技术，用户实现面向对象编程语言中不同类型系统的数据之间的转换。</p></blockquote><a id="more"></a><p>为了更好的了解ORM，我们先要了解一下JDBC。</p><h3 id="什么是JDBC"><a href="#什么是JDBC" class="headerlink" title="什么是JDBC?"></a>什么是JDBC?</h3><p>JDBC，即<strong>Java Database Connectivity</strong>(Java数据库连接)。它为Java程序提供了访问关系型数据库(relational database)的Java API集合。<strong>这些API使得Java程序可以执行SQL语句并与任何符合SQL的数据库库进行交互。</strong></p><p>JDBC提供了一种<strong>灵活的</strong>结构来编写能够和数据库进行交互的应用，且在<strong>不做任何修改的情况下</strong>，能够运行于不同的平台。</p><h4 id="JDBC的优点和缺点"><a href="#JDBC的优点和缺点" class="headerlink" title="JDBC的优点和缺点"></a>JDBC的优点和缺点</h4><div class="table-container"><table><thead><tr><th style="text-align:center">优点</th><th style="text-align:center">缺点</th></tr></thead><tbody><tr><td style="text-align:center">清晰简单的SQL处理</td><td style="text-align:center">在大型的项目中使用时变得异常复杂</td></tr><tr><td style="text-align:center">处理大数据时有良好表现</td><td style="text-align:center">大量编程开销，没有封装</td></tr><tr><td style="text-align:center">非常适合小应用程序</td><td style="text-align:center">难以实现MVC模式</td></tr><tr><td style="text-align:center">语法简单易学</td><td style="text-align:center">查询是DBMS特有的</td></tr></tbody></table></div><h3 id="为什么使用对象关系映射-ORM"><a href="#为什么使用对象关系映射-ORM" class="headerlink" title="为什么使用对象关系映射(ORM)?"></a>为什么使用对象关系映射(ORM)?</h3><p>当我们使用面向对象系统时，对象模型和关系数据库存在不匹配的现象，<strong>RDMSs(关系型数据库) 以表格的形式表示数据，而面向对象编程语言，如java,C# 将数据表示为对象的属性，以及对象之间的关系</strong>。</p><p>例如下面的一个简单的实体类：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String firstName;</span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> salary;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String fname, String lname, <span class="keyword">int</span> sal)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.firstName = fname;</span><br><span class="line">        <span class="keyword">this</span>.lastName = lname;</span><br><span class="line">        <span class="keyword">this</span>.salary = sal;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFirstName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> firstName;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLastName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lastName;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSalary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> salary;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>上面的对象在关系型数据库中可以这样存储和检索的：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> EMPLOYEE (</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span> auto_increment,</span><br><span class="line">    first_name <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">default</span> <span class="literal">null</span>,</span><br><span class="line">    last_name <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">default</span> <span class="literal">null</span>,</span><br><span class="line">    salary <span class="built_in">int</span> <span class="keyword">default</span> <span class="literal">null</span>,</span><br><span class="line">    contraint PK_id primary <span class="keyword">key</span> (<span class="keyword">id</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div><h4 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h4><ol><li>可能我们开发了几个页面后，要修改数据库的设计，我们应该怎样处理？</li><li>将对象存储到关系型数据库和从数据库中读取存在以下五个<strong>不匹配(mismatch)</strong>的问题：</li></ol><div class="table-container"><table><thead><tr><th style="text-align:center">不匹配(Mismatch)</th><th style="text-align:center">描述(Description)</th></tr></thead><tbody><tr><td style="text-align:center">Granularity(粒度)</td><td style="text-align:center">有时你可能会有一个对象模型，它的类比数据库中的相应的表的数量还要多。</td></tr><tr><td style="text-align:center">Inheritence(继承)</td><td style="text-align:center">RDBMS不定义任何类似继承的东西，但这确是面向对象编程语言中的的自然范式。</td></tr><tr><td style="text-align:center">Identity(标识)</td><td style="text-align:center">RDBMS正好定义了一个“相等”的概念：主键。但是Java定义对象标识(a == b) 和对象相等(a.equals(b))。</td></tr><tr><td style="text-align:center">Associations(关联)</td><td style="text-align:center">面向对象编程语言使用对象引用来表示关联，而RDBMS将关联表示为外键。</td></tr><tr><td style="text-align:center">Navigation(检索)</td><td style="text-align:center">在Java和RDBMS中访问对象的方式根本不同。</td></tr></tbody></table></div><p><strong>对象关系映射（ORM）是处理上述所有不匹配问题的解决方案</strong>。</p><h3 id="什么是ORM"><a href="#什么是ORM" class="headerlink" title="什么是ORM?"></a>什么是ORM?</h3><p>ORM 是一项在关系型数据库和面向对象编程语言之间转换数据的编程技术。</p><p>相比于简单的JDBC，ORM有以下优点：</p><div class="table-container"><table><thead><tr><th style="text-align:center">No.</th><th style="text-align:center">Advantages</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">让业务逻辑代码访问数据对象，而不是数据表</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">隐藏了业务逻辑的SQL查询的详细信息</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">无需处理数据库实现问题</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">基于业务概念而非数据库结构的实体</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">基于JDBC“底层”</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">事务管理和自动密钥生成</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">应用程序快速开发</td></tr></tbody></table></div><p>一个 ORM 解决方案由以下四个实体组成：</p><div class="table-container"><table><thead><tr><th style="text-align:center">No.</th><th style="text-align:center">Solutions</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">对持久化类的对象执行基本CRUD操作的API</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">用于指定引用类和类的属性的查询的语言或API</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">用于指定映射元数据的可配置工具</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">一种与事务对象进行交互以执行脏检查，懒惰关联提取以及其他优化功能的技术。</td></tr></tbody></table></div><h3 id="Java-ORM-框架"><a href="#Java-ORM-框架" class="headerlink" title="Java ORM 框架"></a>Java ORM 框架</h3><p>有许多持久化框架ORM解决方案使用java实现的，如：</p><ul><li>Enterprise JavaBeans Entity Beans</li><li>Java Data Ojects</li><li>Castor</li><li>TopLink</li><li>Spring DAO</li><li>Hibernate</li><li>Mybatis</li><li>等等。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;对象关系映射(Oject Relational Mapping, ORM)是一种程序技术，用户实现面向对象编程语言中不同类型系统的数据之间的转换。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java框架学习" scheme="http://rovo98.github.io/categories/Java%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="学习笔记" scheme="http://rovo98.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Java框架基础" scheme="http://rovo98.github.io/tags/Java%E6%A1%86%E6%9E%B6%E5%9F%BA%E7%A1%80/"/>
    
      <category term="ORM" scheme="http://rovo98.github.io/tags/ORM/"/>
    
  </entry>
  
  <entry>
    <title>Struts 2基础学习 - Interceptors</title>
    <link href="http://rovo98.github.io/posts/5e817364/"/>
    <id>http://rovo98.github.io/posts/5e817364/</id>
    <published>2018-04-11T06:06:12.000Z</published>
    <updated>2018-10-08T05:08:41.745Z</updated>
    
    <content type="html"><![CDATA[<p>Interceptors(拦截器)在概念上同<strong>servlet过滤器以及JDK动态代理类</strong>一样。拦截器可以透切(crosscutting)<code>action</code>以及框架来实现一些特定的功能。例如：</p><ol><li>在action调用执行前，预先执行某些代码；</li><li>在action调用和执行后，再次执行你指定的代码；</li><li>用来捕捉异常，以便可以执行替代处理(alternate processing)。</li></ol><a id="more"></a><p>事实上，<strong>Struts 2</strong>框架的许多特性都是使用拦截器实现的。例如： <code>exception handling</code>, <code>file uploading</code>, <code>lifecycle callbacks</code>等等。因为<strong>Struts 2</strong>在拦截器上强调了它的大部分功能，因此不太可能为单个<code>action</code>分配7或8个拦截器。</p><h3 id="Struts-2框架拦截器"><a href="#Struts-2框架拦截器" class="headerlink" title="Struts 2框架拦截器"></a>Struts 2框架拦截器</h3><p><strong>Struts 2</strong>框架提供了许多预先配置并且可以开箱即用的拦截器。下面是一些比较重要的拦截器：</p><div class="table-container"><table><thead><tr><th style="text-align:center">Interceptor</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td style="text-align:center">alias</td><td style="text-align:center">允许参数(parameters)跨请求拥有不同的别名</td></tr><tr><td style="text-align:center">checkbox</td><td style="text-align:center">通过为未选中的复选框(check box)添加参数值false来协助管理复选框</td></tr><tr><td style="text-align:center">conversionError</td><td style="text-align:center">将字符串转换为参数类型的错误信息放入Action的字段错误中</td></tr><tr><td style="text-align:center">createSession</td><td style="text-align:center">自动创建一个HTTP session如果它没有存在</td></tr><tr><td style="text-align:center">debugging</td><td style="text-align:center">为开发人员提供几个不同的调式界面</td></tr><tr><td style="text-align:center">execAndWait</td><td style="text-align:center">当action在后台执行时，给用户提供一个等待页面</td></tr><tr><td style="text-align:center">exception</td><td style="text-align:center">将action引发的异常映射到result,并通过重定向自动处理异常</td></tr><tr><td style="text-align:center">fileUpload</td><td style="text-align:center">便于文件上传</td></tr><tr><td style="text-align:center">i18n</td><td style="text-align:center">在用户回话期间跟踪所选的语言环境</td></tr><tr><td style="text-align:center">logger</td><td style="text-align:center">通过输出被执行的action的名字来提供简单的日志信息</td></tr><tr><td style="text-align:center">params</td><td style="text-align:center">允许在action中设置request的参数</td></tr><tr><td style="text-align:center">prepare</td><td style="text-align:center">这是一个用来的做预处理工作的典型代表，例如：建立数据库连接</td></tr><tr><td style="text-align:center">profile</td><td style="text-align:center">允许为action记录简单的分析信息</td></tr><tr><td style="text-align:center">scope</td><td style="text-align:center">在session或application域中存储和检索action的状态</td></tr><tr><td style="text-align:center">ServletConfig</td><td style="text-align:center">提供可以访问各种基于servlet信息的action</td></tr><tr><td style="text-align:center">timer</td><td style="text-align:center">为action需要执行多少时间提供一个简单的分析信息</td></tr><tr><td style="text-align:center">token</td><td style="text-align:center">检查有效标记的action以防止重复的表单提交</td></tr><tr><td style="text-align:center">validation</td><td style="text-align:center">为action的提供验证支持</td></tr></tbody></table></div><h3 id="如何使用拦截器？"><a href="#如何使用拦截器？" class="headerlink" title="如何使用拦截器？"></a>如何使用拦截器？</h3><p>我们可以直接在<code>struts.xml</code>配置文件中配置<strong>Struts 2</strong>已经提供的拦截器，例如使用<code>timer</code>拦截器来打印执行<code>action</code>所需要的时间，同时还可以使用<code>params</code>拦截器来将<code>request</code>参数传递给<code>action</code>。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version = "1.0" Encoding = "UTF-8"?&gt;</span><br><span class="line"><span class="meta">&lt;!DOCTYPE struts PUBLIC</span></span><br><span class="line"><span class="meta">   "-//Apache Software Foundation//DTD Struts Configuration 2.0//EN"</span></span><br><span class="line"><span class="meta">   "http://struts.apache.org/dtds/struts-2.0.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">struts</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">constant</span> <span class="attr">name</span> = <span class="string">"struts.devMode"</span> <span class="attr">value</span> = <span class="string">"true"</span> /&gt;</span></span><br><span class="line">   </span><br><span class="line">   <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span> = <span class="string">"helloworld"</span> <span class="attr">extends</span> = <span class="string">"struts-default"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span> = <span class="string">"hello"</span> </span></span><br><span class="line"><span class="tag">         <span class="attr">class</span> = <span class="string">"com.rovo98.struts2.HelloWorldAction"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">method</span> = <span class="string">"execute"</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">interceptor-ref</span> <span class="attr">name</span> = <span class="string">"params"</span>/&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">interceptor-ref</span> <span class="attr">name</span> = <span class="string">"timer"</span> /&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span> = <span class="string">"success"</span>&gt;</span>/HelloWorld.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">struts</span>&gt;</span></span><br></pre></td></tr></table></figure></div><h3 id="创建自定义拦截器"><a href="#创建自定义拦截器" class="headerlink" title="创建自定义拦截器"></a>创建自定义拦截器</h3><p>在我们的应用程序中使用<strong>拦截器</strong>来透切(crosscutting)应用使用一种优雅的方式。创建自定义的拦截器很容易，只需要实现<code>Interceptor</code>接口就行了。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interceptor</span> <span class="keyword">extends</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">intercept</span><span class="params">(ActionInvocation invocation)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>其中<code>init()</code>方法用来初始化拦截器，<code>destroy()</code>方法被用来销毁拦截器。不像<code>action</code>，拦截器<code>request</code>中被重复使用，所以它需要考虑线程安全问题，特别是<code>intercept()</code>方法。</p><p><code>ActionInvocation</code>对象提供的运行环境的访问。它允许访问<code>action</code>本身和调用<code>action</code>的方法并确定<code>action</code>是否已经被调用。</p><p>如果你不需要实现初始化和销毁拦截器的代码，可以直接继承<code>AbstractInterceptor</code>类，它不需要实现<code>init()</code>和<code>destroy()</code>方法。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.rovo98.struts2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> com.opensymphony.xwork2.ActionInvocation;</span><br><span class="line"><span class="keyword">import</span> com.opensymphony.xwork2.interceptor.AbstractInterceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterceptor</span> <span class="keyword">extends</span> <span class="title">AbstractInterceptor</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">intercept</span><span class="params">(ActionInvocation invocation)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="comment">/* let us do some pre-processing */</span></span><br><span class="line">      String output = <span class="string">"Pre-Processing"</span>; </span><br><span class="line">      System.out.println(output);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* let us call action or next interceptor */</span></span><br><span class="line">      String result = invocation.invoke();</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* let us do some post-processing */</span></span><br><span class="line">      output = <span class="string">"Post-Processing"</span>; </span><br><span class="line">      System.out.println(output);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>实际的<code>action</code>将通过拦截器调用<code>invocation.invoke()</code>方法来执行。因此我们<code>action</code>执行前或执行后加入我们的处理代码。</p><p>框架本身通过对<code>ActionInvocation</code>对象的<code>invoke()</code>方法的第一次调用来启动该过程。每次调用<code>invoke()</code>，<code>ActionInvocation</code>都会查询其状态并执行下一个拦截器。当所有的配置的拦截器都执行完了之后，<code>action</code>才会被执行。</p><p>下面是其工作流程图：</p><p><img src="actioninvocation.jpg" alt=""></p><h3 id="拦截器栈"><a href="#拦截器栈" class="headerlink" title="拦截器栈"></a>拦截器栈</h3><p>不难想象，当我们为单个<code>action</code>配置多个拦截器时，它们很快会变得很难管理。所以<strong>Struts 2</strong>引入了拦截器栈的概念来管理。下面是一个在<code>sturtsdefault.xml</code>配置文件中的一个拦截器栈：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">interceptor-stack</span> <span class="attr">name</span> = <span class="string">"basicStack"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">interceptor-ref</span> <span class="attr">name</span> = <span class="string">"exception"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">interceptor-ref</span> <span class="attr">name</span> = <span class="string">"servlet-config"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">interceptor-ref</span> <span class="attr">name</span> = <span class="string">"prepare"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">interceptor-ref</span> <span class="attr">name</span> = <span class="string">"checkbox"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">interceptor-ref</span> <span class="attr">name</span> = <span class="string">"params"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">interceptor-ref</span> <span class="attr">name</span> = <span class="string">"conversionError"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">interceptor-stack</span>&gt;</span></span><br></pre></td></tr></table></figure></div><p>上面的拦截器栈拥有唯一标识<code>basicStack</code>,当我们使用这个拦截器栈时，实际上和之前配置单个拦截器使用的是同样的语法：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>= <span class="string">"hello"</span> <span class="attr">class</span>= <span class="string">"com.rovo98.struts2.MyActoin"</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">interceptor-ref</span> <span class="attr">name</span> = <span class="string">"basicStack"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span>&gt;</span>/view.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br></pre></td></tr></table></figure></div><p>通过上面的配置，为<code>hello</code>action 配置了六个拦截器，且这六个拦截器在<code>action</code>被执行前将被按顺序执行。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Interceptors(拦截器)在概念上同&lt;strong&gt;servlet过滤器以及JDK动态代理类&lt;/strong&gt;一样。拦截器可以透切(crosscutting)&lt;code&gt;action&lt;/code&gt;以及框架来实现一些特定的功能。例如：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在action调用执行前，预先执行某些代码；&lt;/li&gt;
&lt;li&gt;在action调用和执行后，再次执行你指定的代码；&lt;/li&gt;
&lt;li&gt;用来捕捉异常，以便可以执行替代处理(alternate processing)。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Java框架学习" scheme="http://rovo98.github.io/categories/Java%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Struts 2" scheme="http://rovo98.github.io/categories/Java%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/Struts-2/"/>
    
    
      <category term="学习笔记" scheme="http://rovo98.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Java框架基础" scheme="http://rovo98.github.io/tags/Java%E6%A1%86%E6%9E%B6%E5%9F%BA%E7%A1%80/"/>
    
      <category term="Struts 2基础学习" scheme="http://rovo98.github.io/tags/Struts-2%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Struts 2基础学习 - Actions</title>
    <link href="http://rovo98.github.io/posts/338c78b5/"/>
    <id>http://rovo98.github.io/posts/338c78b5/</id>
    <published>2018-04-11T06:01:19.000Z</published>
    <updated>2018-10-08T05:08:41.741Z</updated>
    
    <content type="html"><![CDATA[<p><code>action</code>是<strong>Struts 2</strong> 框架的核心，它们适用于任何MVC框架。每个URL都映射到一个具体的<code>action</code>，<code>action</code>提供了业务逻辑处理来响应用户发起的请求。</p><a id="more"></a><p>但是，<code>action</code>拥有另外两个重要的职能。第一，    <code>action</code>在数据(data)从<code>request</code>中传递到视图(view,无论是jsp还是其他的result)的过程扮演着一个重要的角色。第二，<code>action</code>帮助<strong>Struts 2</strong> 来确定哪个result对应的视图(view)将被返回去响应用户的请求。</p><h3 id="创建Action"><a href="#创建Action" class="headerlink" title="创建Action"></a>创建Action</h3><p>创建和使用<code>action</code>类的唯一要求就是<strong>必须要有一个无参方法(noargument method)返回<code>String</code>或<code>Result</code>对象，并且必须是<code>POJO</code>(Plain Ordinary Java Object).如果该方法没有给出，默认的，<code>execute()</code>方法将会被执行。</strong></p><p>另外，我们可以通过继承实现了六个接口(其中包含<code>Action</code> interface)的<code>ActionSupport</code>类来创建我们的<code>action</code>类。 <code>Action</code>接口的定义如下：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Action</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SUCCESS = <span class="string">"success"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NONE = <span class="string">"none"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ERROR = <span class="string">"error"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String INPUT = <span class="string">"input"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOGIN = <span class="string">"login"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>下面是一个简单的普通的    <code>action</code>：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.rovo98.struts2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldAction</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span>  String <span class="title">getNane</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>我们说过<code>action</code>可以控制视图，为了验证这一点，我们对上面的<code>action</code>的<code>execute()</code>方法做简单的修改，以及继承<code>ActionSupport</code>类：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.rovo98.struts2;</span><br><span class="line"><span class="keyword">import</span> com.opensymphony.xwork2.ActionSupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldAction</span> <span class="keyword">extends</span> <span class="title">ActionSupport</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"SECRET"</span>.equals(name)) &#123;</span><br><span class="line">        <span class="keyword">return</span> SUCCESS;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="使用Action"><a href="#使用Action" class="headerlink" title="使用Action"></a>使用Action</h3><h4 id="在struts-xml-配置文件中配置action"><a href="#在struts-xml-配置文件中配置action" class="headerlink" title="在struts.xml 配置文件中配置action"></a>在struts.xml 配置文件中配置action</h4><p>在上面的<code>action</code>中，我们执行<code>execute()</code>方法的业务逻辑是从<code>request</code>对象中获取的<code>name</code>的值如果是<code>&quot;SECRET&quot;</code>的话，返回<code>SUCCESS</code>,否则返回<code>ERROR</code>。<code>struts.xml</code>配置文件如下：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version = "1.0" Encoding = "UTF-8"?&gt;</span><br><span class="line"><span class="meta">&lt;!DOCTYPE struts PUBLIC</span></span><br><span class="line"><span class="meta">   "-//Apache Software Foundation//DTD Struts Configuration 2.0//EN"</span></span><br><span class="line"><span class="meta">   "http://struts.apache.org/dtds/struts-2.0.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">struts</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">constant</span> <span class="attr">name</span> = <span class="string">"struts.devMode"</span> <span class="attr">value</span> = <span class="string">"true"</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span> = <span class="string">"helloworld"</span> <span class="attr">extends</span> = <span class="string">"struts-default"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span> = <span class="string">"hello"</span> </span></span><br><span class="line"><span class="tag">         <span class="attr">class</span> = <span class="string">"com.rovo98.struts2.HelloWorldAction"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">method</span> = <span class="string">"execute"</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span> = <span class="string">"success"</span>&gt;</span>/HelloWorld.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span> = <span class="string">"error"</span>&gt;</span>/AccessDenied.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">struts</span>&gt;</span></span><br></pre></td></tr></table></figure></div><p>从上面的配置文件看，当用户请求<code>hello</code>action映射的URL时，<code>HelloworldAction</code>的<code>execute()</code>方法将会被执行，返回<code>SUCCESS</code>时，将以<code>HelloWorld.jsp</code>去响应用户的请求，否则以<code>AccessDenied.jsp</code>来响应用户的请求。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;action&lt;/code&gt;是&lt;strong&gt;Struts 2&lt;/strong&gt; 框架的核心，它们适用于任何MVC框架。每个URL都映射到一个具体的&lt;code&gt;action&lt;/code&gt;，&lt;code&gt;action&lt;/code&gt;提供了业务逻辑处理来响应用户发起的请求。&lt;/p&gt;
    
    </summary>
    
      <category term="Java框架学习" scheme="http://rovo98.github.io/categories/Java%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Struts 2" scheme="http://rovo98.github.io/categories/Java%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/Struts-2/"/>
    
    
      <category term="学习笔记" scheme="http://rovo98.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Java框架基础" scheme="http://rovo98.github.io/tags/Java%E6%A1%86%E6%9E%B6%E5%9F%BA%E7%A1%80/"/>
    
      <category term="Struts 2基础学习" scheme="http://rovo98.github.io/tags/Struts-2%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
