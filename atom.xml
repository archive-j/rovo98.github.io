<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>rovo98&#39;s Blog</title>
  
  <subtitle>Leave your comfort zone!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://rovo98.github.io/"/>
  <updated>2018-11-15T10:48:33.060Z</updated>
  <id>http://rovo98.github.io/</id>
  
  <author>
    <name>rovo98</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>GPG入门使用</title>
    <link href="http://rovo98.github.io/posts/7ea77913/"/>
    <id>http://rovo98.github.io/posts/7ea77913/</id>
    <published>2018-11-14T11:08:30.000Z</published>
    <updated>2018-11-15T10:48:33.060Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><blockquote><p>gpg  is the OpenPGP part of the GNU Privacy Guard (GnuPG). It is a tool to provide digital encryption and signing services using the OpenPGP standard.<br>gpg features: complete key management and all the bells and whistles you would expect from a full OpenPGP implementation.</p></blockquote><div class="note info"><p><code>GnuPG</code>(GPG) 是 基于<code>OpenPGP</code>(由<a href="https://www.ietf.org/rfc/rfc4880.txt" target="_blank" rel="noopener">RFC4880</a>定义,也被称为<code>PGP</code>)的一个完整的和免费的实现.我们可以使用<code>GPG</code>来对我们的数据和通信进行加密(encrypt)和签名(sign), 它具有通用的密钥管理系统，以及各种公钥目录的访问模块. 我们可以很容易地使用<code>GPG</code>提供的命令行工具(当前它还提供不同平台下的图形界面工具<em>frontends</em>,以及库文件<em>libraries</em>)与其他的应用进行结合.同时还对<code>S/MIME</code>和<code>SSH(Security Shell)</code>提供支持.</p></div><a id="more"></a><p>本文使用环境为Linux命令行，掌握命令行，Window(<code>Gpg4win</code>)等<a href="https://www.gnupg.org/download/index.html" target="_blank" rel="noopener">其他客户端</a>也很容易掌握。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><code>GPG</code>有两种安装方式。可以<a href="https://www.gnupg.org/download/index.html" target="_blank" rel="noopener">下载源码</a>, 自己编译安装:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure></div><p>更方便的方式是直接安装编译好的二进制包:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Arch 环境</span><br><span class="line">sudo pacman -S gnupg</span><br><span class="line"></span><br><span class="line"># Debian / Ubuntu 环境</span><br><span class="line">sudo apt-get install gnupg</span><br><span class="line"></span><br><span class="line"># Fedora 环境</span><br><span class="line">yum install gnupg</span><br></pre></td></tr></table></figure></div><p>安装完成后，键入下面的命令:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --help</span><br></pre></td></tr></table></figure></div><p>如果屏幕显示GPG的帮助信息，就表示安装成功。<br><img src="gpg-help.png" alt=""></p><h3 id="密钥管理"><a href="#密钥管理" class="headerlink" title="密钥管理"></a>密钥管理</h3><p>在使用<code>GPG</code>进行加密和签名之前，我们应该清楚的知道，它还是一个优秀的密钥管理工具(key Manager).</p><p>可以使用<code>gpg --list-keys</code>查看当前管理的所有密钥.</p><h4 id="生成密钥对"><a href="#生成密钥对" class="headerlink" title="生成密钥对"></a>生成密钥对</h4><p>使用<code>gpg --gen-key</code>或<code>gpg --full-gen-key</code>(设置完整的参数配置来生成密钥对)</p><p>以完整的生成密钥对为例,<code>gpg --full-gen-key</code></p><p>(1).选择加密的算法(默认<code>RSA</code>):<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">gpg (GnuPG) 2.2.11; Copyright (C) 2018 Free Software Foundation, Inc.</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.</span><br><span class="line"></span><br><span class="line">Please select what kind of key you want:</span><br><span class="line">   (1) RSA and RSA (default)</span><br><span class="line">   (2) DSA and Elgamal</span><br><span class="line">   (3) DSA (sign only)</span><br><span class="line">   (4) RSA (sign only)</span><br><span class="line">Your selection?</span><br></pre></td></tr></table></figure></div></p><p>(2).选择密钥的大小(默认2048位):</p><div class="note warning"><p>密钥的位数越大，对于防范暴力破解攻击就越安全,但是对于各种用途，使用默认的大小已经足够了，因为绕过加密比试图破解代价反而更少一些。此外，随着密钥大小的增加，加密和解密将变慢，较大的密钥位数可能会影响签名的长度。</p></div><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RSA keys may be between 1024 and 4096 bits long.</span><br><span class="line">What keysize do you want? (2048)</span><br></pre></td></tr></table></figure></div><p>(3). 配置密钥的失效时间(默认0, 永不失效)</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Please specify how long the key should be valid.</span><br><span class="line">         0 = key does not expire</span><br><span class="line">      &lt;n&gt;  = key expires in n days</span><br><span class="line">      &lt;n&gt;w = key expires in n weeks</span><br><span class="line">      &lt;n&gt;m = key expires in n months</span><br><span class="line">      &lt;n&gt;y = key expires in n years</span><br><span class="line">Key is valid for? (0) </span><br><span class="line">Key does not expire at all</span><br><span class="line">Is this correct? (y/N) y</span><br></pre></td></tr></table></figure></div><p>(4). 配置用户信息</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GnuPG needs to construct a user ID to identify your key.</span><br><span class="line"></span><br><span class="line">Real name: alice</span><br><span class="line">Email address: alice@gmail.com</span><br><span class="line">Comment: A Test case</span><br><span class="line">You selected this USER-ID:</span><br><span class="line">    &quot;alice (A Test case) &lt;alice@gmail.com&gt;&quot;</span><br><span class="line"></span><br><span class="line">Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? </span><br><span class="line"></span><br><span class="line"># 最后确认信息，若需要修改可进行更新，按O确认</span><br></pre></td></tr></table></figure></div><p>(5). 最后输入加密密码，完成密钥对的生成</p><p><img src="gpg-passphrase.png" alt=""></p><p>查看当前的所有密钥对:</p><p><img src="gpg-list-keys.png" alt=""></p><h4 id="密钥的导出和导入"><a href="#密钥的导出和导入" class="headerlink" title="密钥的导出和导入"></a>密钥的导出和导入</h4><p>导入公钥/私钥:</p><p>公钥和私钥的导入都是使用一样的命令<code>gpg --import</code></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#导入公钥</span><br><span class="line">gpg --import rovo98.pub</span><br><span class="line"># 导入私钥</span><br><span class="line">gpg --import rovo98.pri</span><br></pre></td></tr></table></figure></div><p>导入公钥之后，应进行验证。<code>GnuPG</code>提供了功能强大的信任模型，不需要我们亲自验证导入的每一个公钥。但是一些公钥还是需要亲自进行验证的，下面简单了解一下如何对导入的公钥进行验证。</p><div class="note danger"><p>通过验证公钥的指纹，然后签名(Sign)公钥以将其证明为有效公钥来验证密钥。可以使用<code>--fingerprint</code>命令行选项快速查看公钥的指纹，但为了验证公钥，必须对其进行编辑。</p></div><p>编辑公钥示例:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gpg --edit-key blake@cyb.org</span><br><span class="line"></span><br><span class="line">pub  1024D/9E98BC16  created: 1999-06-04 expires: never      trust: -/q</span><br><span class="line">sub  1024g/5C8CBD41  created: 1999-06-04 expires: never     </span><br><span class="line">(1)  Blake (Executioner) &lt;blake@cyb.org&gt;</span><br><span class="line"></span><br><span class="line">Command&gt; fpr</span><br><span class="line">pub  1024D/9E98BC16 1999-06-04 Blake (Executioner) &lt;blake@cyb.org&gt;</span><br><span class="line">             Fingerprint: 268F 448F CCD7 AF34 183E  52D8 9BDE 1A08 9E98 BC16</span><br></pre></td></tr></table></figure></div><blockquote><p>公钥的指纹验证需要通过公钥的所有者进行验证。可以通过电话或任何其他方式亲自完成，只要能够和公钥的真正所有者进行联系就行。<br><strong>如果获得指纹与公钥所有者的指纹相同，才可以确定我们得到是正确的公钥副本</strong></p></blockquote><p>检查指纹之后，最后进行公钥的签名(Sign)完成验证。由于公钥签名是公钥加密中的一个弱点，因此在进行签名验证之前，必须确保指纹验证是正确的。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Command&gt;&gt; sign</span><br><span class="line">             </span><br><span class="line">pub  1024D/9E98BC16  created: 1999-06-04 expires: never      trust: -/q</span><br><span class="line">             Fingerprint: 268F 448F CCD7 AF34 183E  52D8 9BDE 1A08 9E98 BC16</span><br><span class="line"></span><br><span class="line">     Blake (Executioner) &lt;blake@cyb.org&gt;</span><br><span class="line"></span><br><span class="line">Are you really sure that you want to sign this key</span><br><span class="line">with your key: <span class="string">"Alice (Judge) &lt;alice@cyb.org&gt;"</span></span><br><span class="line"></span><br><span class="line">Really sign?</span><br></pre></td></tr></table></figure></div><blockquote><p>签名之后，可以检查公钥，以列出其上面的签名，并查看我们添加的签名。公钥上的每个用户ID都可以具有一个或多个自签名以及已经通过公钥验证的签名。</p></blockquote><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Command&gt; check</span><br><span class="line">uid  Blake (Executioner) &lt;blake@cyb.org&gt;</span><br><span class="line">sig!       9E98BC16 1999-06-04   [self-signature]</span><br><span class="line">sig!       BB7576AC 1999-06-04   Alice (Judge) &lt;alice@cyb.org&gt;</span><br></pre></td></tr></table></figure></div><p><strong>导出公钥(Public key)</strong></p><p>要将公钥发送给对应的用户之前，我们需要将密钥对的公钥导出，在<code>GPG</code>中使用<code>gpg --export</code>命令导出</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --output alice.gpg --<span class="built_in">export</span> alice@gmail.com</span><br></pre></td></tr></table></figure></div><p>默认导出的文件是以<strong>二进制格式</strong>保存的，非常不方便进行传输，因此<code>GPG</code>还提供了<code>--armor</code>参数来指定以<code>ASCII</code>码形式导出。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --armor --output alice.gpg --<span class="built_in">export</span> alice@gmail.com</span><br></pre></td></tr></table></figure></div><p><img src="gpg-export-pub-key.png" alt=""></p><p><strong>导出私钥(Private key)</strong>:</p><p><code>GPG</code>还支持导出私钥，不过是对所有的私钥进行导出，同样可以二进制格式或<code>ASCII</code>格式导出.</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --<span class="built_in">export</span>-secret-keys --armor</span><br></pre></td></tr></table></figure></div><h4 id="上传公钥"><a href="#上传公钥" class="headerlink" title="上传公钥"></a>上传公钥</h4><p>公钥服务器是网络上专门储存用户公钥的服务器。send-keys参数可以将公钥上传到服务器。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --send-keys [用户ID] --keyserver [服务器域名]</span><br></pre></td></tr></table></figure></div><p>使用上面的命令，你的公钥就被传到了服务器，然后通过交换机制，所有的公钥服务器最终都会包含你的公钥。</p><p>由于公钥服务器没有检查机制，任何人都可以用你的名义上传公钥，所以没有办法保证服务器上的公钥的可靠性。通常，你可以在网站上公布一个公钥指纹，让其他人核对下载到的公钥是否为真。fingerprint参数生成公钥指纹。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --fingerprint [用户ID]</span><br></pre></td></tr></table></figure></div><p>从公钥服务器上获取公钥:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --receive-keys</span><br></pre></td></tr></table></figure></div><p>获取到的公钥需要进行验证,参考上面提到的导入公钥的验证方式。</p><h3 id="加密和解密文件"><a href="#加密和解密文件" class="headerlink" title="加密和解密文件"></a>加密和解密文件</h3><p>在加密和解密文件时，公钥和私钥各自具有特定的作用。</p><blockquote><p>公钥可以被认为是开放式保险箱。当通过公钥加密文件时，该文件被放入保险箱，安全关闭，并且组合锁经过多次旋转和组合。<br>相对应的私钥是可以重新打开保险箱并检索文件的组合(组合锁组合)。换句话说，之后持有私钥的人才能恢复和使用相关公钥加密文件。</p></blockquote><div class="note info"><p>因此加解密过程应该是这样的，假设你要给<code>alice</code>发送加密信息，使用<code>alice</code>的公钥对信息进行加密，则<code>alice</code>可以使用她的私钥对加密信息进行解密，而当她向你发送加密信息，加密信息时使用的应该是你的公钥。</p></div><p>加密例子: 使用<code>alice</code>的公钥对<code>sourceListforKali</code>进行加密</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --output sourceListforKali.en --encrypt sourceListforKali --recipient alice@gmail.com</span><br></pre></td></tr></table></figure></div><p><code>--recipient</code>指定使用的公钥</p><p>解密:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --output sourceListforKali.de --decrypt sourceListforKali.en</span><br></pre></td></tr></table></figure></div><p>输入之前创建该密钥对的密码就可以对文件进行解密。</p><p><img src="gpg-encrypt-decrypt.png" alt=""></p><div class="note warning"><p>我们还可以在不使用公钥的情况下，对文件进行加密，使用的是对称密码(symmetric chiper).使用<code>--symmetric</code>参数即可</p><p>手动输入加密密码即可。</p></div><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --output sourceListforKali.gpg --symmetric sourceListforKali</span><br></pre></td></tr></table></figure></div><h3 id="签名-signatures"><a href="#签名-signatures" class="headerlink" title="签名(signatures)"></a>签名(signatures)</h3><p>数字签名证明文档并为其加上时间戳。如果随后以任何方式修改了文档，则签名验证将失败。数字签名可以起到与手写签名相同的作用，并具有防篡改的额外好处。</p><p>例如：当你将文件签名并发布后，则接受到该文件的用户可以验证签名来查看文件是否被修改过。</p><h4 id="创建和验证签名"><a href="#创建和验证签名" class="headerlink" title="创建和验证签名"></a>创建和验证签名</h4><p>创建和验证签名使用公/私钥对的方式不同于加解密操作。使用签名者的私钥创建签名，使用相应的公钥验证签名。</p><p>使用数字签名的好处是一般情况下，签名人是确定的，除非签名者的私钥被泄露了。</p><p>使用<code>--sign</code>参数创建数字签名，例:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gpg --output doc.sig --sign doc</span><br><span class="line">You need a passphrase to unlock the private key <span class="keyword">for</span></span><br><span class="line">user: <span class="string">"Alice (Judge) &lt;alice@cyb.org&gt;"</span></span><br><span class="line">1024-bit DSA key, ID BB7576AC, created 1999-06-04</span><br><span class="line"></span><br><span class="line">Enter passphrase:</span><br></pre></td></tr></table></figure></div><p>签名的文件在签名之前会被进行压缩处理，并输出一个二进制格式的签名文件。根据给定的签名文件，可以检查签名或检查签名并恢复原始文件。</p><p>检查和验证签名使用<code>--verify</code>参数选项,验证签名并恢复原始文件使用<code>--decrypt</code>选项:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gpg --output doc --decrypt doc.sig</span><br><span class="line">gpg: Signature made Fri Jun  4 12:02:38 1999 CDT using DSA key ID BB7576AC</span><br><span class="line">gpg: Good signature from <span class="string">"Alice (Judge) &lt;alice@cyb.org&gt;"</span></span><br></pre></td></tr></table></figure></div><div class="note danger"><p>一般情况下，数字签名多数应用于对互联网上的帖子<em>post</em>以及<em>email</em>进行签名。这种情况下，我们一般不希望对需要签名的文件进行压缩处理，因此可以使用<code>--clearsign</code>选项，在不修改文件的情况下，将文件以<code>ASCII</code>的形式包装在签名文件中。</p></div><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">gpg --clearsign doc</span><br><span class="line"></span><br><span class="line">You need a passphrase to unlock the secret key <span class="keyword">for</span></span><br><span class="line">user: <span class="string">"Alice (Judge) &lt;alice@cyb.org&gt;"</span></span><br><span class="line">1024-bit DSA key, ID BB7576AC, created 1999-06-04</span><br><span class="line"></span><br><span class="line">-----BEGIN PGP SIGNED MESSAGE-----</span><br><span class="line">Hash: SHA1</span><br><span class="line"></span><br><span class="line">[...]</span><br><span class="line">-----BEGIN PGP SIGNATURE-----</span><br><span class="line">Version: GnuPG v0.9.7 (GNU/Linux)</span><br><span class="line">Comment: For info see http://www.gnupg.org</span><br><span class="line"></span><br><span class="line">iEYEARECAAYFAjdYCQoACgkQJ9S6ULt1dqz6IwCfQ7wP6i/i8HhbcOSKF4ELyQB1</span><br><span class="line">oCoAoOuqpRqEzr4kOkQqHRLE/b8/Rw2k</span><br><span class="line">=y6kj</span><br><span class="line">-----END PGP SIGNATURE-----</span><br></pre></td></tr></table></figure></div><div class="note primary"><p>分离的、独立的签名文件(<em>Detached signatures</em>): 一个签名过的文件的用途一般是很少的。</p><p>其他用户必须从签名文件中恢复原始文档，即使使用未压缩处理的签名文件(Clearsigned)，也必须编辑签名文档以恢复原始文档。</p><p>因此，<code>GPG</code>还提供用于对文档创建分离签名第三种签名方法，该签名是单独的文件。使用<code>--detach-sig</code>选项创建分离签名。</p></div><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gpg --output doc.sig --detach-sig doc</span><br><span class="line"></span><br><span class="line">You need a passphrase to unlock the secret key <span class="keyword">for</span></span><br><span class="line">user: <span class="string">"Alice (Judge) &lt;alice@cyb.org&gt;"</span></span><br><span class="line">1024-bit DSA key, ID BB7576AC, created 1999-06-04</span><br><span class="line"></span><br><span class="line">Enter passphrase:</span><br></pre></td></tr></table></figure></div><p>通过此方法创建的签名，在验证时就需要同时使用签名和对应原文件:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gpg --verify doc.sig doc</span><br><span class="line"></span><br><span class="line">gpg: Signature made Fri Jun  4 12:38:46 1999 CDT using DSA key ID BB7576AC</span><br><span class="line">gpg: Good signature from <span class="string">"Alice (Judge) &lt;alice@cyb.org&gt;"</span></span><br></pre></td></tr></table></figure></div><h3 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h3><p>以上就是<code>GnuPG</code>的简单入门使用，更多的可以详细阅读<code>GnuPG</code>提供的<a href="https://www.gnupg.org/documentation/index.html" target="_blank" rel="noopener">用户手册和文档</a>.</p><p>例如: 我们可以在加密文件的同时对文件进行签名(使用三种签名方法的其中一种)</p><div class="note primary"><p>参看链接:</p><ul><li><a href="https://www.gnupg.org/gph/en/manual.html" target="_blank" rel="noopener">https://www.gnupg.org/gph/en/manual.html</a></li><li><a href="https://futureboy.us/pgp.html" target="_blank" rel="noopener">https://futureboy.us/pgp.html</a></li></ul></div>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;引入&quot;&gt;&lt;a href=&quot;#引入&quot; class=&quot;headerlink&quot; title=&quot;引入&quot;&gt;&lt;/a&gt;引入&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;gpg  is the OpenPGP part of the GNU Privacy Guard (GnuPG). It is a tool to provide digital encryption and signing services using the OpenPGP standard.&lt;br&gt;gpg features: complete key management and all the bells and whistles you would expect from a full OpenPGP implementation.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;&lt;code&gt;GnuPG&lt;/code&gt;(GPG) 是 基于&lt;code&gt;OpenPGP&lt;/code&gt;(由&lt;a href=&quot;https://www.ietf.org/rfc/rfc4880.txt&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;RFC4880&lt;/a&gt;定义,也被称为&lt;code&gt;PGP&lt;/code&gt;)的一个完整的和免费的实现.我们可以使用&lt;code&gt;GPG&lt;/code&gt;来对我们的数据和通信进行加密(encrypt)和签名(sign), 它具有通用的密钥管理系统，以及各种公钥目录的访问模块. 我们可以很容易地使用&lt;code&gt;GPG&lt;/code&gt;提供的命令行工具(当前它还提供不同平台下的图形界面工具&lt;em&gt;frontends&lt;/em&gt;,以及库文件&lt;em&gt;libraries&lt;/em&gt;)与其他的应用进行结合.同时还对&lt;code&gt;S/MIME&lt;/code&gt;和&lt;code&gt;SSH(Security Shell)&lt;/code&gt;提供支持.&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://rovo98.github.io/categories/Linux/"/>
    
      <category term="softwares" scheme="http://rovo98.github.io/categories/Linux/softwares/"/>
    
    
      <category term="linux" scheme="http://rovo98.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>记录一次linux系统迁移过程</title>
    <link href="http://rovo98.github.io/posts/3babee60/"/>
    <id>http://rovo98.github.io/posts/3babee60/</id>
    <published>2018-10-07T06:00:00.000Z</published>
    <updated>2018-11-14T15:21:00.995Z</updated>
    
    <content type="html"><![CDATA[<p>就在最近，终于为自己的电脑加装了固态。在装完固态之后，首先面临的问题就是如何将原先安装在机械硬盘上的<code>linux</code>系统迁移到固态上。还要考虑后续配置的问题。</p><p>本文主要讲述在迁移<code>Linux</code>系统到新的固态硬盘上所遇到的问题以及找到的相应的解决方法。</p><p>这里先给出系统迁移以及相关配置完成之后的机械硬盘和固态硬盘的简单测速对比:</p><p><img src="/images/linux/hdparam.png" alt=""></p><a id="more"></a><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><div class="note info"><p>拆开电脑，直接加装固态,顺便清清灰尘，换一下硅脂(ps: 这不知道是我第几次拆电脑了…,表示以后再也不买GPU风扇了，这已经是第二次失败的购买经历了(<code>除非得到与原来匹配的风扇一致的风扇，不然我是不再换了</code>).</p></div><p>清尘换硅脂:</p><p><img src="install_ssd01.jpg" alt="install-ssd-01"><br>加装固态和散热板:</p><p><img src="install_ssd02.jpg" alt="install-ssd-01"></p><div class="note primary"><p>关于固态如何购买挑选，需要很好的了解自己电脑能够支持的固态类型和市场所提供的固态类型，并综合各种因素才能做出最好的选择。这里我推荐几篇个人觉得不错的文章:</p><ul><li><a href="https://www.laptopmag.com/articles/laptop-ssd-guide" target="_blank" rel="noopener">https://www.laptopmag.com/articles/laptop-ssd-guide</a></li><li><a href="https://www.tomshardware.com/reviews/ssd-buying-guide,5602.html" target="_blank" rel="noopener">https://www.tomshardware.com/reviews/ssd-buying-guide,5602.html</a></li><li><a href="https://www.velocitymicro.com/blog/nvme-vs-m-2-vs-sata-whats-the-difference/" target="_blank" rel="noopener">https://www.velocitymicro.com/blog/nvme-vs-m-2-vs-sata-whats-the-difference/</a></li><li><a href="https://blog.csdn.net/u010109732/article/details/79032845" target="_blank" rel="noopener">https://blog.csdn.net/u010109732/article/details/79032845</a></li><li><a href="https://www.zhihu.com/question/48972075" target="_blank" rel="noopener">https://www.zhihu.com/question/48972075</a></li><li><a href="https://www.pc841.com/article/20180914-92342_all.html" target="_blank" rel="noopener">https://www.pc841.com/article/20180914-92342_all.html</a></li><li><a href="https://www.techadvisor.co.uk/test-centre/storage/best-ssd-2018-3235200/" target="_blank" rel="noopener">https://www.techadvisor.co.uk/test-centre/storage/best-ssd-2018-3235200/</a></li></ul><p>以上推荐文章仅作为参考。</p></div><h3 id="迁移系统"><a href="#迁移系统" class="headerlink" title="迁移系统"></a>迁移系统</h3><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>进入原先的<code>linux</code>系统，对已经安装上的固态硬盘进行分区。因为我之前在没有固态之前，在机械硬盘上就已经安装了三个系统(<code>win10</code>, <code>manjaro</code>, <code>kali</code>),因此在分区时，我是考虑只把两个<code>linux</code>迁移到固态上，毕竟<code>win10</code>现在已经基本不使用了，并将机械硬盘上的<code>EFI</code>分区也迁移到固态上。分区这里，可以按照自己的需求对固态硬盘进行分区。</p><p>分区工具的选择，随意，哪个顺手用哪个，例如:<code>gparted</code>, <code>fdisk</code>, <code>parted</code>,还有各种桌面自带的分区工具。我是使用的是<code>fdisk</code>:<br>例如:<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo fdisk /dev/nvme0n1</span><br></pre></td></tr></table></figure></div></p><p><img src="fdisk_parted.png" alt="diskparted"></p><p>这里我已经分好区了的，具体的操作在<code>fdisk</code>中进行:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Generic</span><br><span class="line">   d   delete a partition</span><br><span class="line">   F   list free unpartitioned space</span><br><span class="line">   l   list known partition types</span><br><span class="line">   n   add a new partition</span><br><span class="line">   p   print the partition table</span><br><span class="line">   t   change a partition type</span><br><span class="line">   v   verify the partition table</span><br><span class="line">   i   print information about a partition</span><br><span class="line"></span><br><span class="line">  Misc</span><br><span class="line">   m   print this menu</span><br><span class="line">   x   extra functionality (experts only)</span><br><span class="line"></span><br><span class="line">  Script</span><br><span class="line">   I   load disk layout from sfdisk script file</span><br><span class="line">   O   dump disk layout to sfdisk script file</span><br><span class="line"></span><br><span class="line">  Save &amp; Exit</span><br><span class="line">   w   write table to disk and exit</span><br><span class="line">   q   quit without saving changes</span><br><span class="line"></span><br><span class="line">  Create a new label</span><br><span class="line">   g   create a new empty GPT partition table</span><br><span class="line">   G   create a new empty SGI (IRIX) partition table</span><br><span class="line">   o   create a new empty DOS partition table</span><br><span class="line">   s   create a new empty Sun partition table</span><br></pre></td></tr></table></figure></div><p>例如创建<code>EFI</code>分区:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Command (m for help): n</span><br><span class="line">Partition number (2-128, default 2): 2 # 创建一个分区作为EFI分区</span><br><span class="line">First sector (xxxxx-xxxxxxxxxxx, default xxxxx): </span><br><span class="line">Last sector, +sectors or +size&#123;K,M,G,T,P&#125; (34-2047, default xxxxxxx): +200M</span><br><span class="line">Created a new partition 2 of type &apos;Linux filesystem&apos; and of size 200 Mb.</span><br><span class="line">Command (m for help): t  # 修改EFI分区的分区类型为EFI系统分区</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"># 最后保存设置</span><br><span class="line">Command (m for help): w</span><br></pre></td></tr></table></figure></div><div class="note danger"><p>请注意先查看所执行的分区操作是不是你想要的再进行最后的保存设置</p></div><p>其他的分区创建类似<code>EFI</code>的创建，<code>swap</code>分区需要指定为<code>Linux swap</code>分区，作为<code>linux</code>数据分区的分区在创建时默认就是<code>linux filesystem</code>类型了，不需要更改，之后对创建的分区进行格式化:将<code>EFI</code>格式化为<code>fat32</code>，将<code>linux</code>数据分区格式化<code>ext4</code>； 先通过<code>sudo fdisk -l</code>或<code>lsblk</code>查看已经创建分区对应的设备名,例如:<br><code>sudo fdisk -l</code>:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Disk /dev/nvme0n1: 238.5 GiB, 256060514304 bytes, 500118192 sectors</span><br><span class="line">Units: sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disklabel type: gpt</span><br><span class="line">Disk identifier: 6D071E80-FF82-420B-A2D8-7A0BC4759F06</span><br><span class="line"></span><br><span class="line">Device             Start       End   Sectors  Size Type</span><br><span class="line">/dev/nvme0n1p1        34    262177    262144  128M Microsoft reserved</span><br><span class="line">/dev/nvme0n1p2    264192    673791    409600  200M EFI System</span><br><span class="line">/dev/nvme0n1p3    673792   9062399   8388608    4G Linux swap</span><br><span class="line">/dev/nvme0n1p4   9062400 428492799 419430400  200G Linux filesystem</span><br><span class="line">/dev/nvme0n1p5 428492800 500117503  71624704 34.2G Linux filesystem</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disk /dev/sda: 931.5 GiB, 1000204886016 bytes, 1953525168 sectors</span><br><span class="line">Units: sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 4096 bytes</span><br><span class="line">I/O size (minimum/optimal): 4096 bytes / 4096 bytes</span><br><span class="line">Disklabel type: gpt</span><br><span class="line">Disk identifier: D5CB68A7-96DA-4C61-84E2-61C98489BFF1</span><br><span class="line"></span><br><span class="line">Device          Start        End   Sectors   Size Type</span><br><span class="line">/dev/sda1          64  125829183 125829120    60G Microsoft basic data</span><br><span class="line">/dev/sda2   125829184  880802416 754973233   360G Microsoft basic data</span><br><span class="line">/dev/sda3   880803904 1596575151 715771248 341.3G Microsoft basic data</span><br><span class="line">/dev/sda4  1596575744 1953521663 356945920 170.2G Microsoft basic data</span><br></pre></td></tr></table></figure></div><p><code>lsblk</code> 查看分好的磁盘分区:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">NAME        MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sda           8:0    0 931.5G  0 disk </span><br><span class="line">├─sda1        8:1    0    60G  0 part /run/media/rovo98/System</span><br><span class="line">├─sda2        8:2    0   360G  0 part /run/media/rovo98/Mshinoda</span><br><span class="line">├─sda3        8:3    0 341.3G  0 part /run/media/rovo98/Chester bennington</span><br><span class="line">└─sda4        8:4    0 170.2G  0 part /run/media/rovo98/LSR</span><br><span class="line">sr0          11:0    1  1024M  0 rom  </span><br><span class="line">nvme0n1     259:0    0 238.5G  0 disk </span><br><span class="line">├─nvme0n1p1 259:1    0   128M  0 part </span><br><span class="line">├─nvme0n1p2 259:2    0   200M  0 part /boot/efi</span><br><span class="line">├─nvme0n1p3 259:3    0     4G  0 part [SWAP]</span><br><span class="line">├─nvme0n1p4 259:4    0   200G  0 part /</span><br><span class="line">└─nvme0n1p5 259:5    0  34.2G  0 part /run/media/rovo98/a002d542-c8c4-4c98-85af-8a4446dbaa1b</span><br></pre></td></tr></table></figure></div><p>对特定的分区进行格式化,例如:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 对于linux数据分区</span><br><span class="line">mkfs.ext4 /dev/nvme0n1p4</span><br><span class="line">mkfs.ext4 /dev/nvme0n1p5</span><br><span class="line"># EFI分区</span><br><span class="line">mkfs.fat /dev/nvme0n1p2</span><br></pre></td></tr></table></figure></div><div class="note danger"><p><strong>注意</strong>: 执行每条格式化命令前，必须确认指定的分区是否是你想要格式化的分区</p></div><p>做好这些准备之后，就可以进行系统的迁移了</p><h4 id="系统迁移操作"><a href="#系统迁移操作" class="headerlink" title="系统迁移操作"></a>系统迁移操作</h4><p>对于<code>Linux</code>系统，我们只需要知道<strong>Linux一切皆文件</strong>就行了。因此对于系统的迁移就变得简单了，可以使用<code>dd</code>,打包压缩然后解压缩，有关系统备份和恢复可以参看<code>Arch wiki</code>给出的:<a href="https://wiki.archlinux.org/index.php/System_backup" target="_blank" rel="noopener">https://wiki.archlinux.org/index.php/System_backup</a>.这里我是使用的是<code>tar</code>结合<code>pigz</code>(<a href="http://www.ywnds.com/?p=10332" target="_blank" rel="noopener">什么是pigz?</a>)解压缩工具进行备份和恢复:</p><p>备份(打包压缩)<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tar --use-compress-program=pigz -cvpf /run/media/rovo98/Chester\ bennington/LP/GHOST/manjaro_backup_2018.10.7.tgz --exclude=/proc --exclude=/sys --exclude=/mnt --exclude=/run/media --exclude=/lost+found /</span><br></pre></td></tr></table></figure></div></p><p>恢复到目标硬盘分区上(解包解压缩):<br>先目标分区挂载到<code>/mnt</code>下，如:<code>/mnt/manjaro</code></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount /dev/nvme0n1p4 /mnt/manjaro</span><br></pre></td></tr></table></figure></div><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tar --use-compress-program=pigz -xvpf /run/media/rovo98/Chester\ bennington/LP/GHOST/manjaro_backup_2018.10.7.tgz -C /mnt/manjaro</span><br></pre></td></tr></table></figure></div><p>完成后需要手动创建，上面打包压缩是排除的文件夹:<code>/proc</code>, <code>/sys</code>, <code>/mnt</code>, <code>/run</code>, <code>/lost+found</code>.</p><div class="note primary"><p>详细备份和恢复过程可以参考查看:<a href="https://www.jianshu.com/p/b03a51c682a5" target="_blank" rel="noopener">Arch上的备份还原</a></p></div><h4 id="修复Grub、fstab文件以及refind引导管理"><a href="#修复Grub、fstab文件以及refind引导管理" class="headerlink" title="修复Grub、fstab文件以及refind引导管理"></a>修复Grub、fstab文件以及refind引导管理</h4><p>首先将<code>/proc</code>,<code>/run</code>,<code>/dev</code>,<code>/sys</code>重新挂载，让目标分区上的系统也拥有这些内容:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mount /proc /mnt/manjaro/proc</span><br><span class="line">mount /sys /mnt/manjaro/sys</span><br><span class="line">mount /run /mnt/manjaro/run</span><br><span class="line">mount /dev /mnt/manjaro/dev</span><br></pre></td></tr></table></figure></div><div class="note warning"><p>这些目录必须重新挂载，不然，当<code>chroot</code>切换进入目标系统之后，将无法获取一些系统信息，如：设备, 磁盘分区信息等. </p></div><p><img src="mount-bind.png" alt=""></p><p>在<code>chroot</code>到目标系统之前，需要挂载<code>EFI</code>分区到<code>/mnt/manjaro/boot/efi</code>（refind管理文件默认位置）下：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount /dev/nvme0n1p2 /mnt/manjaro/boot/efi</span><br></pre></td></tr></table></figure></div><p><img src="efi_root.png" alt=""></p><p><code>chroot</code>到目标系统中，进行之后的操作</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chroot /mnt/manjaro</span><br></pre></td></tr></table></figure></div><h4 id="更新fstab文件"><a href="#更新fstab文件" class="headerlink" title="更新fstab文件"></a>更新fstab文件</h4><p>获取相应分区的<code>UUID</code>，以更新<code>fstab</code>文件和<code>/etc/default/grub</code>文件:<br><code>blkid</code>:</p><p><img src="blkid.png" alt=""></p><p>或</p><p><code>ls -l /dev/disk/by-uuid</code>:</p><p><img src="byuuid.png" alt=""></p><p>更新<code>fstab</code>文件:</p><p><img src="updated-fstab.png" alt=""></p><div class="note primary"><p>主要修改挂载项以及对应的<code>UUID</code>，有关<code>fstab</code>文件的详细内容可以参考<a href="https://wiki.archlinux.org/index.php/Fstab" target="_blank" rel="noopener">https://wiki.archlinux.org/index.php/Fstab</a></p></div><h4 id="修复Grub"><a href="#修复Grub" class="headerlink" title="修复Grub"></a>修复Grub</h4><ol><li><p>重新生成Grub</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo grub-install --target=x86_64-efi --efi-directory=/boot/efi --bootloader=Manjaro --recheck</span><br></pre></td></tr></table></figure></div></li><li><p>更新Grub配置文件</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo update-grub</span><br><span class="line">或</span><br><span class="line">sudo grub-mkconfig -o /boot/grub/grub.cfg</span><br></pre></td></tr></table></figure></div></li></ol><div class="note warning"><p><strong>注意</strong>：如果此过程中出现以下提示信息:</p><p><code>EFI variables are not supported on this system.</code></p><p>需要先安装<code>efibootmgr</code>, <code>dosfstools</code>以及<code>grub</code>包，然后重新尝试重新生成<code>Grub</code>并更新其配置文件.</p></div><p>若仍出现该信息，则先退出<code>chroot</code>环境，并加载<code>efivarfs</code>模块:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo modprobe efivarfs</span><br></pre></td></tr></table></figure></div><p>然后再进入<code>chroot</code>环境，执行:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -t efivarfs efivarfs /sys/firmware/efi/efivars</span><br></pre></td></tr></table></figure></div><p>再重新生成<code>Grub</code>并更新<code>Grub</code>配置文件就好了。</p><div class="note primary"><p>参考链接:<a href="https://wiki.manjaro.org/index.php/Restore_the_GRUB_Bootloader" target="_blank" rel="noopener">https://wiki.manjaro.org/index.php/Restore_the_GRUB_Bootloader</a></p></div><h4 id="重新配置refind"><a href="#重新配置refind" class="headerlink" title="重新配置refind"></a>重新配置refind</h4><p>对之前的<code>refind</code>配置文件进行备份，保留主题文件<code>themes</code>及<code>refind.conf</code>就好了，其余的文件在执行<code>refind-install</code>时会自动生成.</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 已经生成过了的,打印信息如下</span><br><span class="line">ShimSource is none</span><br><span class="line">Installing rEFInd on Linux....</span><br><span class="line">ESP was found at /boot/efi using vfat</span><br><span class="line">Found rEFInd installation in /boot/efi/EFI/refind; upgrading it.</span><br><span class="line">Installing driver for ext4 (ext4_x64.efi)</span><br><span class="line">Copied rEFInd binary files</span><br><span class="line"></span><br><span class="line">Notice: Backed up existing icons directory as icons-backup.</span><br><span class="line">Existing refind.conf file found; copying sample file as refind.conf-sample</span><br><span class="line">to avoid overwriting your customizations.</span><br><span class="line"></span><br><span class="line">Keeping existing NVRAM entry</span><br><span class="line">rEFInd is set as the default boot manager.</span><br><span class="line">Existing //boot/refind_linux.conf found; not overwriting.</span><br></pre></td></tr></table></figure></div><p><img src="refind.png" alt=""></p><p>可以使用<code>efibootmgr</code>管理启动项，例如:<br><code>efibootmgr</code>查看当前所有的启动项，<code>efibootmgr -Bb xxxx</code>来删除不要的启动项，详细使用可以<code>man efibootmgr</code>来查看。</p><p><img src="efibootmgr.png" alt=""></p><p>其中的<code>windows</code>系统启动项通过<code>PE</code>用<code>UEFI</code>引导修复生成即可(需要注意的是老旧的PE识别不了<code>nvme</code>固态)。</p><p>以上就是迁移Linux系统的完整过程了</p><h4 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h4><p>在做完上面的所有操作，并将之前机械硬盘上的<code>EFI</code>分区等等(除<code>Win10</code>系统之外)都删除之后，重新启动进入固态盘上的系统，在<code>Grub</code>引导过程出现<code>UUID=***************</code>找不到的信息，经过查看之后发现，在<code>Grub</code>引导时居然没有挂载我那块<code>nvme</code>固态。</p><p>通过了解发现<code>Grub2.2</code>版本并不支持<code>nvme</code>的固态，可以使用安装<code>bootloader</code>来进行引导。PS: 但我<code>Manjaro</code>安装的<code>Grub</code>是<code>2.3</code>版本的，理论上是支持的。</p><div class="note primary"><p>参考链接: <a href="https://bbs.archlinux.org/viewtopic.php?id=209653" target="_blank" rel="noopener">https://bbs.archlinux.org/viewtopic.php?id=209653</a></p></div><p>通过一番查找之后，终于找到了解决方法:</p><ol><li><p>添加加载模块 <code>sudo vim /etc/mkinitcpio.conf</code></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="DIFF"><figure class="iseeu highlight /diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="deletion">- MODULES = ""</span></span><br><span class="line"><span class="addition">+ MODULES="nvme"</span></span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure></div></li><li><p>更新<code>mkinitcpio</code></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#参数说明，详细可以通过man查看</span><br><span class="line">-p, --preset preset</span><br><span class="line">Build initramfs image(s) according to specified preset. This may be a file in /etc/mkinitcpio.d (without the .preset extension) or a full, absolute path to a file. This option may be specified multiple times to process multiple presets.</span><br></pre></td></tr></table></figure></div></li><li><p>更新Grub</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo update-grub</span><br><span class="line">或</span><br><span class="line">sudo grub-mkocnfig -o /boot/grub/grub.cfg</span><br></pre></td></tr></table></figure></div></li></ol><p>再次重启之后，便可以成功进入系统了。</p><div class="note primary"><p>参考链接:<a href="http://blog.51cto.com/shenfly231/1918426" target="_blank" rel="noopener">http://blog.51cto.com/shenfly231/1918426</a>, 若要安装<code>bootloader</code>也可以参考该链接。</p></div><h3 id="SSD优化"><a href="#SSD优化" class="headerlink" title="SSD优化"></a>SSD优化</h3><h4 id="开启Trim功能"><a href="#开启Trim功能" class="headerlink" title="开启Trim功能"></a>开启Trim功能</h4><p>关于什么是<code>TRIM</code>?：</p><blockquote><p>SSD TRIM is an Advanced Technology Attachment (ATA) command that enables an operating system to inform a NAND flash solid-state drive (SSD) which data blocks it can erase because they are no longer in use. The use of TRIM can improve the performance of writing data to SSDs and contribute to longer SSD life.</p></blockquote><div class="note primary"><p>了解可以参考: <a href="https://searchstorage.techtarget.com/definition/TRIM" target="_blank" rel="noopener">https://searchstorage.techtarget.com/definition/TRIM</a>，以及<code>Arch wiki</code>上的:<br><a href="https://wiki.archlinux.org/index.php/Solid_state_drive#TRIM" target="_blank" rel="noopener">https://wiki.archlinux.org/index.php/Solid_state_drive#TRIM</a></p></div><blockquote><p>Most SSDs support the <strong>ATA_TRIM command</strong> for <strong>sustained long-term performance and wear-leveling</strong>. A techspot article shows performance benchmark examples of before and after filling an SSD with data.</p><p>As of Linux kernel version 3.8 onwards, support for TRIM was continually added for the different filesystems. See the following table for an indicative overview:</p></blockquote><p><img src="trim-supported.png" alt=""></p><p>在使用<code>Trim</code>功能之前需要查看固态硬盘是否支持，否则可能造成数据丢失:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsblk --discard</span><br></pre></td></tr></table></figure></div><p><img src="lsblk-discard.png" alt=""></p><p><code>DISC-GRAN</code>和<code>DISC-MAX</code>不为<code>0</code>则表示支持，详细查看上面的<code>Arch Wiki</code>给出的文章。</p><p>关于使用的<code>Trim</code>方式，我使用的<code>Continuous TRIM</code>(详见<code>Arch Wiki</code>)<br>即在<code>/etc/fstab</code>文件的挂载项中添加参数<code>discard</code><br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="DIFF"><figure class="iseeu highlight /diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">- UUID=D942-EEB0                            /boot/efi      vfat    defaults,noatime 0 2</span></span><br><span class="line"><span class="deletion">- UUID=67180790-92d0-48d3-8f00-448161019f2d swap           swap    defaults,noatime 0 2</span></span><br><span class="line"><span class="deletion">- UUID=e2708091-5a07-47a6-bc26-5fdaa044c5f3 /              ext4    defaults,noatime 0 1</span></span><br><span class="line"><span class="addition">+ UUID=D942-EEB0                            /boot/efi      vfat    defaults,discard,noatime 0 2</span></span><br><span class="line"><span class="addition">+ UUID=67180790-92d0-48d3-8f00-448161019f2d swap           swap    defaults,discard,noatime 0 2</span></span><br><span class="line"><span class="addition">+ UUID=e2708091-5a07-47a6-bc26-5fdaa044c5f3 /              ext4    defaults,discard,noatime 0 1</span></span><br></pre></td></tr></table></figure></div></p><h4 id="IO调度器选择"><a href="#IO调度器选择" class="headerlink" title="IO调度器选择"></a>IO调度器选择</h4><p>一般来说，IO调度算法是为低速硬盘准备的，对于固态，最好是不使用任何IO调度器，或使用对硬盘干预程度最低的调度算法。</p><ol><li>查看当前固态的IO调度器:<br><img src="io-schedulers.png" alt=""><br>可以看到我当前固态没有使用任何调度器，而机械硬盘使用的是<code>bfq-sq</code>.</li><li><p>修改IO调度器(临时的):</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo noop &gt; /sys/block/sda/queue/scheduler</span><br></pre></td></tr></table></figure></div></li><li><p>要永久生效则需要添加编写开机自启动脚本<br>详见参考链接.</p></li></ol><div class="note primary"><p>更多信息以及详细的内容可以参考下面给出的参考链接.<br>参考链接:</p><ul><li><a href="https://wiki.archlinux.org/index.php/Improving_performance#Storage_devices" target="_blank" rel="noopener">https://wiki.archlinux.org/index.php/Improving_performance#Storage_devices</a></li><li><a href="https://blog.codeship.com/linux-io-scheduler-tuning/" target="_blank" rel="noopener">https://blog.codeship.com/linux-io-scheduler-tuning/</a></li><li><a href="https://www.ibm.com/developerworks/cn/linux/l-lo-io-scheduler-optimize-performance/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/linux/l-lo-io-scheduler-optimize-performance/index.html</a></li></ul></div><h4 id="另外"><a href="#另外" class="headerlink" title="另外"></a>另外</h4><div class="note primary"><p>更多有关<code>Linux VM</code>性能调优的可以参考:<br><a href="https://lonesysadmin.net/tag/linux-vm-performance-tuning/" target="_blank" rel="noopener">https://lonesysadmin.net/tag/linux-vm-performance-tuning/</a></p></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;就在最近，终于为自己的电脑加装了固态。在装完固态之后，首先面临的问题就是如何将原先安装在机械硬盘上的&lt;code&gt;linux&lt;/code&gt;系统迁移到固态上。还要考虑后续配置的问题。&lt;/p&gt;
&lt;p&gt;本文主要讲述在迁移&lt;code&gt;Linux&lt;/code&gt;系统到新的固态硬盘上所遇到的问题以及找到的相应的解决方法。&lt;/p&gt;
&lt;p&gt;这里先给出系统迁移以及相关配置完成之后的机械硬盘和固态硬盘的简单测速对比:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/linux/hdparam.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://rovo98.github.io/categories/Linux/"/>
    
    
      <category term="ssd" scheme="http://rovo98.github.io/tags/ssd/"/>
    
  </entry>
  
  <entry>
    <title>编译自己的Vim8.1</title>
    <link href="http://rovo98.github.io/posts/97c4fd12/"/>
    <id>http://rovo98.github.io/posts/97c4fd12/</id>
    <published>2018-08-27T12:12:13.000Z</published>
    <updated>2018-10-31T08:49:27.251Z</updated>
    
    <content type="html"><![CDATA[<p>最近换了<code>Manjaro</code> linux系统，发现通过系统<code>pacman -S vim</code>安装的无图形版本<code>vim</code>不支持<code>clipboard</code>功能。</p><p><img src="/images/linux/vim-version-original.png" alt=""></p><p>本想看能不能通过某种方式，来扩展现有安装好的<code>vim</code>,但是通过<code>google</code>了解到：<br><blockquote class="blockquote-center"><p>VIM is intended to be a portable editor that “just works” on all systems. By having the default version use the clipboard functionality, it will need to link against X11 libraries, and a separate version of VIM would need to be compiled for desktop versus server (no pre-installed X11/xorg) builds. This is why the vim and vim-gtk packages are provided.</p><p>VIM旨在成为一个可在所有系统上“正常工作”的便携式编辑器。通过使默认版本使用剪贴板功能，它将需要链接到X11库，并且需要针对桌面与服务器（没有预安装的X11 / xorg）构建编译单独版本的VIM。这就是提供vim和vim-gtk软件包的原因。</p></blockquote></p><a id="more"></a><p>虽然知道<code>gvim</code>带有支持<code>clipboard</code>的<code>vim</code>，但是我又不想装<code>gvim</code>。自己的系统又有<code>X11</code>库和 <code>Xorg</code>，所以决定自己编译一个<code>vim</code>.</p><div class="note warning"><p><strong>注意</strong>： 对于没有<code>X11</code>和<code>Xorg</code>的需要在编译前配置好，否则编译会出错.</p></div><h3 id="一、从github上获取vim的源码"><a href="#一、从github上获取vim的源码" class="headerlink" title="一、从github上获取vim的源码"></a>一、从github上获取vim的源码</h3><p>直接使用<code>git</code> clone <code>vim</code>仓库：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/vim/vim.git vim_source</span><br></pre></td></tr></table></figure></div><h3 id="二、配置、编译并安装"><a href="#二、配置、编译并安装" class="headerlink" title="二、配置、编译并安装"></a>二、配置、编译并安装</h3><p>我的编译配置：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">make clean</span><br><span class="line">./configure \</span><br><span class="line">    --enable-cscope \ </span><br><span class="line">    --enable-largefile \ </span><br><span class="line">    --enable-multibyte \ </span><br><span class="line">    --enable-mzschemeinterp \ </span><br><span class="line">    --enable-xim \ </span><br><span class="line">    --enable-tclinterp=dynamic \ </span><br><span class="line">    --enable-perlinterp=dynamic \ </span><br><span class="line">    --enable-python3interp=dynamic\ </span><br><span class="line">    --enable-pythoninterp=dynamic \ </span><br><span class="line">    --enable-rubyinterp=dynamic \ </span><br><span class="line">    --enable-luainterp=dynamic \</span><br><span class="line">    --enable-gui=no \</span><br><span class="line">    --enable-fontset \</span><br><span class="line">    --enable-terminal \</span><br><span class="line">    --with-features=huge \</span><br><span class="line">    --with-x \</span><br><span class="line">    --with-compiledby=&quot;rovo98&quot; \</span><br><span class="line">    --with-python-config-dir=/usr/lib/python2.7/config-$(uname-m)-linux-gnu</span><br><span class="line">    --with-python3-config-dir=/usr/lib/python3.7/config-$(uname -m)-linux-gnu</span><br></pre></td></tr></table></figure></div><p>编译并安装:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make &amp;&amp; sudo make install</span><br></pre></td></tr></table></figure></div><p><strong>编译配置的说明</strong>:</p><p>上面的参数中启用了对tcl、perl、python、ruby、lua的支持。同时为了使用系统的剪切板还启用了对X的支持， 安装位置默认是<code>/usr/local</code>下， 由<code>--perfix=PREFIX</code>参数指定。</p><p>更多详细可以使用<code>./configure --help</code>查看:</p><p><strong>删除编译产生的中间文件</strong> :</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make clean &amp;&amp; make distclean</span><br></pre></td></tr></table></figure></div><p><strong>成果:</strong></p><p><img src="vim_installed.png" alt=""></p><p><strong>为<code>vim</code>创建一个桌面图标</strong>:</p><p><code>vim.desktop</code>:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[Desktop Entry]</span><br><span class="line">Name=Vim[compiled by rovo98]</span><br><span class="line">Version=8.1</span><br><span class="line">Exec=vim %f</span><br><span class="line">Comment=Vim is a highly configurable text editor for efficiently creating and changing any kind of text.</span><br><span class="line">Icon=/usr/share/vim/vim81/src/vim.ico</span><br><span class="line">Type=Application</span><br><span class="line">MimeType=text/plain;</span><br><span class="line">Terminal=true</span><br><span class="line">Encoding=UTF-8</span><br><span class="line">Categories=Utility;</span><br></pre></td></tr></table></figure></div><p>把<code>vim.desktop</code>放到<code>/usr/share/applications/</code>下就行了。</p><p>现在可以享受你自己编译的vim了。</p><div class="note primary"><p>参考链接: </p><ul><li><a href="https://vi.stackexchange.com/questions/13564/why-is-vim-for-debian-compiled-without-clipboard" target="_blank" rel="noopener">https://vi.stackexchange.com/questions/13564/why-is-vim-for-debian-compiled-without-clipboard</a></li><li><a href="https://stackoverflow.com/questions/11416069/compile-vim-with-clipboard-and-xterm" target="_blank" rel="noopener">https://stackoverflow.com/questions/11416069/compile-vim-with-clipboard-and-xterm</a></li></ul></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近换了&lt;code&gt;Manjaro&lt;/code&gt; linux系统，发现通过系统&lt;code&gt;pacman -S vim&lt;/code&gt;安装的无图形版本&lt;code&gt;vim&lt;/code&gt;不支持&lt;code&gt;clipboard&lt;/code&gt;功能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/linux/vim-version-original.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;本想看能不能通过某种方式，来扩展现有安装好的&lt;code&gt;vim&lt;/code&gt;,但是通过&lt;code&gt;google&lt;/code&gt;了解到：&lt;br&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;VIM is intended to be a portable editor that “just works” on all systems. By having the default version use the clipboard functionality, it will need to link against X11 libraries, and a separate version of VIM would need to be compiled for desktop versus server (no pre-installed X11/xorg) builds. This is why the vim and vim-gtk packages are provided.&lt;/p&gt;
&lt;p&gt;VIM旨在成为一个可在所有系统上“正常工作”的便携式编辑器。通过使默认版本使用剪贴板功能，它将需要链接到X11库，并且需要针对桌面与服务器（没有预安装的X11 / xorg）构建编译单独版本的VIM。这就是提供vim和vim-gtk软件包的原因。&lt;/p&gt;
&lt;/blockquote&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://rovo98.github.io/categories/Linux/"/>
    
      <category term="softwares" scheme="http://rovo98.github.io/categories/Linux/softwares/"/>
    
    
      <category term="linux" scheme="http://rovo98.github.io/tags/linux/"/>
    
      <category term="vim" scheme="http://rovo98.github.io/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>Arch linux系列 安装 haroopad markdown 编辑器</title>
    <link href="http://rovo98.github.io/posts/63e58ebb/"/>
    <id>http://rovo98.github.io/posts/63e58ebb/</id>
    <published>2018-08-26T05:12:00.000Z</published>
    <updated>2018-10-08T05:08:41.445Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Haroopad 是一个优秀的 Markdown 编辑器，是一个用于创建适宜 Web 的文档的处理器。使用 Haroopad 可以创作各种格式的文档，比如博客文章、幻灯片、演示文稿、报告和电子邮件等。Haroopad 在 Windows、Mac OS X 和 Linux 上均可用。它有 Debian/Ubuntu 的软件包，也有 Windows 和 Mac 的二进制文件。该应用程序使用 node-webkit、CodeMirror，marked，以及 Twitter 的 Bootstrap 。</p><p>Haroo 在韩语中的意思是“一天”。</p></blockquote><p>本文主要介绍通过压缩包<code>**.tar.gz</code>的方式安装 <code>Haroopad</code>.</p><a id="more"></a><h3 id="一、下载-Haroopad"><a href="#一、下载-Haroopad" class="headerlink" title="一、下载 Haroopad"></a>一、下载 Haroopad</h3><p>我们可以从官网直接下载我们需要的压缩包，官网地址: <a href="http://pad.haroopress.com/user.html" target="_blank" rel="noopener">Haroopad官网地址</a></p><p><img src="haroopad_website.png" alt=""></p><p>这里我选择的是linux binary 64 位的压缩包。</p><h3 id="二、解压并安装Haroopad"><a href="#二、解压并安装Haroopad" class="headerlink" title="二、解压并安装Haroopad"></a>二、解压并安装Haroopad</h3><p>根据下载的压缩包格式进行解压： 例如 **.tar.gz格式</p><p>解压并放到<code>/opt/</code>目录下:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tar zxvf haroopad-v0.13.1.x64.tar.gz -C haroopad</span><br><span class="line">sudo cp -r haroopad /opt/</span><br><span class="line"></span><br><span class="line">tar zxvf data.tar.gz</span><br><span class="line">tar zxvf control.tar.gz</span><br></pre></td></tr></table></figure></div><p>把解压出来的 usr中的文件放到<code>/usr/</code>下：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo cp -r ./usr /</span><br><span class="line"><span class="comment"># 执行 postinst</span></span><br><span class="line">chmod 755 postinst</span><br><span class="line">sudo ./postinst</span><br></pre></td></tr></table></figure></div><p><img src="haroopad_install.png" alt=""></p><h3 id="三、修复桌面图标"><a href="#三、修复桌面图标" class="headerlink" title="三、修复桌面图标"></a>三、修复桌面图标</h3><p>为haroopad 换一个合适的桌面图标:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /usr/share/applications/Haroopad.desktop</span><br></pre></td></tr></table></figure></div><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[Desktop Entry]</span><br><span class="line">Name=haroopad</span><br><span class="line">Version=0.13.1</span><br><span class="line">Exec=haroopad</span><br><span class="line">Comment=The Next Document processor based on Markdown</span><br><span class="line">#Icon=haroopad</span><br><span class="line">Icon=/usr/share/icons/hicolor/128x128/apps/haroopad.png</span><br><span class="line">Type=Application</span><br><span class="line">Terminal=false</span><br><span class="line">StartupNotify=true</span><br><span class="line">Encoding=UTF-8</span><br><span class="line">Categories=Development;GTK;GNOME;</span><br></pre></td></tr></table></figure></div><h3 id="四、配置Haroopad"><a href="#四、配置Haroopad" class="headerlink" title="四、配置Haroopad"></a>四、配置Haroopad</h3><p>相关的Haroopad设置，可以打开 <code>偏好设置</code>进行配置:</p><p><img src="haroopad_settings.png" alt=""></p><p>到此，Haroopad 安装就完成了。</p><p>参考链接: <a href="https://www.jianshu.com/p/dba9acabf0a7" target="_blank" rel="noopener">https://www.jianshu.com/p/dba9acabf0a7</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Haroopad 是一个优秀的 Markdown 编辑器，是一个用于创建适宜 Web 的文档的处理器。使用 Haroopad 可以创作各种格式的文档，比如博客文章、幻灯片、演示文稿、报告和电子邮件等。Haroopad 在 Windows、Mac OS X 和 Linux 上均可用。它有 Debian/Ubuntu 的软件包，也有 Windows 和 Mac 的二进制文件。该应用程序使用 node-webkit、CodeMirror，marked，以及 Twitter 的 Bootstrap 。&lt;/p&gt;
&lt;p&gt;Haroo 在韩语中的意思是“一天”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文主要介绍通过压缩包&lt;code&gt;**.tar.gz&lt;/code&gt;的方式安装 &lt;code&gt;Haroopad&lt;/code&gt;.&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://rovo98.github.io/categories/Linux/"/>
    
      <category term="softwares" scheme="http://rovo98.github.io/categories/Linux/softwares/"/>
    
    
      <category term="linux" scheme="http://rovo98.github.io/tags/linux/"/>
    
      <category term="markdown" scheme="http://rovo98.github.io/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>Manjaro linux 安装与配置</title>
    <link href="http://rovo98.github.io/posts/a1898ce2/"/>
    <id>http://rovo98.github.io/posts/a1898ce2/</id>
    <published>2018-08-22T04:00:00.000Z</published>
    <updated>2019-03-04T07:18:12.597Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/linux/manjaro-installed.png" alt=""></p><blockquote><p>Manjaro是一款基于Arch Linux、对用户友好、全球排名第一的Linux发行版。（排名数据源于<a href="http://distrowatch.com/" target="_blank" rel="noopener">DistroWatch</a>，统计日期2018.08.22，时间段3个月。）<br>在Linux圈，Arch的确是一个异常强大的发行版。它有3个无与伦比的优势：</p><ol><li>滚动更新可以使软件保持最新；</li><li>AUR软件仓库有着世界上最齐全的Linux软件（<a href="https://www.lulinux.com/archives/2787" target="_blank" rel="noopener">参考《一张列表展示ArchLinux系软件有多丰富——看哭百万Debian、RedHat系同学》</a>）；</li><li>丰富的wiki和活跃的社区让所有问题都可以快速得到满意的答案。</li></ol></blockquote><p>相比于<code>Arch linux</code>, 不得感叹, <a href="http://www.manjaro.cn/451" target="_blank" rel="noopener">人生苦短,我用 <strong>Manjaro</strong>啊!</a></p><a id="more"></a><h3 id="一、Manjaro的安装"><a href="#一、Manjaro的安装" class="headerlink" title="一、Manjaro的安装"></a>一、Manjaro的安装</h3><h4 id="镜像下载"><a href="#镜像下载" class="headerlink" title="镜像下载"></a>镜像下载</h4><p>官方网站：<a href="https://manjaro.org/get-manjaro/" target="_blank" rel="noopener">https://manjaro.org/get-manjaro/</a><br>选择自己喜欢的桌面环境就好，目前官方支持包括xfce、kde、gnome三种桌面环境。而在官方的社区版本中提供更多桌面环境的支持，比如国产的deepin桌面环境</p><p>但是官方服务器在海外，所以我们也可以选择国内开源镜像进行下载<br>清华大学开源镜像：<a href="https://mirrors.tuna.tsinghua.edu.cn/manjaro-cd/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/manjaro-cd/</a></p><blockquote><p>由于我基本都把上述的版本和一些社区版本安装过(出于各种原因&gt;_&lt;)，我建议是从官方网站下载最新的官方版本进行安装(好像清华大学源的镜像并不是最新的)，至于桌面环境的选择，看个人，我选择的是<code>KDE</code>(其实，桌面环境在安装之后也是可以换的)。</p></blockquote><h4 id="制作U盘启动盘"><a href="#制作U盘启动盘" class="headerlink" title="制作U盘启动盘"></a>制作U盘启动盘</h4><p>manjaro官方提供的<a href="https://manjaro.github.io/homepage/public/support/userguide/" target="_blank" rel="noopener">Manjaro User Guide</a>手册里面介绍了使用 来制作镜像的方法许多方法，例如：</p><ul><li>Linux系统下，使用 <code>dd</code>命令来制作：<br><code>sudo dd if=manjaro-xfce-17.1-stable-x86_64.iso of=/dev/sdcbs=4M</code>, <code>of</code>指定烧录U盘的挂载位置;</li><li>在windows系统下使用烧录软件<code>Rufus</code>来进行烧录:<br> <img src="Rufus.png" alt=""></li></ul><p><strong>[注意]</strong>： 烧录完成后，在进入<code>Live</code>系统前，需要对<code>BIOS</code>进行一些设置，关闭安全启动。之后即可顺利进入这个界面(至于BIOS vs UEFI的启动进入的<code>Live</code>系统的方式，详见手册。由于我安装的是多个系统，所以是<code>GPT+UEFI</code>引导):</p><p><img src="manjaro-boot-menu.png" alt=""></p><h4 id="安装系统"><a href="#安装系统" class="headerlink" title="安装系统"></a>安装系统</h4><p>进入启动菜单界面后，可以对一些基本的选项进行配置，如，时区，语言，键盘布局等。</p><p>具体的安装步骤请直接参考官网的<code>Manjaro User Guide.pdf</code>,这里主要说说安装系统时可能遇到的问题(我基本踩过的坑…)。</p><ol><li><strong>对于双显卡的电脑,特别是有Nvidia卡的</strong>: 在进入<code>live</code>系统之前,可以将<code>Driver</code>选项设置为<code>no-free</code>(让系统自动安装合适的闭源驱动),并在<code>boot</code>项那里按<code>E</code>编辑, 在<code>boot</code>那一行将<code>nouveau.modeset=1</code>设置为<code>nouveau.modeset=0</code>来禁用开源<code>nouveau</code>驱动,然后进入<code>Live</code>安装系统。<br><strong>但是,安装完系统后重启还有可能进不去桌面</strong>,可以尝试在<code>Grub</code>菜单启动界面按[E]编辑,找到<code>quite</code>并在后面加入(注意空格):<blockquote><p><code>acpi_osi=! acpi_osi=&#39;Windows 2009&#39;</code><br>或者<br><code>acpi_osi=! acpi_osi=Linux acpi_osi=&#39;Windows 2015&#39; pcie_port_pm=off</code><br><strong>(很多硬件厂商的BIOS驱动都对Linux不友好(我的电脑就是这样的…)，无法顺利加载ACPI模块，而导致无法驱动独立显卡,acpi_osi=’Windows 2009’的意思是告诉ACPI模块，我是‘Windows 7’，别闹情绪了，赶紧工作吧。)</strong><br>接着按 F10 进入系统。<br><br>顺利进入系统后,将这些内核启动参数配置永久生效(修改grub的配置文件):<br><code>sudo vim /etc/default/grub</code><br>在<code>GRUB_CMDLINE_LINUX</code>中添加参数:<br><img src="manjaro-grub.png" alt=""><br>之后更新 <code>grub</code>文件:<br><code>sudo update-grub</code><br>或<br><code>sudo grub-mkconfig -o /boot/grub/grub.cfg</code><br><img src="update-grub.png" alt=""><br>参考链接: </p><ol><li><a href="https://forum.manjaro.org/t/a-start-job-is-running-for-livemedia-mhwd-script/3395/15" target="_blank" rel="noopener">https://forum.manjaro.org/t/a-start-job-is-running-for-livemedia-mhwd-script/3395/15</a></li><li><a href="https://wiki.archlinux.org/index.php/Kernel_parameters" target="_blank" rel="noopener">https://wiki.archlinux.org/index.php/Kernel_parameters</a></li><li><a href="https://www.kernel.org/doc/Documentation/admin-guide/kernel-parameters.txt" target="_blank" rel="noopener">https://www.kernel.org/doc/Documentation/admin-guide/kernel-parameters.txt</a></li></ol></blockquote></li><li>启动时出现的<code>ACPI ERROR</code>问题，很多都说是内核版本的原因，有尝试过添加内核启动参数<code>acpi=off</code>，启动正常进入系统，但键盘无法使用，所以这个提示<code>ACPI</code>错误的问题，由于不影响使用，所以可以不管(强迫症的可以再看看)<blockquote><p><img src="boot-acpi-error.png" alt=""><br>参考链接: <a href="https://forum.manjaro.org/t/acpi-error-during-boot/35125" target="_blank" rel="noopener">https://forum.manjaro.org/t/acpi-error-during-boot/35125</a></p></blockquote></li><li>屏幕亮度无法调节或异常的问题： <code>Arch Wiki</code>已经给出很详细的解决方法:<br>链接: <a href="https://wiki.archlinux.org/index.php/backlight" target="_blank" rel="noopener">https://wiki.archlinux.org/index.php/backlight</a><br>例如：开机亮度设置: <code>vim /etc/rc.local</code>:<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="ZSH"><figure class="iseeu highlight /zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/sh -e</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># rc.local</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This script is executed at the end of the each multiuser runlevel.</span></span><br><span class="line"><span class="comment"># Make sure that the script will "exit 0" on successs or any other value on error</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># In order to enable or disable this script just change the execution bits.</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># By default this script does nothing.</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> 127 &gt;&gt; /sys/class/backlight/intel_backlight/brightness</span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure></div></li></ol><div class="note primary"><p>对于安装<code>Manjaro</code>系统出现的问题，大多数都可以在官方的论坛<a href="https://forum.manjaro.org/" target="_blank" rel="noopener">Manjaro Forum</a>以及<a href="https://wiki.manjaro.org/index.php?title=Main_Page" target="_blank" rel="noopener">Manjaro Wiki</a>，还有<code>Arch Linux</code>的<a href="https://wiki.manjaro.org" target="_blank" rel="noopener">Arch Wiki</a>以及上找到解决方法。</p></div><h3 id="二、Manjaro-配置"><a href="#二、Manjaro-配置" class="headerlink" title="二、Manjaro 配置"></a>二、Manjaro 配置</h3><p>简单说一下一些安装系统之后的一些常规配置。</p><h4 id="配置更新源并更新系统"><a href="#配置更新源并更新系统" class="headerlink" title="配置更新源并更新系统"></a>配置更新源并更新系统</h4><ol><li><p>配置中国的mirrors：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="ZSH"><figure class="iseeu highlight /zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman-mirrors -i -c China -m rank</span><br></pre></td></tr></table></figure></div></li><li><p>在 <code>/etc/pacman.conf</code>中添加<code>archlinuxcn</code>源:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[archlinuxcn]</span><br><span class="line">SigLevel= TrustedOnly</span><br><span class="line">Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch</span><br></pre></td></tr></table></figure></div></li><li><p>安装<code>archlinuxcn-keyring</code>:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S archlinuxcn-keyring</span><br></pre></td></tr></table></figure></div></li><li><p>同步并更新系统；</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="ZSH"><figure class="iseeu highlight /zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -Syyu</span><br></pre></td></tr></table></figure></div></li></ol><h4 id="安装配置中文输入法"><a href="#安装配置中文输入法" class="headerlink" title="安装配置中文输入法"></a>安装配置中文输入法</h4><ol><li><p>安装中文输入法和<code>fcitx</code>管理工具:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="ZSH"><figure class="iseeu highlight /zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S fcitx-sougoupinyin <span class="comment"># 输入法看个人</span></span><br><span class="line">sudo pacman -S fcitx-im</span><br><span class="line">sudo pacman -S fcitx-configtool</span><br></pre></td></tr></table></figure></div></li><li><p>解决中文输入法无法切换问题: 添加文件<code>~/.xprofile</code>:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export GTK_MODULE=fcitx</span><br><span class="line">export QT_IM_MODULE=fcitx</span><br><span class="line">export XMODIFIERS=&quot;@im=fcitx&quot;</span><br></pre></td></tr></table></figure></div></li></ol><p>重启即可。</p><h4 id="配置Intel-和-Nvidia-双显卡切换"><a href="#配置Intel-和-Nvidia-双显卡切换" class="headerlink" title="配置Intel 和 Nvidia 双显卡切换"></a>配置Intel 和 Nvidia 双显卡切换</h4><p>Manjaro 提供了强大的硬件检测模块<code>mhwd</code>，可以很方便的安装各种驱动，要实现Intel 和 Nvidia 双显卡切换，我们需要安装video-hybrid-intel-nvidia-bumblebee <code>nvidia</code>闭源驱动和intel驱动的混合版<code>bumblebee</code>。对于之前安装系统是在<code>Live</code>启动菜单选择<code>Driver=no-free</code>的可以看看这个驱动是否已经安装：<br>系统设置中的硬件设置:<br><img src="manjaro-graphic-cards.png" alt=""><br>或<br><br><img src="manjaro-mhwd-installed-pci.png" alt=""></p><p>对于未安装的，这里提供一个最为简单的方式，<strong>直接在硬件设置中，右键安装即可，这样可以省去自己去添加用户组和开机启动，以及切换状态初始化</strong></p><div class="note warning"><p><strong>[注意：]</strong> 下面的这些依赖必须安装，否则会出现独立显卡无法正常工作的问题(fps跟集成显卡差不多)：</p></div><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="ZSH"><figure class="iseeu highlight /zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S virtualgl lib32-virtualgl</span><br></pre></td></tr></table></figure></div><p>对于独立显卡的使用，可以使用<code>bbswitch</code>来进行切换开关，然后使用<code>optirun</code>来运行程序:</p><blockquote><ol><li>首先查看显卡的状态: <code>lspci | grep -i nvidia</code>(rev ff 表示关闭状态)<br><img src="nvidia-off.png" alt=""></li><li>打开独立显卡，并进行测试，对比集成显卡的fps：<ul><li>集成显卡 FPS:<br><img src="intel-fps.png" alt=""></li><li>打开独立显卡<code>sudo tee /proc/acpi/bbswitch &lt;&lt;&lt; &quot;ON&quot;</code>,测试FPS:<br><img src="nvidia-fps.png" alt=""></li></ul></li><li>独立显卡设置 nvidia-settings 需要用<code>optirun nvidia-setting -c :8</code>才能打开:<br><img src="nvidia-settings.png" alt=""></li></ol></blockquote><h4 id="使用-zsh-和-oh-my-zsh-配置终端"><a href="#使用-zsh-和-oh-my-zsh-配置终端" class="headerlink" title="使用 zsh 和 oh-my-zsh 配置终端"></a>使用 zsh 和 oh-my-zsh 配置终端</h4><p>我的 zsh 终端模拟器(theme: rjkirch_mod)：</p><p><img src="my-zsh.png" alt=""></p><p>基本配置过程：</p><ul><li>查看系统安装了多少shell <code>cat /etc/shells</code></li><li>查看当前shell : <code>echo $SHELL</code></li><li>使用 <code>chsh</code>切换默认<code>shell</code>.</li></ul><p>配置 zsh，直接使用<strong>oh-my-zsh</strong>来进行配置: <a href="https://github.com/robbyrussell/oh-my-zsh" target="_blank" rel="noopener">Oh-my-zsh</a>.<br>zsh 主题可以自行按个人喜好配置，当然也可以随机(每次打开终端都随机选择一个主题).</p><p>插件推荐: (插件配置太多的话，会使shell启动速度变慢，适当就好)</p><p><img src="zsh-plugins.png" alt=""></p><ul><li><a href="https://github.com/wting/autojump" target="_blank" rel="noopener">Autojump</a></li><li><a href="https://github.com/zsh-users/zsh-syntax-highlighting" target="_blank" rel="noopener">zsh-syntax-highlighting</a></li><li><a href="https://github.com/zsh-users/zsh-autosuggestions" target="_blank" rel="noopener">zsh-autosuggestions</a></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>Manjaro</code>的安装和基本配置就到此结束。最后，简单说一下我安装此系统的缘由。在安装<code>manjaro</code>之前，我使用的是<code>win10 LTSB 2016</code>，之前接触过的的Linux发行版是<code>CentOS</code>, <code>Unbuntu</code>以及 <code>kali</code>， 前两者我不怎么想要，本来想直接换成<code>kali</code>，但是考虑到<code>kali</code>一般是作为一个工具来使用，并不适合我平时开发和日常使用，就再次寻找适合的Linux发行版，最后看上了<code>Arch Linux</code>，但是又因为<code>Arch</code>上手难度较高，退而求其次，选择了<code>Manjaro</code>。当然啦，<code>Win10</code>肯定是要保留的，<code>Kali</code>也是要的。</p><p>于是乎，在原先的<code>GPT+UEFI</code>引导方式的基础之上，我重新分配了我的磁盘，将原有的<code>Win10</code>系统盘缩小，把它当备用系统，<code>Manjaro</code>作为主要系统使用，而<code>Kali</code>只作为工具使用，其他的磁盘分区作为数据存放的分区，各个系统共用。</p><p><img src="win-manjaro-kali.jpg" alt=""></p><p><img src="disk-structure.png" alt=""></p><div class="note danger"><p>说明: 对于上面给出的分区方案仅供参考，<strong>例如: 对于<code>Linux</code>的<code>swap</code>分区(用于虚拟内存的置换)来说，由于系统启动时会对<code>swap</code>进行初始化，因此多个系统可以使用一个<code>swap</code>分区即可。只要配置<code>UUID</code>没错就行了，毕竟多系统主机每次也只能启动一个系统。。。</strong></p><p>上面的分区旨在演示，基于<code>GPT</code> (<em>GUID Partion Table</em> 分区表(可以分128主要分区，而<code>MBR</code>(<em>Master Boot Record</em>)分区表只能是4个主要分区, 请自行了解两者的区别) 使用<code>UEFI</code>(<em>Unified Extensible Firmware Interface</em>)如何为安装多系统做准备。</p></div><p>然后使用 <code>REfind</code>来管理和引导系统:</p><p><img src="refind-menu.jpg" alt=""></p><div class="note primary"><p>对于Refind有兴趣的可以直接<code>google</code>或<code>baidu</code>了解一下，选择一个现有的主题然后自己稍微进行配置一下，就可以了。<br>参考:</p><ul><li><a href="http://www.rodsbooks.com/refind/" target="_blank" rel="noopener">http://www.rodsbooks.com/refind/</a></li><li><a href="https://wiki.archlinux.org/index.php/REFInd_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87" target="_blank" rel="noopener">Arch Wiki 上关于refind的内容</a>)</li></ul></div><h4 id="各个系统桌面"><a href="#各个系统桌面" class="headerlink" title="各个系统桌面"></a>各个系统桌面</h4><ul><li>Win10 LTSB</li></ul><p><img src="win10.png" alt=""></p><ul><li>Manjaro(DE: KDE)</li></ul><p><img src="manjaro-desktop.png" alt=""></p><ul><li>Kali</li></ul><p><img src="kali.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/linux/manjaro-installed.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Manjaro是一款基于Arch Linux、对用户友好、全球排名第一的Linux发行版。（排名数据源于&lt;a href=&quot;http://distrowatch.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;DistroWatch&lt;/a&gt;，统计日期2018.08.22，时间段3个月。）&lt;br&gt;在Linux圈，Arch的确是一个异常强大的发行版。它有3个无与伦比的优势：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;滚动更新可以使软件保持最新；&lt;/li&gt;
&lt;li&gt;AUR软件仓库有着世界上最齐全的Linux软件（&lt;a href=&quot;https://www.lulinux.com/archives/2787&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;参考《一张列表展示ArchLinux系软件有多丰富——看哭百万Debian、RedHat系同学》&lt;/a&gt;）；&lt;/li&gt;
&lt;li&gt;丰富的wiki和活跃的社区让所有问题都可以快速得到满意的答案。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;相比于&lt;code&gt;Arch linux&lt;/code&gt;, 不得感叹, &lt;a href=&quot;http://www.manjaro.cn/451&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;人生苦短,我用 &lt;strong&gt;Manjaro&lt;/strong&gt;啊!&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://rovo98.github.io/categories/Linux/"/>
    
    
      <category term="linux" scheme="http://rovo98.github.io/tags/linux/"/>
    
      <category term="manjaro" scheme="http://rovo98.github.io/tags/manjaro/"/>
    
  </entry>
  
  <entry>
    <title>爬取校内腾讯企业邮箱通信录</title>
    <link href="http://rovo98.github.io/posts/e675b5d9/"/>
    <id>http://rovo98.github.io/posts/e675b5d9/</id>
    <published>2018-07-25T06:07:00.000Z</published>
    <updated>2018-10-08T05:08:42.451Z</updated>
    
    <content type="html"><![CDATA[<p>简单使用python <code>request</code> + <code>re</code> 爬取校内邮箱通信录(腾讯企业邮箱)的用户信息数据。</p><a id="more"></a><h3 id="一、分析需要爬取的数据"><a href="#一、分析需要爬取的数据" class="headerlink" title="一、分析需要爬取的数据"></a>一、分析需要爬取的数据</h3><p>通过手动打开浏览器，正常访问网站，判断需要爬取的数据是静态还是动态数据，制定不同的爬取方案。</p><h4 id="1-静态-动态-数据类型判断"><a href="#1-静态-动态-数据类型判断" class="headerlink" title="1. 静态/动态 数据类型判断"></a>1. 静态/动态 数据类型判断</h4><p>登陆企业校内邮箱，可以看到需要获取的内容主要呈现在该页面:<br><br><img src="step_01.png" alt=""></p><p><code>F12</code>打开控制台，查看<code>Elements</code>，可以很容易发现，用户数据在目录节点没有展开的情况下，html文档中并不会包含我们需要的数据，当点击展开目录节点后，才能获取到数据。<br><br><img src="step_02.png" alt=""><br>因此，可以判断，我们需要爬取的数据是动态生成的，可以初步认为是通过<code>AJAX</code>异步请求来从服务器端获取数据的。</p><h4 id="2-数据定位"><a href="#2-数据定位" class="headerlink" title="2. 数据定位"></a>2. 数据定位</h4><p>我们已经知道了需要爬取的数据是动态生成的，这时，同样<code>F12</code>打开控制台，到<code>Network</code>栏目下，查找类型为<code>XHR</code>(AJAX的请求链接)的请求链接，并按数据文件大小从到小排序，再次刷新页面，点击通讯录栏目，展开到具体的用户项，依次点击<code>XHR</code>以确定需要的数据是通过哪个链接获取的：<br><br><img src="step_03.png" alt=""></p><p>可以看到，请求链接格式为:<code>https://exmail.qq.com/cgi-bin/laddr_biz?t=memtree&amp;limit={limit}&amp;partyid={pid}&amp;action=show_party&amp;sid={sid}</code>,参数有 - <br></p><div class="table-container"><table><thead><tr><th style="text-align:center">Argument</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td style="text-align:center">t</td><td style="text-align:center">取值不变,<code>memtree</code>，具体含义就不管了</td></tr><tr><td style="text-align:center">limit</td><td style="text-align:center">链接中取值:<code>500</code>,单次获取用户的最大数量，<br>我们可以自己修改，再次发起请求来验证</td></tr><tr><td style="text-align:center">partyid</td><td style="text-align:center">变化值，为所属组的id,例如：<br>学生 -&gt; 专业 -&gt; 院系<br>学生所属专业<code>partyid</code>就是的专业的<code>id</code>,etc.</td></tr><tr><td style="text-align:center">action</td><td style="text-align:center">在此链接中不变，取值:<code>show_party</code></td></tr><tr><td style="text-align:center">sid</td><td style="text-align:center">用户登陆后生成的<code>sid</code>值，访问过程中不变</td></tr></tbody></table></div><p><img src="step_04.png" alt=""></p><p>通过上面的分析，我们可以知道，要获取所有学生的信息，主要是在获取所有的专业的<code>id</code>后，依次作为上面链接的<code>partyid</code>来发起请求即可。</p><p>尝试在html <code>Elements</code>文档中搜索，能够搜到相应的数据，但它也是动态生成的 - </p><p><img src="step_05.png" alt=""></p><p>继续在<code>Network</code>中将过滤类型设置为<code>doc</code>同时按文件大小排序，查找包含<code>oPartyList</code>的文件 -</p><p><img src="step_06.png" alt=""></p><p>到此，我们所有的分析任务已经结束了，接下来只需要编写相应的爬虫程序即可。</p><h3 id="二、爬虫程序设计"><a href="#二、爬虫程序设计" class="headerlink" title="二、爬虫程序设计"></a>二、爬虫程序设计</h3><p>这里只是编写一个简单的爬虫程序，不使用IP代理，爬虫发起请求所需的<code>sid</code>通过用户自己登陆后手动获取，相应的<code>cookie</code>也是如此。</p><h4 id="1-获取所有专业的id"><a href="#1-获取所有专业的id" class="headerlink" title="1. 获取所有专业的id"></a>1. 获取所有专业的id</h4><p>上面分析提到的，要获取用户数据，主要是要先获取到用户所在的组id<code>partyid</code>。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getAllPID</span><span class="params">()</span>:</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">    获取所有的专业id,作为用户的pid.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    sid = <span class="string">'xxx'</span>   <span class="comment"># 用户登陆后的sid</span></span><br><span class="line">    all_parties_url = <span class="string">'https://exmail.qq.com/cgi-bin/laddr_biz?action=show_party_list&amp;sid=&#123;sid&#125;&amp;t=contact&amp;view=biz'</span>.format(sid=sid)</span><br><span class="line">    cookies = dict(...) <span class="comment"># cookie参数和值</span></span><br><span class="line">    request = request.get(all_parties_url,cookies=cookies)</span><br><span class="line">    </span><br><span class="line">    regexp = <span class="string">r'&#123;id:"(\S*?)", pid:"(\S*?)", name:"(\S*?)", order:"(\S*?)"&#125;'</span></span><br><span class="line">    results = re.findall(regexp,text)</span><br><span class="line">    all_parties_ids = []       <span class="comment"># 所有pid</span></span><br><span class="line">    all_parties_info = dict() <span class="comment"># 所有组信息</span></span><br><span class="line">    root_party = <span class="keyword">None</span>      <span class="comment"># 根通信组</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> results:</span><br><span class="line">    all_parties_id.append(p[<span class="number">0</span>])</span><br><span class="line">        party = dict(id=item[<span class="number">0</span>], pid=item[<span class="number">1</span>], name=item[<span class="number">2</span>], order=item[<span class="number">3</span>])</span><br><span class="line">        all_parties_info[item[<span class="number">0</span>]] = party</span><br><span class="line">        <span class="keyword">if</span> p[<span class="number">1</span>] == <span class="number">0</span> <span class="keyword">or</span> p[<span class="number">1</span>] == <span class="string">'0'</span>:</span><br><span class="line">        root_party = party</span><br></pre></td></tr></table></figure></div><h4 id="2-获取学生信息数据"><a href="#2-获取学生信息数据" class="headerlink" title="2. 获取学生信息数据"></a>2. 获取学生信息数据</h4><p>依次遍历<code>pid</code>列表，构造不同的<code>pid</code>不同的链接，来获取全部的通讯录内容。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getAllUserInfo</span><span class="params">()</span>:</span></span><br><span class="line">...</span><br><span class="line">    获取所有通讯录用户信息</span><br><span class="line">    ...</span><br><span class="line">    all_user_info = []  <span class="comment"># 用于保存所有用户数据信息</span></span><br><span class="line">    <span class="comment"># 获取用户数据的链接</span></span><br><span class="line">    party_user_url = <span class="string">'https://exmail.qq.com/cgi-bin/laddr_biz?t=memtree&amp;limit=&#123;limit&#125;'</span>\</span><br><span class="line">    <span class="string">'&amp;partyid=&#123;pid&#125;&amp;action=show_party&amp;sid=&#123;sid&#125;'</span></span><br><span class="line">    regexp = <span class="string">r'&#123;uin:"(\S*?)", pid:"(\S*?)", alias:"(\S*?)", sex:"(\S*?), pos:"(\S*?)", tel:"(\S*?)",'</span>\</span><br><span class="line">    <span class="string">' birth:"(\S*?)(\S*?)(\S*?)(\S*?)", slave_alias:"(\S*?)(\S*?)(\S*?)", department:"(\S*?)(\S*?)", mobile:"(\S*?)"&#125;'</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> pid <span class="keyword">in</span> all_parites_ids:</span><br><span class="line">        <span class="comment"># 依次构造不同pid的请求链接</span></span><br><span class="line">    url = party_user_url.format(limit=limit, pid=pid, sid=sid)</span><br><span class="line">        request = requests.get(url, cookies=cookies)</span><br><span class="line">        text = request.text</span><br><span class="line">        results = re.findall(regexp, text)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> results:</span><br><span class="line">        user = dict(uin=item[<span class="number">0</span>], pid=item[<span class="number">1</span>], name=item[<span class="number">2</span>], alias=item[<span class="number">3</span>], sex=item[<span class="number">4</span>],</span><br><span class="line">            pos=item[<span class="number">5</span>], tel=item[<span class="number">6</span>],birth=item[<span class="number">7</span>], slave_alias=item[<span class="number">8</span>], department=item[<span class="number">9</span>],</span><br><span class="line">                   mobile=item[<span class="number">10</span>])</span><br><span class="line">         all_user_info.append(user)</span><br></pre></td></tr></table></figure></div><p>完整的程序，请移步到<a href="https://github.com/rovo98/python-learning/blob/master/web-spiders/tx_email_spider/tx_email_spider.py" target="_blank" rel="noopener">Github</a>查看.</p><h3 id="三、爬取结果"><a href="#三、爬取结果" class="headerlink" title="三、爬取结果"></a>三、爬取结果</h3><p><img src="step_07.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单使用python &lt;code&gt;request&lt;/code&gt; + &lt;code&gt;re&lt;/code&gt; 爬取校内邮箱通信录(腾讯企业邮箱)的用户信息数据。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://rovo98.github.io/categories/Python/"/>
    
      <category term="python爬虫" scheme="http://rovo98.github.io/categories/Python/python%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="Spider demo" scheme="http://rovo98.github.io/tags/Spider-demo/"/>
    
  </entry>
  
  <entry>
    <title>解决Github国内访问出现的问题</title>
    <link href="http://rovo98.github.io/posts/7e3029b3/"/>
    <id>http://rovo98.github.io/posts/7e3029b3/</id>
    <published>2018-06-10T07:58:34.000Z</published>
    <updated>2018-11-01T13:38:38.745Z</updated>
    
    <content type="html"><![CDATA[<p>主要通过修改hosts文件解决Github在国内访问不了、访问慢和页面加载异常的问题(没钱买vpn~)。</p><p>简单了解一下github, github是目前全球最大的男性同性交友网站(~滑稽~), 使用示例如下：</p><p><img src="/images/解决Github访问问题/communication.png" alt=""></p><a id="more"></a><p>开个玩笑，回归正题。</p><h3 id="为什么访问不了以及访问速度会很慢？"><a href="#为什么访问不了以及访问速度会很慢？" class="headerlink" title="为什么访问不了以及访问速度会很慢？"></a>为什么访问不了以及访问速度会很慢？</h3><p>GitHub在中国大陆访问速度慢的问题原因有很多，但最直接和最主要的原因是GitHub的分发加速网络的域名遭到DNS污染。</p><p>由于GitHub的加速分发CDN域名assets-cdn.github.com遭到DNS污染，导致无法连接使用GitHub的加速分发服务器，才使得中国大陆访问速度很慢。</p><p><img src="github_problem.png" alt="problem"></p><h3 id="如何解决DNS污染？"><a href="#如何解决DNS污染？" class="headerlink" title="如何解决DNS污染？"></a>如何解决DNS污染？</h3><p>一般的DNS问题都可以通过修改Hosts文件来解决，GitHub的CDN域名被污染问题也不例外，同样可以通过修改Hosts文件解决。</p><p>将域名解析直接指向IP地址来绕过DNS的解析，以此解决污染问题。</p><h4 id="获取被污染域名的实际IP地址"><a href="#获取被污染域名的实际IP地址" class="headerlink" title="获取被污染域名的实际IP地址"></a>获取被污染域名的实际IP地址</h4><p>访问<a href="https://www.ipaddress.com" target="_blank" rel="noopener">ipaddress.com</a>,使用ip lookup 工具获得相关域名的ip地址。</p><p>例如： github.com</p><p><img src="github_ipaddress.png" alt="ip address"></p><p>可以看到，我查出的域名ip地址为： <code>192.30.253.112</code> 和 <code>192.30.253.113</code> (任取一个即可)</p><h4 id="修改host文件，在文件中添加一行："><a href="#修改host文件，在文件中添加一行：" class="headerlink" title="修改host文件，在文件中添加一行："></a>修改host文件，在文件中添加一行：</h4><p><strong>[注] ： windows的hosts文件位置为： </strong><br><code>C:/windows/system32/drivers/etc/hosts</code></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">192.30.253.112 github.com</span><br></pre></td></tr></table></figure></div><h4 id="刷新dns缓存"><a href="#刷新dns缓存" class="headerlink" title="刷新dns缓存"></a>刷新dns缓存</h4><p>打开命令行cmd,输入如下命令：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig /flushdns</span><br></pre></td></tr></table></figure></div><p>此时再刷新页面即可。此时可以正常访问github，但是访问速度还是很慢，我们接着做优化。</p><h4 id="Github-访问提速"><a href="#Github-访问提速" class="headerlink" title="Github 访问提速"></a>Github 访问提速</h4><p>在hosts文件中继续加入，如下代码：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># GitHub Start</span><br><span class="line">192.30.253.112 github.com</span><br><span class="line">192.30.253.119 gist.github.com</span><br><span class="line">151.101.228.133 assets-cdn.github.com</span><br><span class="line">151.101.228.133 raw.githubusercontent.com</span><br><span class="line">151.101.228.133 gist.githubusercontent.com</span><br><span class="line">151.101.228.133 cloud.githubusercontent.com</span><br><span class="line">151.101.228.133 camo.githubusercontent.com</span><br><span class="line">151.101.228.133 avatars0.githubusercontent.com</span><br><span class="line">151.101.228.133 avatars1.githubusercontent.com</span><br><span class="line">151.101.228.133 avatars2.githubusercontent.com</span><br><span class="line">151.101.228.133 avatars3.githubusercontent.com</span><br><span class="line">151.101.228.133 avatars4.githubusercontent.com</span><br><span class="line">151.101.228.133 avatars5.githubusercontent.com</span><br><span class="line">151.101.228.133 avatars6.githubusercontent.com</span><br><span class="line">151.101.228.133 avatars7.githubusercontent.com</span><br><span class="line">151.101.228.133 avatars8.githubusercontent.com</span><br><span class="line">192.30.253.116  api.github.com</span><br><span class="line"># GitHub End</span><br></pre></td></tr></table></figure></div><div class="note warning"><p><strong>注意</strong> : 这里域名对应的ip是通过dns查询工具查询得到的，你应当选择的是延时相对较小且比较稳定的ip。</p></div><p>例如，上面的<code>151.101.228.133</code>是对我来说较好的ip:</p><p><img src="ping_test.png" alt="dns 查询检测"></p><div class="note info"><p>推荐的dns查询检测工具：</p><ul><li><a href="https://tool.lu/dns/" target="_blank" rel="noopener">DNS查询 - 在线工具</a></li><li><a href="http://tool.chinaz.com/dns/" target="_blank" rel="noopener">DNS检测|DNS查询-站长工具</a></li></ul><p>你可对单个域名多查询几次，以挑选稳定且速度较快的ip。</p></div><h4 id="快速地访问github"><a href="#快速地访问github" class="headerlink" title="快速地访问github"></a>快速地访问github</h4><p>再次刷新dns缓存后，你已经可以快速地访问github了。</p><p><img src="github_test.gif" alt=""></p><div class="note primary"><p>参考：<a href="https://github.com/chenxuhua/issues-blog/issues/3" target="_blank" rel="noopener">https://github.com/chenxuhua/issues-blog/issues/3</a></p></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要通过修改hosts文件解决Github在国内访问不了、访问慢和页面加载异常的问题(没钱买vpn~)。&lt;/p&gt;
&lt;p&gt;简单了解一下github, github是目前全球最大的男性同性交友网站(~滑稽~), 使用示例如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/解决Github访问问题/communication.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="tips" scheme="http://rovo98.github.io/categories/tips/"/>
    
    
      <category term="github" scheme="http://rovo98.github.io/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>PPP 点对点通信验证</title>
    <link href="http://rovo98.github.io/posts/28ff89ad/"/>
    <id>http://rovo98.github.io/posts/28ff89ad/</id>
    <published>2018-06-09T16:10:00.000Z</published>
    <updated>2018-10-08T05:08:42.645Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/ppp通信验证/structure.png" alt=""></p><p>使用Cisco Packet Tracer7 (思科网络模拟器)验证ppp点对点通信。</p><a id="more"></a><h3 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h3><p>使用<code>packet Tracer</code> 模拟两台路由器，进行点对点通信测试。</p><h3 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h3><h4 id="配置路由器"><a href="#配置路由器" class="headerlink" title="配置路由器"></a>配置路由器</h4><p>由于只需要验证点对点通信，对路由器的配置，相对比较简单，<br>路由器之间使用的是serial DCE 串口线相连。</p><p>配置Router1的<code>serial 2/0</code>串口为ip: <code>11.0.0.1</code> mask: <code>255.0.0.0</code>,并配置时钟频率为<code>64000</code></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Router&gt; enable</span><br><span class="line">Router# configure terminal</span><br><span class="line">Router(config) # hostname RA</span><br><span class="line">RA (config) # interface serial 2/0</span><br><span class="line">RA (config) # no shutdown</span><br><span class="line">RA (config-if) # ip address 11.0.0.1 255.0.0.0</span><br><span class="line">RA (config-if) # clock rate 64000</span><br></pre></td></tr></table></figure></div><p>配置Router2的<code>serial 3/0</code> 串口为ip: <code>11.0.0.2</code> mask： <code>255.0.0.0</code></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Router&gt; enable</span><br><span class="line">Router# configure terminal</span><br><span class="line">Router(config) # hostname RB</span><br><span class="line">RB (config) # interface serial 3/0</span><br><span class="line">RB (config) # no shutdown</span><br><span class="line">RB (config-if) # ip address 11.0.0.2 255.0.0.0</span><br></pre></td></tr></table></figure></div><ul><li>查看两个路由的串口状态：</li></ul><p><code>RA</code>:</p><p><img src="hdsl_rt1.png" alt="RA serial 2/0"></p><p><code>RB</code>:</p><p><img src="hdsl_rt2.png" alt="RB serial 3/0"></p><p>可以看到，路由器这里点对点通信默认使用的<code>HDLC</code>(High Level Data Link Control, 面向比特的同步协议)协议。</p><h4 id="HDLC情况下验证ping："><a href="#HDLC情况下验证ping：" class="headerlink" title="HDLC情况下验证ping："></a>HDLC情况下验证ping：</h4><p><code>11.0.0.1</code> ping <code>11.0.0.2</code>:</p><p><img src="hdlc_ping_rt1.png" alt="RA ping Test"></p><p><code>11.0.0.2</code> ping <code>11.0.0.1</code>:</p><p><img src="hdlc_ping_rt2.png" alt="RB ping Test"></p><p>ping 测试成功。</p><h4 id="配置RA-RB使用ppp协议，再做ping测试："><a href="#配置RA-RB使用ppp协议，再做ping测试：" class="headerlink" title="配置RA,RB使用ppp协议，再做ping测试："></a>配置RA,RB使用ppp协议，再做ping测试：</h4><ul><li>先配置<code>RA</code> 使用 <code>ppp</code>协议：</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RA # configure terminal</span><br><span class="line">RA (config) # interface serial 2/0</span><br><span class="line">RA (config-if) # encapsulation ppp</span><br></pre></td></tr></table></figure></div><p><img src="RA_ppp_setting.png" alt="RA serial 2/0"></p><p>可以看到<code>RA</code>当前使用的是<code>ppp</code>写协议，<code>LCP</code>处于<code>Closed</code>,此时，路由器应当无法进行点对点通信。</p><p><img src="RA_ppp_fTest.png" alt="ping Test"></p><ul><li>配置<code>RB</code>使用<code>ppp</code>协议：</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RB # configure terminal</span><br><span class="line">RB (config) # interface serial 3/0</span><br><span class="line">RB (config-if) # encapsulation ppp</span><br></pre></td></tr></table></figure></div><p><img src="RB_ppp_setting.png" alt="RB serial 3/0"></p><p>这时，可以看到<code>RB</code>也是使用了<code>ppp</code>协议，且<code>LCP</code>也处于<code>Open</code>状态，路由器之间可以进行通信。</p><p><img src="RB_ppp_sTest.png" alt="ping Test"></p><h4 id="给ppp协议添加authentication鉴别"><a href="#给ppp协议添加authentication鉴别" class="headerlink" title="给ppp协议添加authentication鉴别"></a>给ppp协议添加authentication鉴别</h4><ul><li>先配置<code>RA</code>，使其开启<code>ppp chap</code> (Challenge Handshake Authentication Protocol), 给<code>RB</code> 添加身份验证</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RA # config terminal</span><br><span class="line">RA (config) # username RB password password</span><br><span class="line">RA (config) # interface serial 2/0</span><br><span class="line">RA (config-if) # ppp authentication chap</span><br></pre></td></tr></table></figure></div><p><img src="RA_ppp_au.png" alt="RA serial 2/0"></p><p>此时，虽然<code>RA</code>和<code>RB</code>都是使用<code>ppp</code>协议，但是<code>RA</code>给<code>RB</code>添加了身份认证，而<code>RB</code>则没有，此时<code>LCP</code>处于<code>Closed</code>状态，它们之间无法进行通信。</p><ul><li>配置<code>RB</code>, 添加对<code>RA</code>的身份验证：</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RB # config terminal</span><br><span class="line">RB (config) # username RA password password</span><br><span class="line">RB (config) # interface serial 2/0</span><br><span class="line">RB (config-if) # ppp authentication chap</span><br></pre></td></tr></table></figure></div><p><img src="RB_ppp_au.png" alt="RB serial 3/0"></p><p>可以看到此时，<code>LCP</code>已经打开，路由器之间可以进行点对点通信。</p><p><img src="RB_ping_final.png" alt="ping"></p><h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><p>通过该实验，简单地验证了<code>ppp</code>协议在点对点信道中的使用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/ppp通信验证/structure.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;使用Cisco Packet Tracer7 (思科网络模拟器)验证ppp点对点通信。&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://rovo98.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="ppp通信" scheme="http://rovo98.github.io/tags/ppp%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>使用ensp进行简单的路由器互连实验</title>
    <link href="http://rovo98.github.io/posts/cc46ce96/"/>
    <id>http://rovo98.github.io/posts/cc46ce96/</id>
    <published>2018-06-06T16:00:00.000Z</published>
    <updated>2018-10-08T05:08:42.558Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/ensp_路由连接实验/route-structure.png" alt=""></p><p>使用ensp做华为AR1220路由进行简单的互连实验。</p><a id="more"></a><h3 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h3><ul><li>路由器设置</li><li>手动设置静态路由</li></ul><h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><ul><li>华为路由器AR1220</li><li>主机</li><li>Serial设备连接串口线和Copper以太网和千兆以太网连接线</li></ul><p>备注：所有实验设备均由<strong>ensp</strong>模拟。</p><h4 id="路由连接实验设计"><a href="#路由连接实验设计" class="headerlink" title="路由连接实验设计"></a>路由连接实验设计</h4><p>整体设计结构如下：</p><ul><li>1.其中分为六个不同的局域网；</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">192.168.11.0 网段 -&gt;</span><br><span class="line">    主机:   192.168.11.11</span><br><span class="line">            192.168.11.12</span><br><span class="line">    路由器AR6一个GigabitEthernet接口作为该网段的默认网关(192.168.11.1)</span><br><span class="line"></span><br><span class="line">192.168.12.0 网段 -&gt;</span><br><span class="line">    主机:   192.168.12.11</span><br><span class="line">            192.168.12.12</span><br><span class="line">    路由器AR4的一个GigabitEthernet接口作为该网段的默认网关(192.168.12.1)</span><br><span class="line"></span><br><span class="line">192.168.13.0 网段 -&gt;</span><br><span class="line">    主机:    192.168.13.11</span><br><span class="line">            192.168.13.12</span><br><span class="line">            192.168.13.13</span><br><span class="line">   路由器AR7的一个GigabitEthernet接口作为该网段的默认网关(192.168.13.1)</span><br><span class="line">   </span><br><span class="line">1.1.2.0 网段 -&gt; 路由器AR6和路由器AR7之间的接口</span><br><span class="line">1.1.1.0 网段 -&gt; 路由器AR6和AR4之间的接口</span><br><span class="line">1.1.3.0 网段 -&gt; 路由器AR6和AR7之间的接口</span><br></pre></td></tr></table></figure></div><ul><li>2.设备的连接：</li></ul><blockquote><p>除了路由器之间连接使用serial串口连接线外，其他均使用Copper连接线。</p></blockquote><h3 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h3><h4 id="配置各个局域网的ip及其网关"><a href="#配置各个局域网的ip及其网关" class="headerlink" title="配置各个局域网的ip及其网关"></a>配置各个局域网的ip及其网关</h4><ul><li>例如：<code>192.168.11.0</code>网段下的<code>192.168.11.11</code>主机：</li></ul><p><img src="pc1_setting.png" alt="PC1"></p><ul><li>配置 <code>192.168.11.1</code>作为<code>192.168.11.0</code>网段的网关：</li></ul><p><img src="gateway1.png" alt="设置网关"></p><p>所有主机经过配置后，他们应该可以ping通自己网段下的所有主机，如：<code>192.168.11.12</code> ping <code>192.168.11.11</code></p><p><img src="pingTest.png" alt="局域网ping测试"></p><p><strong>[需要注意的是]</strong>： 由于路由器互连时使用的是serial串口，所以路由器之间配置的是serial串口的ip。</p><p>例如：配置AR6的两个serial串口的接口ip为：<code>1.1.1.1</code>和<code>1.1.2.1</code>：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;Huawei&gt; system-view</span><br><span class="line">[Huawei] inter serial 2/0/1</span><br><span class="line">[Huawei-Servial2/0/1] ip address 1.1.1.1 255.255.255.0</span><br><span class="line">[Huawei-Servial2/0/1] quit</span><br><span class="line">[Huawei] inter serial 2/0/0</span><br><span class="line">[Huawei-Serial2/0/0] ip address 1.1.2.1 255.255.255.0</span><br></pre></td></tr></table></figure></div><h4 id="各个路由器的静态路由："><a href="#各个路由器的静态路由：" class="headerlink" title="各个路由器的静态路由："></a>各个路由器的静态路由：</h4><p>对于路由器AR6,我们希望所有<strong>目的网络</strong>为<code>192.168.12.0</code>的数据包都交付给AR4,即下一跳为<code>1.1.1.2</code>;所有目的网络为<code>192.168.13.0</code>的都交给AR7,下一跳为<code>1.1.2.2</code>：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Huawei&gt; system-view</span><br><span class="line">[Huawei] ip route-static 192.168.12.0 255.255.255.0 1.1.1.2</span><br><span class="line">[Huawei] ip route-static 192.168.13.0 255.255.255.0 1.1.2.2</span><br></pre></td></tr></table></figure></div><p>对于路由器AR4，所有目的网络为<code>192.168.11.0</code>的数据包交给AR6，下一跳为：<code>1.1.1.1</code>，目的网络为<code>192.168.13.0</code>的数据包交给AR7，下一跳为：<code>1.1.3.1</code>：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Huawei&gt; system-view</span><br><span class="line">[Huawei] ip route-static 192.168.11.0 255.255.255.0 1.1.1.1</span><br><span class="line">[Huawei] ip route-static 192.168.13.0 255.255.255.0 1.1.3.1</span><br></pre></td></tr></table></figure></div><p>对于路由器AR7， 所有目的网络为<code>192.168.11.0</code>的数据包都交给AR6，下一跳为：<code>1.1.2.1</code>，所有目的网络为<code>192.168.12.0</code>的数据包都交给AR4，下一跳为：<code>1.1.3.2</code>：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Huawei&gt; system-view</span><br><span class="line">[Huawei] ip route-static 192.168.11.0 255.255.255.0 1.1.2.1</span><br><span class="line">[Huawei] ip route-static 192.168.12.0 255.255.255.0 1.1.3.2</span><br></pre></td></tr></table></figure></div><p>经过以上对各个路由器的静态路由的配置后，我们可以通过<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">display ip routing-table</span><br></pre></td></tr></table></figure></div></p><p>来查看各个路由器的路由表：</p><ul><li>AR6路由表：</li></ul><p><img src="route1_info.png" alt="AR6路由表"></p><ul><li>AR4路由表：</li></ul><p><img src="route2_info.png" alt="AR4路由表"></p><ul><li>AR7路由表：</li></ul><p><img src="route3_info.png" alt="AR7路由表"></p><h3 id="测试实验结果"><a href="#测试实验结果" class="headerlink" title="测试实验结果"></a>测试实验结果</h3><p>使用任意一个局域网下的主机ping不同局域网下的主机：</p><p><code>192.168.11.11</code> ping <code>192.168.13.12</code> 和 <code>192.168.12.12</code>:</p><p><img src="tracert1.png" alt="tracert测试1"></p><p><code>192.168.12.11</code> ping <code>192.168.11.12</code> 和 <code>192.168.13.13</code>:</p><p><img src="tracert2.png" alt="tracert测试2"></p><p><code>192.168.13.11</code> ping <code>192.168.11.11</code> 和 <code>192.168.12.11</code>：</p><p><img src="tracert3.png" alt="tracert测试3"></p><p>由以上测试可以看出简单的路由器连接实验成功。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/ensp_路由连接实验/route-structure.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;使用ensp做华为AR1220路由进行简单的互连实验。&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://rovo98.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="路由器" scheme="http://rovo98.github.io/tags/%E8%B7%AF%E7%94%B1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>CentOS7通过yum(yellow dog update modifier) 安装mysql5.7</title>
    <link href="http://rovo98.github.io/posts/86d29d2c/"/>
    <id>http://rovo98.github.io/posts/86d29d2c/</id>
    <published>2018-04-22T16:00:00.000Z</published>
    <updated>2018-10-08T05:08:42.765Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h3 id="配置yum源"><a href="#配置yum源" class="headerlink" title="配置yum源"></a>配置yum源</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载mysql安装源包</span></span><br><span class="line">root @~&gt; wget http://dev.mysql.com/get/mysql57-community-release-el7-8.noarch.rpm</span><br><span class="line"><span class="comment"># 安装mysql源</span></span><br><span class="line">root @~&gt; yum localinstall mysql57-community-release-el7-8.noarch.rpm</span><br></pre></td></tr></table></figure></div><p>检查mysql源是否安装成功:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root @~&gt; yum repolist enabled | grep <span class="string">"mysql.*-community.*"</span></span><br></pre></td></tr></table></figure></div><p>如下图则安装成功:</p><p><img src="repo-resource.png" alt="mysql_source"></p><h3 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ ~&gt; yum install -y mysql-community-server</span><br></pre></td></tr></table></figure></div><h3 id="启动MySQL服务并设置开机自动启动"><a href="#启动MySQL服务并设置开机自动启动" class="headerlink" title="启动MySQL服务并设置开机自动启动"></a>启动MySQL服务并设置开机自动启动</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ ~&gt; systemctl start mysqld</span><br></pre></td></tr></table></figure></div><p>查看MySQL启动状态</p><p><img src="mysql-status.png" alt="mysqld进程状态"></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ ~&gt; systemctl <span class="built_in">enable</span> mysqld</span><br><span class="line">root@ ~&gt; systemctl daemon-reload</span><br></pre></td></tr></table></figure></div><h3 id="修改默认密码"><a href="#修改默认密码" class="headerlink" title="修改默认密码"></a>修改默认密码</h3><p>刚安装完的mysql会自动给root用户分配一个临时密码，而且必须重新设置密码(从5.5版本开始)</p><ul><li>先查看root用户的临时密码</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ ~&gt; grep <span class="string">"temporary password"</span> /var/<span class="built_in">log</span>/mysqld.log</span><br></pre></td></tr></table></figure></div><ul><li>使用临时的密码登录进mysql来设置新的密码</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="built_in">set</span> PASSWORD = PASSWORD(<span class="string">'[YOUR_NEW_PASSWORD]'</span>)</span><br></pre></td></tr></table></figure></div><p><img src="temporary-password.png" alt="查看临时密码"></p><ul><li>可能遇到的问题：设置的密码过于简单mysql报错:</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Your password does not satisfy the current policy requirements.</span><br></pre></td></tr></table></figure></div><p>解决方法：由于刚安装的mysql的密码默认强度是最高的，若想要设置简单的密码就要修改<strong>validate_password_policy</strong>的值，</p><h4 id="validate-password-policy有以下取值："><a href="#validate-password-policy有以下取值：" class="headerlink" title="validate_password_policy有以下取值："></a>validate_password_policy有以下取值：</h4><div class="table-container"><table><thead><tr><th style="text-align:center">Policy</th><th style="text-align:center">Tests Performed</th></tr></thead><tbody><tr><td style="text-align:center">0 or LOW</td><td style="text-align:center">Length</td></tr><tr><td style="text-align:center">1 or MEDIUM</td><td style="text-align:center">Length;numeric,lowercase/uppercase,and special characters</td></tr><tr><td style="text-align:center">2 or STRONG</td><td style="text-align:center">Length;numeric,lowercase/uppercase,and special characters; dictionary file</td></tr></tbody></table></div><p>操作：</p><ul><li>设置安全级别</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="built_in">set</span> global validate_password_policy=0;</span><br></pre></td></tr></table></figure></div><ul><li>设置密码长度为8，可以设置为其他值，最小为4位</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="built_in">set</span> global validate_password_length=4;</span><br></pre></td></tr></table></figure></div><p>之后就可以设置简单的密码了。</p><h3 id="允许root远程登录"><a href="#允许root远程登录" class="headerlink" title="允许root远程登录"></a>允许root远程登录</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; GRANT ALL PRIVILEGES ON *.* TO <span class="string">'root'</span>@<span class="string">'%'</span> IDENTIFIED BY <span class="string">'[YOUR_PASSWORD]'</span> WITH GRANT OPTION;</span><br><span class="line">mysql&gt; flush privileges;</span><br></pre></td></tr></table></figure></div><h3 id="修改字符集编码为UTF-8"><a href="#修改字符集编码为UTF-8" class="headerlink" title="修改字符集编码为UTF-8"></a>修改字符集编码为UTF-8</h3><ul><li>查看当前字符编码</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like <span class="string">"char%';</span></span><br></pre></td></tr></table></figure></div><p>检测是否都是utf-8(filesystem除外)，如果不是就需要修改。 <strong>character_set_server</strong>一般是lantin1。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 停止mysqld服务</span></span><br><span class="line">systemctl stop mysqld</span><br><span class="line"><span class="comment"># 进入my.cnf文件，一般是/etc/路径下</span></span><br><span class="line">vim /etc/my.cnf</span><br><span class="line"><span class="comment"># 在[mysqld]下追加character-set-server=utf-8</span></span><br><span class="line"><span class="comment"># 在[mysql]下追加default-character-set=utf-8</span></span><br><span class="line"><span class="comment"># 启动mysqld</span></span><br><span class="line">systemctl start mysqld</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      CentOS7下安装mysql。
    
    </summary>
    
      <category term="mysql" scheme="http://rovo98.github.io/categories/mysql/"/>
    
    
      <category term="mysql5.7安装" scheme="http://rovo98.github.io/tags/mysql5-7%E5%AE%89%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>Union-Find -- 动态连通性问题算法</title>
    <link href="http://rovo98.github.io/posts/b3f33dac/"/>
    <id>http://rovo98.github.io/posts/b3f33dac/</id>
    <published>2018-03-07T08:00:12.000Z</published>
    <updated>2018-10-08T05:08:41.948Z</updated>
    
    <content type="html"><![CDATA[<p><code>union-find</code>算法主要用于解决动态连通性问题。</p><a id="more"></a><p>我们设计算法时面对的第一个任务就是<strong>精确地定义问题</strong>。为了说明问题，通常会设计一份<code>API</code>来封装所需的基本操作。</p><h2 id="UF-API"><a href="#UF-API" class="headerlink" title="UF API"></a>UF API</h2><p>根据Union Find 算法需求定义接口 - </p><div class="table-container"><table><thead><tr><th style="text-align:center">Method</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td style="text-align:center">UF(int n)</td><td style="text-align:center">以整数标识(0到n-1)初始化n个触点</td></tr><tr><td style="text-align:center">int find(int p)</td><td style="text-align:center">p所在分量的标识符</td></tr><tr><td style="text-align:center">void union(int p, int q)</td><td style="text-align:center">在p和q之间增加一条连接</td></tr><tr><td style="text-align:center">boolean connected(int p, int q)</td><td style="text-align:center">如果p和q存在于同一个分量返回true</td></tr><tr><td style="text-align:center">int count()</td><td style="text-align:center">连通分支的数量</td></tr></tbody></table></div><p>此时，解决动态连通性问题设计算法的问题已经被我们转化为实现这份API。</p><ul><li>定义一种数据结构表示已知的连接</li><li>基于此数据结构实现高效的<code>union()</code>、<code>find()</code>、<code>connected()</code>和<code>count()</code>方法</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UF</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] parent;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UF</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    parent = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        count = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> find(p) == find(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span> ...</span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> ...</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure></div><h3 id="第一种实现方式-quick-find算法"><a href="#第一种实现方式-quick-find算法" class="headerlink" title="第一种实现方式: quick-find算法"></a>第一种实现方式: quick-find算法</h3><p>   这种实现方式保证当且仅当<code>parent[p] == parent[q]</code>时<code>p</code>和<code>q</code>是连通的。即在同一个连通分支的所有触点在<code>parent[]</code>中的值必须全部相同。 也意味着<code>connected(p, q)</code>只需要判断<code>parent[p] == parent[q]</code>，只有在<code>p</code>和<code>q</code>所在连通分支相同时返回<code>true</code>,否则<code>p</code>所在连通分支的所有触点对应<code>parent[]</code>中的值为一个值，而q所在连通分支的所有触点对应<code>parent[]</code>中的值为另一个值。因此我们在合并分量时需要<strong>遍历整个数组</strong>来将所有和<code>parent[p]</code>相等的元素变为<code>parent[q]</code>，或者反过来。<br>由此实现的<code>find()</code>、<code>union()</code>方法如下：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> parent[p];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> rootP = find(p);</span><br><span class="line">    <span class="keyword">int</span> rootQ = find(q);</span><br><span class="line">    <span class="keyword">if</span> (rootP == rootQ) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parent.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (parent[i] == rootQ) parent[i] = rootP;</span><br><span class="line">    &#125;</span><br><span class="line">    count--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="quick-find-算法分析"><a href="#quick-find-算法分析" class="headerlink" title="quick-find 算法分析"></a>quick-find 算法分析</h4><blockquote><p><code>find()</code> 操作速度显然是很快的，因为它只需要访问<code>parent[]</code>数组一次。但quick-find算法一般无法处理大型问题，因为对于每一对输入的触点 <code>union()</code>都需要扫描整个<code>parent[]</code>数组。可以看出此算法的时间复杂度应该为：$O(n^2).$</p><p><strong>命题F: 在quick-find 算法中，每次<code>find()</code> 调用只需要访问数组一次，而归并两个分量的<code>union()</code>操作访问数组的次数在$(N+3)$到$(2N+1)$之间。</strong></p></blockquote><h3 id="第二种实现方式：-quick-union算法"><a href="#第二种实现方式：-quick-union算法" class="headerlink" title="第二种实现方式： quick-union算法"></a>第二种实现方式： quick-union算法</h3><p>该算法的重点是在于提高 <code>union()</code>方法的速度，它和 quick-find 都是基于相同的数据结构 —— 以触点为索引的 <code>parent[]</code> 数组，在此之上，我们用它们来定义更加复杂的结构。令每个触点所对应的 <code>parent[]</code> 元素都是同一个分量中的另一触点名称（也可能是它自己) — 这种联系称为<strong>链接</strong>。</p><p>在实现<code>find()</code>方法时，从给定的触点开始，由它的链接得到另一个触点，再由这个触点的链接到达第三个触点，直到随着链接到达<strong>根触点，链接指向自己的触点</strong>。<br>而对于实现<code>union()</code>方法，只需有由p和q的链接分别去找它们的根触点，然后只需要将一个跟触点链接到另一个即可。由此实现的<code>find()</code>、<code>union()</code>方法如下：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (p != parent[p]) &#123;</span><br><span class="line">    p = parent[p];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> rootP = find(p);</span><br><span class="line">    <span class="keyword">int</span> rootQ = find(q);</span><br><span class="line">    <span class="keyword">if</span> (rootP == rootQ) <span class="keyword">return</span>;</span><br><span class="line">    parent[rootP] = parent[rootQ];</span><br><span class="line">    count--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="quick-union-算法分析"><a href="#quick-union-算法分析" class="headerlink" title="quick-union 算法分析"></a>quick-union 算法分析</h4><blockquote><p>在quick-union 中<code>parent[]</code>数组用父链接的形式表示的一片森林。quick-union 算法明显比quick-find 算法更快，因为它不需要为每一对输入遍历整个数组。</p></blockquote><p>在最好的情况下，<code>find()</code>只需要访问一次数组就能得到一个触点所在的分量的标识符；而在最坏的情况下，需要$2N - 1$次数组访问。<br><strong>我们可以把quick-union看作是quick-find算法的改进</strong>。—— 它将<code>union()</code>操作改进为线性级别。</p><blockquote><p><em>定义： 一棵树的大小是它的节点的数量。树中的一个节点的深度是它到根节点的路径的链接数。树的高度是它的所有节点的最大深度。</em></p><p><strong>命题G: quick-union 算法中的 find() 方法访问数组的次数为1 加上给定触点所对应的节点的深度的两倍。<code>union()</code> 和 <code>connected()</code> 访问数组的次数为两次 <code>find()</code>操作 （如果 union() 中给定的两个触点分别存在于不同的树中则还需要加 1).</strong></p></blockquote><p><strong>由命题G我们可以知道算法在最坏的情况下的运行时间是平方级别的。</strong><br>例如：输入的整数对为$0-1、0-2、0-3$等，$N-1$ 对之后，$N$ 个触点将全部处于相同的集合之中且由quick-union算法得到的树的高度为 $N-1$, 其中0链接到2, 2链接到3，如此下去。由命题G可知，对于整数对 $0 - i$, <code>union()</code> 操作访问数组的次数为$2i + 2$ （触点0的深度为i, 触点 i 的深度为 0）。 处理 N 对整数所需的所有 <code>find()</code> 操作访问数组的总次数为 $2(1+2+…+N)~N^2$。</p><h3 id="第三种实现方式：-加权quick-union算法"><a href="#第三种实现方式：-加权quick-union算法" class="headerlink" title="第三种实现方式： 加权quick-union算法"></a>第三种实现方式： 加权quick-union算法</h3><p>改进quick-union算法，不再随意在<code>union()</code>中将一棵树连接到另一颗树，而是<strong>记录树的大小(节点个数)或高度并总是将较小的树连接到较大的树上</strong>。</p><ul><li>记录树的大小(节点个数)加权</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UF</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] parent;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] rank;</span><br><span class="line">    <span class="keyword">private</span> count;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UF</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    parent = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        rank = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        count = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        parent[i] = i;</span><br><span class="line">            rank[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (p != parent[p]) &#123;</span><br><span class="line">        parent[p] = parent[parent[p]]; <span class="comment">// 路径压缩</span></span><br><span class="line">            p = parent[p];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rootP = find(p);</span><br><span class="line">        <span class="keyword">int</span> rootQ = find(q);</span><br><span class="line">        <span class="keyword">if</span> (rootP == rootQ) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 将较小的树连接到较大的树上</span></span><br><span class="line">        <span class="keyword">if</span> (rank[rootP] &gt; rank[rootQ]) &#123;</span><br><span class="line">        parent[rootQ] = rootP;</span><br><span class="line">            rank[rootP] += rank[rootQ];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        parent[rootP] = rootQ;</span><br><span class="line">            rank[rootQ] += rank[rootP];</span><br><span class="line">        &#125;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li>记录树的高度</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UF</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] parent;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] rank;</span><br><span class="line">    <span class="keyword">private</span> count;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UF</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    parent = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        rank = <span class="keyword">new</span> <span class="keyword">byte</span>[n];</span><br><span class="line">        count = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        parent[i] = i;</span><br><span class="line">            rank[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (p != parent[p]) &#123;</span><br><span class="line">        parent[p] = parent[parent[p]];</span><br><span class="line">            p = parent[p];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rootP = find(p);</span><br><span class="line">        <span class="keyword">int</span> rootQ = find(q);</span><br><span class="line">        <span class="keyword">if</span> (rootP == rootQ) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 将高度较低的树连接到高度较高的树上</span></span><br><span class="line">        <span class="keyword">if</span> (rank[rootP] &gt; rank[rootQ]) &#123;</span><br><span class="line">        parent[rootQ] = rootP;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (rank[rootP] &lt; rank[rootQ]) &#123;</span><br><span class="line">        parent[rootP] = rootQ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">        parent[rootQ] = rootP;</span><br><span class="line">            rank[rootP]++;</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="加权quick-union-算法分析"><a href="#加权quick-union-算法分析" class="headerlink" title="加权quick-union 算法分析"></a>加权quick-union 算法分析</h4><blockquote><p><strong>命题H: 对于 $N$ 个触点，加权 quick-union 算法构造的森林中的任意节点的深度最多为 $lgN$。</strong></p><p>推论: 对于加权 quick-union 算法和 N 个触点， 在最坏的情况下 <code>find()</code>、 <code>connected()</code> 和 <code>union()</code> 的成本的增长数量级为 $log N$。</p></blockquote><p>union-find 的具体实现: <a href="https://github.com/rovo98/ds-and-algs#uf----go-back-to-top" target="_blank" rel="noopener">查看</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;union-find&lt;/code&gt;算法主要用于解决动态连通性问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithms" scheme="http://rovo98.github.io/categories/Algorithms/"/>
    
      <category term="Union Find" scheme="http://rovo98.github.io/categories/Algorithms/Union-Find/"/>
    
    
      <category term="union-find" scheme="http://rovo98.github.io/tags/union-find/"/>
    
  </entry>
  
  <entry>
    <title>基本查找算法 - basical searching algorithms</title>
    <link href="http://rovo98.github.io/posts/d83777d2/"/>
    <id>http://rovo98.github.io/posts/d83777d2/</id>
    <published>2018-03-06T16:00:00.000Z</published>
    <updated>2018-10-08T05:08:41.818Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>基本查找算法，我们只谈<strong>静态查找</strong>的查找算法。</p><h3 id="线性查找-linear-search"><a href="#线性查找-linear-search" class="headerlink" title="线性查找 - linear search"></a>线性查找 - linear search</h3><p>特点： </p><ul><li>从头开始遍历数组，一个一个和<strong>key</strong>比较，查找成功则返回索引值。</li><li>不要求数组是<strong>有序的</strong>。</li><li>时间复杂度为： $O(n)$.</li></ul><h4 id="线性查找原始抽象方法实现如下"><a href="#线性查找原始抽象方法实现如下" class="headerlink" title="线性查找原始抽象方法实现如下:"></a>线性查找原始抽象方法实现如下:</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">linearSearch</span><span class="params">(Comparable[] a, Comparable key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a[i].compareTo(key) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="跳跃查找-jump-search"><a href="#跳跃查找-jump-search" class="headerlink" title="跳跃查找 - jump search"></a>跳跃查找 - jump search</h3><p>特点：</p><ul><li>要求查找数组<strong>有序</strong>；</li><li>主要思想是每次跳跃固定量的元素来确定目标元素所在的区间，再使用线性查找在区间上搜索目标元素。</li><li>时间复杂度为： $O(\sqrt{n})$.</li></ul><p><strong>[notice] : </strong> 假设我们要在一个有n个元素的数组中搜索某个元素，最坏情况下（<strong>当目标元素为最后个元素时），这个算法要跳跃n/m步，在线性搜索时作m-1次比较。</strong>令 $f(n) = ((n/m) + m-1$.当m = $\sqrt{n}$时，f(n) 取最小值，所以通常情况下，跳跃查找所使用的固定跳跃步数为 $\sqrt{n}$. </p><h4 id="跳跃查找的原始抽象方法实现如下："><a href="#跳跃查找的原始抽象方法实现如下：" class="headerlink" title="跳跃查找的原始抽象方法实现如下："></a>跳跃查找的原始抽象方法实现如下：</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">jumpSearch</span><span class="params">(Comparable[] a, Comparable key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = a.length;</span><br><span class="line">    <span class="keyword">int</span> block_size = Math.floor(Math.sqrt(n));</span><br><span class="line"><span class="keyword">int</span> step = block_size;</span><br><span class="line">    <span class="comment">// 查找目标元素可能出现的区间</span></span><br><span class="line">    <span class="keyword">int</span> prev = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (a[Math.min(step, n) - <span class="number">1</span>].compareTo(key) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    prev = step;</span><br><span class="line">        step += block_size;</span><br><span class="line">        <span class="keyword">if</span> (prev &gt;= n)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用线性查找在确定的区间上查找目标元素</span></span><br><span class="line">    <span class="keyword">while</span> (a[prev].compareTo(key) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    prev++;</span><br><span class="line">        <span class="keyword">if</span> (prev == Math.min(step, n))</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a[prev].compareTo(key) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="二分查找-binary-search"><a href="#二分查找-binary-search" class="headerlink" title="二分查找 - binary search"></a>二分查找 - binary search</h3><ul><li>要求数组<strong>有序</strong>。</li><li>将已经排好序的数组分为两个区间(interval), 把区间的中间元素与<strong>key</strong>比较, 若大于则搜索左区间，若小于则搜索右区间，等于则返回元素的索引。<strong>当区间长度为0时（key没出现在数组中)</strong>,返回-1。</li><li>时间复杂度为 ： $O(nlogn)$.</li></ul><h4 id="二分查找原始抽象方法实现如下"><a href="#二分查找原始抽象方法实现如下" class="headerlink" title="二分查找原始抽象方法实现如下:"></a>二分查找原始抽象方法实现如下:</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(Comparable[] a, Comparable key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> lo = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> hi = a.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[mid].compareTo(key) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[mid].compareTo(key) &gt; <span class="number">0</span>)</span><br><span class="line">        hi = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        lo = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearchRecursion</span><span class="params">(Comparable[] a, Comparable key, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (lo &lt;= hi) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[mid].compareTo(key) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[mid].compareTo(key) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> binarySearchRecursion(a, key, mid+<span class="number">1</span>, hi);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> binarySearchRecursion(a, key, lo, mid-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="三分查找-ternary-search"><a href="#三分查找-ternary-search" class="headerlink" title="三分查找 - ternary search"></a>三分查找 - ternary search</h3><p>特点：</p><ul><li>三分查找是二分查找的扩展；</li><li>时间复杂度为 ： $O(nlog_3n)$.</li></ul><p><strong>[notice]:</strong> 虽然看似三分查找的时间复杂度比二分查找的时间复杂度小，但是<strong>在最坏情况下</strong>，二分查找需要$2Log<em>2n + 1$次比较，而三分查找需要$4Log</em>{3}n + 1$次比较</p><h4 id="三分查找原始抽象方法实现如下："><a href="#三分查找原始抽象方法实现如下：" class="headerlink" title="三分查找原始抽象方法实现如下："></a>三分查找原始抽象方法实现如下：</h4><p>特点：</p><ul><li>类似二分查找，将查找数组划分为三个部分来进行查找；</li><li>时间复杂度： $Log_3n$.</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归实现.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ternarySearch</span><span class="params">(Comparable[] a, Comparable key, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (lo &lt;= hi) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid1 = lo + (hi - lo) / <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> mid2 = mid1 + (hi - lo) / <span class="number">3</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (a[mid1].compareTo(key) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> mid1;</span><br><span class="line">        <span class="keyword">if</span> (a[mid2].compareTo(key) == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> mid2;</span><br><span class="line">        <span class="comment">// 目标元素只可能出现在第一部分.</span></span><br><span class="line">        <span class="keyword">if</span> (a[mid1].compareTo(key) &gt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> ternarySearch(a, key, lo, mid1-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 目标元素只可能出现在第三部分.</span></span><br><span class="line">        <span class="keyword">if</span> (a[mid2].compareTo(key) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ternarySearch(a, key, mid2+<span class="number">1</span>, hi);</span><br><span class="line">        <span class="comment">// 目标元素只可能出现在第二部分.</span></span><br><span class="line">        <span class="keyword">return</span> ternarySearch(a, key, mid1+<span class="number">1</span>, mid2-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查找失败.</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="指数搜索-exponential-search"><a href="#指数搜索-exponential-search" class="headerlink" title="指数搜索 - exponential search"></a>指数搜索 - exponential search</h3><p>特点：</p><ul><li>找到目标元素可能出现的区间；</li><li>使用二分查找在区间上查找目标元素;</li><li>时间复杂度： $logn$;</li></ul><p><strong>[notice]</strong>:</p><ol><li>适用于目标数组元素大小趋向于无限大的情况；</li><li>当目标出现在目标数组左边时，指数搜索速度比二分查找快。</li></ol><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">exponentialSearch</span><span class="params">(Comparable[] a, Comparable key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n  = a.length;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n &amp;&amp; a[i].compareTo(key) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"> i = i * <span class="number">2</span>;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> binarySearch(a, key, i/<span class="number">2</span>, Math.min(i, n-<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="插值搜索-interpolation-search"><a href="#插值搜索-interpolation-search" class="headerlink" title="插值搜索 - interpolation search"></a>插值搜索 - interpolation search</h3><p>特点：</p><ul><li><p>原理： 假设查找数组的元素是均匀分布的，使用<strong>直线插值搜索</strong>，不像二分查找那样每次都是搜索区间中间元素。它能够快速的接近目标元素。</p></li><li><p>当元素均匀分布的情况，时间复杂度为: $O(log(log n))$, 最坏情况: $O(n)$.</p></li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java program to implement interpolatoin search.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">interpolationSearch</span><span class="params">(Comparable[] a, Comparable key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> lo = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> hi = a.length - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (lo &lt;= hi &amp;&amp; less(key, a[hi]) &amp;&amp; less(a[lo], key)) &#123;</span><br><span class="line">    <span class="keyword">int</span> pos = lo + (hi - lo) * (key - a[lo]) / (a[hi] - a[lo]);</span><br><span class="line">        <span class="keyword">if</span> (a[pos].compareTo(key) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> pos;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[pos].compareTo(key) &gt; <span class="number">0</span>)</span><br><span class="line">        hi = pos - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            lo = pos + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="NOTICE"><a href="#NOTICE" class="headerlink" title="NOTICE"></a>NOTICE</h3><p>本文中，涉及的算法详细实现和使用，请移步到github<a href="https://github.com/rovo98/ds-and-algs#searching-algorithms----go-back-to-top" target="_blank" rel="noopener">查看</a>。</p>]]></content>
    
    <summary type="html">
    
      使用java实现并简要分析抽象的基本静态查找算法。notes, learning from algs4.
    
    </summary>
    
      <category term="Algorithms" scheme="http://rovo98.github.io/categories/Algorithms/"/>
    
      <category term="searching algs" scheme="http://rovo98.github.io/categories/Algorithms/searching-algs/"/>
    
    
      <category term="basical searching algs" scheme="http://rovo98.github.io/tags/basical-searching-algs/"/>
    
  </entry>
  
  <entry>
    <title>快速排序 - quickSort</title>
    <link href="http://rovo98.github.io/posts/d9de8e4c/"/>
    <id>http://rovo98.github.io/posts/d9de8e4c/</id>
    <published>2018-03-05T16:00:00.000Z</published>
    <updated>2018-10-08T05:08:41.931Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>快速排序的主要特点是：</p><ol><li>原地排序 (in-place);</li><li>将长度为 N 的数组排序所需的时间和NlgN成正比；</li><li>排序内循环比大多数排序算法都要短小，意味着无论是在理论上还是实际中都要更快。</li></ol><p>缺点：<br>    快速排序非常的脆弱，在实现时要非常小心才能避免低劣的性能。</p><h3 id="基本算法"><a href="#基本算法" class="headerlink" title="基本算法"></a>基本算法</h3><p>快速排序是一种<strong>分治</strong>排序算法，它将一个数组分成两个子数组，将两部分独立地排序。不同于归并排序，快速排序的递归调用发生在处理子数之前。</p><p>快速排序方法抽象实现如下：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Quick</span> </span>&#123;</span><br><span class="line"><span class="comment">// quick sort java implement.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">    sort(a, <span class="number">0</span>, a.length-<span class="number">1</span>);</span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">isSorted</span><span class="params">(a)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hi &lt;= lo)<span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> j = partition(a, lo, hi);</span><br><span class="line">        sort(a, lo, j-<span class="number">1</span>);</span><br><span class="line">        sort(a, j+<span class="number">1</span>, hi);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">partition</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = lo;</span><br><span class="line">        <span class="keyword">int</span> j = hi + <span class="number">1</span>;</span><br><span class="line">        Comparable v = a[lo];</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (less(a[++i], v)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lo == hi) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (less(v, a[--j])) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == lo) <span class="keyword">break</span>; <span class="comment">// redundant since a[lo] is sentinel.</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Check if pointers cross.</span></span><br><span class="line">            <span class="keyword">if</span> (j &lt;= i)<span class="keyword">break</span>;</span><br><span class="line">            exch(a, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        exch(a, lo, j);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>上述切分方法示意图: [from algs4]</p><p><img src="quickSort_partition_1.png" alt="切分示意图"></p><p>切分轨迹图: [from algs4]</p><p><img src="quickSort_partition_2.png" alt="切分轨迹图"></p><blockquote><p><strong>命题 K</strong>： 将长度为N的无重复的数组排序，快速排序平均需要 ~ $2NlnN$ 次比较(以及$1/6$的交换)</p></blockquote><p><strong>[notice]</strong>: 尽管快速排序有很多优点，它的基本实现仍有一个潜在的缺点：</p><p>在切分不平衡时该算法可能及其低效。例如： 如果第一个次从最小的元素切分，第二次从第二小的元素切分，则这样每次只会移除一个元素。<br>[solution] : <strong>在快速排序之前将数组随机排序可以避免这种情况的发生</strong>。</p><h3 id="算法改进"><a href="#算法改进" class="headerlink" title="算法改进"></a>算法改进</h3><h4 id="1-切换到插入排序"><a href="#1-切换到插入排序" class="headerlink" title="1.切换到插入排序"></a>1.切换到插入排序</h4><p>和大多数递归排序算法一样(如归并)，改进快速排序的简单方法基于以下两点：</p><ul><li>对于小数组，快速排序比插入排序慢；</li><li>以为递归，快速排序的sort()方法在小数组中也会调用自己。</li></ul><p>改进 ： 将<strong>sort()方法</strong>中的</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (hi &lt;= lo) <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure></div><p>改为：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (hi &lt;= lo + M) &#123;</span><br><span class="line">insertion.sort(a, lo, hi);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>[<strong>notice</strong>] : 这里的切换参数 M 的最佳值是和系统相关的，但是5 ~ 15 之间的任意值在大多数情况下都能令人满意。</p><h4 id="2-三取样切分"><a href="#2-三取样切分" class="headerlink" title="2. 三取样切分"></a>2. 三取样切分</h4><p>改进快速排序性能的第二个方法是<strong>使用子数组的一小部分的中位数来切分数组</strong>。这样的切分的效果更好，但代价是需要计算中位数。</p><ul><li>人们发现将取样设为 3 并用大小居中的元素切分效果<strong>最好</strong>； 我们还可以将取样元素放在数组末尾作为哨兵(sentinel)。</li></ul><p>三取样切分抽象实现 : <a href="https://github.com/rovo98/ds-and-algs/blob/master/ds/sorting/exercises/QuickSortImprovedTwo.java" target="_blank" rel="noopener">详细查看</a></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSortImproved</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">sort(a, <span class="number">0</span>, a.length-<span class="number">1</span>);</span><br><span class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">isSorted</span><span class="params">(a)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> staic <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">dealPivot(a, lo, hi);</span><br><span class="line">    <span class="keyword">int</span> i = lo;</span><br><span class="line">    <span class="keyword">int</span> j = hi - <span class="number">1</span>;</span><br><span class="line">    Comparable v = a[hi - <span class="number">1</span>]; <span class="comment">// set the  pivot at hi -1 as a sentinel.</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (less(a[++i], v)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == hi-<span class="number">1</span>) <span class="keyword">break</span>; <span class="comment">// redundant since a[hi - 1] is sentinel.</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; lo &amp;&amp; less(v, a[--j])) &#123;  &#125;</span><br><span class="line">        </span><br><span class="line">       <span class="comment">// check if pointers cross.</span></span><br><span class="line">        <span class="keyword">if</span> (j &lt;= i) <span class="keyword">break</span>;</span><br><span class="line">        exch(a, i, j);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (i &lt; hi-<span class="number">1</span>) &#123;</span><br><span class="line">   exch(a, i, hi - <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   sort(a, lo, i - <span class="number">1</span>);</span><br><span class="line">   sort(a, i + <span class="number">1</span>, hi);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 三取样并将切分元素放在数组末尾</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dealPivot</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (less(a[mid], a[lo]))</span><br><span class="line">    exch(a, lo, mid);</span><br><span class="line">    <span class="keyword">if</span> (less(a[hi], a[lo]))</span><br><span class="line">    exch(a, lo, hi);</span><br><span class="line">    <span class="keyword">if</span> (less(a[hi], a[mid]))</span><br><span class="line">    exch(a, mid, hi);</span><br><span class="line">    <span class="comment">// put the pivot to hi - 1 as a sentinel.</span></span><br><span class="line">    exch(a, mid, hi - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="熵最优的排序"><a href="#熵最优的排序" class="headerlink" title="熵最优的排序"></a>熵最优的排序</h4><p>实际应用中经常会出现含有大量重复元素的数组，我们实现的快速排序性能尚可，但是<strong>还有巨大的改进空间</strong>。例如：一个元素全部重复的子数组就不需要继续排序了，但我们的快速排序还是会继续将它切分为更小的数组。</p><p>[solution] : <strong>一个简单想法是将数组切分为三个部分，分别为小于、等于和大于切分元素的数组元素</strong>。</p><p>DIjkstra 解法 ： 从左到右遍历数组一次，维护一个指针 lt 使得 a[lo .. lt-1]中的元素都小于v, 一个 gt 使得a[gt+1 .. hi]中的元素都大于v, 一个指针 i 使得a[lt .. i-1]中的元素都等于v, a[i .. gt]中的元素都未确定。</p><ul><li>a[i] 小于 v, 将a[lt]和a[i]交换，将lt 和 i加一；</li><li>a[i] 大于 v, 将a[gt]和a[i]交换， 将gt减一；</li><li>a[i] 等于 v, i++.</li></ul><p>熵最优排序抽象实现： <a href="https://github.com/rovo98/ds-and-algs/blob/master/ds/sorting/exercises/Quick3Ways.java" target="_blank" rel="noopener">详细查看</a></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">sort(a, <span class="number">0</span>, a.length-<span class="number">1</span>);</span><br><span class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">isSorted</span><span class="params">(a)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (hi &lt;= lo) <span class="keyword">return</span>;</span><br><span class="line">    Comparable v = a[lo];</span><br><span class="line">    <span class="keyword">int</span> lt = lo;</span><br><span class="line">    <span class="keyword">int</span> i = lo + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> gt = hi;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (i &lt;= gt) &#123;</span><br><span class="line">    <span class="keyword">if</span> (less(a[i], v)) exch(a, i++,  lt++);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (less(v, a[i]))exch(a, gt--, i);</span><br><span class="line">        <span class="keyword">else</span> i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// since a[lt .. i-1] is sorted.</span></span><br><span class="line">    <span class="comment">// sort the other subarrays recursively.</span></span><br><span class="line">    sort(a, lo, lt-<span class="number">1</span>);</span><br><span class="line">    sort(a, gt+<span class="number">1</span>, hi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>[notice] : <strong>三向切分的最坏情况是所有主键均不相同。</strong>对于标准的快速排序，随着数组规模的增大其运行时间会趋于平均时间，大幅偏离的情况是非常罕见的，因此可以肯定<strong>三向切分的快速排序运行时间和输入的信息量的N倍是成正比的。</strong> ———— 因为对于包含大量重复元素的数组，它将排序时间从线性对数级降到了线性级别。</p><h3 id="NOTICE"><a href="#NOTICE" class="headerlink" title="NOTICE"></a>NOTICE</h3><p>本文中，涉及的算法详细实现和使用，请移步到github<a href="https://github.com/rovo98/ds-and-algs#sorting-algorithms----go-back-to-top" target="_blank" rel="noopener">查看</a>。</p>]]></content>
    
    <summary type="html">
    
      快速排序 notes for algs4.
    
    </summary>
    
      <category term="Algorithms" scheme="http://rovo98.github.io/categories/Algorithms/"/>
    
      <category term="sorting algs" scheme="http://rovo98.github.io/categories/Algorithms/sorting-algs/"/>
    
    
      <category term="sorting algs" scheme="http://rovo98.github.io/tags/sorting-algs/"/>
    
  </entry>
  
  <entry>
    <title>归并排序 - mergeSort</title>
    <link href="http://rovo98.github.io/posts/1368334/"/>
    <id>http://rovo98.github.io/posts/1368334/</id>
    <published>2018-03-04T16:00:00.000Z</published>
    <updated>2018-10-08T05:08:41.878Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>归并排序属于<strong>分治算法(Divide and Conquer)</strong>。通过递归不断把待排序数组分成两个部分，将有序的两部分再重新归并一起来实现对数组的排序。</p><p><strong>[pseudo code for 2-way merge sort]</strong>:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MergeSort(arr[], aux[], lo, hi)</span><br><span class="line">If hi &gt; lo</span><br><span class="line">1. Find the middle point to divide the array into two halves;</span><br><span class="line">int mid = lo + (hi - lo) / 2;</span><br><span class="line">2. Call MergeSort for first half;</span><br><span class="line">MergeSort(arr, aux, lo, mid);</span><br><span class="line">3. Call MergeSort for second half;</span><br><span class="line">MergeSort(arr, aux, mid+1, hi);</span><br><span class="line">4. Merge the two halves sorted in step 2 and 3;</span><br><span class="line">Call merge(arr, aux, lo, mid, hi);</span><br></pre></td></tr></table></figure></div><h3 id="原地归并的抽象方法"><a href="#原地归并的抽象方法" class="headerlink" title="原地归并的抽象方法"></a>原地归并的抽象方法</h3><p>要实现上述的归并方法 — <strong>merge()</strong>很简单，创建一个数组将需要归并的<strong>原数组的两个部分</strong>中的元素放到这个数组中，然后再归并按大小顺序放回原数组。</p><blockquote><p>但是，这里我们要考虑一个问题，当我们用归并排序对一个比较大的数组进行排序时，我们需要进行很多次归并，因此在每一次归并时都创建一个新的数组来存储排序结果会带来问题。我们可以考虑只创建一个<strong>辅助数组<code>aux[]</code></strong>, 在每一个归并时，将原数组需要归并的两个部分复制到<code>aux[]</code>中，再把归并结果放回原数组。</p></blockquote><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(Comparable[] a, Comparable[] aux, <span class="keyword">int</span> lo, <span class="keyword">int</span> mid, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line"><span class="comment">// precondition: a[lo .. mid] and a[mid+1 .. hi] is sorted.</span></span><br><span class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">isSorted</span><span class="params">(a, lo, mid)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">isSorted</span><span class="params">(a, mid+<span class="number">1</span>, hi)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// copy a[lo .. hi] to aux[lo .. hi].</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = lo; k &lt;= hi; k++) &#123;</span><br><span class="line">    aux[k] = a[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = lo;</span><br><span class="line">    <span class="keyword">int</span> j = mid+<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = lo; k &lt;= hi; k++) &#123;</span><br><span class="line">    <span class="keyword">if</span>      (i &gt; mid)               a[k] = aux[j++];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; hi)                a[k] = aux[i++];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (less(aux[j], aux[i]))  a[k] = aux[j++];</span><br><span class="line">        <span class="keyword">else</span>                a[k] = aux[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// postcondition: a[lo .. hi] is sorted.</span></span><br><span class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">isSorted</span><span class="params">(a, lo, hi)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>[说明] : 该方法先将原数组两个需要归并的部分复制到aux[]中，然后<strong>从两个部分的起始位置开始取元素，一直选择两个部分中较小的元素放回原数组中，当有一部分元素取完了，则将另一部分剩余的元素全部放回原数组</strong>。</p><p>原地归并抽象方法轨迹： [from algs4]</p><p><img src="mergeSort_merge.png" alt="原地归并抽象方法轨迹"></p><h3 id="自顶向下的归并排序"><a href="#自顶向下的归并排序" class="headerlink" title="自顶向下的归并排序"></a>自顶向下的归并排序</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = a.length;</span><br><span class="line">    Comparable[] aux = <span class="keyword">new</span> Comparable[n];</span><br><span class="line">    sort(a, aux, <span class="number">0</span>, a.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, Comparable[] aux, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line"><span class="comment">// If array size is 1 then return.</span></span><br><span class="line"><span class="keyword">if</span> (hi &lt;= lo)    <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// Find the middle point to divide array into two halves.</span></span><br><span class="line">    <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// Call the mergeSort for first half.</span></span><br><span class="line">    sort(a, aux, lo, mid);</span><br><span class="line">    <span class="comment">// Call the mergeSort for second half.</span></span><br><span class="line">    sort(a, aux, mid+<span class="number">1</span>, hi);</span><br><span class="line">    <span class="comment">// Merge two halves sorted.</span></span><br><span class="line">    merge(a, aux, lo, mid, hi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>自顶向下归并结果轨迹 : [from algs4]</p><p><img src="mergeSort_ubSort_1.png" alt="自顶向下归并结果轨迹"></p><p>自顶向下归并排序调用轨迹 : [from algs4]</p><p><img src="mergeSort_ubSort_2.png" alt="自顶向下归并排序调用轨迹"></p><blockquote><p><strong>命题 F: 对于长度为 $N$ 的任意数组， 自顶向下归并排序需要 $1/2NlgN$ 至 $NlgN$ 次比较。</strong></p><p>自顶向下的所需时间表达式为 : $T(N) = 2T(N/2) + O(n)$使用解决递归式的 <code>Master method</code> 解得 $T(N) = \Theta(n log n)$</p></blockquote><p>我们可以通过下图来理解命题F, 每个节点都表示一个<code>sort()</code>方法通过<code>merge()</code>方法归并而成的子数组。<strong>这棵树正好有 $n$ 层。对于$0 ~ n-1$ 之间的任意 $k$, 自顶向下的第 $k$ 层有 $2^k$个子数组，每个数组长度为 $2^{n-k}$, 归并最多需要 $2^{n-k}$ 次比较。</strong>因此每层的比较次数为$2^k X 2^{n-k} = 2^n$, n 层总共为 $n2^n = NlgN$。</p><p>子数组树状图 : [from algs4]</p><p><img src="mergeSort_ubSort_3.png" alt="子数组树状图"></p><blockquote><p><strong>命题 G : 对于长度为 $N$ 的任意数组，自顶向下的归并排序最多需要访问数组 $6NlgN$ 次。</strong></p><p>证明： 每次归并最多需要访问数组 $6N$ 次（$2N$ 次用来复制， $2N$次用来将排好序的元素移动回去，另外最多比较$2N$次），根据<strong>命题F</strong>即可得到这个命题的结果。</p></blockquote><p><strong>[小结]</strong>: 归并排序排序算法的缺点是辅助数组所使用的额外空间和N的大小成正比。一些能够大幅度缩短归并排序的运行时间的想法：</p><ul><li>对小规模子数组进行插入排序；</li><li>测试数组是否已经有序；</li><li>不将元素复制到辅助数组中。</li></ul><h3 id="自底向上的归并排序"><a href="#自底向上的归并排序" class="headerlink" title="自底向上的归并排序"></a>自底向上的归并排序</h3><p>实现归并排序另外一种方法是<strong>先归并那些微型数组， 然后再成对归并得到的子数组，直到将整个数组归并在一起</strong>。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MergeBU</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = a.length;</span><br><span class="line">    Comparable[] aux = <span class="keyword">new</span> Comparable[n];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> sz = <span class="number">1</span>; sz &lt; n; sz += sz) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> lo = sz; lo &lt; n-sz; lo += sz+sz) &#123;</span><br><span class="line">        merge(a, aux, lo, lo+sz-<span class="number">1</span>, Math.min(lo+sz+sz-<span class="number">1</span>, n-<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#123;</span><br></pre></td></tr></table></figure></div><p>[注] : 自底向上的归并排序会多次遍历整个数组，根据子数组大小进行两两归并。子数组的大小 sz 的初始值为 1， 每次加倍。最后一个子数组的大小只有在数组大小是 sz 的偶数倍的时候才会等于 sz(否则它会比sz小)。</p><p>自底向上归并排序结果轨迹 ： [from algs4]</p><p><img src="mergeSort_buSort_1.png" alt="自底向上归并排序结果轨迹"></p><blockquote><p><strong>命题 H : 对于长度为 $N$ 的任意数组， 自底向上的归并排序需要 $1/2NlgN$ 至 $NlgN$次比较，最多访问数组 $6NlgN$ 次。</strong></p><p>证明 ： 处理一个数组的遍数正好是 $lgN$(即 $2^n &lt;= N &lt;2^n+1$ 中的 $n$)。每一遍会访问数组6N次。比较次数在 $N/2$ 和 $N$ 之间。</p></blockquote><p>【补充】： 当数组长度为 2 的幂时，自顶向下和自底向上的归并排序所用的比较次数和数组访问次数正好相同，只是顺序不同。其他时候，两种方法的比较和数组访问的次序会有所不同。</p><h3 id="NOTICE"><a href="#NOTICE" class="headerlink" title="NOTICE"></a>NOTICE</h3><p>本文中，涉及的算法详细实现和使用，请移步到github<a href="https://github.com/rovo98/ds-and-algs#sorting-algorithms----go-back-to-top" target="_blank" rel="noopener">查看</a>。</p>]]></content>
    
    <summary type="html">
    
      归并排序 notes, learning from algs4.
    
    </summary>
    
      <category term="Algorithms" scheme="http://rovo98.github.io/categories/Algorithms/"/>
    
      <category term="sorting algs" scheme="http://rovo98.github.io/categories/Algorithms/sorting-algs/"/>
    
    
      <category term="sorting algs" scheme="http://rovo98.github.io/tags/sorting-algs/"/>
    
  </entry>
  
  <entry>
    <title>基本排序算法 - basial sorting algorithms with java implementation</title>
    <link href="http://rovo98.github.io/posts/57d02cec/"/>
    <id>http://rovo98.github.io/posts/57d02cec/</id>
    <published>2018-03-04T16:00:00.000Z</published>
    <updated>2018-10-08T05:08:41.825Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我们关注的主要对象是<strong>重新排列数组元素的算法</strong>， 其中每个元素都有一个<strong>主键</strong>。排序算法的目的就是将所有元素的主键按照某种方式排列(通常按照大小或是字母顺序)。</p></blockquote><a id="more"></a><p>在java中元素通常都是对象，对主键的抽象描述则是通过一种内置的机制(<code>Comparable</code>接口)来完成的。</p><h4 id="排序算法类模板"><a href="#排序算法类模板" class="headerlink" title="排序算法类模板"></a>排序算法类模板</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(Comparable[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    Comparable temp = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*排序算法，如InsertionSort、BubbleSort、</span></span><br><span class="line"><span class="comment">        SelectionSort、ShellSort等*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">        System.out.print(a[i] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(Comparable v, Comparable w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v.compareTo(w) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSorted</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (less(a[i], a[i-<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Unit tests the &#123;<span class="doctag">@code</span> Example&#125; sorting algorithm.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@args</span> command-line arguments.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 测试代码...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>这个类展示的是数组排序实现的框架。代码中实现的排序方法适用于任意实现了<code>Comparable</code>接口的数据类型</strong>。</p><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>无论数组的初始状态是什么，我们都无法确保排序算法都能成功。所以谨慎起见，我们会在测试代码中添加一条语句<code>assert isSorted(a);</code>来确保排序后的数组都是有序的。</p><h4 id="运行时间"><a href="#运行时间" class="headerlink" title="运行时间"></a>运行时间</h4><p>评估算法的性能。首先，要计算各个排序算法在不同的随机输入下的基本操作的次数(包括比较和交换，或者是读写数组的次数)。</p><blockquote><p>排序成本模型 : 在研究排序算法时，我们需要计算比较和交换的数量。<br>  对于不交换元素的算法，我们会计算访问数组的次数。</p></blockquote><h4 id="额外的内存使用"><a href="#额外的内存使用" class="headerlink" title="额外的内存使用"></a>额外的内存使用</h4><p>排序算法的额外内存开销和运行时间是同等重要的。排序算法可以分为两类:</p><ul><li>除了函数调用所需的栈和固定数目的实例变量之外无需额外内存的<strong>原地排序算法</strong>。</li><li>需要额外内存空间来存储另一份数组副本的其他排序算法。</li></ul><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p>上面的排序模板适用于实现了Comparable接口的数据类型。例如, java中封装数字类型的<code>Integer</code>、<code>Double</code>、以及<code>String</code>和其他许多高级数据类型。<br>而对于自己创建的数据类型，我们是要实现Comparable接口就能够保证能够使用排序算法进行排序。</p><p>自定义数据类型样例:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Date</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Date</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> day;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> month;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> year;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Date</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> m, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123; day = d; month = m; year = y; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">day</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> day; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">month</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> month; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">year</span><span class="params">()</span>   </span>&#123; <span class="keyword">return</span> year;  &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Date that)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.year &gt; that.year) <span class="keyword">return</span> +<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.year &lt; that.year) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.month &gt; that.month) <span class="keyword">return</span> +<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.month &lt; that.month) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.day &gt; that.day) <span class="keyword">return</span> +<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.day &lt; that.day) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> month + <span class="string">"/"</span> + day + <span class="string">"/"</span> + year;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>首先，找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置(如果第一个元素就是最小的元素那么它就和自己交换)。 再次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到整个数组排序完成。<strong>不断地选择剩余元素中的最小者</strong>。</p><blockquote><p><strong>命题 A: 对于长度为 $N$ 的数组，选择排序需要大约 $N^2/2$ 次比较和 $N$ 次交换。</strong><br>  证明： 可以通过算法的排序轨迹来证明，用一张$N X N$的表格来表示排序的轨迹，其中每个非灰色字符都表示一次比较。表格中大约有一半的元素不是  灰色的 — 即对角线和其上部分的元素。对角巷上的每个元素都对应真一次交换。通过查看代码我们可以更精确地得到，$0$ 到 $N-1$ 的任意 $i$ 都会  进行一次交换和 $N-1-i$ 次比较，因此   总共有$N$次交换以及 $(N-1)+（N-2)+…+2+1 = N(N-1)/2 ~ N^2/2$。</p></blockquote><p>算法轨迹图示（from algs4)：</p><p><img src="bs_selectionSort_1.png" alt="插入排序算法轨迹例子"></p><p>算法实现:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Selection</span> </span>&#123;</span><br><span class="line"><span class="comment">/* 其他的方法同排序算法模板*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = a.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> min = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (less(a[j], a[min]) &#123;</span><br><span class="line">                min = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            exch(a, i, min);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>与选择排序一样，当前索引左边的所有元素都是有序的，但他们的最终位置不确定，为了给更小的元素腾出空间，它们可能会移动。当索引到达数组的右端时，数组排序就完成了。</p><p>和选择排序不同的是，插入排序<strong>所需的时间取决于输入中元素的初始顺序</strong>。例如对于一个很大且其中的元素已经有序（或接近有序）的数组进行插入排序将会比对随机数组或逆序数组进行排序要快得多。</p><blockquote><p><strong>命题 B : 对于随机排列的长度为 $N$ 且主键不重复的数组, 平均情况下插入排序需要 ~ $N^2/4$次比较以及 $~N^2/4$次交换。最坏情况下需要 ~N^2  /2  次比较和 ~ $N^2/2$次交换，最好情况下需要$N-1$次比较和$0$次交换。</strong><br>  证明： 和证明命题A一样，通过一个$N X N$的算法轨迹表可以很容易就得到交换和比较的次数。最坏的情况下对角线之下所有元素都需要移动位置，最   好情况下都不需要。对于随机排列的数组，在平均情况下每个元素都可能向后移动半个数组的长度 ，因此交换总数是对角线之下的元素总数的二分之。   比较的总次数是交换的次数加上一个额外的项，该项为 $N$ 减去被插入的元素正好是已知的最小   元   素的次数。在最坏情况下（逆序数组），这一   项相对于总数可以忽略不计；在最好的情况下（数组已经有序），这一项等于$N-1$。</p></blockquote><p>插入排序算法轨迹图示（from algs4):</p><p><img src="bs_insertionSort_1.png" alt="插入排序算法轨迹图例"></p><p>算法实现:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Insertion</span> </span>&#123;</span><br><span class="line"><span class="comment">/*其他的方法同排序算法模板*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = a.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j&gt;<span class="number">0</span>&amp;&amp;less(a[j], a[j-<span class="number">1</span>]; j--) &#123;</span><br><span class="line">            exch(a, j, j-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>附加：</strong></p><p>对于插入排序，我们要考虑的更一般情况是<strong>部分有序的数组</strong>。<br><strong>倒置</strong>指的是数组中的两个顺序颠倒的元素。比如EXAMPLE中有11对倒置：<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">E-A  X-A  X-M  X-P  X-LX-E</span><br><span class="line">M-L M-E  P-L  P-E L-E</span><br></pre></td></tr></table></figure></div></p><p>如果数组中倒置的数量小于数组大小的某个倍数，那么我们说这个数组是<strong>部分有序</strong>的。<br>几种典型的部分有序的数组:</p><ul><li>数组中每个元素距离它的最终位置不远；</li><li>一个有序数组接一个小数组；</li><li>数组中只有几个元素位置不正确。</li></ul><p><strong>插入排序对这样的数组很有效，而选择排序则不然。当倒置的数量很少时，插入排序比大部分的其他排序算法都要快</strong>。</p><blockquote><p><strong>命题 C: 插入排序需要的交换的操作和数组的中倒置的数量相同，需要的比较次数大于等于倒置的数量，小于等于倒置的数量加上数组的大小再减一</strong>。<br>  证明： 每次交换都改变了两个顺序颠倒的元素的位置，相当于减少了一对倒置，当倒置数量为0时，排序就完成了。每次交换都对应着一次比较，且$1$   到$N  -1$之间的每个$i$都可能需要一次额外的比较(在<code>a[i]</code>没有达到数组的左端时)。</p></blockquote><p><strong>[算法改进]</strong> : 大幅提高插入排序的速度，在内循环中将较大的元素都向右移动而不是总是交换两个元素(这样访问数组的次数就能减半)。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = a.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    Comparable key = a[i];</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span> (j = i-<span class="number">1</span>; j &gt;= <span class="number">0</span>&amp;&amp;less(key, a[j]); j--) &#123;</span><br><span class="line">        a[j+<span class="number">1</span>] = a[j];</span><br><span class="line">        &#125;</span><br><span class="line">        a[j+<span class="number">1</span>] = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>希尔排序是基于插入排序的快速排序算法.<br>对于规模乱序数组插入排序很慢，因为它只会交换相邻的元素，因此元素只能一点一点地从数组的一端移动到另外一端。<br>希尔排序为了加快速度简单地改进了插入排序 —— 交换不相邻的元素以对数组的<strong>局部</strong>进行排序，并最终使用插入排序将局部有序的数组排序。</p><p><strong>希尔排序的思想</strong>:使任意间隔为h的元素都是有序的。<br>这样的数组称为<strong>h有序数组</strong>。对于任意以1为结尾的h序列（递增序列），我们使用它都能将数组排序。</p><p>算法实现： —— 使用的递增序列来自 algs4.</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shell</span> </span>&#123;</span><br><span class="line"><span class="comment">/*其他排序算法方法同模板*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> n = a.length;</span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (h &lt; n/<span class="number">3</span>) h = <span class="number">3</span> * h + <span class="number">1</span>; <span class="comment">// 1， 4， 13， 40， 121， ...</span></span><br><span class="line">        <span class="keyword">while</span> (h &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= h&amp;&amp;less(a[j], a[j-h]); j -= h) &#123;</span><br><span class="line">                exch(a, j, j-h);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            h /= <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>[递增序列的选择]</strong> : 算法的性能不仅取决于h，还取决与h之间的数学性质。目前还没有人能证明某个递增序列是”最好的”。以上算法实现使用的递增序列（使用序列 $1/2(3^k-1)$,从N/3开始递减至1.）的计算和使用都很简单且和复杂的递增序列的性能接近。</p><p>算法轨迹图例 — example (from algs4):</p><p><img src="bs_shellSort_1.png" alt="希尔排序算法轨迹图例"></p><p><strong>实际应用</strong>: 对于中等大小的数组它的运行时间是可以接受的且它的代码量小，不需要额外的内存空间。<em>所以在面临一个排序问题而没有系统排序函数可用时，可先用希尔排序，然后再考虑是否将它替换为更加复杂的排序算法</em>。</p><p><strong>[算法改进]</strong> : 由于希尔排序是基于插入排序，所以我们可以参照插入排序的改进，对希尔排序进行改进 — 把内循环中较大的元素右移而不是交换两个元素。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = a.length;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (h &lt; n/<span class="number">3</span>) h = <span class="number">3</span> * h + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (h &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h; i &lt; n; i++) &#123;</span><br><span class="line">        Comparable key = a[i];</span><br><span class="line">            <span class="keyword">int</span> j;</span><br><span class="line">            <span class="keyword">for</span> (j = i-h; j &gt;= <span class="number">0</span>&amp;&amp;less(key, a[j]); j -= h) &#123;</span><br><span class="line">            a[j+h] = a[j];</span><br><span class="line">            &#125;</span><br><span class="line">            a[j+h] = key;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="附加-——-冒泡排序"><a href="#附加-——-冒泡排序" class="headerlink" title="附加 —— 冒泡排序"></a>附加 —— 冒泡排序</h3><p>冒泡排序相对比较简单，这里直接给出它的实现:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bubble</span> </span>&#123;</span><br><span class="line"><span class="comment">/*其他排序算法方法同排序算法模板*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">int</span> n = a.length;</span><br><span class="line"> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n&amp;&amp;flag == <span class="keyword">true</span>; i++) &#123;</span><br><span class="line"> flag = <span class="keyword">false</span>;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n-i; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (less(a[j+<span class="number">1</span>], a[j]) &#123;</span><br><span class="line">        exch(a, j+<span class="number">1</span>, j);</span><br><span class="line">           flag = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></div><p><strong>算法分析</strong>: 对于冒泡排序，最坏情况下，算法需要进行N-1趟排序，总的数组元素比较的次数为$(N-1)+(N-2)+…+1$ ~ $N^2/2$， 总的交换次数为数组中<strong>倒置</strong>的数量。</p><h3 id="NOTICE"><a href="#NOTICE" class="headerlink" title="NOTICE"></a>NOTICE</h3><p>本文中，涉及的算法详细实现和使用，请移步到github<a href="https://github.com/rovo98/ds-and-algs#sorting-algorithms----go-back-to-top" target="_blank" rel="noopener">查看</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;我们关注的主要对象是&lt;strong&gt;重新排列数组元素的算法&lt;/strong&gt;， 其中每个元素都有一个&lt;strong&gt;主键&lt;/strong&gt;。排序算法的目的就是将所有元素的主键按照某种方式排列(通常按照大小或是字母顺序)。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Algorithms" scheme="http://rovo98.github.io/categories/Algorithms/"/>
    
      <category term="sorting algs" scheme="http://rovo98.github.io/categories/Algorithms/sorting-algs/"/>
    
    
      <category term="sorting algs" scheme="http://rovo98.github.io/tags/sorting-algs/"/>
    
  </entry>
  
  <entry>
    <title>Advanture 1 Leetcode - 944 - Delete Columns to Make Sorted</title>
    <link href="http://rovo98.github.io/posts/f5b699c8/"/>
    <id>http://rovo98.github.io/posts/f5b699c8/</id>
    <published>2018-02-10T02:00:00.000Z</published>
    <updated>2018-11-27T05:22:17.036Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>给出由 N 个小写字母串组成的数组 <code>A</code>，所有小写字母串的长度都相同。<br>现在，我们可以选择任何一组删除索引，对于每个字符串，我们将删除这些索引中的所有字符。<br>举个例子，如果字符串为 <code>&quot;abcdef&quot;</code>，且删除索引是 <code>{0, 2, 3}</code>，那么删除之后的最终字符串为 <code>&quot;bef&quot;</code>。<br>假设我们选择了一组删除索引 <code>D</code>，在执行删除操作之后，<code>A</code> 中剩余的每一列都是有序的。<br>形式上，第 <code>c</code> 列为 <code>[A[0][c], A[1][c], ..., A[A.length-1][c]]</code><br>返回 <code>D.length</code> 的最小可能值。<br><br></p><ul><li><a href="https://leetcode-cn.com/problems/delete-columns-to-make-sorted/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/delete-columns-to-make-sorted/</a>(中文)</li><li><a href="https://leetcode.com/problems/delete-columns-to-make-sorted/" target="_blank" rel="noopener">https://leetcode.com/problems/delete-columns-to-make-sorted/</a>(en)<br><br><br>示例 1：<br>输入：[“cba”,”daf”,”ghi”]<br>输出：1<br>示例 2：<br>输入：[“a”,”b”]<br>输出：0<br>示例 3：<br>输入：[“zyx”,”wvu”,”tsr”]<br>输出：3<br>提示：<br>1 &lt;= A.length &lt;= 100<br>1 &lt;= A[i].length &lt;= 1000</li></ul></blockquote><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>对于这种可以快速得出解题思路的题目：</p><div class="note primary"><p>由于每个字符串的长度一样，所以我们只需要依次比较字符串对应的每一列，<strong>判断是否满足非降序</strong>即可得到结果。</p></div><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDeletionSize</span><span class="params">(String[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = A[<span class="number">0</span>].length(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = A.length-<span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (A[j].charAt(i) &gt; A[j+<span class="number">1</span>].charAt(i)) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>复杂度分析(Complexity Analysis)</strong>:</p><ul><li>时间复杂度(Time complexity): $O(n)$</li><li>空间复杂度(Space complexity): $O(1)$</li></ul><div class="note waring"><p>此题目，在<code>leetcode</code>上被归类为<code>greedy</code>，但我觉的解题思路并没怎么体现贪心算法的思想。。。</p></div>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;给出由 N 个小写字母串组成的数组 &lt;code&gt;A&lt;/code&gt;，所有小写字母串的长度都相同。&lt;br&gt;现在，我们可以选择任何一组删除索引，对于每个字符串，我们将删除这些索引中的所有字符。&lt;br&gt;举个例子，如果字符串为 &lt;code&gt;&amp;quot;abcdef&amp;quot;&lt;/code&gt;，且删除索引是 &lt;code&gt;{0, 2, 3}&lt;/code&gt;，那么删除之后的最终字符串为 &lt;code&gt;&amp;quot;bef&amp;quot;&lt;/code&gt;。&lt;br&gt;假设我们选择了一组删除索引 &lt;code&gt;D&lt;/code&gt;，在执行删除操作之后，&lt;code&gt;A&lt;/code&gt; 中剩余的每一列都是有序的。&lt;br&gt;形式上，第 &lt;code&gt;c&lt;/code&gt; 列为 &lt;code&gt;[A[0][c], A[1][c], ..., A[A.length-1][c]]&lt;/code&gt;&lt;br&gt;返回 &lt;code&gt;D.length&lt;/code&gt; 的最小可能值。&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/delete-columns-to-make-sorted/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/delete-columns-to-make-sorted/&lt;/a&gt;(中文)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://leetcode.com/problems/delete-columns-to-make-sorted/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/delete-columns-to-make-sorted/&lt;/a&gt;(en)&lt;br&gt;&lt;br&gt;&lt;br&gt;示例 1：&lt;br&gt;输入：[“cba”,”daf”,”ghi”]&lt;br&gt;输出：1&lt;br&gt;示例 2：&lt;br&gt;输入：[“a”,”b”]&lt;br&gt;输出：0&lt;br&gt;示例 3：&lt;br&gt;输入：[“zyx”,”wvu”,”tsr”]&lt;br&gt;输出：3&lt;br&gt;提示：&lt;br&gt;1 &amp;lt;= A.length &amp;lt;= 100&lt;br&gt;1 &amp;lt;= A[i].length &amp;lt;= 1000&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://rovo98.github.io/categories/Leetcode/"/>
    
    
      <category term="leetcode-greedy-easy" scheme="http://rovo98.github.io/tags/leetcode-greedy-easy/"/>
    
  </entry>
  
  <entry>
    <title>Advantrue 1 - Leetcode 189 - Rotate Array</title>
    <link href="http://rovo98.github.io/posts/885fe7d0/"/>
    <id>http://rovo98.github.io/posts/885fe7d0/</id>
    <published>2018-02-02T02:00:00.000Z</published>
    <updated>2018-11-30T16:16:21.492Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。<br>链接:</p><ol><li><a href="https://leetcode-cn.com/problems/rotate-array/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/rotate-array/</a>(中文)</li><li><a href="https://leetcode.com/problems/rotate-array/" target="_blank" rel="noopener">https://leetcode.com/problems/rotate-array/</a>(en)</li></ol><p>示例 1:</p><p>输入: [1,2,3,4,5,6,7] 和 k = 3<br>输出: [5,6,7,1,2,3,4]<br>解释:<br>向右旋转 1 步: [7,1,2,3,4,5,6]<br>向右旋转 2 步: [6,7,1,2,3,4,5]<br>向右旋转 3 步: [5,6,7,1,2,3,4]<br>示例 2:</p><p>输入: [-1,-100,3,99] 和 k = 2<br>输出: [3,99,-1,-100]<br>解释:<br>向右旋转 1 步: [99,-1,-100,3]<br>向右旋转 2 步: [3,99,-1,-100]<br>说明:</p><p>尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。<br>要求使用空间复杂度为 O(1) 的原地算法。</p></blockquote><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>首先考虑考虑<code>brute-force</code>暴力解法，要使数组中的元素整体右移<code>k</code>位，最直接的方式是循环<code>k</code>次，每次循环让每个元素依次跟最后一个元素进行交换<code>swap</code>即可。</p><blockquote><p>例如: input : [1, 2, 3, 4], k = 1<br>      loop1: 4, 2, 3, 1 -&gt;<br>             4, 1, 3, 2 -&gt;<br>             4, 1, 2, 3</p></blockquote><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> last = nums[nums.length-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[j];</span><br><span class="line">                nums[j] = last;</span><br><span class="line">                last = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>复杂度分析(Compelxity Analysis):</strong></p><ul><li>时间复杂度(Time complexity): $O(kn)$</li><li>空间复杂度(Space complexity): $O(1)$</li></ul><p>Submission status:</p><blockquote><p>该解法通过所有测试用例，但是执行时间为<code>109 ms</code>, 击败<code>14.9%</code>的<code>java</code>代码提交。</p></blockquote><div class="note primary"><p>解题思路二:</p><blockquote><p>利用辅助数组，先将需要移动变换的元素放在移动后的位置，再将辅助数组元素移回原数组.</p></blockquote></div><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] aux = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            aux[(i+k) % nums.length] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; aux.length; i++) &#123;</span><br><span class="line">            nums[i] = aux[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>复杂度分析(Compelxity Analysis):</strong></p><ul><li>时间复杂度(Time complexity): $O(n)$</li><li>空间复杂度(Space complexity): $O(n)$</li></ul><p>Submission status:</p><blockquote><p>代码提交运行时间: <code>1 ms</code> 击败<code>53.8%</code>的<code>java</code>提交代码。</p></blockquote><div class="note primary"><p>解题思路三:</p><p>除了上面给出的第二种方案，还有更好的解题方法，能够做到<code>O(n)</code>运行时间，以及<code>O(1)</code>的空间复杂度.</p></div><blockquote><p>思路: 拿题目给定的例子来说，[1,2,3,4,5,6,7], k = 3.<br>首先将数组划分成两个部分: <code>0~nums.length-k-1</code>,即<code>[1,2,3,4]和</code>nums.length-k ~ nums.length-1],即<code>[5,6,7]</code>,把两个部分进行翻转，此时数组变成<code>[4,3,2,1,7,6,5]</code>.<br>最后，将整个数组进行翻转即可得到我们想要的结果: <code>[5,6,7,1,2,3,4]</code>.</p></blockquote><div class="note warning"><p>需要注意的是，需要对<code>k</code>进行处理，当<code>k &gt; nums.length</code>情况，会出现越界情况。<br>解决方法: 使<code>k</code>进行 <strong>mod</strong> <code>nums.length</code>运算(<code>k = k % nums.length</code>).</p></div><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        k %= nums.length;</span><br><span class="line">        reverse(nums, <span class="number">0</span>, nums.length-k - <span class="number">1</span>);</span><br><span class="line">        reverse(nums, nums.length-k, nums.length-<span class="number">1</span>);</span><br><span class="line">        reverse(nums, <span class="number">0</span>, nums.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">            nums[i] = nums[j];</span><br><span class="line">            nums[j] = temp;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>复杂度分析(Complexity Analysis)</strong>:</p><ul><li>时间复杂度(Time complexity): $O(n)$</li><li>空间复杂度(Space complexity): $O(1)$</li></ul><p>Submission status:</p><blockquote><p>代码提交运行时间: <code>0 ms</code>, 击败<code>100%</code>的<code>java</code>提交代码。</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在处理数组问题时，需要非常小心，时刻注意边界，避免发生数组越界问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。&lt;br&gt;链接:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/rotate-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/rotate-array/&lt;/a&gt;(中文)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://leetcode.com/problems/rotate-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/rotate-array/&lt;/a&gt;(en)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;示例 1:&lt;/p&gt;
&lt;p&gt;输入: [1,2,3,4,5,6,7] 和 k = 3&lt;br&gt;输出: [5,6,7,1,2,3,4]&lt;br&gt;解释:&lt;br&gt;向右旋转 1 步: [7,1,2,3,4,5,6]&lt;br&gt;向右旋转 2 步: [6,7,1,2,3,4,5]&lt;br&gt;向右旋转 3 步: [5,6,7,1,2,3,4]&lt;br&gt;示例 2:&lt;/p&gt;
&lt;p&gt;输入: [-1,-100,3,99] 和 k = 2&lt;br&gt;输出: [3,99,-1,-100]&lt;br&gt;解释:&lt;br&gt;向右旋转 1 步: [99,-1,-100,3]&lt;br&gt;向右旋转 2 步: [3,99,-1,-100]&lt;br&gt;说明:&lt;/p&gt;
&lt;p&gt;尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。&lt;br&gt;要求使用空间复杂度为 O(1) 的原地算法。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://rovo98.github.io/categories/Leetcode/"/>
    
    
      <category term="leetcode-array-easy" scheme="http://rovo98.github.io/tags/leetcode-array-easy/"/>
    
  </entry>
  
  <entry>
    <title>Advantrue 1 - Leetcode 11 - Container With Most Water</title>
    <link href="http://rovo98.github.io/posts/dac7fdaa/"/>
    <id>http://rovo98.github.io/posts/dac7fdaa/</id>
    <published>2018-02-01T08:01:00.000Z</published>
    <updated>2018-11-27T05:23:28.368Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>给定 n 个非负整数 <code>a1，a2，...，an</code>，每个数代表坐标中的一个点 <code>(i, ai)</code> 。在坐标内画 <code>n</code> 条垂直线，垂直线 <code>i</code> 的两个端点分别为 <code>(i, ai)</code> 和 <code>(i, 0)</code>。找出其中的两条线，使得它们与 <code>x</code> 轴共同构成的容器可以容纳最多的水。<br><br></p><ul><li><a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/container-with-most-water/</a>(中文)</li><li><a href="https://leetcode.com/problems/container-with-most-water/" target="_blank" rel="noopener">https://leetcode.com/problems/container-with-most-water/</a>(en)<br><br><br>说明：你不能倾斜容器，且 n 的值至少为 2。<br>示例:<br>输入: [1,8,6,2,5,4,8,3,7]<br>输出: 49</li></ul></blockquote><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>对于这样的题目，很明显可以快速的使用<code>brute-force</code>方式得到解法:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxArea = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; height; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = (j-i) * (height[i]&gt;height[j]?height[j]:height[i]);</span><br><span class="line">                <span class="keyword">if</span> (temp &gt; maxArea)</span><br><span class="line">                    maxArea = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>复杂度分析(Complexity Analysis)</strong>:</p><ul><li>时间复杂度(Time complexity): $O(n^2)$</li><li>空间复杂度(Space complexity): $O(1)$</li></ul><div class="note primary"><p>显然使用<code>brute-force</code>解法设计的算法是正确的，但是时间复杂度是$O(n^2)$级别，因此我们需要考虑优化。<br>代码提交状况:<br>运行时间(Runtime): 269 ms<br>beats rate: 20.1%</p></div><div class="note warning"><p>其实仔细看的话，要使围成的矩形面积最大，无非就是让长和宽尽量的大，因此我们可以使用<code>Two-pointers</code>双指针的思想:<br>使用两个指针<code>i,j</code>分别指向<code>0</code>和<code>height.length-1</code>，让一开始的<code>x</code>坐标距离最大化，然后判断它们所对应的高度谁低，<br>依据较低的高度值计算面积，再将对应索引指针增<code>1</code>(对于低索引指针)或减<code>1</code>(高索引指针)。</p></div><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxArea = Integer.MIN_VAlUE;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = height.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="comment">// int x = j - i;</span></span><br><span class="line">            <span class="comment">// maxArea = Math.max(maxArea,Math.min(heigth[i], height[j])*x);</span></span><br><span class="line">            <span class="comment">// if (height[i] &lt; height[j]) &#123;</span></span><br><span class="line">            <span class="comment">//     i++;</span></span><br><span class="line">            <span class="comment">// &#125; else &#123;</span></span><br><span class="line">            <span class="comment">//     j--;</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            <span class="comment">// 对代码进行缩减</span></span><br><span class="line">            maxArea = Math.max(maxArea, height[j]&lt;height[i]?(j-i)*height[j--]:(j-i))*height[i++]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>复杂度分析(Complexity Analysis)</strong>:</p><ul><li>时间复杂度(Time complexity): $O(n)$</li><li>空间复杂度(Space complexity): $O(1)$</li></ul><div class="note primary"><p>使用<strong>双指针</strong>，只需要一次遍历就能得到结果。可以见得双指针是非常有效的工具，也是数组类问题中常见的解题思路: 例如，对于已经排好序的两数之和(Two sum - sorted)问题,就可以使用双指针进行解决。</p><p>代码提交状况:<br>运行时间(Runtime): 6 ms<br>beat rate: 65.95%</p></div>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;给定 n 个非负整数 &lt;code&gt;a1，a2，...，an&lt;/code&gt;，每个数代表坐标中的一个点 &lt;code&gt;(i, ai)&lt;/code&gt; 。在坐标内画 &lt;code&gt;n&lt;/code&gt; 条垂直线，垂直线 &lt;code&gt;i&lt;/code&gt; 的两个端点分别为 &lt;code&gt;(i, ai)&lt;/code&gt; 和 &lt;code&gt;(i, 0)&lt;/code&gt;。找出其中的两条线，使得它们与 &lt;code&gt;x&lt;/code&gt; 轴共同构成的容器可以容纳最多的水。&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/container-with-most-water/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/container-with-most-water/&lt;/a&gt;(中文)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://leetcode.com/problems/container-with-most-water/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/container-with-most-water/&lt;/a&gt;(en)&lt;br&gt;&lt;br&gt;&lt;br&gt;说明：你不能倾斜容器，且 n 的值至少为 2。&lt;br&gt;示例:&lt;br&gt;输入: [1,8,6,2,5,4,8,3,7]&lt;br&gt;输出: 49&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://rovo98.github.io/categories/Leetcode/"/>
    
    
      <category term="leetcode-array-medium" scheme="http://rovo98.github.io/tags/leetcode-array-medium/"/>
    
  </entry>
  
  <entry>
    <title>Advanture 1 - Leetcode 561 - Array Partition I</title>
    <link href="http://rovo98.github.io/posts/270f73f9/"/>
    <id>http://rovo98.github.io/posts/270f73f9/</id>
    <published>2018-02-01T06:12:30.000Z</published>
    <updated>2018-11-27T05:23:18.482Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>给定长度为 2n 的数组, 你的任务是将这些数分成 n 对, 例如 (a1, b1), (a2, b2), …, (an, bn) ，使得从1 到 n 的 min(ai, bi) 总和最大。<br><br><br>链接:</p><ol><li><a href="https://leetcode.com/problems/array-partition-i/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/array-partition-i/</a>(中文)</li><li><a href="https://leetcode.com/problems/array-partition-i/" target="_blank" rel="noopener">https://leetcode.com/problems/array-partition-i/</a>(en)</li></ol><p>示例 1:</p></blockquote><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,4,3,2]</span><br><span class="line"></span><br><span class="line">输出: 4</span><br><span class="line">解释: n 等于 2, 最大总和为 4 = min(1, 2) + min(3, 4).</span><br></pre></td></tr></table></figure></div><blockquote><p>提示:</p><ol><li>n 是正整数,范围在 [1, 10000].</li><li>数组中的元素范围在 [-10000, 10000].</li></ol></blockquote><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>个人解题思路，观察给定的例子，很容易发现，对于一个给定的$2n$大小的数组，只要在组成数对时每次都从数组选择最小的连两个数来组成$n$个数对。所获得的$1到n的min(a_i,b_i)$总和最大。</p><p>证明: 可以使用数学归纳法进行证明。</p><blockquote><p>因此，首先考虑将数组进行排序，然后将所有奇数位置的元素加和起来就是结果.</p></blockquote><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">arrayPairSum</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="comment">// sort the array first if it is unsorted.</span></span><br><span class="line">        <span class="keyword">if</span> (!isSorted(nums))</span><br><span class="line">            Arrays.sort(nums);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i+=<span class="number">2</span>) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// simple tool for sorting a integer array.</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSorted</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i]&gt;arr[i+<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>复杂度分析(Compelxity Analysis):</strong></p><ul><li>时间复杂度(Time complexity): $O(nlogn)$，主要取决所使用的排序算法</li><li>空间复杂度(Space complexity): $O(1)$</li></ul><p>Submission status:</p><blockquote><p>以上解法，通过所有测试用例，运行时间$32 ms$击败$28.65$%的提交(英文版leetcode)</p><p>可以清楚的了解到该问题还有更好的解法。<br>由于<strong>我的解题思路基于比较的排序算法，因此时间复杂度$O(nlogn)$已是最优</strong>,需要考虑另外的解题思路。</p></blockquote><p>如果不排序的情况下，得到结果。？？？ —&gt; emmm…. 没想到。。。</p><blockquote><p>额…, 解题思路不变，还是基于排序，但是应用<strong>空间换时间</strong>的思想，因此容易想到利用<strong>桶排序</strong>对给定数组进行排序(毕竟数组元素范围已经给定$-10000 ~ 10000$)</p></blockquote><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">arrayPairSum</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">20001</span>];</span><br><span class="line">        <span class="keyword">int</span> maxElemt = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> minElemt = Integer.MAX_VALUE;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            bucket[nums[i]+<span class="number">10000</span>]++;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; maxElemt)</span><br><span class="line">                maxElemt = nums[i];</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; minElemt)</span><br><span class="line">                minElemt = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        minElemt += <span class="number">10000</span>;  <span class="comment">// offset is 10000</span></span><br><span class="line">        maxElemt += <span class="number">10000</span>;</span><br><span class="line">        <span class="keyword">boolean</span> isOdd = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = minElemt; i &lt;= maxElemt; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bucket[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bucket[i]; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (isOdd)</span><br><span class="line">                        result += (i - <span class="number">10000</span>);</span><br><span class="line">                    isOdd = !isOdd;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="note primary"><p>代码简单解释，由于给定数组元素的范围为$-10000$ ~ $10000$, 因此桶排序所需要的总的容量为$20000$, 对给定数组出现的元素进行偏移(偏移量为$10000$)<br><code>bucket[nums[i]+10000]++</code>，使用两个整型变量<code>minElemt</code>和<code>maxElemt</code>确定元素出现的范围, 使用<em>flag</em>变量<code>isOdd</code>判断当前处理元素是处于奇数位置还是偶数位置。</p></div><p><strong>复杂度分析(Complexity Analysis)</strong>:</p><ul><li>时间复杂度(Time complexity): $O(n)$, 就算是数组所有元素都相同的情况，也是只要遍历$n$次</li><li>空间复杂度(Space complexity): $O(n)$ 对于该题目来说，$n为20000$</li></ul><p><strong>Submission status</strong>:</p><blockquote><p>代码提交状况: 运行时间$7 ms$,超过$100$%的<code>java</code>代码提交。</p></blockquote><p><img src="leetcode-561-2.png" alt=""></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>第一种解法是通用解法，可以适用于不同的给定数组元素范围，而第二种解法只适用于此题，当元素范围比较大时，所花费的空间代价高。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;给定长度为 2n 的数组, 你的任务是将这些数分成 n 对, 例如 (a1, b1), (a2, b2), …, (an, bn) ，使得从1 到 n 的 min(ai, bi) 总和最大。&lt;br&gt;&lt;br&gt;&lt;br&gt;链接:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://leetcode.com/problems/array-partition-i/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/array-partition-i/&lt;/a&gt;(中文)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://leetcode.com/problems/array-partition-i/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/array-partition-i/&lt;/a&gt;(en)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;示例 1:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [1,4,3,2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: n 等于 2, 最大总和为 4 = min(1, 2) + min(3, 4).&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;提示:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;n 是正整数,范围在 [1, 10000].&lt;/li&gt;
&lt;li&gt;数组中的元素范围在 [-10000, 10000].&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://rovo98.github.io/categories/Leetcode/"/>
    
    
      <category term="leetcode-array-easy" scheme="http://rovo98.github.io/tags/leetcode-array-easy/"/>
    
  </entry>
  
  <entry>
    <title>Advanture 1 - leetcode 1 - Two Sum</title>
    <link href="http://rovo98.github.io/posts/917327d3/"/>
    <id>http://rovo98.github.io/posts/917327d3/</id>
    <published>2018-02-01T01:00:30.000Z</published>
    <updated>2018-11-27T05:23:55.808Z</updated>
    
    <content type="html"><![CDATA[<p><code>leetcode</code>解题思路总结:</p><blockquote><p>给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。</p><p>你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。<br>链接:</p><ul><li><a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/two-sum/</a>(中文)</li><li><a href="https://leetcode.com/problems/two-sum/" target="_blank" rel="noopener">https://leetcode.com/problems/two-sum/</a>(en)</li></ul><p>示例:</p></blockquote><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [2, 7, 11, 15], target = 9</span><br><span class="line"></span><br><span class="line">因为 nums[0] + nums[1] = 2 + 7 = 9</span><br><span class="line">所以返回 [0, 1]</span><br></pre></td></tr></table></figure></div><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>对于这样的题目，最容易想到的是<code>brute-force</code>暴力解法, 直接两重循环进行迭代.</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] == target-nums[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;i, j&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Returns null if solution not found.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>复杂度分析(Complexity Analysising):</strong></p><ul><li>时间复杂度(Time complexity): $O(n^2)$</li><li>空间复杂度(Space complexity): $O(1)$</li></ul><p>暴力解法虽然可行，但是时间复杂度为$O(n^2)$, 考虑进行优化，首先想到是可以以空间换时间:</p><div class="note primary"><p>如果能够把给定数组的数，用某种数据结构将每个数的数值以及对应的索引(index)保存起来，则只需要用一次遍历查找<br><code>target - nums[i]</code>是否存在于该数据结构中，且非<code>nums[i]</code>即可。</p></div><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> remain = target - map.get(nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(remain) &amp;&amp; map.get(remain) != i)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;i, map.get(remain)&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// returns null if solution not found.</span></span><br><span class="line">        reutrn <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>复杂度分析(Complexity Analysising)</strong>:</p><ul><li>时间复杂度(Time complexity): $O(n)$</li><li>空间复杂度(Space complexity): $O(n)$</li></ul><div class="note warning"><p>年轻的我，本以为上面的这种解法已经是最优的了，但是看完讨论区之后，才焕然大悟，它还可以进行优化:<br>仔细看的话，上面的<code>HashMap</code>算法访问了<code>nums</code>数组两遍，而接下来，从<code>leetcode</code>上学习到的优化方法就是<strong>将<code>nums</code>数组的访问从两遍降到一遍</strong>.</p></div><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> remain = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(remain))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;map.get(remain), i&#125;;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="note info"><p>由于<code>map</code>中保存的肯定是索引<code>i</code>之前的数，因此不需要判断<code>map.get(remain) != i</code>.</p></div><p><strong>复杂度分析(Complexity Analysising)</strong>:</p><ul><li>时间复杂度(Time complexity): O(n)</li><li>空间复杂度(Space complexity): O(n)</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>对于能够快速使用<code>brute-force</code>暴力解法解决的问题，考虑优化时，首先考虑能够减少循环的嵌套，其次是考虑减少数组的访问次数、元素比较次数、元素交换次数等。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;leetcode&lt;/code&gt;解题思路总结:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。&lt;/p&gt;
&lt;p&gt;你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。&lt;br&gt;链接:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/two-sum/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/two-sum/&lt;/a&gt;(中文)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://leetcode.com/problems/two-sum/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/two-sum/&lt;/a&gt;(en)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;给定 nums = [2, 7, 11, 15], target = 9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;因为 nums[0] + nums[1] = 2 + 7 = 9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;所以返回 [0, 1]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://rovo98.github.io/categories/Leetcode/"/>
    
    
      <category term="leetcode-array-easy" scheme="http://rovo98.github.io/tags/leetcode-array-easy/"/>
    
  </entry>
  
</feed>
