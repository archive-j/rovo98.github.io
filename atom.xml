<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>rovo98&#39;s Blog</title>
  
  <subtitle>Leave your comfort zone!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://rovo98.github.io/"/>
  <updated>2018-06-12T06:50:18.642Z</updated>
  <id>http://rovo98.github.io/</id>
  
  <author>
    <name>rovo98</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>解决Github国内访问出现的问题</title>
    <link href="http://rovo98.github.io/posts/7e3029b3/"/>
    <id>http://rovo98.github.io/posts/7e3029b3/</id>
    <published>2018-06-10T07:58:34.000Z</published>
    <updated>2018-06-12T06:50:18.642Z</updated>
    
    <content type="html"><![CDATA[<p>主要通过修改hosts文件解决Github在国内访问不了、访问慢和页面加载异常的问题(没钱买vpn~)。</p><p>简单了解一下github, github是目前全球最大的男性同性交友网站(~滑稽~), 使用示例如下：</p><p><img src="/images/解决Github访问问题/communication.png" alt=""></p><a id="more"></a><p>开个玩笑，回归正题。</p><h3 id="为什么访问不了以及访问速度会很慢？"><a href="#为什么访问不了以及访问速度会很慢？" class="headerlink" title="为什么访问不了以及访问速度会很慢？"></a>为什么访问不了以及访问速度会很慢？</h3><p>GitHub在中国大陆访问速度慢的问题原因有很多，但最直接和最主要的原因是GitHub的分发加速网络的域名遭到DNS污染。</p><p>由于GitHub的加速分发CDN域名assets-cdn.github.com遭到DNS污染，导致无法连接使用GitHub的加速分发服务器，才使得中国大陆访问速度很慢。</p><p><img src="github_problem.png" alt="problem"></p><h3 id="如何解决DNS污染？"><a href="#如何解决DNS污染？" class="headerlink" title="如何解决DNS污染？"></a>如何解决DNS污染？</h3><p>一般的DNS问题都可以通过修改Hosts文件来解决，GitHub的CDN域名被污染问题也不例外，同样可以通过修改Hosts文件解决。</p><p>将域名解析直接指向IP地址来绕过DNS的解析，以此解决污染问题。</p><h4 id="获取被污染域名的实际IP地址"><a href="#获取被污染域名的实际IP地址" class="headerlink" title="获取被污染域名的实际IP地址"></a>获取被污染域名的实际IP地址</h4><p>访问<a href="https://wwww.ipaddress.com" target="_blank" rel="noopener">ipaddress.com</a>,使用ip lookup 工具获得相关域名的ip地址。</p><p>例如： github.com</p><p><img src="github_ipaddress.png" alt="ip address"></p><p>可以看到，我查出的域名ip地址为： 192.30.254.112 和 192.30.253.113 (任取一个即可)</p><h4 id="修改host文件，在文件中添加一行："><a href="#修改host文件，在文件中添加一行：" class="headerlink" title="修改host文件，在文件中添加一行："></a>修改host文件，在文件中添加一行：</h4><p><strong>[注] ： windows的hosts文件位置为：</strong><br>C:/windows/system32/drivers/etc/hosts</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">192.30.253.112 github.com</span><br></pre></td></tr></table></figure><h4 id="刷新dns缓存"><a href="#刷新dns缓存" class="headerlink" title="刷新dns缓存"></a>刷新dns缓存</h4><p>打开命令行cmd,输入如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig /flushdns</span><br></pre></td></tr></table></figure><p>此时再刷新页面即可。此时可以正常访问github，但是访问速度还是很慢，我们接着做优化。</p><h4 id="Github-访问提速"><a href="#Github-访问提速" class="headerlink" title="Github 访问提速"></a>Github 访问提速</h4><p>在hosts文件中继续加入，如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># GitHub Start</span><br><span class="line">192.30.253.112 github.com</span><br><span class="line">192.30.253.119 gist.github.com</span><br><span class="line">151.101.228.133 assets-cdn.github.com</span><br><span class="line">151.101.228.133 raw.githubusercontent.com</span><br><span class="line">151.101.228.133 gist.githubusercontent.com</span><br><span class="line">151.101.228.133 cloud.githubusercontent.com</span><br><span class="line">151.101.228.133 camo.githubusercontent.com</span><br><span class="line">151.101.228.133 avatars0.githubusercontent.com</span><br><span class="line">151.101.228.133 avatars1.githubusercontent.com</span><br><span class="line">151.101.228.133 avatars2.githubusercontent.com</span><br><span class="line">151.101.228.133 avatars3.githubusercontent.com</span><br><span class="line">151.101.228.133 avatars4.githubusercontent.com</span><br><span class="line">151.101.228.133 avatars5.githubusercontent.com</span><br><span class="line">151.101.228.133 avatars6.githubusercontent.com</span><br><span class="line">151.101.228.133 avatars7.githubusercontent.com</span><br><span class="line">151.101.228.133 avatars8.githubusercontent.com</span><br><span class="line">192.30.253.116  api.github.com</span><br><span class="line"># GitHub End</span><br></pre></td></tr></table></figure><p><strong>[notice]</strong> : 这里域名对应的ip是通过dns查询工具查询得到的，你应当选择的是延时相对较小且比较稳定的ip。</p><p>例如，上面的151.101.228.133是对我来说较好的ip:</p><p><img src="ping_test.png" alt="dns 查询检测"></p><p>推荐的dns查询检测工具：</p><ul><li><a href="https://tool.lu/dns/" target="_blank" rel="noopener">DNS查询 - 在线工具</a></li><li><a href="http://tool.chinaz.com/dns/" target="_blank" rel="noopener">DNS检测|DNS查询-站长工具</a></li></ul><p>你可对单个域名多查询几次，以挑选稳定且速度较快的ip。</p><h4 id="快速地访问github"><a href="#快速地访问github" class="headerlink" title="快速地访问github"></a>快速地访问github</h4><p>再次刷新dns缓存后，你已经可以快速地访问github了。</p><p><img src="github_test.gif" alt=""></p><p>参考：<a href="https://github.com/chenxuhua/issues-blog/issues/3" target="_blank" rel="noopener">https://github.com/chenxuhua/issues-blog/issues/3</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要通过修改hosts文件解决Github在国内访问不了、访问慢和页面加载异常的问题(没钱买vpn~)。&lt;/p&gt;&lt;p&gt;简单了解一下github, github是目前全球最大的男性同性交友网站(~滑稽~), 使用示例如下：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/images/解决Github访问问题/communication.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="tips" scheme="http://rovo98.github.io/categories/tips/"/>
    
    
      <category term="github" scheme="http://rovo98.github.io/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>PPP 点对点通信验证</title>
    <link href="http://rovo98.github.io/posts/28ff89ad/"/>
    <id>http://rovo98.github.io/posts/28ff89ad/</id>
    <published>2018-06-09T16:10:00.000Z</published>
    <updated>2018-06-12T06:50:18.616Z</updated>
    
    <content type="html"><![CDATA[<p>使用Cisco Packet Tracer7 (思科网络模拟器)验证ppp点对点通信。</p><p><img src="/images/ppp通信验证/packetTracer7.png" alt=""></p><a id="more"></a><h3 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h3><p>使用packet Tracer 模拟两台路由器，进行点对点通信测试。</p><h4 id="实验设计"><a href="#实验设计" class="headerlink" title="实验设计"></a>实验设计</h4><p>实验设备结构图：</p><p><img src="structure.png" alt="结构"></p><ul><li>均使用思科模拟器中的Generic 泛型路由<h3 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h3></li></ul><h4 id="配置路由器"><a href="#配置路由器" class="headerlink" title="配置路由器"></a>配置路由器</h4><p>由于只需要验证点对点通信，对路由器的配置，相对比较简单，<br>路由器之间使用的是serial DCE 串口线相连。</p><p>配置Router1的serial 2/0串口为ip: 11.0.0.1 mask: 255.0.0.0,并配置时钟频率为64000</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Router&gt; enable</span><br><span class="line">Router# configure terminal</span><br><span class="line">Router(config) # hostname RA</span><br><span class="line">RA (config) # interface serial 2/0</span><br><span class="line">RA (config) # no shutdown</span><br><span class="line">RA (config-if) # ip address 11.0.0.1 255.0.0.0</span><br><span class="line">RA (config-if) # clock rate 64000</span><br></pre></td></tr></table></figure><p>配置Router2的serial 3/0 串口为ip: 11.0.0.2 mask： 255.0.0.0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Router&gt; enable</span><br><span class="line">Router# configure terminal</span><br><span class="line">Router(config) # hostname RB</span><br><span class="line">RB (config) # interface serial 3/0</span><br><span class="line">RB (config) # no shutdown</span><br><span class="line">RB (config-if) # ip address 11.0.0.2 255.0.0.0</span><br></pre></td></tr></table></figure><ul><li>查看两个路由的串口状态：</li></ul><p>RA:</p><p><img src="hdsl_rt1.png" alt="RA serial 2/0"></p><p>RB:</p><p><img src="hdsl_rt2.png" alt="RB serial 3/0"></p><p>可以看到，路由器这里点对点通信默认使用的HDLC(High Level Data Link Control, 面向比特的同步协议)协议。</p><h4 id="HDLC情况下验证ping："><a href="#HDLC情况下验证ping：" class="headerlink" title="HDLC情况下验证ping："></a>HDLC情况下验证ping：</h4><p>11.0.0.1 ping 11.0.0.2:</p><p><img src="hdlc_ping_rt1.png" alt="RA ping Test"></p><p>11.0.0.2 ping 11.0.0.1:</p><p><img src="hdlc_ping_rt2.png" alt="RB ping Test"></p><p>ping 测试成功。</p><h4 id="配置RA-RB使用ppp协议，再做ping测试："><a href="#配置RA-RB使用ppp协议，再做ping测试：" class="headerlink" title="配置RA,RB使用ppp协议，再做ping测试："></a>配置RA,RB使用ppp协议，再做ping测试：</h4><ul><li>先配置RA 使用 ppp协议：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RA # configure terminal</span><br><span class="line">RA (config) # interface serial 2/0</span><br><span class="line">RA (config-if) # encapsulation ppp</span><br></pre></td></tr></table></figure><p><img src="RA_ppp_setting.png" alt="RA serial 2/0"></p><p>可以看到RA当前使用的是ppp写协议，LCP处于Closed,此时，路由器应当无法进行点对点通信。</p><p><img src="RA_ppp_fTest.png" alt="ping Test"></p><ul><li>配置RB使用ppp协议：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RB # configure terminal</span><br><span class="line">RB (config) # interface serial 3/0</span><br><span class="line">RB (config-if) # encapsulation ppp</span><br></pre></td></tr></table></figure><p><img src="RB_ppp_setting.png" alt="RB serial 3/0"></p><p>这时，可以看到RB也是使用了ppp协议，且LCP也处于Open状态，路由器之间可以进行通信。</p><p><img src="RB_ppp_sTest.png" alt="ping Test"></p><h4 id="给ppp协议添加authentication鉴别"><a href="#给ppp协议添加authentication鉴别" class="headerlink" title="给ppp协议添加authentication鉴别"></a>给ppp协议添加authentication鉴别</h4><ul><li>先配置RA，使其开启ppp chap (Challenge Handshake Authentication Protocol), 给RB 添加身份验证</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RA # config terminal</span><br><span class="line">RA (config) # username RB password password</span><br><span class="line">RA (config) # interface serial 2/0</span><br><span class="line">RA (config-if) # ppp authentication chap</span><br></pre></td></tr></table></figure><p><img src="RA_ppp_au.png" alt="RA serial 2/0"></p><p>此时，虽然RA和RB都是使用ppp协议，但是RA给RB添加了身份认证，而RB则没有，此时LCP处于Closed状态，它们之间无法进行通信。</p><ul><li>配置RB, 添加对RA的身份验证：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RB # config terminal</span><br><span class="line">RB (config) # username RA password password</span><br><span class="line">RB (config) # interface serial 2/0</span><br><span class="line">RB (config-if) # ppp authentication chap</span><br></pre></td></tr></table></figure><p><img src="RB_ppp_au.png" alt="RB serial 3/0"></p><p>可以看到此时，LCP已经打开，路由器之间可以进行点对点通信。</p><p><img src="RB_ping_final.png" alt="ping"></p><h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><p>通过该实验，简单地验证了ppp协议在点对点信道中的使用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用Cisco Packet Tracer7 (思科网络模拟器)验证ppp点对点通信。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/images/ppp通信验证/packetTracer7.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://rovo98.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="ppp通信" scheme="http://rovo98.github.io/tags/ppp%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>文章加密测试</title>
    <link href="http://rovo98.github.io/posts/26ea2038/"/>
    <id>http://rovo98.github.io/posts/26ea2038/</id>
    <published>2018-06-09T03:24:07.000Z</published>
    <updated>2018-06-12T06:50:18.628Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="这是被加密的内容"><a href="#这是被加密的内容" class="headerlink" title="这是被加密的内容."></a>这是被加密的内容.</h1>]]></content>
    
    <summary type="html">
    
      文章加密测试。密码： password
    
    </summary>
    
      <category term="博客" scheme="http://rovo98.github.io/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="hexo" scheme="http://rovo98.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>使用ensp进行简单的路由器互连实验</title>
    <link href="http://rovo98.github.io/posts/cc46ce96/"/>
    <id>http://rovo98.github.io/posts/cc46ce96/</id>
    <published>2018-06-06T16:00:00.000Z</published>
    <updated>2018-06-12T07:40:32.735Z</updated>
    
    <content type="html"><![CDATA[<p>简单使用ensp做华为AR1220路由互连的实验。</p><p><img src="/images/ensp_路由连接实验/ensp.png" alt=""></p><a id="more"></a><h3 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h3><ul><li>路由器设置</li><li>手动设置静态路由</li></ul><h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><ul><li>华为路由器AR1220</li><li>主机</li><li>Serial设备连接串口线和Copper以太网和千兆以太网连接线</li></ul><p>备注：所有实验设备均由ensp模拟。</p><h4 id="路由连接实验设计"><a href="#路由连接实验设计" class="headerlink" title="路由连接实验设计"></a>路由连接实验设计</h4><p>整体结构如下：</p><p><img src="route-structure.png" alt="整体结构"></p><ul><li>1.其中分为六个不同的局域网；</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">192.168.11.0 网段 -&gt;</span><br><span class="line">    主机:   192.168.11.11</span><br><span class="line">            192.168.11.12</span><br><span class="line">    路由器AR6一个GigabitEthernet接口作为该网段的默认网关(192.168.11.1)</span><br><span class="line"></span><br><span class="line">192.168.12.0 网段 -&gt;</span><br><span class="line">    主机:   192.168.12.11</span><br><span class="line">            192.168.12.12</span><br><span class="line">    路由器AR4的一个GigabitEthernet接口作为该网段的默认网关(192.168.12.1)</span><br><span class="line"></span><br><span class="line">192.168.13.0 网段 -&gt;</span><br><span class="line">    主机:    192.168.13.11</span><br><span class="line">            192.168.13.12</span><br><span class="line">            192.168.13.13</span><br><span class="line">   路由器AR7的一个GigabitEthernet接口作为该网段的默认网关(192.168.13.1)</span><br><span class="line">   </span><br><span class="line">1.1.2.0 网段 -&gt; 路由器AR6和路由器AR7之间的接口</span><br><span class="line">1.1.1.0 网段 -&gt; 路由器AR6和AR4之间的接口</span><br><span class="line">1.1.3.0 网段 -&gt; 路由器AR6和AR7之间的接口</span><br></pre></td></tr></table></figure><ul><li>2.设备的连接：</li></ul><blockquote><p>除了路由器之间连接使用serial串口连接线外，其他均使用Copper连接线。</p></blockquote><h3 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h3><h4 id="配置各个局域网的ip及其网关"><a href="#配置各个局域网的ip及其网关" class="headerlink" title="配置各个局域网的ip及其网关"></a>配置各个局域网的ip及其网关</h4><ul><li>例如：192.168.11.0网段下的192.168.11.11主机：</li></ul><p><img src="pc1_setting.png" alt="PC1"></p><ul><li>配置 192.168.11.1作为192.168.11.0网段的网关：</li></ul><p><img src="gateway1.png" alt="设置网关"></p><p>所有主机经过配置后，他们应该可以ping通自己网段下的所有主机，如：192.168.11.12 ping 192.168.11.11</p><p><img src="pingTest.png" alt="局域网ping测试"></p><ul><li><strong>[需要注意的是]</strong>： 由于路由器互连时使用的是Serial串口，所以路由器之间配置的是serial串口的ip。</li></ul><p>例如：配置AR6的两个serial串口的接口ip为：1.1.1.1和1.1.2.1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;Huawei&gt; system-view</span><br><span class="line">[Huawei] inter serial 2/0/1</span><br><span class="line">[Huawei-Servial2/0/1] ip address 1.1.1.1 255.255.255.0</span><br><span class="line">[Huawei-Servial2/0/1] quit</span><br><span class="line">[Huawei] inter serial 2/0/0</span><br><span class="line">[Huawei-Serial2/0/0] ip address 1.1.2.1 255.255.255.0</span><br></pre></td></tr></table></figure><h4 id="各个路由器的静态路由："><a href="#各个路由器的静态路由：" class="headerlink" title="各个路由器的静态路由："></a>各个路由器的静态路由：</h4><p>对于路由器AR6,我们希望所有<strong>目的网络为192.168.12.0</strong>的数据包都交付给AR4,即<strong>下一跳为1.1.1.2</strong>;所有<strong>目的网络为192.168.13.0</strong>的都交给AR7,<strong>下一跳为1.1.2.2</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Huawei&gt; system-view</span><br><span class="line">[Huawei] ip route-static 192.168.12.0 255.255.255.0 1.1.1.2</span><br><span class="line">[Huawei] ip route-static 192.168.13.0 255.255.255.0 1.1.2.2</span><br></pre></td></tr></table></figure><p>对于路由器AR4，所有<strong>目的网络为192.168.11.0</strong>的数据包交给AR6，<strong>下一跳为：1.1.1.1，目的网络为192.168.13.0</strong>的数据包交给AR7，<strong>下一跳为：1.1.3.1</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Huawei&gt; system-view</span><br><span class="line">[Huawei] ip route-static 192.168.11.0 255.255.255.0 1.1.1.1</span><br><span class="line">[Huawei] ip route-static 192.168.13.0 255.255.255.0 1.1.3.1</span><br></pre></td></tr></table></figure><p>对于路由器AR7， 所有<strong>目的网络为192.168.11.0</strong>的数据包都交给AR6，<strong>下一跳为：1.1.2.1</strong>，所有<strong>目的网络为192.168.12.0</strong>的数据包都交给AR4，<strong>下一跳为：1.1.3.2</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Huawei&gt; system-view</span><br><span class="line">[Huawei] ip route-static 192.168.11.0 255.255.255.0 1.1.2.1</span><br><span class="line">[Huawei] ip route-static 192.168.12.0 255.255.255.0 1.1.3.2</span><br></pre></td></tr></table></figure><p>经过以上对各个路由器的静态路由的配置后，我们可以通过<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">display ip routing-table</span><br></pre></td></tr></table></figure><p></p><p>来查看各个路由器的路由表：</p><ul><li>AR6路由表：</li></ul><p><img src="route1_info.png" alt="AR6路由表"></p><ul><li>AR4路由表：</li></ul><p><img src="route2_info.png" alt="AR4路由表"></p><ul><li>AR7路由表：</li></ul><p><img src="route3_info.png" alt="AR7路由表"></p><h3 id="测试实验结果"><a href="#测试实验结果" class="headerlink" title="测试实验结果"></a>测试实验结果</h3><p>使用任意一个局域网下的主机ping不同局域网下的主机：</p><ul><li>192.168.11.11 ping 192.168.13.12 和 192.168.12.12:</li></ul><p><img src="tracert1.png" alt="tracert测试1"></p><ul><li>192.168.12.11 ping 192.168.11.12 和 192.168.13.13:</li></ul><p><img src="tracert2.png" alt="tracert测试2"></p><ul><li>192.168.13.11 ping 192.168.11.11 和 192.168.12.11：</li></ul><p><img src="tracert3.png" alt="tracert测试3"></p><p>由以上测试可以看出简单的路由器连接实验成功。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单使用ensp做华为AR1220路由互连的实验。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/images/ensp_路由连接实验/ensp.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://rovo98.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="路由器" scheme="http://rovo98.github.io/tags/%E8%B7%AF%E7%94%B1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>CentOS7通过yum(yellow dog update modifier) 安装mysql5.7</title>
    <link href="http://rovo98.github.io/posts/86d29d2c/"/>
    <id>http://rovo98.github.io/posts/86d29d2c/</id>
    <published>2018-04-22T16:00:00.000Z</published>
    <updated>2018-06-12T06:50:18.590Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h3 id="配置yum源"><a href="#配置yum源" class="headerlink" title="配置yum源"></a>配置yum源</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载mysql安装源包</span></span><br><span class="line">root @~&gt; wget http://dev.mysql.com/get/mysql57-community-release-el7-8.noarch.rpm</span><br><span class="line"><span class="comment"># 安装mysql源</span></span><br><span class="line">root @~&gt; yum localinstall mysql57-community-release-el7-8.noarch.rpm</span><br></pre></td></tr></table></figure><p>检查mysql源是否安装成功:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root @~&gt; yum repolist enabled | grep <span class="string">"mysql.*-community.*"</span></span><br></pre></td></tr></table></figure><p>如下图则安装成功:</p><p><img src="repo-resource.png" alt="mysql_source"></p><h3 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ ~&gt; yum install -y mysql-community-server</span><br></pre></td></tr></table></figure><h3 id="启动MySQL服务并设置开机自动启动"><a href="#启动MySQL服务并设置开机自动启动" class="headerlink" title="启动MySQL服务并设置开机自动启动"></a>启动MySQL服务并设置开机自动启动</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ ~&gt; systemctl start mysqld</span><br></pre></td></tr></table></figure><p>查看MySQL启动状态</p><p><img src="mysql-status.png" alt="mysqld进程状态"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ ~&gt; systemctl <span class="built_in">enable</span> mysqld</span><br><span class="line">root@ ~&gt; systemctl daemon-reload</span><br></pre></td></tr></table></figure><h3 id="修改默认密码"><a href="#修改默认密码" class="headerlink" title="修改默认密码"></a>修改默认密码</h3><p>刚安装完的mysql会自动给root用户分配一个临时密码，而且必须重新设置密码(从5.5版本开始)</p><ul><li>先查看root用户的临时密码</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ ~&gt; grep <span class="string">"temporary password"</span> /var/<span class="built_in">log</span>/mysqld.log</span><br></pre></td></tr></table></figure><ul><li>使用临时的密码登录进mysql来设置新的密码</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="built_in">set</span> PASSWORD = PASSWORD(<span class="string">'[YOUR_NEW_PASSWORD]'</span>)</span><br></pre></td></tr></table></figure><p><img src="temporary-password.png" alt="查看临时密码"></p><ul><li>可能遇到的问题：设置的密码过于简单mysql报错:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Your password does not satisfy the current policy requirements.</span><br></pre></td></tr></table></figure><p>解决方法：由于刚安装的mysql的密码默认强度是最高的，若想要设置简单的密码就要修改<strong>validate_password_policy</strong>的值，</p><h4 id="validate-password-policy有以下取值："><a href="#validate-password-policy有以下取值：" class="headerlink" title="validate_password_policy有以下取值："></a>validate_password_policy有以下取值：</h4><div class="table-container"><table><thead><tr><th style="text-align:center">Policy</th><th style="text-align:center">Tests Performed</th></tr></thead><tbody><tr><td style="text-align:center">0 or LOW</td><td style="text-align:center">Length</td></tr><tr><td style="text-align:center">1 or MEDIUM</td><td style="text-align:center">Length;numeric,lowercase/uppercase,and special characters</td></tr><tr><td style="text-align:center">2 or STRONG</td><td style="text-align:center">Length;numeric,lowercase/uppercase,and special characters; dictionary file</td></tr></tbody></table></div><p>操作：</p><ul><li>设置安全级别</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="built_in">set</span> global validate_password_policy=0;</span><br></pre></td></tr></table></figure><ul><li>设置密码长度为8，可以设置为其他值，最小为4位</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="built_in">set</span> global validate_password_length=4;</span><br></pre></td></tr></table></figure><p>之后就可以设置简单的密码了。</p><h3 id="允许root远程登录"><a href="#允许root远程登录" class="headerlink" title="允许root远程登录"></a>允许root远程登录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; GRANT ALL PRIVILEGES ON *.* TO <span class="string">'root'</span>@<span class="string">'%'</span> IDENTIFIED BY <span class="string">'[YOUR_PASSWORD]'</span> WITH GRANT OPTION;</span><br><span class="line">mysql&gt; flush privileges;</span><br></pre></td></tr></table></figure><h3 id="修改字符集编码为UTF-8"><a href="#修改字符集编码为UTF-8" class="headerlink" title="修改字符集编码为UTF-8"></a>修改字符集编码为UTF-8</h3><ul><li>查看当前字符编码</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like <span class="string">"char%';</span></span><br></pre></td></tr></table></figure><p>检测是否都是utf-8(filesystem除外)，如果不是就需要修改。 <strong>character_set_server</strong>一般是lantin1。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 停止mysqld服务</span></span><br><span class="line">systemctl stop mysqld</span><br><span class="line"><span class="comment"># 进入my.cnf文件，一般是/etc/路径下</span></span><br><span class="line">vim /etc/my.cnf</span><br><span class="line"><span class="comment"># 在[mysqld]下追加character-set-server=utf-8</span></span><br><span class="line"><span class="comment"># 在[mysql]下追加default-character-set=utf-8</span></span><br><span class="line"><span class="comment"># 启动mysqld</span></span><br><span class="line">systemctl start mysqld</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      CentOS7下安装mysql。
    
    </summary>
    
      <category term="mysql" scheme="http://rovo98.github.io/categories/mysql/"/>
    
    
      <category term="mysql5.7安装" scheme="http://rovo98.github.io/tags/mysql5-7%E5%AE%89%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>Java持久化框架基础学习笔记 - ORM</title>
    <link href="http://rovo98.github.io/posts/4e7f2cb9/"/>
    <id>http://rovo98.github.io/posts/4e7f2cb9/</id>
    <published>2018-04-12T11:41:44.000Z</published>
    <updated>2018-06-12T13:23:00.341Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>对象关系映射(Oject Relational Mapping, ORM)是一种程序技术，用户实现面向对象编程语言中不同类型系统的数据之间的转换。</p></blockquote><p><img src="/images/Java框架学习基础-ORM/orm.png" alt=""></p><a id="more"></a><p>为了更好的了解ORM，我们先要了解一下JDBC。</p><h3 id="什么是JDBC"><a href="#什么是JDBC" class="headerlink" title="什么是JDBC?"></a>什么是JDBC?</h3><p>JDBC，即<strong>Java Database Connectivity</strong>(Java数据库连接)。它为Java程序提供了访问关系型数据库(relational database)的Java API集合。<strong>这些API使得Java程序可以执行SQL语句并与任何符合SQL的数据库库进行交互。</strong></p><p>JDBC提供了一种<strong>灵活的</strong>结构来编写能够和数据库进行交互的应用，且在<strong>不做任何修改的情况下</strong>，能够运行于不同的平台。</p><h4 id="JDBC的优点和缺点"><a href="#JDBC的优点和缺点" class="headerlink" title="JDBC的优点和缺点"></a>JDBC的优点和缺点</h4><div class="table-container"><table><thead><tr><th style="text-align:center">优点</th><th style="text-align:center">缺点</th></tr></thead><tbody><tr><td style="text-align:center">清晰简单的SQL处理</td><td style="text-align:center">在大型的项目中使用时变得异常复杂</td></tr><tr><td style="text-align:center">处理大数据时有良好表现</td><td style="text-align:center">大量编程开销，没有封装</td></tr><tr><td style="text-align:center">非常适合小应用程序</td><td style="text-align:center">难以实现MVC模式</td></tr><tr><td style="text-align:center">语法简单易学</td><td style="text-align:center">查询是DBMS特有的</td></tr></tbody></table></div><h3 id="为什么使用对象关系映射-ORM"><a href="#为什么使用对象关系映射-ORM" class="headerlink" title="为什么使用对象关系映射(ORM)?"></a>为什么使用对象关系映射(ORM)?</h3><p>当我们使用面向对象系统时，对象模型和关系数据库存在不匹配的现象，<strong>RDMSs(关系型数据库) 以表格的形式表示数据，而面向对象编程语言，如java,C# 将数据表示为对象的属性，以及对象之间的关系</strong>。</p><p>例如下面的一个简单的实体类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String firstName;</span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> salary;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String fname, String lname, <span class="keyword">int</span> sal)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.firstName = fname;</span><br><span class="line">        <span class="keyword">this</span>.lastName = lname;</span><br><span class="line">        <span class="keyword">this</span>.salary = sal;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFirstName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> firstName;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLastName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lastName;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSalary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> salary;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的对象在关系型数据库中可以这样存储和检索的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> EMPLOYEE (</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span> auto_increment,</span><br><span class="line">    first_name <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">default</span> <span class="literal">null</span>,</span><br><span class="line">    last_name <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">default</span> <span class="literal">null</span>,</span><br><span class="line">    salary <span class="built_in">int</span> <span class="keyword">default</span> <span class="literal">null</span>,</span><br><span class="line">    contraint PK_id primary <span class="keyword">key</span> (<span class="keyword">id</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h4><ol><li>可能我们开发了几个页面后，要修改数据库的设计，我们应该怎样处理？</li><li>将对象存储到关系型数据库和从数据库中读取存在以下五个<strong>不匹配(mismatch)</strong>的问题：</li></ol><div class="table-container"><table><thead><tr><th style="text-align:center">不匹配(Mismatch)</th><th style="text-align:center">描述(Description)</th></tr></thead><tbody><tr><td style="text-align:center">Granularity(粒度)</td><td style="text-align:center">有时你可能会有一个对象模型，它的类比数据库中的相应的表的数量还要多。</td></tr><tr><td style="text-align:center">Inheritence(继承)</td><td style="text-align:center">RDBMS不定义任何类似继承的东西，但这确是面向对象编程语言中的的自然范式。</td></tr><tr><td style="text-align:center">Identity(标识)</td><td style="text-align:center">RDBMS正好定义了一个“相等”的概念：主键。但是Java定义对象标识(a == b) 和对象相等(a.equals(b))。</td></tr><tr><td style="text-align:center">Associations(关联)</td><td style="text-align:center">面向对象编程语言使用对象引用来表示关联，而RDBMS将关联表示为外键。</td></tr><tr><td style="text-align:center">Navigation(检索)</td><td style="text-align:center">在Java和RDBMS中访问对象的方式根本不同。</td></tr></tbody></table></div><p><strong>对象关系映射（ORM）是处理上述所有不匹配问题的解决方案</strong>。</p><h3 id="什么是ORM"><a href="#什么是ORM" class="headerlink" title="什么是ORM?"></a>什么是ORM?</h3><p>ORM 是一项在关系型数据库和面向对象编程语言之间转换数据的编程技术。</p><p>相比于简单的JDBC，ORM有以下优点：</p><div class="table-container"><table><thead><tr><th style="text-align:center">No.</th><th style="text-align:center">Advantages</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">让业务逻辑代码访问数据对象，而不是数据表</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">隐藏了业务逻辑的SQL查询的详细信息</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">无需处理数据库实现问题</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">基于业务概念而非数据库结构的实体</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">基于JDBC“底层”</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">事务管理和自动密钥生成</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">应用程序快速开发</td></tr></tbody></table></div><p>一个 ORM 解决方案由以下四个实体组成：</p><div class="table-container"><table><thead><tr><th style="text-align:center">No.</th><th style="text-align:center">Solutions</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">对持久化类的对象执行基本CRUD操作的API</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">用于指定引用类和类的属性的查询的语言或API</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">用于指定映射元数据的可配置工具</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">一种与事务对象进行交互以执行脏检查，懒惰关联提取以及其他优化功能的技术。</td></tr></tbody></table></div><h3 id="Java-ORM-框架"><a href="#Java-ORM-框架" class="headerlink" title="Java ORM 框架"></a>Java ORM 框架</h3><p>有许多持久化框架ORM解决方案使用java实现的，如：</p><ul><li>Enterprise JavaBeans Entity Beans</li><li>Java Data Ojects</li><li>Castor</li><li>TopLink</li><li>Spring DAO</li><li>Hibernate</li><li>Mybatis</li><li>等等。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;对象关系映射(Oject Relational Mapping, ORM)是一种程序技术，用户实现面向对象编程语言中不同类型系统的数据之间的转换。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;/images/Java框架学习基础-ORM/orm.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java框架学习" scheme="http://rovo98.github.io/categories/Java%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java框架基础" scheme="http://rovo98.github.io/tags/Java%E6%A1%86%E6%9E%B6%E5%9F%BA%E7%A1%80/"/>
    
      <category term="ORM" scheme="http://rovo98.github.io/tags/ORM/"/>
    
      <category term="学习笔记" scheme="http://rovo98.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>基本查找算法 - basical searching algorithms</title>
    <link href="http://rovo98.github.io/posts/d83777d2/"/>
    <id>http://rovo98.github.io/posts/d83777d2/</id>
    <published>2018-03-06T16:00:00.000Z</published>
    <updated>2018-06-12T06:50:18.583Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>基本查找算法，我们只谈<strong>静态查找</strong>的查找算法。</p><h3 id="线性查找-linear-search"><a href="#线性查找-linear-search" class="headerlink" title="线性查找 - linear search"></a>线性查找 - linear search</h3><p>特点：</p><ul><li>从头开始遍历数组，一个一个和<strong>key</strong>比较，查找成功则返回索引值。</li><li>不要求数组是<strong>有序的</strong>。</li><li>时间复杂度为： $O(n)$.</li></ul><h4 id="线性查找原始抽象方法实现如下"><a href="#线性查找原始抽象方法实现如下" class="headerlink" title="线性查找原始抽象方法实现如下:"></a>线性查找原始抽象方法实现如下:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">linearSearch</span><span class="params">(Comparable[] a, Comparable key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a[i].compareTo(key) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="跳跃查找-jump-search"><a href="#跳跃查找-jump-search" class="headerlink" title="跳跃查找 - jump search"></a>跳跃查找 - jump search</h3><p>特点：</p><ul><li>要求查找数组<strong>有序</strong>；</li><li>主要思想是每次跳跃固定量的元素来确定目标元素所在的区间，再使用线性查找在区间上搜索目标元素。</li><li>时间复杂度为： $O(\sqrt{n})$.</li></ul><p><strong>[notice] : </strong>假设我们要在一个有n个元素的数组中搜索某个元素，最坏情况下（<strong>当目标元素为最后个元素时），这个算法要跳跃n/m步，在线性搜索时作m-1次比较。</strong>令 $f(n) = ((n/m) + m-1$.当m = $\sqrt{n}$时，f(n) 取最小值，所以通常情况下，**跳跃查找所使用的固定跳跃步数为 $\sqrt{n}$.</p><h4 id="跳跃查找的原始抽象方法实现如下："><a href="#跳跃查找的原始抽象方法实现如下：" class="headerlink" title="跳跃查找的原始抽象方法实现如下："></a>跳跃查找的原始抽象方法实现如下：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">jumpSearch</span><span class="params">(Comparable[] a, Comparable key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = a.length;</span><br><span class="line">    <span class="keyword">int</span> block_size = Math.floor(Math.sqrt(n));</span><br><span class="line"><span class="keyword">int</span> step = block_size;</span><br><span class="line">    <span class="comment">// 查找目标元素可能出现的区间</span></span><br><span class="line">    <span class="keyword">int</span> prev = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (a[Math.min(step, n) - <span class="number">1</span>].compareTo(key) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    prev = step;</span><br><span class="line">        step += block_size;</span><br><span class="line">        <span class="keyword">if</span> (prev &gt;= n)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用线性查找在确定的区间上查找目标元素</span></span><br><span class="line">    <span class="keyword">while</span> (a[prev].compareTo(key) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    prev++;</span><br><span class="line">        <span class="keyword">if</span> (prev == Math.min(step, n))</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a[prev].compareTo(key) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二分查找-binary-search"><a href="#二分查找-binary-search" class="headerlink" title="二分查找 - binary search"></a>二分查找 - binary search</h3><ul><li>要求数组<strong>有序</strong>。</li><li>将已经排好序的数组分为两个区间(interval), 把区间的中间元素与<strong>key</strong>比较, 若大于则搜索左区间，若小于则搜索右区间，等于则返回元素的索引。<strong>当区间长度为0时（key没出现在数组中)</strong>,返回-1。</li><li>时间复杂度为 ： $O(nlogn)$.</li></ul><h4 id="二分查找原始抽象方法实现如下"><a href="#二分查找原始抽象方法实现如下" class="headerlink" title="二分查找原始抽象方法实现如下:"></a>二分查找原始抽象方法实现如下:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(Comparable[] a, Comparable key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> lo = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> hi = a.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[mid].compareTo(key) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[mid].compareTo(key) &gt; <span class="number">0</span>)</span><br><span class="line">        hi = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        lo = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearchRecursion</span><span class="params">(Comparable[] a, Comparable key, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (lo &lt;= hi) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[mid].compareTo(key) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[mid].compareTo(key) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> binarySearchRecursion(a, key, mid+<span class="number">1</span>, hi);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> binarySearchRecursion(a, key, lo, mid-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三分查找-ternary-search"><a href="#三分查找-ternary-search" class="headerlink" title="三分查找 - ternary search"></a>三分查找 - ternary search</h3><p>特点：</p><ul><li>三分查找是二分查找的扩展；</li><li>时间复杂度为 ： $O(nlog_3n)$.</li></ul><p><strong>[notice]:</strong> 虽然看似三分查找的时间复杂度比二分查找的时间复杂度小，但是<strong>在最坏情况下</strong>，二分查找需要$2Log_2n + 1$次比较，而三分查找需要$4Log_{3}n + 1$次比较</p><h4 id="三分查找原始抽象方法实现如下："><a href="#三分查找原始抽象方法实现如下：" class="headerlink" title="三分查找原始抽象方法实现如下："></a>三分查找原始抽象方法实现如下：</h4><p>特点：</p><ul><li>类似二分查找，将查找数组划分为三个部分来进行查找；</li><li>时间复杂度： $Log_3n$.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归实现.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ternarySearch</span><span class="params">(Comparable[] a, Comparable key, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (lo &lt;= hi) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid1 = lo + (hi - lo) / <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> mid2 = mid1 + (hi - lo) / <span class="number">3</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (a[mid1].compareTo(key) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> mid1;</span><br><span class="line">        <span class="keyword">if</span> (a[mid2].compareTo(key) == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> mid2;</span><br><span class="line">        <span class="comment">// 目标元素只可能出现在第一部分.</span></span><br><span class="line">        <span class="keyword">if</span> (a[mid1].compareTo(key) &gt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> ternarySearch(a, key, lo, mid1-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 目标元素只可能出现在第三部分.</span></span><br><span class="line">        <span class="keyword">if</span> (a[mid2].compareTo(key) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ternarySearch(a, key, mid2+<span class="number">1</span>, hi);</span><br><span class="line">        <span class="comment">// 目标元素只可能出现在第二部分.</span></span><br><span class="line">        <span class="keyword">return</span> ternarySearch(a, key, mid1+<span class="number">1</span>, mid2-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查找失败.</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="指数搜索-exponential-search"><a href="#指数搜索-exponential-search" class="headerlink" title="指数搜索 - exponential search"></a>指数搜索 - exponential search</h3><p>特点：</p><ul><li>找到目标元素可能出现的区间；</li><li>使用二分查找在区间上查找目标元素;</li><li>时间复杂度： $logn$;</li></ul><p><strong>[notice]</strong>:</p><ol><li>适用于目标数组元素大小趋向于无限大的情况；</li><li>当目标出现在目标数组左边时，指数搜索速度比二分查找快。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">exponentialSearch</span><span class="params">(Comparable[] a, Comparable key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n  = a.length;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n &amp;&amp; a[i].compareTo(key) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"> i = i * <span class="number">2</span>;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> binarySearch(a, key, i/<span class="number">2</span>, Math.min(i, n-<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插值搜索-interpolation-search"><a href="#插值搜索-interpolation-search" class="headerlink" title="插值搜索 - interpolation search"></a>插值搜索 - interpolation search</h3><p>特点：</p><ul><li><p>原理： 假设查找数组的元素是均匀分布的，使用<strong>直线插值搜索</strong>，不像二分查找那样每次都是搜索区间中间元素。它能够快速的接近目标元素。</p></li><li><p>当元素均匀分布的情况，时间复杂度为: $O(log(log n))$, 最坏情况: $O(n)$.</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java program to implement interpolatoin search.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">interpolationSearch</span><span class="params">(Comparable[] a, Comparable key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> lo = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> hi = a.length - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (lo &lt;= hi &amp;&amp; less(key, a[hi]) &amp;&amp; less(a[lo], key)) &#123;</span><br><span class="line">    <span class="keyword">int</span> pos = lo + (hi - lo) * (key - a[lo]) / (a[hi] - a[lo]);</span><br><span class="line">        <span class="keyword">if</span> (a[pos].compareTo(key) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> pos;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[pos].compareTo(key) &gt; <span class="number">0</span>)</span><br><span class="line">        hi = pos - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            lo = pos + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="NOTICE"><a href="#NOTICE" class="headerlink" title="NOTICE"></a>NOTICE</h3><p>本文中，涉及的算法详细实现和使用，请移步到github<a href="https://github.com/rovo98/ds-and-algs#searching-algorithms----go-back-to-top" target="_blank" rel="noopener">查看</a>。</p>]]></content>
    
    <summary type="html">
    
      使用java实现并简要分析抽象的基本静态查找算法。notes, learning from algs4.
    
    </summary>
    
      <category term="Algorithms" scheme="http://rovo98.github.io/categories/Algorithms/"/>
    
    
      <category term="searching algs" scheme="http://rovo98.github.io/tags/searching-algs/"/>
    
  </entry>
  
  <entry>
    <title>快速排序 - quickSort</title>
    <link href="http://rovo98.github.io/posts/d9de8e4c/"/>
    <id>http://rovo98.github.io/posts/d9de8e4c/</id>
    <published>2018-03-05T16:00:00.000Z</published>
    <updated>2018-06-12T06:50:18.623Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>快速排序的主要特点是：</p><ol><li>原地排序 (in-place);</li><li>将长度为 N 的数组排序所需的时间和NlgN成正比；</li><li>排序内循环比大多数排序算法都要短小，意味着无论是在理论上还是实际中都要更快。</li></ol><p>缺点：<br>快速排序非常的脆弱，在实现时要非常小心才能避免低劣的性能。</p><h3 id="基本算法"><a href="#基本算法" class="headerlink" title="基本算法"></a>基本算法</h3><p>快速排序是一种<strong>分治</strong>排序算法，它将一个数组分成两个子数组，将两部分独立地排序。不同于归并排序，快速排序的递归调用发生在处理子数之前。</p><p>快速排序方法抽象实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Quick</span> </span>&#123;</span><br><span class="line"><span class="comment">// quick sort java implement.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">    sort(a, <span class="number">0</span>, a.length-<span class="number">1</span>);</span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">isSorted</span><span class="params">(a)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hi &lt;= lo)<span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> j = partition(a, lo, hi);</span><br><span class="line">        sort(a, lo, j-<span class="number">1</span>);</span><br><span class="line">        sort(a, j+<span class="number">1</span>, hi);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">partition</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = lo;</span><br><span class="line">        <span class="keyword">int</span> j = hi + <span class="number">1</span>;</span><br><span class="line">        Comparable v = a[lo];</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (less(a[++i], v)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lo == hi) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (less(v, a[--j])) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == lo) <span class="keyword">break</span>; <span class="comment">// redundant since a[lo] is sentinel.</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Check if pointers cross.</span></span><br><span class="line">            <span class="keyword">if</span> (j &lt;= i)<span class="keyword">break</span>;</span><br><span class="line">            exch(a, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        exch(a, lo, j);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述切分方法示意图: [from algs4]</p><p><img src="quickSort_partition_1.png" alt="切分示意图"></p><p>切分轨迹图: [from algs4]</p><p><img src="quickSort_partition_2.png" alt="切分轨迹图"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">命题 K： 将长度为N的无重复的数组排序，快速</span><br><span class="line">排序平均需要 ~2NlnN 次比较(以及1/6的交换)</span><br></pre></td></tr></table></figure><p><strong>[notice]</strong>: 尽管快速排序有很多优点，它的基本实现仍有一个潜在的缺点：</p><p>在切分不平衡时该算法可能及其低效。例如： 如果第一个次从最小的元素切分，第二次从第二小的元素切分，则这样每次只会移除一个元素。<br>[solution] : <strong>在快速排序之前将数组随机排序可以避免这种情况的发生</strong>。</p><h3 id="算法改进"><a href="#算法改进" class="headerlink" title="算法改进"></a>算法改进</h3><h4 id="1-切换到插入排序"><a href="#1-切换到插入排序" class="headerlink" title="1.切换到插入排序"></a>1.切换到插入排序</h4><p>和大多数递归排序算法一样(如归并)，改进快速排序的简单方法基于以下两点：</p><ul><li>对于小数组，快速排序比插入排序慢；</li><li>以为递归，快速排序的sort()方法在小数组中也会调用自己。</li></ul><p>改进 ： 将<strong>sort()方法</strong>中的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (hi &lt;= lo) <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><p>改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (hi &lt;= lo + M) &#123;</span><br><span class="line">insertion.sort(a, lo, hi);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[<strong>notice</strong>] : 这里的切换参数 M 的最佳值是和系统相关的，但是5 ~ 15 之间的任意值在大多数情况下都能令人满意。</p><h4 id="2-三取样切分"><a href="#2-三取样切分" class="headerlink" title="2. 三取样切分"></a>2. 三取样切分</h4><p>改进快速排序性能的第二个方法是<strong>使用子数组的一小部分的中位数来切分数组</strong>。这样的切分的效果更好，但代价是需要计算中位数。</p><ul><li>人们发现将取样设为 3 并用大小居中的元素切分效果<strong>最好</strong>； 我们还可以将取样元素放在数组末尾作为哨兵(sentinel)。</li></ul><p>三取样切分抽象实现 : <a href="https://github.com/rovo98/ds-and-algs/blob/master/ds/sorting/exercises/QuickSortImprovedTwo.java" target="_blank" rel="noopener">详细查看</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSortImproved</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">sort(a, <span class="number">0</span>, a.length-<span class="number">1</span>);</span><br><span class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">isSorted</span><span class="params">(a)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> staic <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">dealPivot(a, lo, hi);</span><br><span class="line">    <span class="keyword">int</span> i = lo;</span><br><span class="line">    <span class="keyword">int</span> j = hi - <span class="number">1</span>;</span><br><span class="line">    Comparable v = a[hi - <span class="number">1</span>]; <span class="comment">// set the  pivot at hi -1 as a sentinel.</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (less(a[++i], v)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == hi-<span class="number">1</span>) <span class="keyword">break</span>; <span class="comment">// redundant since a[hi - 1] is sentinel.</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; lo &amp;&amp; less(v, a[--j])) &#123;  &#125;</span><br><span class="line">        </span><br><span class="line">       <span class="comment">// check if pointers cross.</span></span><br><span class="line">        <span class="keyword">if</span> (j &lt;= i) <span class="keyword">break</span>;</span><br><span class="line">        exch(a, i, j);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (i &lt; hi-<span class="number">1</span>) &#123;</span><br><span class="line">   exch(a, i, hi - <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   sort(a, lo, i - <span class="number">1</span>);</span><br><span class="line">   sort(a, i + <span class="number">1</span>, hi);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 三取样并将切分元素放在数组末尾</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dealPivot</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (less(a[mid], a[lo]))</span><br><span class="line">    exch(a, lo, mid);</span><br><span class="line">    <span class="keyword">if</span> (less(a[hi], a[lo]))</span><br><span class="line">    exch(a, lo, hi);</span><br><span class="line">    <span class="keyword">if</span> (less(a[hi], a[mid]))</span><br><span class="line">    exch(a, mid, hi);</span><br><span class="line">    <span class="comment">// put the pivot to hi - 1 as a sentinel.</span></span><br><span class="line">    exch(a, mid, hi - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="熵最优的排序"><a href="#熵最优的排序" class="headerlink" title="熵最优的排序"></a>熵最优的排序</h4><p>实际应用中经常会出现含有大量重复元素的数组，我们实现的快速排序性能尚可，但是<strong>还有巨大的改进空间</strong>。例如：一个元素全部重复的子数组就不需要继续排序了，但我们的快速排序还是会继续将它切分为更小的数组。</p><p>[solution] : <strong>一个简单想法是将数组切分为三个部分，分别为小于、等于和大于切分元素的数组元素</strong>。</p><p>DIjkstra 解法 ： 从左到右遍历数组一次，维护一个指针 lt 使得 a[lo .. lt-1]中的元素都小于v, 一个 gt 使得a[gt+1 .. hi]中的元素都大于v, 一个指针 i 使得a[lt .. i-1]中的元素都等于v, a[i .. gt]中的元素都未确定。</p><ul><li>a[i] 小于 v, 将a[lt]和a[i]交换，将lt 和 i加一；</li><li>a[i] 大于 v, 将a[gt]和a[i]交换， 将gt减一；</li><li>a[i] 等于 v, i++.</li></ul><p>熵最优排序抽象实现： <a href="https://github.com/rovo98/ds-and-algs/blob/master/ds/sorting/exercises/Quick3Ways.java" target="_blank" rel="noopener">详细查看</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">sort(a, <span class="number">0</span>, a.length-<span class="number">1</span>);</span><br><span class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">isSorted</span><span class="params">(a)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (hi &lt;= lo) <span class="keyword">return</span>;</span><br><span class="line">    Comparable v = a[lo];</span><br><span class="line">    <span class="keyword">int</span> lt = lo;</span><br><span class="line">    <span class="keyword">int</span> i = lo + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> gt = hi;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (i &lt;= gt) &#123;</span><br><span class="line">    <span class="keyword">if</span> (less(a[i], v)) exch(a, i++,  lt++);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (less(v, a[i]))exch(a, gt--, i);</span><br><span class="line">        <span class="keyword">else</span> i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// since a[lt .. i-1] is sorted.</span></span><br><span class="line">    <span class="comment">// sort the other subarrays recursively.</span></span><br><span class="line">    sort(a, lo, lt-<span class="number">1</span>);</span><br><span class="line">    sort(a, gt+<span class="number">1</span>, hi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[notice] : <strong>三向切分的最坏情况是所有主键均不相同。</strong>对于标准的快速排序，随着数组规模的增大其运行时间会趋于平均时间，大幅偏离的情况是非常罕见的，因此可以肯定<strong>三向切分的快速排序运行时间和输入的信息量的N倍是成正比的。</strong> ———— 因为对于包含大量重复元素的数组，它将排序时间从线性对数级降到了线性级别。</p><h3 id="NOTICE"><a href="#NOTICE" class="headerlink" title="NOTICE"></a>NOTICE</h3><p>本文中，涉及的算法详细实现和使用，请移步到github<a href="https://github.com/rovo98/ds-and-algs#sorting-algorithms----go-back-to-top" target="_blank" rel="noopener">查看</a>。</p>]]></content>
    
    <summary type="html">
    
      快速排序 notes for algs4.
    
    </summary>
    
      <category term="Algorithms" scheme="http://rovo98.github.io/categories/Algorithms/"/>
    
    
      <category term="sorting algs" scheme="http://rovo98.github.io/tags/sorting-algs/"/>
    
  </entry>
  
  <entry>
    <title>归并排序 - mergeSort</title>
    <link href="http://rovo98.github.io/posts/1368334/"/>
    <id>http://rovo98.github.io/posts/1368334/</id>
    <published>2018-03-04T16:00:00.000Z</published>
    <updated>2018-06-12T06:50:18.611Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>归并排序属于<strong>分治算法(Divide and Conquer)</strong>。通过递归不断把待排序数组分成两个部分，将有序的两部分再重新归并一起来实现对数组的排序。</p><p><strong>[pseudo code for 2-way merge sort]</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MergeSort(arr[], aux[], lo, hi)</span><br><span class="line">If hi &gt; lo</span><br><span class="line">1. Find the middle point to divide the array into two halves;</span><br><span class="line">int mid = lo + (hi - lo) / 2;</span><br><span class="line">2. Call MergeSort for first half;</span><br><span class="line">MergeSort(arr, aux, lo, mid);</span><br><span class="line">3. Call MergeSort for second half;</span><br><span class="line">MergeSort(arr, aux, mid+1, hi);</span><br><span class="line">4. Merge the two halves sorted in step 2 and 3;</span><br><span class="line">Call merge(arr, aux, lo, mid, hi);</span><br></pre></td></tr></table></figure><h3 id="原地归并的抽象方法"><a href="#原地归并的抽象方法" class="headerlink" title="原地归并的抽象方法"></a>原地归并的抽象方法</h3><p>要实现上述的归并方法 — <strong>merge()</strong>很简单，创建一个数组将需要归并的<strong>原数组的两个部分</strong>中的元素放到这个数组中，然后再归并按大小顺序放回原数组。</p><blockquote><p>但是，这里我们要考虑一个问题，当我们用归并排序对一个比较大的数组进行排序时，我们需要进行很多次归并，因此在每一次归并时都创建一个新的数组来存储排序结果会带来问题。我们可以考虑只创建一个<strong>辅助数组aux[]</strong>, 在每一个归并时，将原数组需要归并的两个部分复制到aux[]中，再把归并结果放回原数组。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(Comparable[] a, Comparable[] aux, <span class="keyword">int</span> lo, <span class="keyword">int</span> mid, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line"><span class="comment">// precondition: a[lo .. mid] and a[mid+1 .. hi] is sorted.</span></span><br><span class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">isSorted</span><span class="params">(a, lo, mid)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">isSorted</span><span class="params">(a, mid+<span class="number">1</span>, hi)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// copy a[lo .. hi] to aux[lo .. hi].</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = lo; k &lt;= hi; k++) &#123;</span><br><span class="line">    aux[k] = a[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = lo;</span><br><span class="line">    <span class="keyword">int</span> j = mid+<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = lo; k &lt;= hi; k++) &#123;</span><br><span class="line">    <span class="keyword">if</span>      (i &gt; mid)               a[k] = aux[j++];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; hi)                a[k] = aux[i++];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (less(aux[j], aux[i]))  a[k] = aux[j++];</span><br><span class="line">        <span class="keyword">else</span>                a[k] = aux[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// postcondition: a[lo .. hi] is sorted.</span></span><br><span class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">isSorted</span><span class="params">(a, lo, hi)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[说明] : 该方法先将原数组两个需要归并的部分复制到aux[]中，然后<strong>从两个部分的起始位置开始取元素，一直选择两个部分中较小的元素放回原数组中，当有一部分元素取完了，则将另一部分剩余的元素全部放回原数组</strong>。</p><p>原地归并抽象方法轨迹： [from algs4]</p><p><img src="mergeSort_merge.png" alt="原地归并抽象方法轨迹"></p><h3 id="自顶向下的归并排序"><a href="#自顶向下的归并排序" class="headerlink" title="自顶向下的归并排序"></a>自顶向下的归并排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = a.length;</span><br><span class="line">    Comparable[] aux = <span class="keyword">new</span> Comparable[n];</span><br><span class="line">    sort(a, aux, <span class="number">0</span>, a.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, Comparable[] aux, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line"><span class="comment">// If array size is 1 then return.</span></span><br><span class="line"><span class="keyword">if</span> (hi &lt;= lo)    <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// Find the middle point to divide array into two halves.</span></span><br><span class="line">    <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// Call the mergeSort for first half.</span></span><br><span class="line">    sort(a, aux, lo, mid);</span><br><span class="line">    <span class="comment">// Call the mergeSort for second half.</span></span><br><span class="line">    sort(a, aux, mid+<span class="number">1</span>, hi);</span><br><span class="line">    <span class="comment">// Merge two halves sorted.</span></span><br><span class="line">    merge(a, aux, lo, mid, hi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自顶向下归并结果轨迹 : [from algs4]</p><p><img src="mergeSort_ubSort_1.png" alt="自顶向下归并结果轨迹"></p><p>自顶向下归并排序调用轨迹 : [from algs4]</p><p><img src="mergeSort_ubSort_2.png" alt="自顶向下归并排序调用轨迹"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">命题 F: 对于长度为 N 的任意数组， 自顶向下归并排序需要 1/2NlgN 至 NlgN 次比较。</span><br><span class="line"></span><br><span class="line">自顶向下的所需时间表达式为 : $T(N) = 2T(N/2) + O(n)$使用解决</span><br><span class="line">递归式的 Master method 解得 T(N) = $\Theta(n log n)$</span><br></pre></td></tr></table></figure><p>我们可以通过下图来理解命题F, 每个节点都表示一个sort()方法通过merge()方法归并而成的子数组。<strong>这棵树正好有 n 层。对于0 ~ n-1 之间的任意 k, 自顶向下的第 k 层有 $2^k$个子数组，每个数组长度为 $2^{n-k}$, 归并最多需要 $2^{n-k}$ 次比较。</strong>因此每层的比较次数为$2^k X 2^{n-k} = 2^n$, n 层总共为 $n2^n = NlgN$。</p><p>子数组树状图 : [from algs4]</p><p><img src="mergeSort_ubSort_3.png" alt="子数组树状图"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">命题 G : 对于长度为 N 的任意数组，自顶向下的归并排序最多需要</span><br><span class="line">访问数组 6NlgN 次。</span><br><span class="line"></span><br><span class="line">证明： 每次归并最多需要访问数组 6N 次（2N 次用来复制， 2N次</span><br><span class="line">用来将排好序的元素移动回去，另外最多比较2N次），根据命题F即</span><br><span class="line">可得到这个命题的结果。</span><br></pre></td></tr></table></figure><p><strong>[小结]</strong>: 归并排序排序算法的缺点是辅助数组所使用的额外空间和N的大小成正比。一些能够大幅度缩短归并排序的运行时间的想法：</p><ul><li>对小规模子数组进行插入排序；</li><li>测试数组是否已经有序；</li><li>不将元素复制到辅助数组中。</li></ul><h3 id="自底向上的归并排序"><a href="#自底向上的归并排序" class="headerlink" title="自底向上的归并排序"></a>自底向上的归并排序</h3><p>实现归并排序另外一种方法是<strong>先归并那些微型数组， 然后再成对归并得到的子数组，直到将整个数组归并在一起</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MergeBU</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = a.length;</span><br><span class="line">    Comparable[] aux = <span class="keyword">new</span> Comparable[n];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> sz = <span class="number">1</span>; sz &lt; n; sz += sz) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> lo = sz; lo &lt; n-sz; lo += sz+sz) &#123;</span><br><span class="line">        merge(a, aux, lo, lo+sz-<span class="number">1</span>, Math.min(lo+sz+sz-<span class="number">1</span>, n-<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#123;</span><br></pre></td></tr></table></figure><p>[注] : 自底向上的归并排序会多次遍历整个数组，根据子数组大小进行两两归并。子数组的大小 sz 的初始值为 1， 每次加倍。最后一个子数组的大小只有在数组大小是 sz 的偶数倍的时候才会等于 sz(否则它会比sz小)。</p><p>自底向上归并排序结果轨迹 ： [from algs4]</p><p><img src="mergeSort_buSort_1.png" alt="自底向上归并排序结果轨迹"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">命题 H : 对于长度为 N 的任意数组， 自底向上的归并排序需要 </span><br><span class="line">1/2NlgN 至 NlgN次比较，最多访问数组 6NlgN 次。</span><br><span class="line"></span><br><span class="line">证明 ： 处理一个数组的遍数正好是 [lgN] (即 2^n &lt;= N &lt;</span><br><span class="line">2^n+1 中的 n)。每一遍会访问数组6N次。</span><br><span class="line">比较次数在 N/2 和 N 之间。</span><br></pre></td></tr></table></figure><p>【补充】： 当数组长度为 2 的幂时，自顶向下和自底向上的归并排序所用的比较次数和数组访问次数正好相同，只是顺序不同。其他时候，两种方法的比较和数组访问的次序会有所不同。</p><h3 id="NOTICE"><a href="#NOTICE" class="headerlink" title="NOTICE"></a>NOTICE</h3><p>本文中，涉及的算法详细实现和使用，请移步到github<a href="https://github.com/rovo98/ds-and-algs#sorting-algorithms----go-back-to-top" target="_blank" rel="noopener">查看</a>。</p>]]></content>
    
    <summary type="html">
    
      归并排序 notes, learning from algs4.
    
    </summary>
    
      <category term="Algorithms" scheme="http://rovo98.github.io/categories/Algorithms/"/>
    
    
      <category term="sorting algs" scheme="http://rovo98.github.io/tags/sorting-algs/"/>
    
  </entry>
  
  <entry>
    <title>基本排序算法 - basial sorting algorithms with java implementation</title>
    <link href="http://rovo98.github.io/posts/57d02cec/"/>
    <id>http://rovo98.github.io/posts/57d02cec/</id>
    <published>2018-03-04T16:00:00.000Z</published>
    <updated>2018-06-12T06:50:18.595Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我们关注的主要对象是<strong>重新排列数组元素的算法</strong>， 其中每个元素都有一个<strong>主键</strong>。排序算法的目的就是将所有元素的主键按照某种方式排列(通常按照大小或是字母顺序)。</p></blockquote><a id="more"></a><p>在java中元素通常都是对象，对主键的抽象描述则是通过一种内置的机制(<strong>Comparable接口</strong>)来完成的。</p><h4 id="排序算法类模板"><a href="#排序算法类模板" class="headerlink" title="排序算法类模板"></a>排序算法类模板</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(Comparable[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    Comparable temp = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*排序算法，如InsertionSort、BubbleSort、</span></span><br><span class="line"><span class="comment">        SelectionSort、ShellSort等*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">        System.out.print(a[i] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(Comparable v, Comparable w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v.compareTo(w) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSorted</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (less(a[i], a[i-<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Unit tests the &#123;<span class="doctag">@code</span> Example&#125; sorting algorithm.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@args</span> command-line arguments.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 测试代码...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这个类展示的是数组排序实现的框架。代码中实现的排序方法适用于任意实现了Comparable接口的数据类型</strong>。</p><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>无论数组的初始状态是什么，我们都无法确保排序算法都能成功。所以谨慎起见，我们会在测试代码中添加一条语句<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">assert</span> <span class="title">isSorted</span><span class="params">(a)</span></span></span><br></pre></td></tr></table></figure><p></p><p>;来确保排序后的数组都是有序的。</p><h4 id="运行时间"><a href="#运行时间" class="headerlink" title="运行时间"></a>运行时间</h4><p>评估算法的性能。首先，要计算各个排序算法在不同的随机输入下的基本操作的次数(包括比较和交换，或者是读写数组的次数)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">排序成本模型 : 在研究排序算法时，我们需要计算比较和交换的数量。</span><br><span class="line">对于不交换元素的算法，我们会计算访问数组的次数。</span><br></pre></td></tr></table></figure><h4 id="额外的内存使用"><a href="#额外的内存使用" class="headerlink" title="额外的内存使用"></a>额外的内存使用</h4><p>排序算法的额外内存开销和运行时间是同等重要的。排序算法可以分为两类:</p><ul><li>除了函数调用所需的栈和固定数目的实例变量之外无需额外内存的<strong>原地排序算法</strong>。</li><li>需要额外内存空间来存储另一份数组副本的其他排序算法。</li></ul><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p>上面的排序模板适用于实现了Comparable接口的数据类型。例如, java中封装数字类型的<strong>Integer、Double、以及String</strong>和其他许多高级数据类型。<br>而对于自己创建的数据类型，我们是要实现Comparable接口就能够保证能够使用排序算法进行排序。</p><p>自定义数据类型样例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Date</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Date</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> day;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> month;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> year;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Date</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> m, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123; day = d; month = m; year = y; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">day</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> day; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">month</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> month; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">year</span><span class="params">()</span>   </span>&#123; <span class="keyword">return</span> year;  &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Date that)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.year &gt; that.year) <span class="keyword">return</span> +<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.year &lt; that.year) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.month &gt; that.month) <span class="keyword">return</span> +<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.month &lt; that.month) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.day &gt; that.day) <span class="keyword">return</span> +<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.day &lt; that.day) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> month + <span class="string">"/"</span> + day + <span class="string">"/"</span> + year;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>首先，找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置(如果第一个元素就是最小的元素那么它就和自己交换)。 再次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到整个数组排序完成。<strong>不断地选择剩余元素中的最小者</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">命题 A: 对于长度为 N 的数组，选择排序需要大约 N^2/2 次比较和 N 次交换。</span><br><span class="line"></span><br><span class="line">证明： 可以通过算法的排序轨迹来证明，用一张N X N的表格</span><br><span class="line">来表示排序的轨迹，其中每个非灰色字符都表示一次比较。</span><br><span class="line">表格中大约有一半的元素不是灰色的 —— 即对角线和其上部分的元素。</span><br><span class="line">对角巷上的每个元素都对应真一次交换。通过查看代码我们可</span><br><span class="line">以更精确地得到，0 到 N-1 的任意 i 都会进行一次交换和 </span><br><span class="line">N-1-i 次比较，因此总共有 N 次交换以及 $(N-1)+（N-2)+...+2+1 = N(N-1)/2 ~ N^2/2$。</span><br></pre></td></tr></table></figure><p>算法轨迹图示（from algs4)：</p><p><img src="bs_selectionSort_1.png" alt="插入排序算法轨迹例子"></p><p>算法实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Selection</span> </span>&#123;</span><br><span class="line"><span class="comment">/* 其他的方法同排序算法模板*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = a.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> min = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (less(a[j], a[min]) &#123;</span><br><span class="line">                min = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            exch(a, i, min);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>与选择排序一样，当前索引左边的所有元素都是有序的，但他们的最终位置不确定，为了给更小的元素腾出空间，它们可能会移动。当索引到达数组的右端时，数组排序就完成了。</p><blockquote><p>和选择排序不同的是，插入排序<strong>所需的时间取决于输入中元素的初始顺序</strong>。例如对于一个很大且其中的元素已经有序（或接近有序）的数组进行插入排序将会比对随机数组或逆序数组进行排序要快得多。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">命题 B : 对于随机排列的长度为 N 且主键不重复的数组， </span><br><span class="line">平均情况下插入排序需要 ~ $N^2/4$次比较以及 $~N^2/4$次交换。</span><br><span class="line">最坏情况下需要 ~N^2/2 次比较和 ~ $N^2/2$次交换，最好情况下需要$N-1$次比较和0次交换。</span><br><span class="line"></span><br><span class="line">证明： 和证明命题A一样，通过一个$N X N$的算法轨迹表可以很</span><br><span class="line">容易就得到交换和比较的次数。最坏的情况下对角线之下所有</span><br><span class="line">元素都需要移动位置，最好情况下都不需要。对于随机排列的</span><br><span class="line">数组，在平均情况下每个元素都可能向后移动半个数组的长度</span><br><span class="line">，因此交换总数是对角线之下的元素总数的二分之一。</span><br><span class="line">比较的总次数是交换的次数加上一个额外的项，该项为 N 减去</span><br><span class="line">被插入的元素正好是已知的最小元素的次数。在最坏情况下</span><br><span class="line">（逆序数组），这一项相对于总数可以忽略不计；在最好的情</span><br><span class="line">况下（数组已经有序），这一项等于N-1。</span><br></pre></td></tr></table></figure><p>插入排序算法轨迹图示（from algs4):</p><p><img src="bs_insertionSort_1.png" alt="插入排序算法轨迹图例"></p><p>算法实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Insertion</span> </span>&#123;</span><br><span class="line"><span class="comment">/*其他的方法同排序算法模板*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = a.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j&gt;<span class="number">0</span>&amp;&amp;less(a[j], a[j-<span class="number">1</span>]; j--) &#123;</span><br><span class="line">            exch(a, j, j-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>附加：</strong></p><p>对于插入排序，我们要考虑的更一般情况是<strong>部分有序的数组</strong>。<br><strong>倒置</strong>指的是数组中的两个顺序颠倒的元素。比如EXAMPLE中有11对倒置：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">E-A  X-A  X-M  X-P  X-LX-E</span><br><span class="line">M-L M-E  P-L  P-E L-E</span><br></pre></td></tr></table></figure><p></p><p>如果数组中倒置的数量小于数组大小的某个倍数，那么我们说这个数组是<strong>部分有序</strong>的。<br>几种典型的部分有序的数组:</p><ul><li>数组中每个元素距离它的最终位置不远；</li><li>一个有序数组接一个小数组；</li><li>数组中只有几个元素位置不正确。</li></ul><p><strong>插入排序对这样的数组很有效，而选择排序则不然。当倒置的数量很少时，插入排序比大部分的其他排序算法都要快</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">命题 C: 插入排序需要的交换的操作和数组的中倒置的数量相同，需要的比较次数大于等于</span><br><span class="line">倒置的数量，小于等于倒置的数量加上数组的大小再减一。</span><br><span class="line"></span><br><span class="line">证明： 每次交换都改变了两个顺序颠倒的元素的位置，相当于减少了一对倒置，当倒置数</span><br><span class="line">量为0时，排序就完成了。每次交换都对应着一次比较，且1到N-1之间的每个i都可能需要一</span><br><span class="line">次额外的比较(在a[i]没有达到数组的左端时)。</span><br></pre></td></tr></table></figure><p><strong>[算法改进]</strong> : 大幅提高插入排序的速度，在内循环中将较大的元素都向右移动而不是总是交换两个元素(这样访问数组的次数就能减半)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = a.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    Comparable key = a[i];</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span> (j = i-<span class="number">1</span>; j &gt;= <span class="number">0</span>&amp;&amp;less(key, a[j]); j--) &#123;</span><br><span class="line">        a[j+<span class="number">1</span>] = a[j];</span><br><span class="line">        &#125;</span><br><span class="line">        a[j+<span class="number">1</span>] = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>希尔排序是基于插入排序的快速排序算法.</p><blockquote><p>对于规模乱序数组插入排序很慢，因为它只会交换相邻的元素，因此元素只能一点一点地从数组的一端移动到另外一端。<br>希尔排序为了加快速度简单地改进了插入排序 —— 交换不相邻的元素以对数组的<strong>局部</strong>进行排序，并最终使用插入排序将局部有序的数组排序。</p><p><strong>希尔排序的思想</strong>:使任意间隔为h的元素都是有序的。<br>这样的数组称为<strong>h有序数组</strong>。对于任意以1为结尾的h序列（递增序列），我们使用它都能将数组排序。</p></blockquote><p>算法实现： —— 使用的递增序列来自 algs4.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shell</span> </span>&#123;</span><br><span class="line"><span class="comment">/*其他排序算法方法同模板*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> n = a.length;</span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (h &lt; n/<span class="number">3</span>) h = <span class="number">3</span> * h + <span class="number">1</span>; <span class="comment">// 1， 4， 13， 40， 121， ...</span></span><br><span class="line">        <span class="keyword">while</span> (h &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= h&amp;&amp;less(a[j], a[j-h]); j -= h) &#123;</span><br><span class="line">                exch(a, j, j-h);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            h /= <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>[递增序列的选择]</strong> : 算法的性能不仅取决于h，还取决与h之间的数学性质。目前还没有人能证明某个递增序列是”最好的”。以上算法实现使用的递增序列（使用序列 $1/2(3^k-1)$,从N/3开始递减至1.）的计算和使用都很简单且和复杂的递增序列的性能接近。</p><p>算法轨迹图例 — example (from algs4):</p><p><img src="bs_shellSort_1.png" alt="希尔排序算法轨迹图例"></p><p><strong>实际应用</strong>: 对于中等大小的数组它的运行时间是可以接受的且它的代码量小，不需要额外的内存空间。<em>所以在面临一个排序问题而没有系统排序函数可用时，可先用希尔排序，然后再考虑是否将它替换为更加复杂的排序算法</em>。</p><p><strong>[算法改进]</strong> : 由于希尔排序是基于插入排序，所以我们可以参照插入排序的改进，对希尔排序进行改进 — 把内循环中较大的元素右移而不是交换两个元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = a.length;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (h &lt; n/<span class="number">3</span>) h = <span class="number">3</span> * h + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (h &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h; i &lt; n; i++) &#123;</span><br><span class="line">        Comparable key = a[i];</span><br><span class="line">            <span class="keyword">int</span> j;</span><br><span class="line">            <span class="keyword">for</span> (j = i-h; j &gt;= <span class="number">0</span>&amp;&amp;less(key, a[j]); j -= h) &#123;</span><br><span class="line">            a[j+h] = a[j];</span><br><span class="line">            &#125;</span><br><span class="line">            a[j+h] = key;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="附加-——-冒泡排序"><a href="#附加-——-冒泡排序" class="headerlink" title="附加 —— 冒泡排序"></a>附加 —— 冒泡排序</h3><p>冒泡排序相对比较简单，这里直接给出它的实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bubble</span> </span>&#123;</span><br><span class="line"><span class="comment">/*其他排序算法方法同排序算法模板*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">int</span> n = a.length;</span><br><span class="line"> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n&amp;&amp;flag == <span class="keyword">true</span>; i++) &#123;</span><br><span class="line"> flag = <span class="keyword">false</span>;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n-i; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (less(a[j+<span class="number">1</span>], a[j]) &#123;</span><br><span class="line">        exch(a, j+<span class="number">1</span>, j);</span><br><span class="line">           flag = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>算法分析</strong>: 对于冒泡排序，最坏情况下，算法需要进行N-1趟排序，总的数组元素比较的次数为$(N-1)+(N-2)+…+1$ ~ $N^2/2$， 总的交换次数为数组中<strong>倒置</strong>的数量。</p><h3 id="NOTICE"><a href="#NOTICE" class="headerlink" title="NOTICE"></a>NOTICE</h3><p>本文中，涉及的算法详细实现和使用，请移步到github<a href="https://github.com/rovo98/ds-and-algs#sorting-algorithms----go-back-to-top" target="_blank" rel="noopener">查看</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;我们关注的主要对象是&lt;strong&gt;重新排列数组元素的算法&lt;/strong&gt;， 其中每个元素都有一个&lt;strong&gt;主键&lt;/strong&gt;。排序算法的目的就是将所有元素的主键按照某种方式排列(通常按照大小或是字母顺序)。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Algorithms" scheme="http://rovo98.github.io/categories/Algorithms/"/>
    
    
      <category term="sorting algs" scheme="http://rovo98.github.io/tags/sorting-algs/"/>
    
  </entry>
  
  <entry>
    <title>jsp基础学习笔记 - 概览</title>
    <link href="http://rovo98.github.io/posts/67d7cfb7/"/>
    <id>http://rovo98.github.io/posts/67d7cfb7/</id>
    <published>2017-10-12T03:40:34.000Z</published>
    <updated>2018-06-12T13:22:18.948Z</updated>
    
    <content type="html"><![CDATA[<p>Java 服务器页面(jsp) 是用来开发动态页面的一项技术。</p><p><img src="/images/jsp基础学习-概览/JSP.png" alt=""></p><a id="more"></a><p>JSP 允许开发人员使用指定的 JSP 标签来向html页面中插入java源代码，标签通常是<strong>以 &lt;% 开头并以 %&gt;</strong> 结束。</p><h3 id="为什么使用-JSP？"><a href="#为什么使用-JSP？" class="headerlink" title="为什么使用 JSP？"></a>为什么使用 JSP？</h3><p>使用Java服务器页面(jsp)与使用实现 Common Gateway Interface(<a href="https://baike.baidu.com/item/CGI/607810" target="_blank" rel="noopener">CGI</a>)的程序目的是大致相同的。但对比CGI，jsp有以下优点：</p><ol><li>性能较好。因为JSP允许直接在html页面中嵌入动态元素，而不需要独立持有CGI文件；</li><li>JSP在服务器处理前都会进行预编译，不像 CGI/<a href="https://baike.baidu.com/item/perl" target="_blank" rel="noopener">Perl</a>, 每次页面被请求时，服务器都需要加在一个解释器(interperter) 以及目标脚本(target script);</li><li>JSP是基于 Java Servlets API 构建的，因此，和Servlets一样，JSP也可以使用这些强大的Enterprise Java API, ：<strong>JDBC, JNDI, EJB, JAXP, 等等</strong>；</li><li><strong>JSP 页面可以和处理业务逻辑的servlets结合使用</strong>，该模型由[java servlet 模板引擎提供支持。</li></ol><p>最后，JSP是JavaEE(企业级应用程序的完整平台)的一个组成部分。这意味着JSP可以在最简单的应用程序中扮演最复杂和最苛刻的角色。</p><h3 id="使用JSP的优势"><a href="#使用JSP的优势" class="headerlink" title="使用JSP的优势"></a>使用JSP的优势</h3><p>下面通过对比不同的技术来体现使用JSP的优点：</p><h4 id="vs-Active-Server-Pages-ASP"><a href="#vs-Active-Server-Pages-ASP" class="headerlink" title="vs. Active Server Pages (ASP)"></a>vs. Active Server Pages (ASP)</h4><p>对比<a href="https://baike.baidu.com/item/asp/128906" target="_blank" rel="noopener">ASP</a>, JSP有两大优点：第一是页面的动态部分是用java写的，而不是Visual Basic或其他MS特定的语言编写，所以它更强有力且易于使用；第二是它可以移植到其他的操作系统和非Microsoft的Web 服务器上，这使它更加健壮。</p><h4 id="vs-Pure-Servets（纯Servlets"><a href="#vs-Pure-Servets（纯Servlets" class="headerlink" title="vs. Pure Servets（纯Servlets)"></a>vs. Pure Servets（纯Servlets)</h4><p>使用JSP可以更容易编写和修改常规的html代码，而不是使用大量的 <strong>println</strong>语句来生成HTML。</p><h4 id="vs-Server-Side-Includes-SSI"><a href="#vs-Server-Side-Includes-SSI" class="headerlink" title="vs. Server-Side Includes (SSI)"></a>vs. Server-Side Includes (<a href="https://baike.baidu.com/item/SSI" target="_blank" rel="noopener">SSI</a>)</h4><p>SSI 实际上只适用于处理简单内容的程序，而不适用于使用表单数据，进行数据库连接等的程序。</p><h4 id="vs-Javascript"><a href="#vs-Javascript" class="headerlink" title="vs. Javascript"></a>vs. Javascript</h4><p>JavaScript 可以在客户端生成HTML，但很难和Web 服务器实现复杂任务的交互，例如：数据库访问以及图像处理等。</p><h4 id="vs-静态HTML"><a href="#vs-静态HTML" class="headerlink" title="vs. 静态HTML"></a>vs. 静态HTML</h4><p>常规的HTML不能包含动态的内容，无法动态地改变页面展示的数据。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java 服务器页面(jsp) 是用来开发动态页面的一项技术。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/images/jsp基础学习-概览/JSP.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="jsp基础学习" scheme="http://rovo98.github.io/categories/jsp%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="学习笔记" scheme="http://rovo98.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="jsp" scheme="http://rovo98.github.io/tags/jsp/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式基本使用</title>
    <link href="http://rovo98.github.io/posts/f85f3c07/"/>
    <id>http://rovo98.github.io/posts/f85f3c07/</id>
    <published>2017-03-15T05:12:38.000Z</published>
    <updated>2018-06-13T09:30:21.043Z</updated>
    
    <content type="html"><![CDATA[<p>regular expression regex RE</p><p>简介</p><p>正则表达式是用来<strong>简洁</strong>表达一组字符串的表达式。</p><blockquote><p>正则表达式——一行胜千言</p></blockquote><ul><li>通用的字符串表达框架</li><li>简洁表达一组字符串的表达式</li><li>针对字符串表达“简洁”和“特征”思想的工具</li><li>判断某一字符串的特征归属</li></ul><a id="more"></a><h3 id="正则表达式在文本处理中十分常用"><a href="#正则表达式在文本处理中十分常用" class="headerlink" title="正则表达式在文本处理中十分常用"></a>正则表达式在文本处理中十分常用</h3><ul><li>表达文本类型的特征(病毒、入侵等)</li><li>同时查找或替换一组字符串</li><li>匹配字符串的全部或部分</li><li><strong>正则表达式主要应用在字符串的匹配中</strong></li></ul><h3 id="正则表达式的使用"><a href="#正则表达式的使用" class="headerlink" title="正则表达式的使用"></a>正则表达式的使用</h3><ul><li>编译：将符合正则表达式语法的字符串转换成正则表达式特征。—— re.compile(regex)</li></ul><h3 id="正则表达式的语法"><a href="#正则表达式的语法" class="headerlink" title="正则表达式的语法"></a>正则表达式的语法</h3><h4 id="正则表达式常用的操作符"><a href="#正则表达式常用的操作符" class="headerlink" title="正则表达式常用的操作符"></a>正则表达式常用的操作符</h4><div class="table-container"><table><thead><tr><th style="text-align:center">操作符</th><th style="text-align:center">说明</th><th style="text-align:center">实例</th></tr></thead><tbody><tr><td style="text-align:center">.</td><td style="text-align:center">表示任何单个字符</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">[ ]</td><td style="text-align:center">字符集，对单个字符给出取值范围</td><td style="text-align:center">[abc]表示a、b、c, [a-z]表示a到z单个字符</td></tr><tr><td style="text-align:center">[^ ]</td><td style="text-align:center">非字符集，对单个字符给出排除范围</td><td style="text-align:center">[^abc]表示非a或b或c的单个字符</td></tr><tr><td style="text-align:center">*</td><td style="text-align:center">前一个字符0次或无限次扩展</td><td style="text-align:center">abc*表示ab、abc、abcc、abcc等</td></tr><tr><td style="text-align:center">+</td><td style="text-align:center">前一个字符1次或无限次扩展</td><td style="text-align:center">abc+表示abc、abcc、abccc等</td></tr><tr><td style="text-align:center">?</td><td style="text-align:center">前一个字符0次或1次扩展</td><td style="text-align:center">abc?表示ab、abc</td></tr><tr><td style="text-align:center">&#124;</td><td style="text-align:center">左右表达式任意一个</td><td style="text-align:center">abc &#124; def表示abc、def</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:center">操作符</th><th style="text-align:center">说明</th><th style="text-align:center">实例</th></tr></thead><tbody><tr><td style="text-align:center">{m}</td><td style="text-align:center">扩展前一个字符m次</td><td style="text-align:center">ab{2}c表示abbc</td></tr><tr><td style="text-align:center">{m,n}</td><td style="text-align:center">扩展前一个字符m至n次</td><td style="text-align:center">ab{1,2}c表示abc、abbc</td></tr><tr><td style="text-align:center">^</td><td style="text-align:center">匹配字符串开头</td><td style="text-align:center">^abc表示abc且在一个字符串的开头</td></tr><tr><td style="text-align:center">$</td><td style="text-align:center">匹配字符串结尾</td><td style="text-align:center">abc$表示abc且在一个字符串的结尾</td></tr><tr><td style="text-align:center">( )</td><td style="text-align:center">分组标记，内部只能使用 &#124; 操作符</td><td style="text-align:center">(abc)表示abc ，(abc&#124;def)表示abc、def</td></tr><tr><td style="text-align:center">\d</td><td style="text-align:center">数字，等价于[0-9]</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">\w</td><td style="text-align:center">单词字符，等价于[A-Za-z0-9]</td></tr></tbody></table></div><h4 id="经典正则表达式实例"><a href="#经典正则表达式实例" class="headerlink" title="经典正则表达式实例"></a>经典正则表达式实例</h4><div class="table-container"><table><thead><tr><th style="text-align:center">^[A-Za-z]+$</th><th style="text-align:center">由26个字母组成的字符串</th></tr></thead><tbody><tr><td style="text-align:center">^[A-za-z0-9]+$</td><td style="text-align:center">由26个字母及数字组成的字符串</td></tr><tr><td style="text-align:center">^-?\d+$</td><td style="text-align:center">整数形式的字符串</td></tr><tr><td style="text-align:center">^[0-9]*[1-9][0-9]*$</td><td style="text-align:center">正整数形式的字符串</td></tr><tr><td style="text-align:center">[1-9]\d{5}</td><td style="text-align:center">中国境内的邮政编码，6 位</td></tr><tr><td style="text-align:center">[\u4e00-\u9fa5]</td><td style="text-align:center">匹配中文字符</td></tr><tr><td style="text-align:center">\d{3}-\d{8} &#124; \d{4}-\d{7}</td><td style="text-align:center">国内电话</td></tr></tbody></table></div><p>IP地址:</p><ul><li>不精确的写法：<ul><li>\d+.\d+.\d+.\d+ —— 以四个点进行分隔作为特点</li><li>\d{1,3}.\d{1,3}.\d{1,3}.\d{1,3}</li></ul></li><li>精确写法：<br>0-99 : [0-9]?\d 100-199 : 1\d{2}<br>200-249 : 2[0-4]\d 250-255 : 25[0-5]<br>(([0-9]?\d|1\d{2}|2[0-4]\d|25[0-5]).){3}([0-9]?\d|1\d{2}|2[0-4]\d|25[0-5])</li></ul><h3 id="Re库的基本使用"><a href="#Re库的基本使用" class="headerlink" title="Re库的基本使用"></a>Re库的基本使用</h3><h4 id="Re库介绍"><a href="#Re库介绍" class="headerlink" title="Re库介绍"></a>Re库介绍</h4><p>Re库是Python的标准库，主要用于字符串匹配。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br></pre></td></tr></table></figure><h4 id="正则表达式的表示类型"><a href="#正则表达式的表示类型" class="headerlink" title="正则表达式的表示类型"></a>正则表达式的表示类型</h4><ul><li>raw string 类型(原生字符串类型) —— 不包含转义字符<br>re 库采用raw string 类型表示正则表达式，表示为：r’text’</li><li>string类型， 更繁琐 —— 需要双重转义</li></ul><h4 id="Re库的主要功能函数"><a href="#Re库的主要功能函数" class="headerlink" title="Re库的主要功能函数"></a>Re库的主要功能函数</h4><div class="table-container"><table><thead><tr><th style="text-align:center">函数</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">re.search()</td><td style="text-align:center">在一个字符串中搜索匹配正则表达式的第一个位置，返回match对象</td></tr><tr><td style="text-align:center">re.match()</td><td style="text-align:center">在一个字符串开始位置起匹配正则表达式，返回match对象</td></tr><tr><td style="text-align:center">re.findall()</td><td style="text-align:center">搜索字符串，以列表类型返回全部能匹配的子串</td></tr><tr><td style="text-align:center">re.spilt()</td><td style="text-align:center">将一个字符串按照正则表达式匹配结果进行分割，返回列表类型</td></tr><tr><td style="text-align:center">re.fiinditer()</td><td style="text-align:center">搜索字符串，返回一个匹配结果的迭代类型，每个迭代元素是match</td></tr><tr><td style="text-align:center">re.sub()</td><td style="text-align:center">在一个字符串中替换所有匹配正则表达式的子串，返回替换后的字符串</td></tr></tbody></table></div><h5 id="re-search-pattern-string-flags-0"><a href="#re-search-pattern-string-flags-0" class="headerlink" title="re.search(pattern, string,flags=0)"></a>re.search(pattern, string,flags=0)</h5><ul><li>在一个字符串中搜索匹配正则表达式的第一个位置，返回match对象<ul><li>pattern: 正则表达式的字符串或者原生字符串 表示</li><li>string : 待匹配字符串</li><li>flags : 正则表达式使用时的控制标记</li></ul></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">常用标记</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">re.I re.IGNORECASE</td><td style="text-align:center">忽略正则表达式的大小写，[A-Z]能够匹配小写字符</td></tr><tr><td style="text-align:center">re.M RE.MULTILINE</td><td style="text-align:center">正则表达式中的^操作符能够将给定字符串的每行当作匹配开始</td></tr><tr><td style="text-align:center">re.S RE.DOTALL</td><td style="text-align:center">正则表达式中的.操作符能够匹配所有字符，默认匹配除换行符外的所有字符</td></tr></tbody></table></div><h5 id="re-match-partern-string-flags-0"><a href="#re-match-partern-string-flags-0" class="headerlink" title="re.match(partern, string, flags=0)"></a>re.match(partern, string, flags=0)</h5><ul><li>从一个字符串的开始位置起匹配正则表达式，返回match对象</li></ul><h5 id="re-findall-pattern-string-flags-0"><a href="#re-findall-pattern-string-flags-0" class="headerlink" title="re.findall(pattern, string , flags=0)"></a>re.findall(pattern, string , flags=0)</h5><ul><li>搜索字符串，以列表类型返回全部能匹配的子串。<ul><li>pattern ： 正则表达式的字符串或原生字符串表示</li><li>string ： 待匹配字符串</li><li>flags: 正则表达式使用时的控制标记</li></ul></li></ul><h5 id="re-split-pattern-string-maxsplit-0-flags-0"><a href="#re-split-pattern-string-maxsplit-0-flags-0" class="headerlink" title="re.split(pattern, string, maxsplit=0, flags=0)"></a>re.split(pattern, string, maxsplit=0, flags=0)</h5><ul><li>将一个字符串按照正则表达式匹配结果进行分割，返回列表类型。<ul><li>maxsplit: 最大分割数</li></ul></li></ul><h5 id="re-finditer-patern-string-flags-0"><a href="#re-finditer-patern-string-flags-0" class="headerlink" title="re.finditer(patern, string, flags=0)"></a>re.finditer(patern, string, flags=0)</h5><ul><li>搜索字符串，返回一个匹配结果的迭代类型，每一个迭代元素是match对象。</li></ul><h5 id="re-sub-pattern-repl-string-count-0-flags-0"><a href="#re-sub-pattern-repl-string-count-0-flags-0" class="headerlink" title="re.sub(pattern, repl, string, count=0, flags=0)"></a>re.sub(pattern, repl, string, count=0, flags=0)</h5><ul><li>在一个字符串中替换所有匹配正则表达式的子串，返回替换后的字符串。<ul><li>repl: 替换匹配字符串的字符串</li><li>count： 替换的最大次数</li></ul></li></ul><h5 id="Re库的另一种等价用法"><a href="#Re库的另一种等价用法" class="headerlink" title="Re库的另一种等价用法"></a>Re库的另一种等价用法</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rst = re.search(<span class="string">r'[1-9]\d&#123;5&#125;'</span>, <span class="string">'BIT100081'</span>)</span><br><span class="line"><span class="comment">#函数式用法： 一次性操作</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#面向对象用法：编译后的多次操作</span></span><br><span class="line">pat = re.compile(<span class="string">r'[1-9]\d&#123;5&#125;'</span>)</span><br><span class="line">rst = pat.search(<span class="string">'BIT100081'</span>)</span><br></pre></td></tr></table></figure><h5 id="regex-re-compile-pattern-flags-0"><a href="#regex-re-compile-pattern-flags-0" class="headerlink" title="regex  = re.compile(pattern, flags=0)"></a>regex = re.compile(pattern, flags=0)</h5><ul><li>将正则表达式的字符串形式编译成正则表达式对象</li></ul><h4 id="Re库的match对象"><a href="#Re库的match对象" class="headerlink" title="Re库的match对象"></a>Re库的match对象</h4><h5 id="Match对象的属性"><a href="#Match对象的属性" class="headerlink" title="Match对象的属性"></a>Match对象的属性</h5><div class="table-container"><table><thead><tr><th style="text-align:center">属性</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">.string</td><td style="text-align:center">待匹配文本</td></tr><tr><td style="text-align:center">.re</td><td style="text-align:center">匹配时使用的pattern对象()正则表达式</td></tr><tr><td style="text-align:center">.pos</td><td style="text-align:center">正则表达式搜索文本的开始位置</td></tr><tr><td style="text-align:center">.endpos</td><td style="text-align:center">正则表达式搜索文本的结束位置</td></tr></tbody></table></div><h5 id="Match对象的方法"><a href="#Match对象的方法" class="headerlink" title="Match对象的方法"></a>Match对象的方法</h5><div class="table-container"><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">.group(0)</td><td style="text-align:center">获得匹配后的字符串</td></tr><tr><td style="text-align:center">.start()</td><td style="text-align:center">匹配字符串在原始字符串的开始位置</td></tr><tr><td style="text-align:center">.end()</td><td style="text-align:center">匹配字符串在原始字符串的结束位置</td></tr><tr><td style="text-align:center">.span()</td><td style="text-align:center">返回(.start(),.end()) — 元组类型</td></tr></tbody></table></div><h4 id="Re库的贪婪匹配和最小匹配"><a href="#Re库的贪婪匹配和最小匹配" class="headerlink" title="Re库的贪婪匹配和最小匹配"></a>Re库的贪婪匹配和最小匹配</h4><ul><li>Re库默认采用贪婪匹配</li></ul><h5 id="最小匹配操作符"><a href="#最小匹配操作符" class="headerlink" title="最小匹配操作符"></a>最小匹配操作符</h5><div class="table-container"><table><thead><tr><th style="text-align:center">操作符</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">*?</td><td style="text-align:center">前一个字符0次或无限次扩展，最小匹配</td></tr><tr><td style="text-align:center">+?</td><td style="text-align:center">前一个字符1次或无限次扩展，最小匹配</td></tr><tr><td style="text-align:center">??</td><td style="text-align:center">前一个字符0次或1次扩展，最小匹配</td></tr><tr><td style="text-align:center">{m,n}?</td><td style="text-align:center">扩展前一个字符m至n次(含n)，最小匹配</td></tr></tbody></table></div><h3 id="高效的正则表达式技巧总结"><a href="#高效的正则表达式技巧总结" class="headerlink" title="高效的正则表达式技巧总结"></a>高效的正则表达式技巧总结</h3><h4 id="误匹配"><a href="#误匹配" class="headerlink" title="误匹配"></a>误匹配</h4><p>指<strong>正则表达式</strong>所匹配的内容范围超过了所需要范围，有些文本命名不符合要求，但是被所写的正则表达式“击中”了。例如：如果使用\d{11}去匹配11位手机号，\d{11}不单单能匹配正确的手机号，它还会匹配98824839344这样明显不是手机号的<strong>字符串</strong>。我们把这样的匹配称为<strong>误匹配</strong>。</p><h4 id="漏匹配"><a href="#漏匹配" class="headerlink" title="漏匹配"></a>漏匹配</h4><p>指正则表达式所匹配的内容所规定的范围太狭窄，有些文本确实是所需要的，但是所写的正则表达式没有将这种情况囊括在内。例如：使用\d{18}来匹配身份证号码，就会漏掉结尾是字母X的情况。<br>写出一条<strong>正则表达式</strong>，既可能出现<strong>误匹配</strong>(条件写得太宽松，范围大于目标文本)，也可能出现<strong>漏匹配</strong>(只描述了目标文本中多种情况的部分)，还可能既有<strong>误匹配</strong>又有<strong>漏匹配</strong>。例如：使用\w+.com来匹配.com结尾的域名，既会误匹配abc_.com(合法域名不包含_,\w包含了这种情况),又会漏掉ab-c.com这样的域名(合法域名可以包含中划线，\w不包含中划线).</p><h4 id="应对方法"><a href="#应对方法" class="headerlink" title="应对方法"></a>应对方法</h4><h5 id="掌握语法细节"><a href="#掌握语法细节" class="headerlink" title="掌握语法细节"></a>掌握语法细节</h5><p>正则表达式在各种语言中，其语法大致相同，细节各有千秋。明确所使用语言的正则的语法的细节，是写出正确、高效<strong>正则表达式</strong>的基础。例如，perl中与\w等效的匹配范围是[a-zA-Z0-9_];perl正则表达式不支持肯定逆序视中使用可变的重复(variable repetition inside lookbehind,例如( ?&lt;=.* )abc), 但是.Net语法是支持这一特性的；又如，JavaScript连逆序环视(lookbehind,如(?&lt;=ab)c)都不支持，而Perl和Python是支持的。&lt;&lt;精通正则表达式&gt;&gt;第三章&lt;&lt;正则表达式的特性和流派概览&gt;&gt;明确地列出了个大派系的正则表达式的异同。</p><h5 id="先粗后精，先减后加"><a href="#先粗后精，先减后加" class="headerlink" title="先粗后精，先减后加"></a>先粗后精，先减后加</h5><p>使用正则表达式语法对于目标文本进行描述和界定，可以像画素描一样，先大致勾勒出框架，在逐步在局部实现细节。仍举刚才的手机例子：先界定\d{11},总不会错；再细化为1[358]\d{9},就向前迈了一大步。先消除 <strong>漏匹配</strong>(刚开始先尽可能多的匹配，做加法)，然后再一点点去除<strong>误匹配</strong>(做减法)。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;regular expression regex RE&lt;/p&gt;&lt;p&gt;简介&lt;/p&gt;&lt;p&gt;正则表达式是用来&lt;strong&gt;简洁&lt;/strong&gt;表达一组字符串的表达式。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;正则表达式——一行胜千言&lt;/p&gt;&lt;/blockquote&gt;&lt;ul&gt;&lt;li&gt;通用的字符串表达框架&lt;/li&gt;&lt;li&gt;简洁表达一组字符串的表达式&lt;/li&gt;&lt;li&gt;针对字符串表达“简洁”和“特征”思想的工具&lt;/li&gt;&lt;li&gt;判断某一字符串的特征归属&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="Python爬虫" scheme="http://rovo98.github.io/categories/Python%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="学习笔记" scheme="http://rovo98.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="regex基础" scheme="http://rovo98.github.io/tags/regex%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>理解Requests库的异常和HTTP协议</title>
    <link href="http://rovo98.github.io/posts/4ae864e2/"/>
    <id>http://rovo98.github.io/posts/4ae864e2/</id>
    <published>2017-03-15T05:11:01.000Z</published>
    <updated>2018-06-12T13:21:59.187Z</updated>
    
    <content type="html"><![CDATA[<p>简单理解Requests库中的异常和HTTP协议。</p><a id="more"></a><div class="table-container"><table><thead><tr><th style="text-align:center">异常</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">requests.ConnectionError</td><td style="text-align:center">网络连接错误异常，如DNS查询失败、拒绝连接等</td></tr><tr><td style="text-align:center">requests.HTTPError</td><td style="text-align:center">HTTP错误异常</td></tr><tr><td style="text-align:center">requests.URLRequired</td><td style="text-align:center">URl缺失异常</td></tr><tr><td style="text-align:center">requests.TooManyRedirects</td><td style="text-align:center">超过最大重定向次数，产生重定向异常</td></tr><tr><td style="text-align:center">requests.ConnectTimeout</td><td style="text-align:center">连接远程服务器超时异常</td></tr><tr><td style="text-align:center">requests.Timeout</td><td style="text-align:center">请求URL超时，产生超时异常</td></tr></tbody></table></div><p>Response的异常：</p><div class="table-container"><table><thead><tr><th style="text-align:center">异常</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">r.raise_for_status()</td><td style="text-align:center">如果不是200， 产生异常requests.HTTPError</td></tr></tbody></table></div><p><strong>爬取网页的通用代码框架</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getHTMLText</span><span class="params">(url)</span> :</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        r = requests.get(url, timeout=<span class="number">30</span>)</span><br><span class="line">        r.raise_for_status() <span class="comment">#如果状态不是200， 引发requests.HTTPError异常</span></span><br><span class="line">        r.encoding = r.apparent_encoding <span class="comment">#将encoding 设置为'utf-8'，一般用于没有charset的header</span></span><br><span class="line">        <span class="keyword">return</span> r.text</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'产生异常'</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    url = <span class="string">"http://www.baidu.com"</span></span><br><span class="line">    print(getHTMLText(url))</span><br></pre></td></tr></table></figure><h4 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h4><p>HTTP, Hypertext Transfer Protocol, 超文本传输协议</p><p>HTTP是一个基于“请求与响应”模式的、无状态的应用层协议。</p><p>HTTP协议采用URL作为定位网络资源的标识。</p><p><strong>URL格式：</strong><a href="http://host\[:port][path" target="_blank" rel="noopener">http://host\[:port][path</a>]</p><p>HTTP URL的理解：</p><p>URL 是通过HTTP协议存取资源的Internet路径，一个URL对应一个数据资源。</p><h4 id="HTTP协议对资源的操作"><a href="#HTTP协议对资源的操作" class="headerlink" title="HTTP协议对资源的操作"></a>HTTP协议对资源的操作</h4><div class="table-container"><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">GET</td><td style="text-align:center">请求获取URL位置的资源</td></tr><tr><td style="text-align:center">HEAD</td><td style="text-align:center">请求获取URL位置资源的响应消息报告，即获取该资源的头部信息</td></tr><tr><td style="text-align:center">POST</td><td style="text-align:center">请求URL位置的资源后附加新的数据</td></tr><tr><td style="text-align:center">PUT</td><td style="text-align:center">请求向URL位置存储一个资源，覆盖原URL位置的资源</td></tr><tr><td style="text-align:center">PATCH</td><td style="text-align:center">请求局部更新URL位置的资源，即改变该处资源的部分内容</td></tr><tr><td style="text-align:center">DELETE</td><td style="text-align:center">请求删除URL位置存储的资源</td></tr></tbody></table></div><p><strong>理解PATCH和PUT的区别</strong>：</p><p>假设URL位置有一组数据UserInfo， 包括UserID、UserName等20个字段</p><p>需求：用户修改了UserName，其他不变。</p><p>采用PATCH，仅向URL提交UserName的剧本更新请求。</p><p>采用PUT，必须将所有20个字段一并提交URL，未提交字段被删除。<br>PATCH的好处：节省网络带宽</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单理解Requests库中的异常和HTTP协议。&lt;/p&gt;
    
    </summary>
    
      <category term="python爬虫" scheme="http://rovo98.github.io/categories/python%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="学习笔记" scheme="http://rovo98.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Requests库" scheme="http://rovo98.github.io/tags/Requests%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Requests库的7个主要方法</title>
    <link href="http://rovo98.github.io/posts/c671c604/"/>
    <id>http://rovo98.github.io/posts/c671c604/</id>
    <published>2017-03-15T05:10:41.000Z</published>
    <updated>2018-06-12T13:21:01.172Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Requests库的7个主要方法"><a href="#Requests库的7个主要方法" class="headerlink" title="Requests库的7个主要方法"></a>Requests库的7个主要方法</h3><div class="table-container"><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">requests.request()</td><td style="text-align:center">构造一个请求，支撑以下各方法的基础方法</td></tr><tr><td style="text-align:center">requests.get()</td><td style="text-align:center">获取HTML网页的主要方法，对应于HTTP的GET</td></tr><tr><td style="text-align:center">requests.head()</td><td style="text-align:center">获取HTML网页头信息的方法，对应于HTTP的HEAD</td></tr><tr><td style="text-align:center">requests.post()</td><td style="text-align:center">向HTML网页提交POST请求的方法，对应于HTTP的POST</td></tr><tr><td style="text-align:center">requests.put()</td><td style="text-align:center">向HTML网页提交PUT请求的方法，对应于HTTP的PUT</td></tr><tr><td style="text-align:center">requests.patch()</td><td style="text-align:center">向HTML网页提交局部修改请求，对应于HTTP的PATCH</td></tr><tr><td style="text-align:center">requests.delete()</td><td style="text-align:center">向HTML页面提交删除请求，对应HTTP的DELETE</td></tr></tbody></table></div><h4 id="requests库的主要方法-基础方法"><a href="#requests库的主要方法-基础方法" class="headerlink" title="requests库的主要方法(基础方法)"></a>requests库的主要方法(基础方法)</h4><p>requests.request(method, url, **kwargs)</p><ul><li><strong>method:</strong>请求方式，对应get/put/post等7种<ul><li>r = requests.request(‘GET’,url, **kwargs)</li><li>r = requsts.request(‘HEAD’,url, **kwargs)</li><li>r = requests.request(‘POST’,url, **kwargs)</li><li>r = requests.request(‘PATCH’,url, **kwargs)</li><li>r = requests.request(‘delete’, url, **kwargs)</li><li>r = requests.request(‘OPTIONS’,url, **kwargs)</li></ul></li></ul><ul><li><strong>url:</strong>拟获取页面的URL链接</li><li>**kwargs: 控制访问的参数，共13个<ul><li>1)params:字典或字节序列，作为参数增加到URL中</li><li>2)data: 字典、字节序列或者文件对象，作为Request的内容</li><li>3)json : JSON格式数据，作为Request内容</li><li>4)headers : 字典，HTTP定制头</li><li>5)cookies : 字典或CookieJar，Request中的cookie</li><li>6)auth : 元组，支持HTTP认证功能</li><li>7)files : 字典类型，传输文件</li><li>8)timeout : 设定的超时时间，秒为单位</li><li>9)proxies : 字典类型，设定访问代理服务器，可以增加登录认证</li><li>10)allow_redirects : True/False, 默认为True,重定向开关</li><li>11)stream : True/False, 默认为True ,获取内容立即下载开关</li><li>12)verify : True/False , 默认为True ， 认证SSL证书开关</li><li>13) cert : 本地SSL证书路径<h4 id="requests-get-方法："><a href="#requests-get-方法：" class="headerlink" title="requests.get()方法："></a>requests.get()方法：</h4></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r = requests.get(url)    <span class="comment">#构造一个向服务器请求资源的Request对象</span></span><br><span class="line"><span class="comment">#返回一个包含服务器资源的Response对象</span></span><br></pre></td></tr></table></figure><p>完整方法：requests.get(==url, params=None, **kwargs==)</p><p>url: 拟获取页面的url链接</p><p>params: url中的额外参数， 字典或字节流格式， 可选</p><p>**kwargs : 12个控制访问的参数，与request()的一样</p><p>实际上是这样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(url, params=None, **kwargs)</span>:</span></span><br><span class="line">    <span class="comment">#Sends a GET request.</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#:param url: URL for the new :class :'Request' object.</span></span><br><span class="line">    <span class="comment">#:param params: (optional) Dictionary ro bytes to be sent in the query</span></span><br><span class="line">    <span class="comment">#:return: :class :'Request &lt;Response&gt;' object</span></span><br><span class="line">    <span class="comment">#:rtype: requests.Response</span></span><br><span class="line">    </span><br><span class="line">    kwargs.setdefault(<span class="string">'allow redirect'</span>, <span class="keyword">True</span>)</span><br><span class="line">    <span class="keyword">return</span> request(<span class="string">'get'</span>, url, params=params, **kwargs)</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">r = requests.get(<span class="string">"http://www.baidu.com"</span>)</span><br><span class="line">print(r)</span><br><span class="line">type(r)</span><br><span class="line">r.headers</span><br><span class="line"></span><br><span class="line"><span class="string">"""输出：</span></span><br><span class="line"><span class="string">200</span></span><br><span class="line"><span class="string">&lt;class 'requests.models.Response'&gt;</span></span><br><span class="line"><span class="string">&#123;'Transfer-Encoding': 'chunked', 'Pragma': 'no-cache', 'Connection': 'Keep-Alive', 'Last-Modified': 'Mon, 23 Jan 2017 13:27:52 GMT', 'Cache-Control': 'private, no-cache, no-store, proxy-revalidate, no-transform', 'Server': 'bfe/1.0.8.18', 'Set-Cookie': 'BDORZ=27315; max-age=86400; domain=.baidu.com; path=/', 'Content-Encoding': 'gzip', 'Date': 'Sat, 15 Jul 2017 13:27:01 GMT', 'Content-Type': 'text/html'&#125;</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h4 id="Response对象的属性"><a href="#Response对象的属性" class="headerlink" title="Response对象的属性"></a>Response对象的属性</h4><div class="table-container"><table><thead><tr><th style="text-align:center">属性</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">r.status_code</td><td style="text-align:center">HTTP请求的返回状态，200表示连接成功，404表示失败</td></tr><tr><td style="text-align:center">r.text</td><td style="text-align:center">HTTP响应内容的字符串形式，即，url对应的页面内容</td></tr><tr><td style="text-align:center">r.encoding</td><td style="text-align:center">从HTTP header中猜测的响应内容编码方式</td></tr><tr><td style="text-align:center">r.apparent_encoding</td><td style="text-align:center">从内容中分析出的响应内容编码方式(备用编码凡是)</td></tr><tr><td style="text-align:center">r.content</td><td style="text-align:center">HTTP响应内容的二进制形式</td></tr></tbody></table></div><p>[注]：<strong>r.encoding: 如果header中不存在charset， 则认为编码为ISO-8859-1</strong></p><h4 id="Requests库的head-方法"><a href="#Requests库的head-方法" class="headerlink" title="Requests库的head()方法"></a>Requests库的head()方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">r = requests.head(<span class="string">'http://httpbin.org/get'</span>)</span><br><span class="line">r.headers</span><br><span class="line">r.text</span><br><span class="line"><span class="string">"""输出：</span></span><br><span class="line"><span class="string">&#123;'Access-Control-Allow-Credentials': 'true', 'X-Processed-Time': '0.000805139541626', 'Via': '1.1 vegur', 'Access-Control-Allow-Origin': '*', 'X-Powered-By': 'Flask', 'Content-Length': '267', 'Server': 'meinheld/0.6.1', 'Content-Type': 'application/json', 'Date': 'Sat, 15 Jul 2017 14:23:41 GMT', 'Connection': 'keep-alive'&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">'' -- r.text</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h4 id="Requests库的post-方法"><a href="#Requests库的post-方法" class="headerlink" title="Requests库的post()方法"></a>Requests库的post()方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">payload = &#123;<span class="string">'key1'</span>:<span class="string">'value1'</span>, <span class="string">'key2'</span>:<span class="string">'value2'</span>&#125;</span><br><span class="line">r = requests.post(<span class="string">'http://httpbin.org/post'</span>, data = payload)</span><br><span class="line">r = requests.post(<span class="string">'http://httpbin.org/post'</span>, data = <span class="string">'ABC'</span>)</span><br><span class="line"><span class="comment">#向URL POST一个字典自动编码为form(表单)</span></span><br><span class="line">print(r.text)</span><br><span class="line"><span class="string">"""输出:</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  "args": &#123;&#125;, </span></span><br><span class="line"><span class="string">  "data": "ABC",    --- &gt; 向URLPOST一个字符串，自动编码为data</span></span><br><span class="line"><span class="string">  "files": &#123;&#125;, </span></span><br><span class="line"><span class="string">  "form": &#123;</span></span><br><span class="line"><span class="string">    "key1": "value1", </span></span><br><span class="line"><span class="string">    "key2": "value2"</span></span><br><span class="line"><span class="string">  &#125;, </span></span><br><span class="line"><span class="string">  "headers": &#123;</span></span><br><span class="line"><span class="string">    "Accept": "*/*", </span></span><br><span class="line"><span class="string">    "Accept-Encoding": "gzip, deflate", </span></span><br><span class="line"><span class="string">    "Connection": "close", </span></span><br><span class="line"><span class="string">    "Content-Length": "23", </span></span><br><span class="line"><span class="string">    "Content-Type": "application/x-www-form-urlencoded", </span></span><br><span class="line"><span class="string">    "Host": "httpbin.org", </span></span><br><span class="line"><span class="string">    "User-Agent": "python-requests/2.18.1"</span></span><br><span class="line"><span class="string">  &#125;, </span></span><br><span class="line"><span class="string">  "json": null, </span></span><br><span class="line"><span class="string">  "origin": "120.85.181.141", </span></span><br><span class="line"><span class="string">  "url": "http://httpbin.org/post"</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h4 id="Requests库的put-方法"><a href="#Requests库的put-方法" class="headerlink" title="Requests库的put()方法"></a>Requests库的put()方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">payload = &#123;<span class="string">'key1'</span>:<span class="string">'value1'</span>, <span class="string">'key2'</span>:<span class="string">'value2'</span>&#125;</span><br><span class="line">r = requests.put(<span class="string">'http://httpbin.org/put'</span>, data = payload)</span><br><span class="line">print(r.text)</span><br><span class="line"><span class="comment">#此方法与post方法类似，只不过是替换了URL位置上资源的内容</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      简单了解python爬虫库requests的7个主要方法.
    
    </summary>
    
      <category term="python爬虫" scheme="http://rovo98.github.io/categories/python%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="学习笔记" scheme="http://rovo98.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Requests库" scheme="http://rovo98.github.io/tags/Requests%E5%BA%93/"/>
    
  </entry>
  
</feed>
