<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>rovo98&#39;s Blog</title>
  
  <subtitle>Leave your comfort zone!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://rovo98.github.io/"/>
  <updated>2018-06-24T10:58:49.286Z</updated>
  <id>http://rovo98.github.io/</id>
  
  <author>
    <name>rovo98</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>解决Github国内访问出现的问题</title>
    <link href="http://rovo98.github.io/posts/7e3029b3/"/>
    <id>http://rovo98.github.io/posts/7e3029b3/</id>
    <published>2018-06-10T07:58:34.000Z</published>
    <updated>2018-06-24T10:58:49.286Z</updated>
    
    <content type="html"><![CDATA[<p>主要通过修改hosts文件解决Github在国内访问不了、访问慢和页面加载异常的问题(没钱买vpn~)。</p><p>简单了解一下github, github是目前全球最大的男性同性交友网站(~滑稽~), 使用示例如下：</p><p><img src="/images/解决Github访问问题/communication.png" alt=""></p><a id="more"></a><p>开个玩笑，回归正题。</p><h3 id="为什么访问不了以及访问速度会很慢？"><a href="#为什么访问不了以及访问速度会很慢？" class="headerlink" title="为什么访问不了以及访问速度会很慢？"></a>为什么访问不了以及访问速度会很慢？</h3><p>GitHub在中国大陆访问速度慢的问题原因有很多，但最直接和最主要的原因是GitHub的分发加速网络的域名遭到DNS污染。</p><p>由于GitHub的加速分发CDN域名assets-cdn.github.com遭到DNS污染，导致无法连接使用GitHub的加速分发服务器，才使得中国大陆访问速度很慢。</p><p><img src="github_problem.png" alt="problem"></p><h3 id="如何解决DNS污染？"><a href="#如何解决DNS污染？" class="headerlink" title="如何解决DNS污染？"></a>如何解决DNS污染？</h3><p>一般的DNS问题都可以通过修改Hosts文件来解决，GitHub的CDN域名被污染问题也不例外，同样可以通过修改Hosts文件解决。</p><p>将域名解析直接指向IP地址来绕过DNS的解析，以此解决污染问题。</p><h4 id="获取被污染域名的实际IP地址"><a href="#获取被污染域名的实际IP地址" class="headerlink" title="获取被污染域名的实际IP地址"></a>获取被污染域名的实际IP地址</h4><p>访问<a href="https://wwww.ipaddress.com" target="_blank" rel="noopener">ipaddress.com</a>,使用ip lookup 工具获得相关域名的ip地址。</p><p>例如： github.com</p><p><img src="github_ipaddress.png" alt="ip address"></p><p>可以看到，我查出的域名ip地址为： <code>192.30.254.112</code> 和 <code>192.30.253.113</code> (任取一个即可)</p><h4 id="修改host文件，在文件中添加一行："><a href="#修改host文件，在文件中添加一行：" class="headerlink" title="修改host文件，在文件中添加一行："></a>修改host文件，在文件中添加一行：</h4><p><strong>[注] ： windows的hosts文件位置为：</strong><br><code>C:/windows/system32/drivers/etc/hosts</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">192.30.253.112 github.com</span><br></pre></td></tr></table></figure><h4 id="刷新dns缓存"><a href="#刷新dns缓存" class="headerlink" title="刷新dns缓存"></a>刷新dns缓存</h4><p>打开命令行cmd,输入如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig /flushdns</span><br></pre></td></tr></table></figure><p>此时再刷新页面即可。此时可以正常访问github，但是访问速度还是很慢，我们接着做优化。</p><h4 id="Github-访问提速"><a href="#Github-访问提速" class="headerlink" title="Github 访问提速"></a>Github 访问提速</h4><p>在hosts文件中继续加入，如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># GitHub Start</span><br><span class="line">192.30.253.112 github.com</span><br><span class="line">192.30.253.119 gist.github.com</span><br><span class="line">151.101.228.133 assets-cdn.github.com</span><br><span class="line">151.101.228.133 raw.githubusercontent.com</span><br><span class="line">151.101.228.133 gist.githubusercontent.com</span><br><span class="line">151.101.228.133 cloud.githubusercontent.com</span><br><span class="line">151.101.228.133 camo.githubusercontent.com</span><br><span class="line">151.101.228.133 avatars0.githubusercontent.com</span><br><span class="line">151.101.228.133 avatars1.githubusercontent.com</span><br><span class="line">151.101.228.133 avatars2.githubusercontent.com</span><br><span class="line">151.101.228.133 avatars3.githubusercontent.com</span><br><span class="line">151.101.228.133 avatars4.githubusercontent.com</span><br><span class="line">151.101.228.133 avatars5.githubusercontent.com</span><br><span class="line">151.101.228.133 avatars6.githubusercontent.com</span><br><span class="line">151.101.228.133 avatars7.githubusercontent.com</span><br><span class="line">151.101.228.133 avatars8.githubusercontent.com</span><br><span class="line">192.30.253.116  api.github.com</span><br><span class="line"># GitHub End</span><br></pre></td></tr></table></figure><p><strong>[notice]</strong> : 这里域名对应的ip是通过dns查询工具查询得到的，你应当选择的是延时相对较小且比较稳定的ip。</p><p>例如，上面的<code>151.101.228.133</code>是对我来说较好的ip:</p><p><img src="ping_test.png" alt="dns 查询检测"></p><p>推荐的dns查询检测工具：</p><ul><li><a href="https://tool.lu/dns/" target="_blank" rel="noopener">DNS查询 - 在线工具</a></li><li><a href="http://tool.chinaz.com/dns/" target="_blank" rel="noopener">DNS检测|DNS查询-站长工具</a></li></ul><p>你可对单个域名多查询几次，以挑选稳定且速度较快的ip。</p><h4 id="快速地访问github"><a href="#快速地访问github" class="headerlink" title="快速地访问github"></a>快速地访问github</h4><p>再次刷新dns缓存后，你已经可以快速地访问github了。</p><p><img src="github_test.gif" alt=""></p><p>参考：<a href="https://github.com/chenxuhua/issues-blog/issues/3" target="_blank" rel="noopener">https://github.com/chenxuhua/issues-blog/issues/3</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要通过修改hosts文件解决Github在国内访问不了、访问慢和页面加载异常的问题(没钱买vpn~)。&lt;/p&gt;&lt;p&gt;简单了解一下github, github是目前全球最大的男性同性交友网站(~滑稽~), 使用示例如下：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/images/解决Github访问问题/communication.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="tips" scheme="http://rovo98.github.io/categories/tips/"/>
    
    
      <category term="github" scheme="http://rovo98.github.io/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>PPP 点对点通信验证</title>
    <link href="http://rovo98.github.io/posts/28ff89ad/"/>
    <id>http://rovo98.github.io/posts/28ff89ad/</id>
    <published>2018-06-09T16:10:00.000Z</published>
    <updated>2018-06-24T11:09:29.767Z</updated>
    
    <content type="html"><![CDATA[<p>使用Cisco Packet Tracer7 (思科网络模拟器)验证ppp点对点通信。</p><p><img src="/images/ppp通信验证/packetTracer7.png" alt=""></p><a id="more"></a><h3 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h3><p>使用<code>packet Tracer</code> 模拟两台路由器，进行点对点通信测试。</p><h4 id="实验设计"><a href="#实验设计" class="headerlink" title="实验设计"></a>实验设计</h4><p>实验设备结构图：</p><p><img src="structure.png" alt="结构"></p><ul><li>均使用思科模拟器中的Generic 泛型路由<h3 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h3></li></ul><h4 id="配置路由器"><a href="#配置路由器" class="headerlink" title="配置路由器"></a>配置路由器</h4><p>由于只需要验证点对点通信，对路由器的配置，相对比较简单，<br>路由器之间使用的是serial DCE 串口线相连。</p><p>配置Router1的<code>serial 2/0</code>串口为ip: <code>11.0.0.1</code> mask: <code>255.0.0.0</code>,并配置时钟频率为<code>64000</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Router&gt; enable</span><br><span class="line">Router# configure terminal</span><br><span class="line">Router(config) # hostname RA</span><br><span class="line">RA (config) # interface serial 2/0</span><br><span class="line">RA (config) # no shutdown</span><br><span class="line">RA (config-if) # ip address 11.0.0.1 255.0.0.0</span><br><span class="line">RA (config-if) # clock rate 64000</span><br></pre></td></tr></table></figure><p>配置Router2的<code>serial 3/0</code> 串口为ip: <code>11.0.0.2</code> mask： <code>255.0.0.0</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Router&gt; enable</span><br><span class="line">Router# configure terminal</span><br><span class="line">Router(config) # hostname RB</span><br><span class="line">RB (config) # interface serial 3/0</span><br><span class="line">RB (config) # no shutdown</span><br><span class="line">RB (config-if) # ip address 11.0.0.2 255.0.0.0</span><br></pre></td></tr></table></figure><ul><li>查看两个路由的串口状态：</li></ul><p><code>RA</code>:</p><p><img src="hdsl_rt1.png" alt="RA serial 2/0"></p><p><code>RB</code>:</p><p><img src="hdsl_rt2.png" alt="RB serial 3/0"></p><p>可以看到，路由器这里点对点通信默认使用的<code>HDLC</code>(High Level Data Link Control, 面向比特的同步协议)协议。</p><h4 id="HDLC情况下验证ping："><a href="#HDLC情况下验证ping：" class="headerlink" title="HDLC情况下验证ping："></a>HDLC情况下验证ping：</h4><p><code>11.0.0.1</code> ping <code>11.0.0.2</code>:</p><p><img src="hdlc_ping_rt1.png" alt="RA ping Test"></p><p><code>11.0.0.2</code> ping <code>11.0.0.1</code>:</p><p><img src="hdlc_ping_rt2.png" alt="RB ping Test"></p><p>ping 测试成功。</p><h4 id="配置RA-RB使用ppp协议，再做ping测试："><a href="#配置RA-RB使用ppp协议，再做ping测试：" class="headerlink" title="配置RA,RB使用ppp协议，再做ping测试："></a>配置RA,RB使用ppp协议，再做ping测试：</h4><ul><li>先配置<code>RA</code> 使用 <code>ppp</code>协议：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RA # configure terminal</span><br><span class="line">RA (config) # interface serial 2/0</span><br><span class="line">RA (config-if) # encapsulation ppp</span><br></pre></td></tr></table></figure><p><img src="RA_ppp_setting.png" alt="RA serial 2/0"></p><p>可以看到<code>RA</code>当前使用的是<code>ppp</code>写协议，<code>LCP</code>处于<code>Closed</code>,此时，路由器应当无法进行点对点通信。</p><p><img src="RA_ppp_fTest.png" alt="ping Test"></p><ul><li>配置<code>RB</code>使用<code>ppp</code>协议：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RB # configure terminal</span><br><span class="line">RB (config) # interface serial 3/0</span><br><span class="line">RB (config-if) # encapsulation ppp</span><br></pre></td></tr></table></figure><p><img src="RB_ppp_setting.png" alt="RB serial 3/0"></p><p>这时，可以看到<code>RB</code>也是使用了<code>ppp</code>协议，且<code>LCP</code>也处于<code>Open</code>状态，路由器之间可以进行通信。</p><p><img src="RB_ppp_sTest.png" alt="ping Test"></p><h4 id="给ppp协议添加authentication鉴别"><a href="#给ppp协议添加authentication鉴别" class="headerlink" title="给ppp协议添加authentication鉴别"></a>给ppp协议添加authentication鉴别</h4><ul><li>先配置<code>RA</code>，使其开启<code>ppp chap</code> (Challenge Handshake Authentication Protocol), 给<code>RB</code> 添加身份验证</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RA # config terminal</span><br><span class="line">RA (config) # username RB password password</span><br><span class="line">RA (config) # interface serial 2/0</span><br><span class="line">RA (config-if) # ppp authentication chap</span><br></pre></td></tr></table></figure><p><img src="RA_ppp_au.png" alt="RA serial 2/0"></p><p>此时，虽然<code>RA</code>和<code>RB</code>都是使用<code>ppp</code>协议，但是<code>RA</code>给<code>RB</code>添加了身份认证，而<code>RB</code>则没有，此时<code>LCP</code>处于<code>Closed</code>状态，它们之间无法进行通信。</p><ul><li>配置<code>RB</code>, 添加对<code>RA</code>的身份验证：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RB # config terminal</span><br><span class="line">RB (config) # username RA password password</span><br><span class="line">RB (config) # interface serial 2/0</span><br><span class="line">RB (config-if) # ppp authentication chap</span><br></pre></td></tr></table></figure><p><img src="RB_ppp_au.png" alt="RB serial 3/0"></p><p>可以看到此时，<code>LCP</code>已经打开，路由器之间可以进行点对点通信。</p><p><img src="RB_ping_final.png" alt="ping"></p><h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><p>通过该实验，简单地验证了<code>ppp</code>协议在点对点信道中的使用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用Cisco Packet Tracer7 (思科网络模拟器)验证ppp点对点通信。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/images/ppp通信验证/packetTracer7.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://rovo98.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="ppp通信" scheme="http://rovo98.github.io/tags/ppp%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>使用ensp进行简单的路由器互连实验</title>
    <link href="http://rovo98.github.io/posts/cc46ce96/"/>
    <id>http://rovo98.github.io/posts/cc46ce96/</id>
    <published>2018-06-06T16:00:00.000Z</published>
    <updated>2018-06-24T11:14:27.427Z</updated>
    
    <content type="html"><![CDATA[<p>简单使用ensp做华为AR1220路由互连的实验。</p><p><img src="/images/ensp_路由连接实验/ensp.png" alt=""></p><a id="more"></a><h3 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h3><ul><li>路由器设置</li><li>手动设置静态路由</li></ul><h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><ul><li>华为路由器AR1220</li><li>主机</li><li>Serial设备连接串口线和Copper以太网和千兆以太网连接线</li></ul><p>备注：所有实验设备均由<strong>ensp</strong>模拟。</p><h4 id="路由连接实验设计"><a href="#路由连接实验设计" class="headerlink" title="路由连接实验设计"></a>路由连接实验设计</h4><p>整体结构如下：</p><p><img src="route-structure.png" alt="整体结构"></p><ul><li>1.其中分为六个不同的局域网；</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">192.168.11.0 网段 -&gt;</span><br><span class="line">    主机:   192.168.11.11</span><br><span class="line">            192.168.11.12</span><br><span class="line">    路由器AR6一个GigabitEthernet接口作为该网段的默认网关(192.168.11.1)</span><br><span class="line"></span><br><span class="line">192.168.12.0 网段 -&gt;</span><br><span class="line">    主机:   192.168.12.11</span><br><span class="line">            192.168.12.12</span><br><span class="line">    路由器AR4的一个GigabitEthernet接口作为该网段的默认网关(192.168.12.1)</span><br><span class="line"></span><br><span class="line">192.168.13.0 网段 -&gt;</span><br><span class="line">    主机:    192.168.13.11</span><br><span class="line">            192.168.13.12</span><br><span class="line">            192.168.13.13</span><br><span class="line">   路由器AR7的一个GigabitEthernet接口作为该网段的默认网关(192.168.13.1)</span><br><span class="line">   </span><br><span class="line">1.1.2.0 网段 -&gt; 路由器AR6和路由器AR7之间的接口</span><br><span class="line">1.1.1.0 网段 -&gt; 路由器AR6和AR4之间的接口</span><br><span class="line">1.1.3.0 网段 -&gt; 路由器AR6和AR7之间的接口</span><br></pre></td></tr></table></figure><ul><li>2.设备的连接：</li></ul><blockquote><p>除了路由器之间连接使用serial串口连接线外，其他均使用Copper连接线。</p></blockquote><h3 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h3><h4 id="配置各个局域网的ip及其网关"><a href="#配置各个局域网的ip及其网关" class="headerlink" title="配置各个局域网的ip及其网关"></a>配置各个局域网的ip及其网关</h4><ul><li>例如：<code>192.168.11.0</code>网段下的<code>192.168.11.11</code>主机：</li></ul><p><img src="pc1_setting.png" alt="PC1"></p><ul><li>配置 <code>192.168.11.1</code>作为<code>192.168.11.0</code>网段的网关：</li></ul><p><img src="gateway1.png" alt="设置网关"></p><p>所有主机经过配置后，他们应该可以ping通自己网段下的所有主机，如：<code>192.168.11.12</code> ping <code>192.168.11.11</code></p><p><img src="pingTest.png" alt="局域网ping测试"></p><p><strong>[需要注意的是]</strong>： 由于路由器互连时使用的是serial串口，所以路由器之间配置的是serial串口的ip。</p><p>例如：配置AR6的两个serial串口的接口ip为：<code>1.1.1.1</code>和<code>1.1.2.1</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;Huawei&gt; system-view</span><br><span class="line">[Huawei] inter serial 2/0/1</span><br><span class="line">[Huawei-Servial2/0/1] ip address 1.1.1.1 255.255.255.0</span><br><span class="line">[Huawei-Servial2/0/1] quit</span><br><span class="line">[Huawei] inter serial 2/0/0</span><br><span class="line">[Huawei-Serial2/0/0] ip address 1.1.2.1 255.255.255.0</span><br></pre></td></tr></table></figure><h4 id="各个路由器的静态路由："><a href="#各个路由器的静态路由：" class="headerlink" title="各个路由器的静态路由："></a>各个路由器的静态路由：</h4><p>对于路由器AR6,我们希望所有<strong>目的网络</strong>为<code>192.168.12.0</code>的数据包都交付给AR4,即下一跳为<code>1.1.1.2</code>;所有目的网络为<code>192.168.13.0</code>的都交给AR7,下一跳为<code>1.1.2.2</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Huawei&gt; system-view</span><br><span class="line">[Huawei] ip route-static 192.168.12.0 255.255.255.0 1.1.1.2</span><br><span class="line">[Huawei] ip route-static 192.168.13.0 255.255.255.0 1.1.2.2</span><br></pre></td></tr></table></figure><p>对于路由器AR4，所有目的网络为<code>192.168.11.0</code>的数据包交给AR6，下一跳为：<code>1.1.1.1</code>，目的网络为<code>192.168.13.0</code>的数据包交给AR7，下一跳为：<code>1.1.3.1</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Huawei&gt; system-view</span><br><span class="line">[Huawei] ip route-static 192.168.11.0 255.255.255.0 1.1.1.1</span><br><span class="line">[Huawei] ip route-static 192.168.13.0 255.255.255.0 1.1.3.1</span><br></pre></td></tr></table></figure><p>对于路由器AR7， 所有目的网络为<code>192.168.11.0</code>的数据包都交给AR6，下一跳为：<code>1.1.2.1</code>，所有目的网络为<code>192.168.12.0</code>的数据包都交给AR4，下一跳为：<code>1.1.3.2</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Huawei&gt; system-view</span><br><span class="line">[Huawei] ip route-static 192.168.11.0 255.255.255.0 1.1.2.1</span><br><span class="line">[Huawei] ip route-static 192.168.12.0 255.255.255.0 1.1.3.2</span><br></pre></td></tr></table></figure><p>经过以上对各个路由器的静态路由的配置后，我们可以通过<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">display ip routing-table</span><br></pre></td></tr></table></figure><p></p><p>来查看各个路由器的路由表：</p><ul><li>AR6路由表：</li></ul><p><img src="route1_info.png" alt="AR6路由表"></p><ul><li>AR4路由表：</li></ul><p><img src="route2_info.png" alt="AR4路由表"></p><ul><li>AR7路由表：</li></ul><p><img src="route3_info.png" alt="AR7路由表"></p><h3 id="测试实验结果"><a href="#测试实验结果" class="headerlink" title="测试实验结果"></a>测试实验结果</h3><p>使用任意一个局域网下的主机ping不同局域网下的主机：</p><p><code>192.168.11.11</code> ping <code>192.168.13.12</code> 和 <code>192.168.12.12</code>:</p><p><img src="tracert1.png" alt="tracert测试1"></p><p><code>192.168.12.11</code> ping <code>192.168.11.12</code> 和 <code>192.168.13.13</code>:</p><p><img src="tracert2.png" alt="tracert测试2"></p><p><code>192.168.13.11</code> ping <code>192.168.11.11</code> 和 <code>192.168.12.11</code>：</p><p><img src="tracert3.png" alt="tracert测试3"></p><p>由以上测试可以看出简单的路由器连接实验成功。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单使用ensp做华为AR1220路由互连的实验。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/images/ensp_路由连接实验/ensp.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://rovo98.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="路由器" scheme="http://rovo98.github.io/tags/%E8%B7%AF%E7%94%B1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>CentOS7通过yum(yellow dog update modifier) 安装mysql5.7</title>
    <link href="http://rovo98.github.io/posts/86d29d2c/"/>
    <id>http://rovo98.github.io/posts/86d29d2c/</id>
    <published>2018-04-22T16:00:00.000Z</published>
    <updated>2018-06-12T06:50:18.590Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h3 id="配置yum源"><a href="#配置yum源" class="headerlink" title="配置yum源"></a>配置yum源</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载mysql安装源包</span></span><br><span class="line">root @~&gt; wget http://dev.mysql.com/get/mysql57-community-release-el7-8.noarch.rpm</span><br><span class="line"><span class="comment"># 安装mysql源</span></span><br><span class="line">root @~&gt; yum localinstall mysql57-community-release-el7-8.noarch.rpm</span><br></pre></td></tr></table></figure><p>检查mysql源是否安装成功:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root @~&gt; yum repolist enabled | grep <span class="string">"mysql.*-community.*"</span></span><br></pre></td></tr></table></figure><p>如下图则安装成功:</p><p><img src="repo-resource.png" alt="mysql_source"></p><h3 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ ~&gt; yum install -y mysql-community-server</span><br></pre></td></tr></table></figure><h3 id="启动MySQL服务并设置开机自动启动"><a href="#启动MySQL服务并设置开机自动启动" class="headerlink" title="启动MySQL服务并设置开机自动启动"></a>启动MySQL服务并设置开机自动启动</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ ~&gt; systemctl start mysqld</span><br></pre></td></tr></table></figure><p>查看MySQL启动状态</p><p><img src="mysql-status.png" alt="mysqld进程状态"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ ~&gt; systemctl <span class="built_in">enable</span> mysqld</span><br><span class="line">root@ ~&gt; systemctl daemon-reload</span><br></pre></td></tr></table></figure><h3 id="修改默认密码"><a href="#修改默认密码" class="headerlink" title="修改默认密码"></a>修改默认密码</h3><p>刚安装完的mysql会自动给root用户分配一个临时密码，而且必须重新设置密码(从5.5版本开始)</p><ul><li>先查看root用户的临时密码</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ ~&gt; grep <span class="string">"temporary password"</span> /var/<span class="built_in">log</span>/mysqld.log</span><br></pre></td></tr></table></figure><ul><li>使用临时的密码登录进mysql来设置新的密码</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="built_in">set</span> PASSWORD = PASSWORD(<span class="string">'[YOUR_NEW_PASSWORD]'</span>)</span><br></pre></td></tr></table></figure><p><img src="temporary-password.png" alt="查看临时密码"></p><ul><li>可能遇到的问题：设置的密码过于简单mysql报错:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Your password does not satisfy the current policy requirements.</span><br></pre></td></tr></table></figure><p>解决方法：由于刚安装的mysql的密码默认强度是最高的，若想要设置简单的密码就要修改<strong>validate_password_policy</strong>的值，</p><h4 id="validate-password-policy有以下取值："><a href="#validate-password-policy有以下取值：" class="headerlink" title="validate_password_policy有以下取值："></a>validate_password_policy有以下取值：</h4><div class="table-container"><table><thead><tr><th style="text-align:center">Policy</th><th style="text-align:center">Tests Performed</th></tr></thead><tbody><tr><td style="text-align:center">0 or LOW</td><td style="text-align:center">Length</td></tr><tr><td style="text-align:center">1 or MEDIUM</td><td style="text-align:center">Length;numeric,lowercase/uppercase,and special characters</td></tr><tr><td style="text-align:center">2 or STRONG</td><td style="text-align:center">Length;numeric,lowercase/uppercase,and special characters; dictionary file</td></tr></tbody></table></div><p>操作：</p><ul><li>设置安全级别</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="built_in">set</span> global validate_password_policy=0;</span><br></pre></td></tr></table></figure><ul><li>设置密码长度为8，可以设置为其他值，最小为4位</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="built_in">set</span> global validate_password_length=4;</span><br></pre></td></tr></table></figure><p>之后就可以设置简单的密码了。</p><h3 id="允许root远程登录"><a href="#允许root远程登录" class="headerlink" title="允许root远程登录"></a>允许root远程登录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; GRANT ALL PRIVILEGES ON *.* TO <span class="string">'root'</span>@<span class="string">'%'</span> IDENTIFIED BY <span class="string">'[YOUR_PASSWORD]'</span> WITH GRANT OPTION;</span><br><span class="line">mysql&gt; flush privileges;</span><br></pre></td></tr></table></figure><h3 id="修改字符集编码为UTF-8"><a href="#修改字符集编码为UTF-8" class="headerlink" title="修改字符集编码为UTF-8"></a>修改字符集编码为UTF-8</h3><ul><li>查看当前字符编码</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like <span class="string">"char%';</span></span><br></pre></td></tr></table></figure><p>检测是否都是utf-8(filesystem除外)，如果不是就需要修改。 <strong>character_set_server</strong>一般是lantin1。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 停止mysqld服务</span></span><br><span class="line">systemctl stop mysqld</span><br><span class="line"><span class="comment"># 进入my.cnf文件，一般是/etc/路径下</span></span><br><span class="line">vim /etc/my.cnf</span><br><span class="line"><span class="comment"># 在[mysqld]下追加character-set-server=utf-8</span></span><br><span class="line"><span class="comment"># 在[mysql]下追加default-character-set=utf-8</span></span><br><span class="line"><span class="comment"># 启动mysqld</span></span><br><span class="line">systemctl start mysqld</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      CentOS7下安装mysql。
    
    </summary>
    
      <category term="mysql" scheme="http://rovo98.github.io/categories/mysql/"/>
    
    
      <category term="mysql5.7安装" scheme="http://rovo98.github.io/tags/mysql5-7%E5%AE%89%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>Hibernate基础学习</title>
    <link href="http://rovo98.github.io/posts/b19895ed/"/>
    <id>http://rovo98.github.io/posts/b19895ed/</id>
    <published>2018-04-13T11:41:44.000Z</published>
    <updated>2018-07-20T12:05:06.457Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/Hibernate基础学习/hibernate_logo.png" alt=""></p><p><strong>Hibernate</strong>是一个对象关系映射(Object-Relational Mapping, <code>ORM</code>)的JAVA解决方案。是在2001年由 <em>Gavin King</em>创建的开源持久化框架。适用于任何使用Java应用程序的功能强大的高性能<strong>对象关系持久化和查询服务</strong>。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>Hibernate</strong>将Java类映射到数据表并将Java数据类型映射到SQL数据类型，使开发人员从95%的常见数据持久化相关编程任务中解脱出来。</p><p><strong>Hibernate</strong>位于传统的Java对象和数据库服务器之间，以适应基于适当$O/R$机制和模式的持久化对象的保存工作。</p><p><img src="hibernate_position.jpg" alt=""></p><h3 id="一、Hibernate-优势"><a href="#一、Hibernate-优势" class="headerlink" title="一、Hibernate 优势"></a>一、Hibernate 优势</h3><ol><li>Hibernate使用XML文件来将Java类映射到数据表，不需要写任何代码。</li><li>提供简单的APIs直接将java对象保存到数据库中，或从数据库中检索出来。</li><li>数据库或数据表发生改变时，只需要修改XML文件。</li><li>不采用不熟悉的SQL类型，而提供一中方法来解决熟悉的Java对象。</li><li>Hibernate不需要应用服务器来操作。</li><li>可以操纵数据库对象的复杂关联。</li><li>使用智能检索策略来最小化数据库的访问。</li><li>提供简单的数据查询。</li></ol><h3 id="二、支持的数据库"><a href="#二、支持的数据库" class="headerlink" title="二、支持的数据库"></a>二、支持的数据库</h3><p><strong>Hibernate</strong>支持所有主流的关系型数据库(RDBMS)。下面简单地列出Hibernate支持的数据库:</p><ul><li>HSQL Database Engine</li><li>DB2/NT</li><li>MySQL</li><li>PostgreSQL</li><li>FrontBase</li><li>Oracle</li><li>Microsoft SQL Server Database</li><li>Sybase SQL Server</li><li>Infomix Dynamic Server</li></ul><h3 id="三、支持的技术"><a href="#三、支持的技术" class="headerlink" title="三、支持的技术"></a>三、支持的技术</h3><p><strong>Hibernate</strong>支持很多其他的技术，包括</p><ul><li>XDoclet Spring</li><li>J2EE</li><li>Eclipse plug-ins</li><li>Maven</li></ul><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p><strong>Hibernate</strong>拥有一个分层的架构，可以使用户在不了解底层APIs的情况下使用它。Hibernate使用数据库和配置数据来向应用提供持久化服务。</p><p>下面是从宏观角度看Hibernate的视图：</p><p><img src="hibernate_high_level.jpg" alt=""></p><p>从细节视角看Hibernate以及它的核心类：</p><p><img src="hibernate_architecture.jpg" alt=""></p><p><strong>Hibernate</strong>使用很多现有的Java API, 例如： <code>JDBC</code>, Java Transaction API(<code>JTA</code>)以及 Java Naming and Directory Interface(<code>JNDI</code>)。<code>JDBC</code>提供了关系数据库通用功能的基本抽象级别，使<strong>Hibernate</strong>支持几乎所有具有<code>JDBC</code>驱动程序的数据库。<code>JNDI</code>和<code>JTA</code>使<code>J2EE</code>可以集成<strong>Hibernate</strong>。</p><p>下面是针对上面架构图中出现的核心类给出的简单解释。</p><h3 id="一、Configuration-Object"><a href="#一、Configuration-Object" class="headerlink" title="一、Configuration Object"></a>一、Configuration Object</h3><p><code>Configuration</code>(配置对象)是在Hibernate应用中第一个被创建的对象，且在Hibernate应用初始化时，只创建一次。它通常代表着Hibernate所需的配置信息或属性。</p><p><code>Configuartion</code>包含一下两个关键的组件:</p><ul><li><code>Database Connection</code>(数据库连接) - 通过hibernate支持的一个或多个配置文件来处理的，例如： <code>hibernate.properties</code>和<code>hibernate.cfg.xml</code>。</li><li><code>Class Mapping Setup</code>(类映射设置) - 该组件负责创建Java类和数据表之间的连接。</li></ul><h3 id="二、SessionFactory-Object"><a href="#二、SessionFactory-Object" class="headerlink" title="二、SessionFactory Object"></a>二、SessionFactory Object</h3><p><code>SessionFactory</code>对象是通过使用<code>Configuration</code>对象创建生成的，该对象可以使用提供的配置文件为应用程序配置Hibernate，并能够实例化<code>Session</code>对象。<code>SessionFactory</code>是一个线程安全对象，并被应用程序的所有线程使用。</p><p><code>Sessionfactory</code>是一个重量级对象，通常在应用程序启动时创建并保留以备后续使用。每个数据库使用单独的配置文件都需要一个<code>SessionFactory</code>对象。因此，如果使用多个数据库，我们可能需要创建多个<code>SessionFactory</code>对象。</p><h3 id="三、Session-Object"><a href="#三、Session-Object" class="headerlink" title="三、Session Object"></a>三、Session Object</h3><p><code>Session</code>对象主要用来从数据库中获取物理连接。<code>Session</code>是轻量级对象，当每次需要与数据库交互时都可以实例化该对象。持久化对象(persistent Objects)就是通过它来实现保存和检索的。</p><p><code>Session</code>对象一般不会保留很长一段时间，因为它并不是线程安全对象，只能在需要使用的时候创建和销毁。</p><h3 id="四、Transaction-Object"><a href="#四、Transaction-Object" class="headerlink" title="四、Transaction Object"></a>四、Transaction Object</h3><p><code>Transaction</code>对象代表了数据库的一个工作单元，大多数RDBMS都支持事务功能。Hibernate中的事务由<code>underlying transaction manager</code>(基础事务管理器)以及<code>transaction</code>(事务，来自<code>JDBC</code>或者<code>JTA</code>)。</p><p>这是一个<strong>可选</strong>对象，Hibernate应用程序可以选择不使用此接口，而是使用自己的应用程序的代码来管理事务。</p><h3 id="五、Query-Object"><a href="#五、Query-Object" class="headerlink" title="五、Query Object"></a>五、Query Object</h3><p><code>Query</code>对象使用<code>SQL</code>或者Hibernate查询语言（<code>HQL</code>)字符串来从数据库中检索数据以及创建对象。一个<code>Query</code>实例一般是用来绑定查询参数，限制返回结果行数，并执行查询操作的。</p><h3 id="七、Criteria-Object"><a href="#七、Criteria-Object" class="headerlink" title="七、Criteria Object"></a>七、Criteria Object</h3><p><code>Criteria</code>对象用于创建和执行面向对象的条件查询来检索对象。</p><h2 id="Hibernate-配置"><a href="#Hibernate-配置" class="headerlink" title="Hibernate 配置"></a>Hibernate 配置</h2><p><strong>Hibernate需要事先知道在哪里可以找到定义Java类和数据表的关系的映射信息。</strong>Hibernate还需哟啊一组与数据库和其他相关参数相关的配置设置。所有这些信息通常由标准Java属性文件(<code>hibernate.properties</code>)或XML文件(<code>hibernate.cfg.xml</code>)提供。</p><p>这里我们只需要考虑<code>hibernate.cfg.xml</code>配置文件的配置。大多数的属性一般都采用默认值，并且不需要在属性文件(<code>hibernate.properties</code>)中制定它们，除非真的需要。配置文件只能保存在应用程序的类路径的根目录中。</p><h3 id="一、Hibernate-属性"><a href="#一、Hibernate-属性" class="headerlink" title="一、Hibernate 属性"></a>一、Hibernate 属性</h3><p>下面列出的使一些重要的属性，当我们在配置数据库时可能会用到：</p><div class="table-container"><table><thead><tr><th style="text-align:center">Properties</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td style="text-align:center">hibernate.dialect</td><td style="text-align:center">数据库方言，该属性能够是Hibernate为选择的数据库生成合适的SQL</td></tr><tr><td style="text-align:center">hibernate.connection.driver_class</td><td style="text-align:center">JDBC 驱动类</td></tr><tr><td style="text-align:center">hibernate.connection.url</td><td style="text-align:center">数据库实例的JDBC URL</td></tr><tr><td style="text-align:center">hibernate.connection.username</td><td style="text-align:center">数据库用户名</td></tr><tr><td style="text-align:center">hibernate.connection.password</td><td style="text-align:center">数据库密码</td></tr><tr><td style="text-align:center">hibernate.connection.pool_size</td><td style="text-align:center">限制Hibernate数据库连接池中等待的连接数</td></tr><tr><td style="text-align:center">hibernate.connection.autocommit</td><td style="text-align:center">允许JDBC连接自动提交</td></tr></tbody></table></div><p>如果使用应用程序服务器和<code>JNDI</code>,则必须配置以下属性：</p><div class="table-container"><table><thead><tr><th style="text-align:center">Properties</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td style="text-align:center">hibernate.connection.datasource</td><td style="text-align:center">在应用服务器上下文中定义<code>JNDI</code>名称</td></tr><tr><td style="text-align:center">hibernate.jndi.class</td><td style="text-align:center"><code>JNDI</code>的<code>InitialContext</code>类</td></tr><tr><td style="text-align:center">hibernate.jndi.&lt; JNDIpropertyname &gt;</td><td style="text-align:center">向<code>JNDI InitialContext</code>传递的属性</td></tr><tr><td style="text-align:center">hibernate.jndi.url</td><td style="text-align:center"><code>JNDI</code> URL</td></tr><tr><td style="text-align:center">hibernate.connection.username</td><td style="text-align:center">数据库用户名</td></tr><tr><td style="text-align:center">hibernate.connection.password</td><td style="text-align:center">数据库密码</td></tr></tbody></table></div><h3 id="二、在Hibernate中配置-MySQL-数据库"><a href="#二、在Hibernate中配置-MySQL-数据库" class="headerlink" title="二、在Hibernate中配置 MySQL 数据库"></a>二、在Hibernate中配置 MySQL 数据库</h3><p><code>MySQL</code>是目前最受欢的开源数据库系统之一。下面通过配置<code>hibernate.cfg.xml</code>文件来配置<code>MySQL</code>数据库，在此之前，确保在<code>MySQL</code>中创建一个<code>testdb</code>数据库，以及<code>test</code>用户。</p><p>[notice] : XML配置文件必须符合Hibernate 2 配置 DTD标准。</p><p><strong>hibernate.cfg.xml</strong>:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version = "1.0" encoding = "utf-8"?&gt;</span><br><span class="line"><span class="meta">&lt;!DOCTYPE hibernate-configuration SYSTEM </span></span><br><span class="line"><span class="meta">"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-configuration</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">session-factory</span>&gt;</span></span><br><span class="line">   </span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">"hibernate.dialect"</span>&gt;</span></span><br><span class="line">         org.hibernate.dialect.MySQL5Dialect</span><br><span class="line">      <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">      </span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">"hibernate.connection.driver_class"</span>&gt;</span></span><br><span class="line">         com.mysql.jdbc.Driver</span><br><span class="line">      <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">&lt;!-- Assume test is the database name --&gt;</span></span><br><span class="line">      </span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">"hibernate.connection.url"</span>&gt;</span></span><br><span class="line">         jdbc:mysql://localhost/test</span><br><span class="line">      <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">      </span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">"hibernate.connection.username"</span>&gt;</span></span><br><span class="line">         root</span><br><span class="line">      <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">      </span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">"hibernate.connection.password"</span>&gt;</span></span><br><span class="line">         root</span><br><span class="line">      <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">&lt;!-- List of XML mapping files --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">mapping</span> <span class="attr">resource</span> = <span class="string">"Employee.hbm.xml"</span>/&gt;</span></span><br><span class="line">      </span><br><span class="line">   <span class="tag">&lt;/<span class="name">session-factory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面配置文件中<code>&lt;mapping&gt;</code>标签与<code>hibernate mapping</code>(映射文件)相关。</p><p>以下是一些重要的数据库方言属性类型：</p><div class="table-container"><table><thead><tr><th style="text-align:center">Database</th><th style="text-align:center">Dialect Property</th></tr></thead><tbody><tr><td style="text-align:center">DB 2</td><td style="text-align:center">org.hibernate.dialect.DB2Dialect</td></tr><tr><td style="text-align:center">HSQLDB</td><td style="text-align:center">org.hibernate.dialect.HSQLDialect</td></tr><tr><td style="text-align:center">HypersonicSQL</td><td style="text-align:center">org.hibernate.dialect.HSQLDialect</td></tr><tr><td style="text-align:center">Informix</td><td style="text-align:center">org.hibernate.dialect.InformixDialect</td></tr><tr><td style="text-align:center">Ingres</td><td style="text-align:center">org.hibernate.dialect.IngresDialect</td></tr><tr><td style="text-align:center">Interbase</td><td style="text-align:center">org.hibernate.dialect.InterbaseDialect</td></tr><tr><td style="text-align:center">Microsoft SQL Server 2000</td><td style="text-align:center">org.hibernate.dialect.SQLServerDialect</td></tr><tr><td style="text-align:center">Microsoft SQL Server 2005</td><td style="text-align:center">org.hibernate.dialect.SQLServer2005Dialect</td></tr><tr><td style="text-align:center">Microsoft SQL Server 2008</td><td style="text-align:center">org.hibernate.dialect.SQLServer2008Dialect</td></tr><tr><td style="text-align:center">MySQL</td><td style="text-align:center">org.hibernate.dialect.MySQLDialect</td></tr><tr><td style="text-align:center">Oracle(any version</td><td style="text-align:center">org.hibernate.dialect.OracleDialect</td></tr><tr><td style="text-align:center">Oracle 11g</td><td style="text-align:center">org.hibernate.dialect.Oracle10gDialect</td></tr><tr><td style="text-align:center">Oracle 10g</td><td style="text-align:center">org.hibernate.dialect.Oracle10gDialect</td></tr><tr><td style="text-align:center">Oracle 9i</td><td style="text-align:center">org.hibernate.dialect.Oracle9iDialect</td></tr><tr><td style="text-align:center">PostgreSQL</td><td style="text-align:center">org.hibernate.dialect.PostgreSQLDialect</td></tr><tr><td style="text-align:center">Progress</td><td style="text-align:center">org.hibernate.dialect.ProgressDialect</td></tr><tr><td style="text-align:center">SAP DB</td><td style="text-align:center">org.hibernate.dialect.SAPDBDialect</td></tr><tr><td style="text-align:center">Sybase</td><td style="text-align:center">org.hibernate.dialect.SybaseDialect</td></tr><tr><td style="text-align:center">Sybase anywhere</td><td style="text-align:center">org.hibernate.dialect.SybaseAnywhereDialect</td></tr></tbody></table></div><h2 id="Sessions"><a href="#Sessions" class="headerlink" title="Sessions"></a>Sessions</h2><p>前面我们已经提到<code>Session</code>使用来获取数据库物理连接的，为轻量级对象，只有需要和数据库发生交互时才进行对象实例化。持久化对象的保存和检索就是通过它来完成的。</p><p><code>Session</code>不能维持太长时间，毕竟它们不是线程安全对象， 只能在需要的时候创建和销毁。<code>Session</code>的主要功能是为映射实体类提供创建、读取和删除操作。</p><p>在给定的时间点中，实例可能有下面的这些状态：</p><ul><li><code>transient</code>(暂时的) - 一个持久类的新实例，与<code>Session</code>没有关联，并且在数据库中没有表示以及没有标识符值，被Hibernate认为是暂时的。</li><li><code>persistent</code>(持久的) - 我们可以通过将暂时的实例(transient)与<code>Session</code>关联来将它进行持久化。</li><li><code>detached</code>(独立的) - 一旦关闭Hibernate <code>Session</code>对象，持久化对象将转化为独立的对象(detached instance)。</li></ul><p>当<code>Session</code>对象中的持久类(persistent classes)是可序列化时，<code>Session</code>也是可序列化的。下面是典型的事务处理代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Session session = factory.openSession();</span><br><span class="line">Transaction tx = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">tx = session.beginTransaction();</span><br><span class="line">    <span class="comment">// do some work</span></span><br><span class="line">    ...</span><br><span class="line">    tx.commit();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="keyword">if</span> (tx != <span class="keyword">null</span>) tx.rollback();</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>[notice]</strong> : 如果<code>Session</code>抛出异常，事务必须回滚(rollback)并且<code>Session</code>需要丢弃。</p><h3 id="一、Session-接口方法"><a href="#一、Session-接口方法" class="headerlink" title="一、Session 接口方法"></a>一、Session 接口方法</h3><p><code>Session</code>接口提供了很多方法，下面列出的是其中一些中重要的方法。更多的信息可以查看Hibernate文档中与<code>Session</code>以及<code>SessionFactory</code>相关的完整方法信息。</p><div class="table-container"><table><thead><tr><th style="text-align:center">Session Method</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td style="text-align:center"><code>Transaction beginTransaction()</code></td><td style="text-align:center">开启一个工作单元并返回已经关联的事务对象。</td></tr><tr><td style="text-align:center"><code>void cancelQuery()</code></td><td style="text-align:center">取消执行当前查询操作</td></tr><tr><td style="text-align:center"><code>void clear()</code></td><td style="text-align:center">完全清除回话(session)</td></tr><tr><td style="text-align:center"><code>Connection close()</code></td><td style="text-align:center">结束回话并释放<code>JDBC</code>连接资源</td></tr><tr><td style="text-align:center"><code>Criteria createCriteria(Class persistentClass)</code></td><td style="text-align:center">为指定的实体类或者实体类的超类创建一个条件查询(<code>Criteria</code>)对象</td></tr><tr><td style="text-align:center"><code>Criteria createCriteria(String entityName)</code></td><td style="text-align:center">根据实体类的名称创建<code>Criteria</code>对象</td></tr><tr><td style="text-align:center"><code>Serializable getIdentifier(Object Object)</code></td><td style="text-align:center">返回与此回话关联的给定实体的标识符值</td></tr><tr><td style="text-align:center"><code>Query createFilter(Object collection, String queryString)</code></td><td style="text-align:center">根据给定的集合(<code>collection</code>)以及过滤字符串创建一个新的<code>Query</code>实例</td></tr><tr><td style="text-align:center"><code>SQLQuery createSQLQuery(String queryString)</code></td><td style="text-align:center">根据给定的SQL查询语句创建一个<code>SQLQuery</code>对象</td></tr><tr><td style="text-align:center"><code>void delete(Object object)</code></td><td style="text-align:center">从数据存储(datastore)中移除持久实例</td></tr><tr><td style="text-align:center"><code>void delete(String entityName, Object object)</code></td><td style="text-align:center">从数据存储中移除持久实例</td></tr><tr><td style="text-align:center"><code>Session get(String entityName, Serializable id)</code></td><td style="text-align:center">根据给定的标识符(identifier)以及实体名返回持久化实例；如果没有该实例，则返回<code>null</code></td></tr><tr><td style="text-align:center"><code>SessionFactory getSessionFactory()</code></td><td style="text-align:center">获取创建该<code>Session</code>实例的<code>SessionFactory</code>对象</td></tr><tr><td style="text-align:center"><code>void refresh(Object object)</code></td><td style="text-align:center">从底层数据库重新读取给定实例的状态</td></tr><tr><td style="text-align:center"><code>Transaction getTransaction()</code></td><td style="text-align:center">获取与该<code>Session</code>关联的<code>Transaction</code>实例</td></tr><tr><td style="text-align:center"><code>boolean isConnected()</code></td><td style="text-align:center">返回当前<code>Session</code>的连接状态</td></tr><tr><td style="text-align:center"><code>boolean isDirty()</code></td><td style="text-align:center">判断<code>Session</code>中是否存在未同步到数据库的脏数据(已经修改过的数据)</td></tr><tr><td style="text-align:center"><code>boolean isOpen()</code></td><td style="text-align:center">判断<code>Session</code>是否打开</td></tr><tr><td style="text-align:center"><code>Serializable save(Object object)</code></td><td style="text-align:center">持久化给定的暂时实例，分配一个生成的标识符</td></tr><tr><td style="text-align:center"><code>void saveOrUpdate(Object object)</code></td><td style="text-align:center">对给定的实例执行<code>save(Object)</code>或者<code>update(Object)</code>操作</td></tr><tr><td style="text-align:center"><code>void update(Object object)</code></td><td style="text-align:center">根据给定的独立实例的标识符更新持久化实例</td></tr><tr><td style="text-align:center"><code>void update(String entityName, Object object)</code></td><td style="text-align:center">根据给定的独立实例的标识符更新持久化实例</td></tr></tbody></table></div><h2 id="Hibernate-持久化类"><a href="#Hibernate-持久化类" class="headerlink" title="Hibernate 持久化类"></a>Hibernate 持久化类</h2><p><strong>Hibernate</strong>的整体理念是从Java类属性中取值并将它们保存到数据表中。Hibernate使用给定的映射文件来获取Java类中的属性值，并将它们映射到数据表和相关字段。</p><p><strong>在Hibernate中，我们把那些对象或实例将被保存到数据表中的Java类成为持久化类，持久类。</strong>一般这些遵循这样的一些简单的规则，即符合<strong>Plain Ordinary Java Object</strong>(<code>POJO</code>)编程模型。</p><p>下面给出的就是持久化类需要遵循的规则，但这并不是硬性要求：</p><ul><li>所有的持久化类都需要有一个默认的构造方法；</li><li>所有类都需要包含一个ID属性，以便在Hibernate和数据库中轻松识别对象，该属性一般映射到数据表中的主键；</li><li>所有需要持久化的属性都应该声明为<code>private</code>并定义<code>getXXX</code>和<code>setXXX</code>方法；</li><li>Hibernate的一个中心特性是代理，因此依赖的持久化类不能是<code>final</code>类或者实现声明所有公共方法的接口；</li><li>所有类不继承或实现<code>EJB</code>框架所需的特定类和接口。</li></ul><p><code>POJO</code>是用来强调给定的对象是一个原始的Java对象，而不是一个特殊的类，也不是一个<code>Enterprise JavaBean</code>。</p><h3 id="一、简单POJO例子"><a href="#一、简单POJO例子" class="headerlink" title="一、简单POJO例子"></a>一、简单POJO例子</h3><p>基于上面提到的规则，定义了下面的一个简单<code>POJO</code>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">   <span class="keyword">private</span> String firstName; </span><br><span class="line">   <span class="keyword">private</span> String lastName;   </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> salary;  </span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String fname, String lname, <span class="keyword">int</span> salary)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.firstName = fname;</span><br><span class="line">      <span class="keyword">this</span>.lastName = lname;</span><br><span class="line">      <span class="keyword">this</span>.salary = salary;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> id;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">( <span class="keyword">int</span> id )</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.id = id;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getFirstName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> firstName;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirstName</span><span class="params">( String first_name )</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.firstName = first_name;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getLastName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> lastName;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLastName</span><span class="params">( String last_name )</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.lastName = last_name;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSalary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> salary;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSalary</span><span class="params">( <span class="keyword">int</span> salary )</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.salary = salary;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Hibernate-映射文件"><a href="#Hibernate-映射文件" class="headerlink" title="Hibernate 映射文件"></a>Hibernate 映射文件</h2><p>对象关系映射通常都是定义在一个XML文档中。该映射文件告诉Hibernate如果将定义的Java类映射到数据库中的数据表。</p><p>尽管很多Hibernate用户都选择使用人工方式来写XML文档。但是现在有很多现有的工具可以用来生成映射文档，其中包含供Hibernate高级用户使用的<code>XDoclet</code>, <code>Middlegen</code>以及<code>AndroMDA</code>。</p><p>对于之前给出的简单的<code>POJO</code>类，假设它需要保存到下面的RDBMS数据表中，以及从中检索数据:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> EMPLOYEE (</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span> auto_increment,</span><br><span class="line">    first_name <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">default</span> <span class="literal">null</span>,</span><br><span class="line">    last_name <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">default</span> <span class="literal">null</span>,</span><br><span class="line">    salaary <span class="built_in">int</span> <span class="keyword">default</span> <span class="literal">null</span>,</span><br><span class="line">    primary <span class="keyword">key</span> (<span class="keyword">id</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>定义映射文件:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version = "1.0" encoding = "utf-8"?&gt;</span><br><span class="line"><span class="meta">&lt;!DOCTYPE hibernate-mapping PUBLIC </span></span><br><span class="line"><span class="meta">"-//Hibernate/Hibernate Mapping DTD//EN"</span></span><br><span class="line"><span class="meta">"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span> = <span class="string">"Employee"</span> <span class="attr">table</span> = <span class="string">"EMPLOYEE"</span>&gt;</span></span><br><span class="line">      </span><br><span class="line">      <span class="tag">&lt;<span class="name">meta</span> <span class="attr">attribute</span> = <span class="string">"class-description"</span>&gt;</span></span><br><span class="line">         This class contains the employee detail. </span><br><span class="line">      <span class="tag">&lt;/<span class="name">meta</span>&gt;</span></span><br><span class="line">      </span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span> = <span class="string">"id"</span> <span class="attr">type</span> = <span class="string">"int"</span> <span class="attr">column</span> = <span class="string">"id"</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"native"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      </span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">"firstName"</span> <span class="attr">column</span> = <span class="string">"first_name"</span> <span class="attr">type</span> = <span class="string">"string"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">"lastName"</span> <span class="attr">column</span> = <span class="string">"last_name"</span> <span class="attr">type</span> = <span class="string">"string"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">"salary"</span> <span class="attr">column</span> = <span class="string">"salary"</span> <span class="attr">type</span> = <span class="string">"int"</span>/&gt;</span></span><br><span class="line">      </span><br><span class="line">   <span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>一般映射文件的文件名格式为: <code>&lt;classname&gt;.hbm.xml</code>。例如上面的映射文件我们可以命名为: <code>Employee.hbm.xml</code>。</p><p>下面是针对映射文件中涉及到的标签元素给出的具体解释:</p><ul><li>映射文件使用<code>&lt;hibernate-mapping&gt;</code>标签作为根标签元素，它包含所有的<code>&lt;class&gt;</code>标签元素；</li><li><code>&lt;class&gt;</code>标签是用来定义java类到数据表的映射关系的。Java类名和数据表名称分别由标签的<code>name</code>和<code>table</code>属性指定；</li><li><code>&lt;meta&gt;</code>标签用于创建类的描述信息，是可选标签；</li><li><code>&lt;id&gt;</code>标签映射Java类的唯一id属性到数据表的主键。该标签的<code>name</code>属性指定类的属性名，<code>column</code>则指定数据表的字段名。<code>type</code>属性为hibernate映射类型，将Java数据类型转化为SQL数据类型。</li><li><code>&lt;generator&gt;</code>标签元素是<code>&lt;id&gt;</code>标签的子元素，用来自动生成主键值。其中<code>class</code>属性设置为<code>native</code>，以使Hibernate根据底层数据库的功能选择<code>identity</code>,<code>sequence</code>或<code>hilo</code>算法来生成主键；</li><li><code>&lt;property&gt;</code>标签则用来将java类中的属性映射到数据表中的字段。<code>name</code>属性指定java类的属性名，相应的，<code>column</code>指定数据表对应的字段名称。<code>type</code>为hibernate映射类型。</li></ul><p>除了上面提到的这些标签元素和属性外，其实还有其他的标签元素和属性。这里只不过是简单地给出了常用的标签元素及其属性的解释。</p><h2 id="Hibernate-映射类型"><a href="#Hibernate-映射类型" class="headerlink" title="Hibernate 映射类型"></a>Hibernate 映射类型</h2><p>当我们配置<strong>Hibernate映射文件</strong>时，我们需要将Java数据类型映射转化为RDBMS数据类型。在映射文件中生命的<strong>类型(types)</strong>既不是java数据类型，也不是SQL 数据据数据类型。我们一般称其为<strong>Hibernate mapping types(hibernate映射类型)</strong>,它们能够将java数据类型转化为SQL数据类型，反之亦然。</p><p>下面给出了所有基本的，日期和时间，大对象以及其他各种内置映射类型。</p><h3 id="一、原始类型-Primitive-Types"><a href="#一、原始类型-Primitive-Types" class="headerlink" title="一、原始类型(Primitive Types)"></a>一、原始类型(Primitive Types)</h3><div class="table-container"><table><thead><tr><th style="text-align:center">Mapping type</th><th style="text-align:center">Java type</th><th style="text-align:center">ANSI SQL Type</th></tr></thead><tbody><tr><td style="text-align:center">integer</td><td style="text-align:center">int or java.lang.Integer</td><td style="text-align:center">INTEGER</td></tr><tr><td style="text-align:center">long</td><td style="text-align:center">long or java.lang.Long</td><td style="text-align:center">BIGINT</td></tr><tr><td style="text-align:center">short</td><td style="text-align:center">short or java.lang.Short</td><td style="text-align:center">SMALLINT</td></tr><tr><td style="text-align:center">float</td><td style="text-align:center">float or java.lang.Float</td><td style="text-align:center">FLOAT</td></tr><tr><td style="text-align:center">double</td><td style="text-align:center">double or java.lang.Double</td><td style="text-align:center">DOUBLE</td></tr><tr><td style="text-align:center">big_decimal</td><td style="text-align:center">java.math.BigDecimal</td><td style="text-align:center">NUMERIC</td></tr><tr><td style="text-align:center">character</td><td style="text-align:center">java.lang.String</td><td style="text-align:center">CHAR(1)</td></tr><tr><td style="text-align:center">string</td><td style="text-align:center">java.lang.String</td><td style="text-align:center">VARCHAR</td></tr><tr><td style="text-align:center">byte</td><td style="text-align:center">byte or java.lang.Byte</td><td style="text-align:center">TINYINT</td></tr><tr><td style="text-align:center">boolean</td><td style="text-align:center">boolean or java.lang.Boolean</td><td style="text-align:center">BIT</td></tr><tr><td style="text-align:center">yes/no</td><td style="text-align:center">boolean or java.lang.Boolean</td><td style="text-align:center">CHAR(1)(‘Y’ or ‘N’)</td></tr><tr><td style="text-align:center">true/false</td><td style="text-align:center">boolean or java.lang.Boolean</td><td style="text-align:center">CHAR(1)(‘Y’ or ‘N’)</td></tr></tbody></table></div><h3 id="二、日期和时间类型"><a href="#二、日期和时间类型" class="headerlink" title="二、日期和时间类型"></a>二、日期和时间类型</h3><div class="table-container"><table><thead><tr><th style="text-align:center">Mapping Type</th><th style="text-align:center">Java Type</th><th style="text-align:center">ANSI SQL Type</th></tr></thead><tbody><tr><td style="text-align:center">date</td><td style="text-align:center">java..util.Date or java.sql.Date</td><td style="text-align:center">DATE</td></tr><tr><td style="text-align:center">time</td><td style="text-align:center">java.util.Date or java.sql.Date</td><td style="text-align:center">TIME</td></tr><tr><td style="text-align:center">timestamp</td><td style="text-align:center">java.util.Date or java.sql.Timestamp</td><td style="text-align:center">TIMESTAMP</td></tr><tr><td style="text-align:center">calendar</td><td style="text-align:center">java.util.Calendar</td><td style="text-align:center">TIMESTAMP</td></tr><tr><td style="text-align:center">calendar_date</td><td style="text-align:center">java.util.Calendar</td><td style="text-align:center">DATE</td></tr></tbody></table></div><h3 id="三、二进制和大对象类型"><a href="#三、二进制和大对象类型" class="headerlink" title="三、二进制和大对象类型"></a>三、二进制和大对象类型</h3><div class="table-container"><table><thead><tr><th style="text-align:center">Mapping Type</th><th style="text-align:center">Java Type</th><th style="text-align:center">ANSI SQL Type</th></tr></thead><tbody><tr><td style="text-align:center">binary</td><td style="text-align:center">byte[]</td><td style="text-align:center">VARBINARY(or BLOB)</td></tr><tr><td style="text-align:center">text</td><td style="text-align:center">java.lang.String</td><td style="text-align:center">CLOB</td></tr><tr><td style="text-align:center">serializable</td><td style="text-align:center">任何实现java.io.Serializable接口的类</td><td style="text-align:center">VARBIANRY(or BLOB</td></tr><tr><td style="text-align:center">clob</td><td style="text-align:center">java.sql.Clob</td><td style="text-align:center">CLOB</td></tr><tr><td style="text-align:center">blob</td><td style="text-align:center">java.sql.Blob</td><td style="text-align:center">BLOB</td></tr></tbody></table></div><h3 id="四、JDK相关类型"><a href="#四、JDK相关类型" class="headerlink" title="四、JDK相关类型"></a>四、JDK相关类型</h3><div class="table-container"><table><thead><tr><th style="text-align:center">Mapping Type</th><th style="text-align:center">Java Type</th><th style="text-align:center">ANSI SQL Type</th></tr></thead><tbody><tr><td style="text-align:center">class</td><td style="text-align:center">java.lang.Class</td><td style="text-align:center">VARCHAR</td></tr><tr><td style="text-align:center">locale</td><td style="text-align:center">java.util.Locale</td><td style="text-align:center">VARCHAR</td></tr><tr><td style="text-align:center">timezone</td><td style="text-align:center">java.util.TimeZone</td><td style="text-align:center">VARCHAR</td></tr><tr><td style="text-align:center">currency</td><td style="text-align:center">java.util.Currency</td><td style="text-align:center">VARCHAR</td></tr></tbody></table></div><h2 id="Hibernate-使用实例"><a href="#Hibernate-使用实例" class="headerlink" title="Hibernate 使用实例"></a>Hibernate 使用实例</h2><p>接下来我们将通过一个简单的例子来了解<strong>Hiberate</strong>是如何为独立应用程序提供持久化服务的。下面使用Hibernate技术分几个不同的步骤来创建一个Java应用程序。</p><h3 id="一、创建POJO类"><a href="#一、创建POJO类" class="headerlink" title="一、创建POJO类"></a>一、创建POJO类</h3><p>创建应用程序的第一步就是创建Java POJO类，这取决与应用程序中需要保留到数据库的类。这里我们创建一个拥有<code>getter</code>和<code>setter</code>方法的<code>Employee</code>类，并让它成为<code>JavaBean</code>兼容类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">   <span class="keyword">private</span> String firstName; </span><br><span class="line">   <span class="keyword">private</span> String lastName;   </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> salary;  </span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String fname, String lname, <span class="keyword">int</span> salary)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.firstName = fname;</span><br><span class="line">      <span class="keyword">this</span>.lastName = lname;</span><br><span class="line">      <span class="keyword">this</span>.salary = salary;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> id;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">( <span class="keyword">int</span> id )</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.id = id;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getFirstName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> firstName;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirstName</span><span class="params">( String first_name )</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.firstName = first_name;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getLastName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> lastName;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLastName</span><span class="params">( String last_name )</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.lastName = last_name;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSalary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> salary;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSalary</span><span class="params">( <span class="keyword">int</span> salary )</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.salary = salary;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、创建数据表"><a href="#二、创建数据表" class="headerlink" title="二、创建数据表"></a>二、创建数据表</h3><p>第二步，就是要在数据库中创建数据表。一张数据表对应一个持久化类。定义<code>EMPLOYEE</code>表来对应<code>Employee</code>持久化类。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> EMPLOYEE (</span><br><span class="line">   <span class="keyword">id</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> auto_increment,</span><br><span class="line">   first_name <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">default</span> <span class="literal">NULL</span>,</span><br><span class="line">   last_name  <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">default</span> <span class="literal">NULL</span>,</span><br><span class="line">   salary     <span class="built_in">INT</span>  <span class="keyword">default</span> <span class="literal">NULL</span>,</span><br><span class="line">   PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="三、创建映射文件"><a href="#三、创建映射文件" class="headerlink" title="三、创建映射文件"></a>三、创建映射文件</h3><p>创建一个映射文件来告诉Hibernate如何将持久化类映射到数据表。</p><p><strong><code>Employee.hbm.xml</code></strong>:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version = "1.0" encoding = "utf-8"?&gt;</span><br><span class="line"><span class="meta">&lt;!DOCTYPE hibernate-mapping PUBLIC </span></span><br><span class="line"><span class="meta">"-//Hibernate/Hibernate Mapping DTD//EN"</span></span><br><span class="line"><span class="meta">"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span> = <span class="string">"Employee"</span> <span class="attr">table</span> = <span class="string">"EMPLOYEE"</span>&gt;</span></span><br><span class="line">      </span><br><span class="line">      <span class="tag">&lt;<span class="name">meta</span> <span class="attr">attribute</span> = <span class="string">"class-description"</span>&gt;</span></span><br><span class="line">         This class contains the employee detail. </span><br><span class="line">      <span class="tag">&lt;/<span class="name">meta</span>&gt;</span></span><br><span class="line">      </span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span> = <span class="string">"id"</span> <span class="attr">type</span> = <span class="string">"int"</span> <span class="attr">column</span> = <span class="string">"id"</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"native"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      </span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">"firstName"</span> <span class="attr">column</span> = <span class="string">"first_name"</span> <span class="attr">type</span> = <span class="string">"string"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">"lastName"</span> <span class="attr">column</span> = <span class="string">"last_name"</span> <span class="attr">type</span> = <span class="string">"string"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">"salary"</span> <span class="attr">column</span> = <span class="string">"salary"</span> <span class="attr">type</span> = <span class="string">"int"</span>/&gt;</span></span><br><span class="line">      </span><br><span class="line">   <span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="四、创建应用程序类"><a href="#四、创建应用程序类" class="headerlink" title="四、创建应用程序类"></a>四、创建应用程序类</h3><p>最后，我们创建一个应用程序类来做简单的测试。例如：保存一些<code>Employee</code>数据，执行<code>CRUD</code>操作等。</p><p><strong><code>ManageEmployee.java</code></strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List; </span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.hibernate.HibernateException; </span><br><span class="line"><span class="keyword">import</span> org.hibernate.Session; </span><br><span class="line"><span class="keyword">import</span> org.hibernate.Transaction;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.SessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.cfg.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ManageEmployee</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> SessionFactory factory; </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         factory = <span class="keyword">new</span> Configuration().configure().buildSessionFactory();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable ex) &#123; </span><br><span class="line">         System.err.println(<span class="string">"Failed to create sessionFactory object."</span> + ex);</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> ExceptionInInitializerError(ex); </span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      ManageEmployee ME = <span class="keyword">new</span> ManageEmployee();</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Add few employee records in database */</span></span><br><span class="line">      Integer empID1 = ME.addEmployee(<span class="string">"Zara"</span>, <span class="string">"Ali"</span>, <span class="number">1000</span>);</span><br><span class="line">      Integer empID2 = ME.addEmployee(<span class="string">"Daisy"</span>, <span class="string">"Das"</span>, <span class="number">5000</span>);</span><br><span class="line">      Integer empID3 = ME.addEmployee(<span class="string">"John"</span>, <span class="string">"Paul"</span>, <span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* List down all the employees */</span></span><br><span class="line">      ME.listEmployees();</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Update employee's records */</span></span><br><span class="line">      ME.updateEmployee(empID1, <span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Delete an employee from the database */</span></span><br><span class="line">      ME.deleteEmployee(empID2);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* List down new list of the employees */</span></span><br><span class="line">      ME.listEmployees();</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* Method to CREATE an employee in the database */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Integer <span class="title">addEmployee</span><span class="params">(String fname, String lname, <span class="keyword">int</span> salary)</span></span>&#123;</span><br><span class="line">      Session session = factory.openSession();</span><br><span class="line">      Transaction tx = <span class="keyword">null</span>;</span><br><span class="line">      Integer employeeID = <span class="keyword">null</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         tx = session.beginTransaction();</span><br><span class="line">         Employee employee = <span class="keyword">new</span> Employee(fname, lname, salary);</span><br><span class="line">         employeeID = (Integer) session.save(employee); </span><br><span class="line">         tx.commit();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (HibernateException e) &#123;</span><br><span class="line">         <span class="keyword">if</span> (tx!=<span class="keyword">null</span>) tx.rollback();</span><br><span class="line">         e.printStackTrace(); </span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         session.close(); </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> employeeID;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* Method to  READ all the employees */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listEmployees</span><span class="params">( )</span></span>&#123;</span><br><span class="line">      Session session = factory.openSession();</span><br><span class="line">      Transaction tx = <span class="keyword">null</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         tx = session.beginTransaction();</span><br><span class="line">         List employees = session.createQuery(<span class="string">"FROM Employee"</span>).list(); </span><br><span class="line">         <span class="keyword">for</span> (Iterator iterator = employees.iterator(); iterator.hasNext();)&#123;</span><br><span class="line">            Employee employee = (Employee) iterator.next(); </span><br><span class="line">            System.out.print(<span class="string">"First Name: "</span> + employee.getFirstName()); </span><br><span class="line">            System.out.print(<span class="string">"  Last Name: "</span> + employee.getLastName()); </span><br><span class="line">            System.out.println(<span class="string">"  Salary: "</span> + employee.getSalary()); </span><br><span class="line">         &#125;</span><br><span class="line">         tx.commit();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (HibernateException e) &#123;</span><br><span class="line">         <span class="keyword">if</span> (tx!=<span class="keyword">null</span>) tx.rollback();</span><br><span class="line">         e.printStackTrace(); </span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         session.close(); </span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* Method to UPDATE salary for an employee */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateEmployee</span><span class="params">(Integer EmployeeID, <span class="keyword">int</span> salary )</span></span>&#123;</span><br><span class="line">      Session session = factory.openSession();</span><br><span class="line">      Transaction tx = <span class="keyword">null</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         tx = session.beginTransaction();</span><br><span class="line">         Employee employee = (Employee)session.get(Employee.class, EmployeeID); </span><br><span class="line">         employee.setSalary( salary );</span><br><span class="line"> session.update(employee); </span><br><span class="line">         tx.commit();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (HibernateException e) &#123;</span><br><span class="line">         <span class="keyword">if</span> (tx!=<span class="keyword">null</span>) tx.rollback();</span><br><span class="line">         e.printStackTrace(); </span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         session.close(); </span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* Method to DELETE an employee from the records */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteEmployee</span><span class="params">(Integer EmployeeID)</span></span>&#123;</span><br><span class="line">      Session session = factory.openSession();</span><br><span class="line">      Transaction tx = <span class="keyword">null</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         tx = session.beginTransaction();</span><br><span class="line">         Employee employee = (Employee)session.get(Employee.class, EmployeeID); </span><br><span class="line">         session.delete(employee); </span><br><span class="line">         tx.commit();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (HibernateException e) &#123;</span><br><span class="line">         <span class="keyword">if</span> (tx!=<span class="keyword">null</span>) tx.rollback();</span><br><span class="line">         e.printStackTrace(); </span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         session.close(); </span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="五、编译执行"><a href="#五、编译执行" class="headerlink" title="五、编译执行"></a>五、编译执行</h3><p>通过编译执行，我们可以得到下面的测试结果：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$java</span> ManageEmployee</span><br><span class="line">.......VARIOUS LOG MESSAGES WILL DISPLAY HERE........</span><br><span class="line"></span><br><span class="line">First Name: Zara  Last Name: Ali  Salary: 1000</span><br><span class="line">First Name: Daisy  Last Name: Das  Salary: 5000</span><br><span class="line">First Name: John  Last Name: Paul  Salary: 10000</span><br><span class="line">First Name: Zara  Last Name: Ali  Salary: 5000</span><br><span class="line">First Name: John  Last Name: Paul  Salary: 10000</span><br></pre></td></tr></table></figure><p><code>EMPLOYEE</code>表中的数据：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from EMPLOYEE;</span><br><span class="line">+----+------------+-----------+--------+</span><br><span class="line">| id | first_name | last_name | salary |</span><br><span class="line">+----+------------+-----------+--------+</span><br><span class="line">| 29 | Zara       | Ali       |   5000 |</span><br><span class="line">| 31 | John       | Paul      |  10000 |</span><br><span class="line">+----+------------+-----------+--------+</span><br><span class="line">2 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure><h2 id="Hibernate-O-R-映射"><a href="#Hibernate-O-R-映射" class="headerlink" title="Hibernate O/R 映射"></a>Hibernate O/R 映射</h2><p>之前，我们已经熟悉了Hibernate的基本<code>O/R</code>映射的使用，但是还有很多映射我们还需要进一步的了解。如：</p><ul><li>集合的映射</li><li>实体类之间的关联映射</li><li>组件映射</li></ul><h3 id="一、集合映射"><a href="#一、集合映射" class="headerlink" title="一、集合映射"></a>一、集合映射</h3><p>如果持久化类中包含某个属性为集合类型，我们也需要将集合类型值映射到数据表中。<strong>Hibernate</strong>能够持久化的集合实例有<code>java.util.Map</code>、<code>java.util.Set</code>、<code>java.util.SortedMap</code>、<code>java.util.SortedSet</code>、<code>java.util.List</code>以及持久化实例中的数组(<code>array</code>)。</p><div class="table-container"><table><thead><tr><th style="text-align:center">Collection Type</th><th style="text-align:center">Mapping Description</th></tr></thead><tbody><tr><td style="text-align:center"><a href="#Set-Mapping">java.util.Set</a></td><td style="text-align:center">使用<code>&lt;set&gt;</code>标签元素进行映射并使用<code>java.util.HashSet</code>进行初始化</td></tr><tr><td style="text-align:center"><a href="#SortedSet-Mapping">java.util.SortedSet</a></td><td style="text-align:center">使用<code>&lt;set&gt;</code>标签进行映射并用<code>java.util.TreeSet</code>初始化，属性<code>sort</code>可以设置为<code>comparator</code>或者<code>natural ordering</code></td></tr><tr><td style="text-align:center"><a href="#List-Mapping">java.util.List</a></td><td style="text-align:center">使用<code>&lt;list&gt;</code>标签进行映射，并用<code>java.util.ArrayList</code>初始化</td></tr><tr><td style="text-align:center"><a href="#Collection-Mapping">java.util.Collection</a></td><td style="text-align:center">使用<code>&lt;bag&gt;</code>或<code>&lt;ibag&gt;</code>标签进行映射配置并使用<code>java.util.ArrayList</code>初始化</td></tr><tr><td style="text-align:center"><a href="#Map-Mapping">java.util.Map</a></td><td style="text-align:center">使用<code>&lt;map</code>标签进行映射并使用<code>java.util.HashMap</code>初始化</td></tr><tr><td style="text-align:center"><a href="#SortedMap-Mapping">java.util.SortedMap</a></td><td style="text-align:center">使用<code>&lt;map</code>标签进行映射并用<code>java.util.TreeMap</code>初始化。属性<code>sort</code>可以设置为<code>comparator</code>或<code>natural ordering</code></td></tr></tbody></table></div><p>对于数组类型的映射，针对Java原始值类型使用<code>&lt;primitive-array&gt;</code>标签，其他的数组类型则使用<code>&lt;array&gt;</code>。但是一般很少使用到。</p><p><strong>[notice]</strong>:如果需要映射用户自定义的集合接口，切该集合接口不是<strong>Hiberate</strong>直接支持的，就需要告诉Hibernate定义集合的语义，通常是很难实现的，一般不推荐使用。</p><h4 id="Set-Mapping"><a href="#Set-Mapping" class="headerlink" title="Set-Mapping"></a>Set-Mapping</h4><h4 id="SortedSet-Mapping"><a href="#SortedSet-Mapping" class="headerlink" title="SortedSet-Mapping"></a>SortedSet-Mapping</h4><h4 id="List-Mapping"><a href="#List-Mapping" class="headerlink" title="List-Mapping"></a>List-Mapping</h4><h4 id="Collection-Mapping"><a href="#Collection-Mapping" class="headerlink" title="Collection-Mapping"></a>Collection-Mapping</h4><h4 id="Map-Mapping"><a href="#Map-Mapping" class="headerlink" title="Map-Mapping"></a>Map-Mapping</h4><h4 id="SortedMap-Mapping"><a href="#SortedMap-Mapping" class="headerlink" title="SortedMap-Mapping"></a>SortedMap-Mapping</h4><h3 id="二、关联映射"><a href="#二、关联映射" class="headerlink" title="二、关联映射"></a>二、关联映射</h3><p>实体类和数据表之间的映射是<code>ORM</code>的灵魂。以下是可以表示对象之间关系的四种方式。关联映射可以是单向的，也可以是双向的。</p><div class="table-container"><table><thead><tr><th style="text-align:center">Mapping Type</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td style="text-align:center"><a href="#Many-to-One">Many-to-One</a></td><td style="text-align:center">多对一关系的映射</td></tr><tr><td style="text-align:center"><a href="#One-to-One">One-to-One</a></td><td style="text-align:center">一对一关系的映射</td></tr><tr><td style="text-align:center"><a href="#One-to-Many">One-to-Many</a></td><td style="text-align:center">一对多关系的映射</td></tr><tr><td style="text-align:center"><a href="#Many-to-Many">Many-to-Many</a></td><td style="text-align:center">多对多关系的映射</td></tr></tbody></table></div><h4 id="Many-to-One"><a href="#Many-to-One" class="headerlink" title="Many-to-One"></a>Many-to-One</h4><h4 id="One-to-One"><a href="#One-to-One" class="headerlink" title="One-to-One"></a>One-to-One</h4><h4 id="One-to-Many"><a href="#One-to-Many" class="headerlink" title="One-to-Many"></a>One-to-Many</h4><h4 id="Many-to-Many"><a href="#Many-to-Many" class="headerlink" title="Many-to-Many"></a>Many-to-Many</h4><h3 id="三、组件映射"><a href="#三、组件映射" class="headerlink" title="三、组件映射"></a>三、组件映射</h3><p>在应用程序中，有很大的可能性一个实体类会持有另一个实体的引用最为成员变量。如果别引用的类没有自己的申明周期并且完全依赖与拥有的实体类的生命周期，那么所引用的类称为<strong>组件类</strong>。</p><p>组件的映射可以以类似集合映射的方式进行，但有点不同与常规的集合映射：</p><div class="table-container"><table><thead><tr><th style="text-align:center">Mapping Type</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td style="text-align:center"><a href="">Component Mappings</a></td><td style="text-align:center">对持有另一个类作为成员变量的实体类进行映射</td></tr></tbody></table></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/Hibernate基础学习/hibernate_logo.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Hibernate&lt;/strong&gt;是一个对象关系映射(Object-Relational Mapping, &lt;code&gt;ORM&lt;/code&gt;)的JAVA解决方案。是在2001年由 &lt;em&gt;Gavin King&lt;/em&gt;创建的开源持久化框架。适用于任何使用Java应用程序的功能强大的高性能&lt;strong&gt;对象关系持久化和查询服务&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Java框架学习" scheme="http://rovo98.github.io/categories/Java%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Hibernate" scheme="http://rovo98.github.io/categories/Java%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/Hibernate/"/>
    
    
      <category term="Java框架基础" scheme="http://rovo98.github.io/tags/Java%E6%A1%86%E6%9E%B6%E5%9F%BA%E7%A1%80/"/>
    
      <category term="hibernate" scheme="http://rovo98.github.io/tags/hibernate/"/>
    
      <category term="学习笔记" scheme="http://rovo98.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java持久化框架基础学习笔记 - ORM</title>
    <link href="http://rovo98.github.io/posts/4e7f2cb9/"/>
    <id>http://rovo98.github.io/posts/4e7f2cb9/</id>
    <published>2018-04-12T11:41:44.000Z</published>
    <updated>2018-07-19T07:54:49.891Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/Java框架学习基础-ORM/orm.png" alt=""></p><blockquote><p>对象关系映射(Oject Relational Mapping, ORM)是一种程序技术，用户实现面向对象编程语言中不同类型系统的数据之间的转换。</p></blockquote><a id="more"></a><p>为了更好的了解ORM，我们先要了解一下JDBC。</p><h3 id="什么是JDBC"><a href="#什么是JDBC" class="headerlink" title="什么是JDBC?"></a>什么是JDBC?</h3><p>JDBC，即<strong>Java Database Connectivity</strong>(Java数据库连接)。它为Java程序提供了访问关系型数据库(relational database)的Java API集合。<strong>这些API使得Java程序可以执行SQL语句并与任何符合SQL的数据库库进行交互。</strong></p><p>JDBC提供了一种<strong>灵活的</strong>结构来编写能够和数据库进行交互的应用，且在<strong>不做任何修改的情况下</strong>，能够运行于不同的平台。</p><h4 id="JDBC的优点和缺点"><a href="#JDBC的优点和缺点" class="headerlink" title="JDBC的优点和缺点"></a>JDBC的优点和缺点</h4><div class="table-container"><table><thead><tr><th style="text-align:center">优点</th><th style="text-align:center">缺点</th></tr></thead><tbody><tr><td style="text-align:center">清晰简单的SQL处理</td><td style="text-align:center">在大型的项目中使用时变得异常复杂</td></tr><tr><td style="text-align:center">处理大数据时有良好表现</td><td style="text-align:center">大量编程开销，没有封装</td></tr><tr><td style="text-align:center">非常适合小应用程序</td><td style="text-align:center">难以实现MVC模式</td></tr><tr><td style="text-align:center">语法简单易学</td><td style="text-align:center">查询是DBMS特有的</td></tr></tbody></table></div><h3 id="为什么使用对象关系映射-ORM"><a href="#为什么使用对象关系映射-ORM" class="headerlink" title="为什么使用对象关系映射(ORM)?"></a>为什么使用对象关系映射(ORM)?</h3><p>当我们使用面向对象系统时，对象模型和关系数据库存在不匹配的现象，<strong>RDMSs(关系型数据库) 以表格的形式表示数据，而面向对象编程语言，如java,C# 将数据表示为对象的属性，以及对象之间的关系</strong>。</p><p>例如下面的一个简单的实体类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String firstName;</span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> salary;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String fname, String lname, <span class="keyword">int</span> sal)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.firstName = fname;</span><br><span class="line">        <span class="keyword">this</span>.lastName = lname;</span><br><span class="line">        <span class="keyword">this</span>.salary = sal;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFirstName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> firstName;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLastName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lastName;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSalary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> salary;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的对象在关系型数据库中可以这样存储和检索的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> EMPLOYEE (</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span> auto_increment,</span><br><span class="line">    first_name <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">default</span> <span class="literal">null</span>,</span><br><span class="line">    last_name <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">default</span> <span class="literal">null</span>,</span><br><span class="line">    salary <span class="built_in">int</span> <span class="keyword">default</span> <span class="literal">null</span>,</span><br><span class="line">    contraint PK_id primary <span class="keyword">key</span> (<span class="keyword">id</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h4><ol><li>可能我们开发了几个页面后，要修改数据库的设计，我们应该怎样处理？</li><li>将对象存储到关系型数据库和从数据库中读取存在以下五个<strong>不匹配(mismatch)</strong>的问题：</li></ol><div class="table-container"><table><thead><tr><th style="text-align:center">不匹配(Mismatch)</th><th style="text-align:center">描述(Description)</th></tr></thead><tbody><tr><td style="text-align:center">Granularity(粒度)</td><td style="text-align:center">有时你可能会有一个对象模型，它的类比数据库中的相应的表的数量还要多。</td></tr><tr><td style="text-align:center">Inheritence(继承)</td><td style="text-align:center">RDBMS不定义任何类似继承的东西，但这确是面向对象编程语言中的的自然范式。</td></tr><tr><td style="text-align:center">Identity(标识)</td><td style="text-align:center">RDBMS正好定义了一个“相等”的概念：主键。但是Java定义对象标识(a == b) 和对象相等(a.equals(b))。</td></tr><tr><td style="text-align:center">Associations(关联)</td><td style="text-align:center">面向对象编程语言使用对象引用来表示关联，而RDBMS将关联表示为外键。</td></tr><tr><td style="text-align:center">Navigation(检索)</td><td style="text-align:center">在Java和RDBMS中访问对象的方式根本不同。</td></tr></tbody></table></div><p><strong>对象关系映射（ORM）是处理上述所有不匹配问题的解决方案</strong>。</p><h3 id="什么是ORM"><a href="#什么是ORM" class="headerlink" title="什么是ORM?"></a>什么是ORM?</h3><p>ORM 是一项在关系型数据库和面向对象编程语言之间转换数据的编程技术。</p><p>相比于简单的JDBC，ORM有以下优点：</p><div class="table-container"><table><thead><tr><th style="text-align:center">No.</th><th style="text-align:center">Advantages</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">让业务逻辑代码访问数据对象，而不是数据表</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">隐藏了业务逻辑的SQL查询的详细信息</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">无需处理数据库实现问题</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">基于业务概念而非数据库结构的实体</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">基于JDBC“底层”</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">事务管理和自动密钥生成</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">应用程序快速开发</td></tr></tbody></table></div><p>一个 ORM 解决方案由以下四个实体组成：</p><div class="table-container"><table><thead><tr><th style="text-align:center">No.</th><th style="text-align:center">Solutions</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">对持久化类的对象执行基本CRUD操作的API</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">用于指定引用类和类的属性的查询的语言或API</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">用于指定映射元数据的可配置工具</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">一种与事务对象进行交互以执行脏检查，懒惰关联提取以及其他优化功能的技术。</td></tr></tbody></table></div><h3 id="Java-ORM-框架"><a href="#Java-ORM-框架" class="headerlink" title="Java ORM 框架"></a>Java ORM 框架</h3><p>有许多持久化框架ORM解决方案使用java实现的，如：</p><ul><li>Enterprise JavaBeans Entity Beans</li><li>Java Data Ojects</li><li>Castor</li><li>TopLink</li><li>Spring DAO</li><li>Hibernate</li><li>Mybatis</li><li>等等。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/Java框架学习基础-ORM/orm.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;对象关系映射(Oject Relational Mapping, ORM)是一种程序技术，用户实现面向对象编程语言中不同类型系统的数据之间的转换。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java框架学习" scheme="http://rovo98.github.io/categories/Java%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java框架基础" scheme="http://rovo98.github.io/tags/Java%E6%A1%86%E6%9E%B6%E5%9F%BA%E7%A1%80/"/>
    
      <category term="学习笔记" scheme="http://rovo98.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="ORM" scheme="http://rovo98.github.io/tags/ORM/"/>
    
  </entry>
  
  <entry>
    <title>Struts 2基础学习 - Interceptors</title>
    <link href="http://rovo98.github.io/posts/5e817364/"/>
    <id>http://rovo98.github.io/posts/5e817364/</id>
    <published>2018-04-11T06:06:12.000Z</published>
    <updated>2018-06-26T14:39:51.950Z</updated>
    
    <content type="html"><![CDATA[<p>Interceptors(拦截器)在概念上同<strong>servlet过滤器以及JDK动态代理类</strong>一样。拦截器可以透切(crosscutting)<code>action</code>以及框架来实现一些特定的功能。例如：</p><ol><li>在action调用执行前，预先执行某些代码；</li><li>在action调用和执行后，再次执行你指定的代码；</li><li>用来捕捉异常，以便可以执行替代处理(alternate processing)。</li></ol><a id="more"></a><p>事实上，<strong>Struts 2</strong>框架的许多特性都是使用拦截器实现的。例如： <code>exception handling</code>, <code>file uploading</code>, <code>lifecycle callbacks</code>等等。因为<strong>Struts 2</strong>在拦截器上强调了它的大部分功能，因此不太可能为单个<code>action</code>分配7或8个拦截器。</p><h3 id="Struts-2框架拦截器"><a href="#Struts-2框架拦截器" class="headerlink" title="Struts 2框架拦截器"></a>Struts 2框架拦截器</h3><p><strong>Struts 2</strong>框架提供了许多预先配置并且可以开箱即用的拦截器。下面是一些比较重要的拦截器：</p><div class="table-container"><table><thead><tr><th style="text-align:center">Interceptor</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td style="text-align:center">alias</td><td style="text-align:center">允许参数(parameters)跨请求拥有不同的别名</td></tr><tr><td style="text-align:center">checkbox</td><td style="text-align:center">通过为未选中的复选框(check box)添加参数值false来协助管理复选框</td></tr><tr><td style="text-align:center">conversionError</td><td style="text-align:center">将字符串转换为参数类型的错误信息放入Action的字段错误中</td></tr><tr><td style="text-align:center">createSession</td><td style="text-align:center">自动创建一个HTTP session如果它没有存在</td></tr><tr><td style="text-align:center">debugging</td><td style="text-align:center">为开发人员提供几个不同的调式界面</td></tr><tr><td style="text-align:center">execAndWait</td><td style="text-align:center">当action在后台执行时，给用户提供一个等待页面</td></tr><tr><td style="text-align:center">exception</td><td style="text-align:center">将action引发的异常映射到result,并通过重定向自动处理异常</td></tr><tr><td style="text-align:center">fileUpload</td><td style="text-align:center">便于文件上传</td></tr><tr><td style="text-align:center">i18n</td><td style="text-align:center">在用户回话期间跟踪所选的语言环境</td></tr><tr><td style="text-align:center">logger</td><td style="text-align:center">通过输出被执行的action的名字来提供简单的日志信息</td></tr><tr><td style="text-align:center">params</td><td style="text-align:center">允许在action中设置request的参数</td></tr><tr><td style="text-align:center">prepare</td><td style="text-align:center">这是一个用来的做预处理工作的典型代表，例如：建立数据库连接</td></tr><tr><td style="text-align:center">profile</td><td style="text-align:center">允许为action记录简单的分析信息</td></tr><tr><td style="text-align:center">scope</td><td style="text-align:center">在session或application域中存储和检索action的状态</td></tr><tr><td style="text-align:center">ServletConfig</td><td style="text-align:center">提供可以访问各种基于servlet信息的action</td></tr><tr><td style="text-align:center">timer</td><td style="text-align:center">为action需要执行多少时间提供一个简单的分析信息</td></tr><tr><td style="text-align:center">token</td><td style="text-align:center">检查有效标记的action以防止重复的表单提交</td></tr><tr><td style="text-align:center">validation</td><td style="text-align:center">为action的提供验证支持</td></tr></tbody></table></div><h3 id="如何使用拦截器？"><a href="#如何使用拦截器？" class="headerlink" title="如何使用拦截器？"></a>如何使用拦截器？</h3><p>我们可以直接在<code>struts.xml</code>配置文件中配置<strong>Struts 2</strong>已经提供的拦截器，例如使用<code>timer</code>拦截器来打印执行<code>action</code>所需要的时间，同时还可以使用<code>params</code>拦截器来将<code>request</code>参数传递给<code>action</code>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version = "1.0" Encoding = "UTF-8"?&gt;</span><br><span class="line"><span class="meta">&lt;!DOCTYPE struts PUBLIC</span></span><br><span class="line"><span class="meta">   "-//Apache Software Foundation//DTD Struts Configuration 2.0//EN"</span></span><br><span class="line"><span class="meta">   "http://struts.apache.org/dtds/struts-2.0.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">struts</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">constant</span> <span class="attr">name</span> = <span class="string">"struts.devMode"</span> <span class="attr">value</span> = <span class="string">"true"</span> /&gt;</span></span><br><span class="line">   </span><br><span class="line">   <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span> = <span class="string">"helloworld"</span> <span class="attr">extends</span> = <span class="string">"struts-default"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span> = <span class="string">"hello"</span> </span></span><br><span class="line"><span class="tag">         <span class="attr">class</span> = <span class="string">"com.rovo98.struts2.HelloWorldAction"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">method</span> = <span class="string">"execute"</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">interceptor-ref</span> <span class="attr">name</span> = <span class="string">"params"</span>/&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">interceptor-ref</span> <span class="attr">name</span> = <span class="string">"timer"</span> /&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span> = <span class="string">"success"</span>&gt;</span>/HelloWorld.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">struts</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="创建自定义拦截器"><a href="#创建自定义拦截器" class="headerlink" title="创建自定义拦截器"></a>创建自定义拦截器</h3><p>在我们的应用程序中使用<strong>拦截器</strong>来透切(crosscutting)应用使用一种优雅的方式。创建自定义的拦截器很容易，只需要实现<code>Interceptor</code>接口就行了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interceptor</span> <span class="keyword">extends</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">intercept</span><span class="params">(ActionInvocation invocation)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>init()</code>方法用来初始化拦截器，<code>destroy()</code>方法被用来销毁拦截器。不像<code>action</code>，拦截器<code>request</code>中被重复使用，所以它需要考虑线程安全问题，特别是<code>intercept()</code>方法。</p><p><code>ActionInvocation</code>对象提供的运行环境的访问。它允许访问<code>action</code>本身和调用<code>action</code>的方法并确定<code>action</code>是否已经被调用。</p><p>如果你不需要实现初始化和销毁拦截器的代码，可以直接继承<code>AbstractInterceptor</code>类，它不需要实现<code>init()</code>和<code>destroy()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.rovo98.struts2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> com.opensymphony.xwork2.ActionInvocation;</span><br><span class="line"><span class="keyword">import</span> com.opensymphony.xwork2.interceptor.AbstractInterceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterceptor</span> <span class="keyword">extends</span> <span class="title">AbstractInterceptor</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">intercept</span><span class="params">(ActionInvocation invocation)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="comment">/* let us do some pre-processing */</span></span><br><span class="line">      String output = <span class="string">"Pre-Processing"</span>; </span><br><span class="line">      System.out.println(output);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* let us call action or next interceptor */</span></span><br><span class="line">      String result = invocation.invoke();</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* let us do some post-processing */</span></span><br><span class="line">      output = <span class="string">"Post-Processing"</span>; </span><br><span class="line">      System.out.println(output);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际的<code>action</code>将通过拦截器调用<code>invocation.invoke()</code>方法来执行。因此我们<code>action</code>执行前或执行后加入我们的处理代码。</p><p>框架本身通过对<code>ActionInvocation</code>对象的<code>invoke()</code>方法的第一次调用来启动该过程。每次调用<code>invoke()</code>，<code>ActionInvocation</code>都会查询其状态并执行下一个拦截器。当所有的配置的拦截器都执行完了之后，<code>action</code>才会被执行。</p><p>下面是其工作流程图：</p><p><img src="actioninvocation.jpg" alt=""></p><h3 id="拦截器栈"><a href="#拦截器栈" class="headerlink" title="拦截器栈"></a>拦截器栈</h3><p>不难想象，当我们为单个<code>action</code>配置多个拦截器时，它们很快会变得很难管理。所以<strong>Struts 2</strong>引入了拦截器栈的概念来管理。下面是一个在<code>sturtsdefault.xml</code>配置文件中的一个拦截器栈：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">interceptor-stack</span> <span class="attr">name</span> = <span class="string">"basicStack"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">interceptor-ref</span> <span class="attr">name</span> = <span class="string">"exception"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">interceptor-ref</span> <span class="attr">name</span> = <span class="string">"servlet-config"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">interceptor-ref</span> <span class="attr">name</span> = <span class="string">"prepare"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">interceptor-ref</span> <span class="attr">name</span> = <span class="string">"checkbox"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">interceptor-ref</span> <span class="attr">name</span> = <span class="string">"params"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">interceptor-ref</span> <span class="attr">name</span> = <span class="string">"conversionError"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">interceptor-stack</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面的拦截器栈拥有唯一标识<code>basicStack</code>,当我们使用这个拦截器栈时，实际上和之前配置单个拦截器使用的是同样的语法：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>= <span class="string">"hello"</span> <span class="attr">class</span>= <span class="string">"com.rovo98.struts2.MyActoin"</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">interceptor-ref</span> <span class="attr">name</span> = <span class="string">"basicStack"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span>&gt;</span>/view.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过上面的配置，为<code>hello</code>action 配置了六个拦截器，且这六个拦截器在<code>action</code>被执行前将被按顺序执行。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Interceptors(拦截器)在概念上同&lt;strong&gt;servlet过滤器以及JDK动态代理类&lt;/strong&gt;一样。拦截器可以透切(crosscutting)&lt;code&gt;action&lt;/code&gt;以及框架来实现一些特定的功能。例如：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;在action调用执行前，预先执行某些代码；&lt;/li&gt;&lt;li&gt;在action调用和执行后，再次执行你指定的代码；&lt;/li&gt;&lt;li&gt;用来捕捉异常，以便可以执行替代处理(alternate processing)。&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
      <category term="Java框架学习" scheme="http://rovo98.github.io/categories/Java%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Struts 2" scheme="http://rovo98.github.io/categories/Java%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/Struts-2/"/>
    
    
      <category term="Java框架基础" scheme="http://rovo98.github.io/tags/Java%E6%A1%86%E6%9E%B6%E5%9F%BA%E7%A1%80/"/>
    
      <category term="学习笔记" scheme="http://rovo98.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Struts 2基础学习" scheme="http://rovo98.github.io/tags/Struts-2%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Struts 2基础学习 - Actions</title>
    <link href="http://rovo98.github.io/posts/338c78b5/"/>
    <id>http://rovo98.github.io/posts/338c78b5/</id>
    <published>2018-04-11T06:01:19.000Z</published>
    <updated>2018-06-23T08:21:16.963Z</updated>
    
    <content type="html"><![CDATA[<p><code>action</code>是<strong>Struts 2</strong> 框架的核心，它们适用于任何MVC框架。每个URL都映射到一个具体的<code>action</code>，<code>action</code>提供了业务逻辑处理来响应用户发起的请求。</p><a id="more"></a><p>但是，<code>action</code>拥有另外两个重要的职能。第一， <code>action</code>在数据(data)从<code>request</code>中传递到视图(view,无论是jsp还是其他的result)的过程扮演着一个重要的角色。第二，<code>action</code>帮助<strong>Struts 2</strong> 来确定哪个result对应的视图(view)将被返回去响应用户的请求。</p><h3 id="创建Action"><a href="#创建Action" class="headerlink" title="创建Action"></a>创建Action</h3><p>创建和使用<code>action</code>类的唯一要求就是<strong>必须要有一个无参方法(noargument method)返回<code>String</code>或<code>Result</code>对象，并且必须是<code>POJO</code>(Plain Ordinary Java Object).如果该方法没有给出，默认的，<code>execute()</code>方法将会被执行。</strong></p><p>另外，我们可以通过继承实现了六个接口(其中包含<code>Action</code> interface)的<code>ActionSupport</code>类来创建我们的<code>action</code>类。 <code>Action</code>接口的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Action</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SUCCESS = <span class="string">"success"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NONE = <span class="string">"none"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ERROR = <span class="string">"error"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String INPUT = <span class="string">"input"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOGIN = <span class="string">"login"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是一个简单的普通的 <code>action</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.rovo98.struts2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldAction</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span>  String <span class="title">getNane</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们说过<code>action</code>可以控制视图，为了验证这一点，我们对上面的<code>action</code>的<code>execute()</code>方法做简单的修改，以及继承<code>ActionSupport</code>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.rovo98.struts2;</span><br><span class="line"><span class="keyword">import</span> com.opensymphony.xwork2.ActionSupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldAction</span> <span class="keyword">extends</span> <span class="title">ActionSupport</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"SECRET"</span>.equals(name)) &#123;</span><br><span class="line">        <span class="keyword">return</span> SUCCESS;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用Action"><a href="#使用Action" class="headerlink" title="使用Action"></a>使用Action</h3><h4 id="在struts-xml-配置文件中配置action"><a href="#在struts-xml-配置文件中配置action" class="headerlink" title="在struts.xml 配置文件中配置action"></a>在struts.xml 配置文件中配置action</h4><p>在上面的<code>action</code>中，我们执行<code>execute()</code>方法的业务逻辑是从<code>request</code>对象中获取的<code>name</code>的值如果是<code>&quot;SECRET&quot;</code>的话，返回<code>SUCCESS</code>,否则返回<code>ERROR</code>。<code>struts.xml</code>配置文件如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version = "1.0" Encoding = "UTF-8"?&gt;</span><br><span class="line"><span class="meta">&lt;!DOCTYPE struts PUBLIC</span></span><br><span class="line"><span class="meta">   "-//Apache Software Foundation//DTD Struts Configuration 2.0//EN"</span></span><br><span class="line"><span class="meta">   "http://struts.apache.org/dtds/struts-2.0.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">struts</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">constant</span> <span class="attr">name</span> = <span class="string">"struts.devMode"</span> <span class="attr">value</span> = <span class="string">"true"</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span> = <span class="string">"helloworld"</span> <span class="attr">extends</span> = <span class="string">"struts-default"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span> = <span class="string">"hello"</span> </span></span><br><span class="line"><span class="tag">         <span class="attr">class</span> = <span class="string">"com.rovo98.struts2.HelloWorldAction"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">method</span> = <span class="string">"execute"</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span> = <span class="string">"success"</span>&gt;</span>/HelloWorld.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span> = <span class="string">"error"</span>&gt;</span>/AccessDenied.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">struts</span>&gt;</span></span><br></pre></td></tr></table></figure><p>从上面的配置文件看，当用户请求<code>hello</code>action映射的URL时，<code>HelloworldAction</code>的<code>execute()</code>方法将会被执行，返回<code>SUCCESS</code>时，将以<code>HelloWorld.jsp</code>去响应用户的请求，否则以<code>AccessDenied.jsp</code>来响应用户的请求。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;action&lt;/code&gt;是&lt;strong&gt;Struts 2&lt;/strong&gt; 框架的核心，它们适用于任何MVC框架。每个URL都映射到一个具体的&lt;code&gt;action&lt;/code&gt;，&lt;code&gt;action&lt;/code&gt;提供了业务逻辑处理来响应用户发起的请求。&lt;/p&gt;
    
    </summary>
    
      <category term="Java框架学习" scheme="http://rovo98.github.io/categories/Java%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Struts 2" scheme="http://rovo98.github.io/categories/Java%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/Struts-2/"/>
    
    
      <category term="Java框架基础" scheme="http://rovo98.github.io/tags/Java%E6%A1%86%E6%9E%B6%E5%9F%BA%E7%A1%80/"/>
    
      <category term="学习笔记" scheme="http://rovo98.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Struts 2基础学习" scheme="http://rovo98.github.io/tags/Struts-2%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Struts 2基础学习 - 配置文件</title>
    <link href="http://rovo98.github.io/posts/3fe084cc/"/>
    <id>http://rovo98.github.io/posts/3fe084cc/</id>
    <published>2018-04-11T06:01:01.000Z</published>
    <updated>2018-06-22T15:22:08.199Z</updated>
    
    <content type="html"><![CDATA[<p>主要了解Struts 2应用的基本配置。看看使用Struts 2的一些重要的配置文件，如：<strong>web.xml, struts.xml,struts-config.xml和struts.properties</strong>，可以对Struts 2应用做哪些配置。</p><a id="more"></a><p>其实，我们只要使用web.xml和struts.xml问价就可以使用Struts 2应用。但是我们还是有必要了解一下其他配置文件。</p><h3 id="web-xml-配置文件"><a href="#web-xml-配置文件" class="headerlink" title="web.xml 配置文件"></a>web.xml 配置文件</h3><p><strong>web.xml</strong> 配置文件是 <strong>J2EE</strong> 配置文件，它决定了Servlet容器如何处理HTTP请求中的元素。严格上来说，它并不是 <strong>Struts 2</strong> 的配置文件，但是我们需要通过配置它来使 Struts 2工作。毕竟Struts 2 是基于一个Filter做Controller实现的)</p><p>这个文件为任何一个Web应用提供一个入口点(entry point),而 <strong>Struts 2 </strong>应用的入口点是定义在 <strong>web.xml</strong> 文件中的一个过滤器(filter)。因此我们会在<strong> web.xml</strong> 中顶一个<strong> FilterDispatcher</strong> 类的入口。</p><p>一个简单的<strong>web.xml</strong>文件配置例子：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version = "1.0" Encoding = "UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns:xsi</span> = <span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xmlns</span> = <span class="string">"http://java.sun.com/xml/ns/javaee"</span> </span></span><br><span class="line"><span class="tag">   <span class="attr">xmlns:web</span> = <span class="string">"http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xsi:schemaLocation</span> = <span class="string">"http://java.sun.com/xml/ns/javaee </span></span></span><br><span class="line"><span class="tag"><span class="string">   http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">id</span> = <span class="string">"WebApp_ID"</span> <span class="attr">version</span> = <span class="string">"3.0"</span>&gt;</span></span><br><span class="line">   </span><br><span class="line">   <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>Struts 2<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.jsp<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line">   </span><br><span class="line">   <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>struts2<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span></span><br><span class="line">         org.apache.struts2.dispatcher.FilterDispatcher</span><br><span class="line">      <span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>struts2<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><p>【notice】: 这里将Struts 2 Filter映射到 <strong>/* </strong>，而不是<strong>/*.action</strong>, 这意味着所有的url都会被Struts 2的过滤器解析。</p><h3 id="struts-xml-配置文件"><a href="#struts-xml-配置文件" class="headerlink" title="struts.xml 配置文件"></a>struts.xml 配置文件</h3><p><strong>struts.xml</strong> 文件包含<strong>actions</strong>开发时需要修改的配置信息。这个文件可以覆盖应用的默认配置，例如：<strong>struts.devMode = false</strong>，该文件可以放置在<strong>WEB-INF/classes</strong>目录下。</p><p>一个<strong>hellowordWorld</strong>例子的<strong>struts.xml</strong>配置文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version = "1.0" Encoding = "UTF-8"?&gt;</span><br><span class="line"><span class="meta">&lt;!DOCTYPE struts PUBLIC</span></span><br><span class="line"><span class="meta">   "-//Apache Software Foundation//DTD Struts Configuration 2.0//EN"</span></span><br><span class="line"><span class="meta">   "http://struts.apache.org/dtds/struts-2.0.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">struts</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">constant</span> <span class="attr">name</span> = <span class="string">"struts.devMode"</span> <span class="attr">value</span> = <span class="string">"true"</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span> = <span class="string">"helloworld"</span> <span class="attr">extends</span> = <span class="string">"struts-default"</span>&gt;</span></span><br><span class="line">     </span><br><span class="line">      <span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span> = <span class="string">"hello"</span> </span></span><br><span class="line"><span class="tag">         <span class="attr">class</span> = <span class="string">"com.rovo98.struts2.HelloWorldAction"</span> </span></span><br><span class="line"><span class="tag">         <span class="attr">method</span> = <span class="string">"execute"</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span> = <span class="string">"success"</span>&gt;</span>/HelloWorld.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">&lt;!-- more actions can be listed here --&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- more packages can be listed here --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">struts</span>&gt;</span></span><br></pre></td></tr></table></figure><p>一点需要注意的是 <strong>DOCTYPE</strong>，所有struts 配置文件都需要有正确的doctype信息，例如上面所展示的。<strong><struts></struts></strong>标签是配置文件中的根标签元素，我们可以在里面定义不同的包(<strong>package</strong>)，使用<strong><package></package></strong>标签可以使用配置信息模块化，当我们需要把一个大型的项目拆分成不同的模块的时候，它将非常有用。</p><p><strong>package</strong> 标签拥有以下的属性：</p><div class="table-container"><table><thead><tr><th style="text-align:center">Attribute</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td style="text-align:center">name(required)</td><td style="text-align:center">包的唯一标识符</td></tr><tr><td style="text-align:center">extends</td><td style="text-align:center">说明包继承于哪个包，默认的，我们使用<strong>struts-default</strong>作为基包(base package)</td></tr><tr><td style="text-align:center">abstract</td><td style="text-align:center">如果属性值为true,终端用户将无法使用该包</td></tr><tr><td style="text-align:center">namespace</td><td style="text-align:center"><strong>action</strong>类的唯一名称空间</td></tr></tbody></table></div><p><strong>constant</strong>标签拥有<strong>name</strong>和<strong>value</strong>属性，可以重写覆盖定义在<strong>default.properites</strong>文件中的属性配置，例如我们上面提到的<strong>struts.devMode</strong>,通过设置<strong>struts.devMode</strong>属性，我们在日志文件中查看debug信息。</p><p>我们通过定义一个<strong>action</strong>标签来映射我们需要访问的链接URL并定义一个实现<strong>execute()</strong>方法的类，任何时刻，当我们访问对应的链接时，该类的<strong>execute()</strong>方法都会被执行。</p><p><strong>result</strong>决定了执行<strong>action</strong>之后，返回浏览器的内容。<strong>action</strong>返回的String应该是和某个<strong>result</strong>的<strong>name</strong>属性值是一致的。<strong>result拥有两个可选的属性</strong>name<strong>和</strong>type<strong>，name属性的值默认为”success”,type默认为”dispatcher”</strong>。</p><p><strong>struts.xml</strong>配置文件在开发中可能会变得非常大，我们可以使用<strong>package</strong>将它们模块化，当然<strong>Struts</strong>还提供了另一种方式，我们可以把配置文件分割成多个xml文件，然后通过下面这种方式来将它们导入：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version = "1.0" Encoding = "UTF-8"?&gt;</span><br><span class="line"><span class="meta">&lt;!DOCTYPE struts PUBLIC</span></span><br><span class="line"><span class="meta">   "-//Apache Software Foundation//DTD Struts Configuration 2.0//EN"</span></span><br><span class="line"><span class="meta">   "http://struts.apache.org/dtds/struts-2.0.dtd"&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">struts</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">"my-struts1.xml"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">"my-struts2.xml"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">struts</span>&gt;</span></span><br></pre></td></tr></table></figure><p>【notice】: 这里有一个配置文件我们过多的提及，是<strong>struts-default.xml</strong>，该文件包含了Struts 的所有标准配置设置，在我们的开发项目中，我们可能并不会触碰到它。感兴趣的话，可以查看<strong>struts2-core-x.x.x.jar</strong>包中的<strong>default.properties</strong>文件。</p><h3 id="struts-config-xml-配置文件"><a href="#struts-config-xml-配置文件" class="headerlink" title="struts-config.xml 配置文件"></a>struts-config.xml 配置文件</h3><p><strong>struts-config.xml</strong>配置文件是Web客户端中View和Model组件之间的链接，但在我们99%的开发项目中，我们并不会接触到它。</p><p>配置文件主要包含以下这些主要的元素:</p><div class="table-container"><table><thead><tr><th style="text-align:center">Interceptor</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td style="text-align:center">struts-config</td><td style="text-align:center">配置文件的根节点</td></tr><tr><td style="text-align:center">form-bean</td><td style="text-align:center">可以将ActionForm的子类映射到一个名称(name),并在整个<strong>struts-config.xml</strong>文件的其余部分中，甚至在JSP页面上，都可使用这个name作为ActionForm的别名</td></tr><tr><td style="text-align:center">global forwards</td><td style="text-align:center">可以将一个页面映射到一个名称(name),并使用该名称来引用实际页面。这可以避免使用网页上的硬编码(hardcoding)网址</td></tr><tr><td style="text-align:center">action-mapping</td><td style="text-align:center">用来声明表单处理程序，也被成为action映射</td></tr><tr><td style="text-align:center">controller</td><td style="text-align:center">配置Struts的内部结构，很少在实际情况中使用</td></tr><tr><td style="text-align:center">plug-in</td><td style="text-align:center">告诉Struts如何查看你的属性文件(properties files)，其中包含提示和错误信息</td></tr></tbody></table></div><p><strong>struts-config.xml</strong>配置文件简单实例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version = "1.0" Encoding = "ISO-8859-1" ?&gt;</span><br><span class="line"><span class="meta">&lt;!DOCTYPE struts-config PUBLIC</span></span><br><span class="line"><span class="meta">   "-//Apache Software Foundation//DTD Struts Configuration 1.0//EN"</span></span><br><span class="line"><span class="meta">   "http://jakarta.apache.org/struts/dtds/struts-config_1_0.dtd"&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">struts-config</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!-- ========== Form Bean Definitions ============ --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">form-beans</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">form-bean</span> <span class="attr">name</span> = <span class="string">"login"</span> <span class="attr">type</span> = <span class="string">"test.struts.LoginForm"</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">form-beans</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!-- ========== Global Forward Definitions ========= --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">global-forwards</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">global-forwards</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!-- ========== Action Mapping Definitions ======== --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">action-mappings</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">action</span></span></span><br><span class="line"><span class="tag">         <span class="attr">path</span> = <span class="string">"/login"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">type</span> = <span class="string">"test.struts.LoginAction"</span> &gt;</span></span><br><span class="line"></span><br><span class="line">         <span class="tag">&lt;<span class="name">forward</span> <span class="attr">name</span> = <span class="string">"valid"</span> <span class="attr">path</span> = <span class="string">"/jsp/MainMenu.jsp"</span> /&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">forward</span> <span class="attr">name</span> = <span class="string">"invalid"</span> <span class="attr">path</span> = <span class="string">"/jsp/LoginView.jsp"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">action-mappings</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!-- ========== Controller Definitions ======== --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">controller</span> <span class="attr">contentType</span> = <span class="string">"text/html;charset = UTF-8"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">debug</span> = <span class="string">"3"</span> <span class="attr">maxFileSize</span> = <span class="string">"1.618M"</span> <span class="attr">locale</span> = <span class="string">"true"</span> <span class="attr">nocache</span> = <span class="string">"true"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">struts-config</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="struts-properties-配置文件"><a href="#struts-properties-配置文件" class="headerlink" title="struts.properties 配置文件"></a>struts.properties 配置文件</h3><p>该配置文件提供了一种可以改变框架默认行为的机制。实际上，所有包含在struts.properties<strong>配置文集中的属性都可以在</strong>web.xml<strong>中使用</strong>init-param<strong>标签来配置。也可以在</strong>struts.xml<strong>配置文件中使用</strong>constant<strong>标签来进行配置。但是，如果你想将不同的配置信息分开，那么你可以使用</strong>struts.properties<strong>，它可以放置在</strong>WEB-INF/classes**目录下。</p><p>在该文件中配置的属性值将会覆盖<strong>struts2-core.x.y.z.jar</strong>包中<strong>default.properties</strong>文件中配置的默认属性值。</p><p>下面是我们开发中可能会使用到的属性值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">### When set to true, Struts will act much more friendly for developers</span><br><span class="line">struts.devMode = true</span><br><span class="line"></span><br><span class="line">### Enables reloading of internationalization files</span><br><span class="line">struts.i18n.reload = true</span><br><span class="line"></span><br><span class="line">### Enables reloading of XML configuration files</span><br><span class="line">struts.configuration.xml.reload = true</span><br><span class="line"></span><br><span class="line">### Sets the port that the server is run on</span><br><span class="line">struts.url.http.port = 8080</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要了解Struts 2应用的基本配置。看看使用Struts 2的一些重要的配置文件，如：&lt;strong&gt;web.xml, struts.xml,struts-config.xml和struts.properties&lt;/strong&gt;，可以对Struts 2应用做哪些配置。&lt;/p&gt;
    
    </summary>
    
      <category term="Java框架学习" scheme="http://rovo98.github.io/categories/Java%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Struts 2" scheme="http://rovo98.github.io/categories/Java%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/Struts-2/"/>
    
    
      <category term="Java框架基础" scheme="http://rovo98.github.io/tags/Java%E6%A1%86%E6%9E%B6%E5%9F%BA%E7%A1%80/"/>
    
      <category term="学习笔记" scheme="http://rovo98.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Struts 2基础学习" scheme="http://rovo98.github.io/tags/Struts-2%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Struts 2基础学习 - 架构</title>
    <link href="http://rovo98.github.io/posts/4fe73428/"/>
    <id>http://rovo98.github.io/posts/4fe73428/</id>
    <published>2018-04-11T06:00:01.000Z</published>
    <updated>2018-06-22T15:22:09.910Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>从高层面来看， Struts 2 是一个纯粹的 MVC (或MVC2)框架，Struts 2使用以下的五个核心部分来实现 Model-View-Controller(MVC) 模式：</p><ul><li>Actions</li><li>Interceptors</li><li>Value Stack / OGNL</li><li>Results / Result types</li><li>View technologies</li></ul></blockquote><a id="more"></a><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>相比于传统的 <code>MVC</code> 框架， <code>Struts 2</code> 略有不同， 这是因为<code>Struts 2</code>中的 <code>action</code>更多的是扮演<code>model</code>的角色， 而不是 <code>controller</code>,虽然这其中有一些重叠的地方。</p><p><img src="struts_2_architecture.gif" alt=""></p><p>上面的图描述了<code>Struts 2</code>架构中的<code>Model</code>, <code>View</code>和<code>Controller</code>。<code>controller</code>由<code>Struts 2</code>的<code>dispatch servlet filter</code>(Servlet分发过滤器) 和 <code>interceptors</code>(拦截器)，<code>actions</code>实现<code>Model</code>, 视图<code>view</code>由<code>result types 和 results</code> 实现。值栈(<code>Value Stack</code>)和 <code>OGNL</code> 提供通用线程，链接和启用其他组件之间的集成。</p><p>除了上述的组件外， 还有大量的关于配置的消息(<strong>information</strong>)， 对Web 应用程序的配置， 对<code>actions</code>的配置，以及<code>interceptors,results</code>等等的配置。</p><h3 id="Request-生命周期"><a href="#Request-生命周期" class="headerlink" title="Request 生命周期"></a>Request 生命周期</h3><p>基于上面的图，我们可以了解到在Struts 2工作流中的用户请求的生命周期是这样的：</p><ol><li>用户向服务器发送一个资源(例如: 页面)请求；</li><li>Struts 2 的 Dispatcher Filter 拦截请求，并选择合适Action；</li><li>执行已配置的<code>interceptors</code>(拦截器)的功能， 例如： 表单验证，文件上传等；</li><li>基于请求操作，调用并执行已选择的<code>action</code>；</li><li>同样，如果需要，配置的拦截器可用于进行任意的后期处理；</li><li>最后，将由<code>view</code>准备的结果(result)返回给用户。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;从高层面来看， Struts 2 是一个纯粹的 MVC (或MVC2)框架，Struts 2使用以下的五个核心部分来实现 Model-View-Controller(MVC) 模式：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Actions&lt;/li&gt;&lt;li&gt;Interceptors&lt;/li&gt;&lt;li&gt;Value Stack / OGNL&lt;/li&gt;&lt;li&gt;Results / Result types&lt;/li&gt;&lt;li&gt;View technologies&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java框架学习" scheme="http://rovo98.github.io/categories/Java%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Struts 2" scheme="http://rovo98.github.io/categories/Java%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/Struts-2/"/>
    
    
      <category term="Java框架基础" scheme="http://rovo98.github.io/tags/Java%E6%A1%86%E6%9E%B6%E5%9F%BA%E7%A1%80/"/>
    
      <category term="学习笔记" scheme="http://rovo98.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Struts 2基础学习" scheme="http://rovo98.github.io/tags/Struts-2%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>基本查找算法 - basical searching algorithms</title>
    <link href="http://rovo98.github.io/posts/d83777d2/"/>
    <id>http://rovo98.github.io/posts/d83777d2/</id>
    <published>2018-03-06T16:00:00.000Z</published>
    <updated>2018-07-09T07:55:05.388Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>基本查找算法，我们只谈<strong>静态查找</strong>的查找算法。</p><h3 id="线性查找-linear-search"><a href="#线性查找-linear-search" class="headerlink" title="线性查找 - linear search"></a>线性查找 - linear search</h3><p>特点：</p><ul><li>从头开始遍历数组，一个一个和<strong>key</strong>比较，查找成功则返回索引值。</li><li>不要求数组是<strong>有序的</strong>。</li><li>时间复杂度为： $O(n)$.</li></ul><h4 id="线性查找原始抽象方法实现如下"><a href="#线性查找原始抽象方法实现如下" class="headerlink" title="线性查找原始抽象方法实现如下:"></a>线性查找原始抽象方法实现如下:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">linearSearch</span><span class="params">(Comparable[] a, Comparable key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a[i].compareTo(key) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="跳跃查找-jump-search"><a href="#跳跃查找-jump-search" class="headerlink" title="跳跃查找 - jump search"></a>跳跃查找 - jump search</h3><p>特点：</p><ul><li>要求查找数组<strong>有序</strong>；</li><li>主要思想是每次跳跃固定量的元素来确定目标元素所在的区间，再使用线性查找在区间上搜索目标元素。</li><li>时间复杂度为： $O(\sqrt{n})$.</li></ul><p><strong>[notice] : </strong>假设我们要在一个有n个元素的数组中搜索某个元素，最坏情况下（<strong>当目标元素为最后个元素时），这个算法要跳跃n/m步，在线性搜索时作m-1次比较。</strong>令 $f(n) = ((n/m) + m-1$.当m = $\sqrt{n}$时，f(n) 取最小值，所以通常情况下，跳跃查找所使用的固定跳跃步数为 $\sqrt{n}$.</p><h4 id="跳跃查找的原始抽象方法实现如下："><a href="#跳跃查找的原始抽象方法实现如下：" class="headerlink" title="跳跃查找的原始抽象方法实现如下："></a>跳跃查找的原始抽象方法实现如下：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">jumpSearch</span><span class="params">(Comparable[] a, Comparable key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = a.length;</span><br><span class="line">    <span class="keyword">int</span> block_size = Math.floor(Math.sqrt(n));</span><br><span class="line"><span class="keyword">int</span> step = block_size;</span><br><span class="line">    <span class="comment">// 查找目标元素可能出现的区间</span></span><br><span class="line">    <span class="keyword">int</span> prev = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (a[Math.min(step, n) - <span class="number">1</span>].compareTo(key) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    prev = step;</span><br><span class="line">        step += block_size;</span><br><span class="line">        <span class="keyword">if</span> (prev &gt;= n)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用线性查找在确定的区间上查找目标元素</span></span><br><span class="line">    <span class="keyword">while</span> (a[prev].compareTo(key) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    prev++;</span><br><span class="line">        <span class="keyword">if</span> (prev == Math.min(step, n))</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a[prev].compareTo(key) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二分查找-binary-search"><a href="#二分查找-binary-search" class="headerlink" title="二分查找 - binary search"></a>二分查找 - binary search</h3><ul><li>要求数组<strong>有序</strong>。</li><li>将已经排好序的数组分为两个区间(interval), 把区间的中间元素与<strong>key</strong>比较, 若大于则搜索左区间，若小于则搜索右区间，等于则返回元素的索引。<strong>当区间长度为0时（key没出现在数组中)</strong>,返回-1。</li><li>时间复杂度为 ： $O(nlogn)$.</li></ul><h4 id="二分查找原始抽象方法实现如下"><a href="#二分查找原始抽象方法实现如下" class="headerlink" title="二分查找原始抽象方法实现如下:"></a>二分查找原始抽象方法实现如下:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(Comparable[] a, Comparable key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> lo = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> hi = a.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[mid].compareTo(key) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[mid].compareTo(key) &gt; <span class="number">0</span>)</span><br><span class="line">        hi = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        lo = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearchRecursion</span><span class="params">(Comparable[] a, Comparable key, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (lo &lt;= hi) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[mid].compareTo(key) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[mid].compareTo(key) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> binarySearchRecursion(a, key, mid+<span class="number">1</span>, hi);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> binarySearchRecursion(a, key, lo, mid-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三分查找-ternary-search"><a href="#三分查找-ternary-search" class="headerlink" title="三分查找 - ternary search"></a>三分查找 - ternary search</h3><p>特点：</p><ul><li>三分查找是二分查找的扩展；</li><li>时间复杂度为 ： $O(nlog_3n)$.</li></ul><p><strong>[notice]:</strong> 虽然看似三分查找的时间复杂度比二分查找的时间复杂度小，但是<strong>在最坏情况下</strong>，二分查找需要$2Log_2n + 1$次比较，而三分查找需要$4Log_{3}n + 1$次比较</p><h4 id="三分查找原始抽象方法实现如下："><a href="#三分查找原始抽象方法实现如下：" class="headerlink" title="三分查找原始抽象方法实现如下："></a>三分查找原始抽象方法实现如下：</h4><p>特点：</p><ul><li>类似二分查找，将查找数组划分为三个部分来进行查找；</li><li>时间复杂度： $Log_3n$.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归实现.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ternarySearch</span><span class="params">(Comparable[] a, Comparable key, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (lo &lt;= hi) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid1 = lo + (hi - lo) / <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> mid2 = mid1 + (hi - lo) / <span class="number">3</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (a[mid1].compareTo(key) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> mid1;</span><br><span class="line">        <span class="keyword">if</span> (a[mid2].compareTo(key) == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> mid2;</span><br><span class="line">        <span class="comment">// 目标元素只可能出现在第一部分.</span></span><br><span class="line">        <span class="keyword">if</span> (a[mid1].compareTo(key) &gt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> ternarySearch(a, key, lo, mid1-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 目标元素只可能出现在第三部分.</span></span><br><span class="line">        <span class="keyword">if</span> (a[mid2].compareTo(key) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ternarySearch(a, key, mid2+<span class="number">1</span>, hi);</span><br><span class="line">        <span class="comment">// 目标元素只可能出现在第二部分.</span></span><br><span class="line">        <span class="keyword">return</span> ternarySearch(a, key, mid1+<span class="number">1</span>, mid2-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查找失败.</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="指数搜索-exponential-search"><a href="#指数搜索-exponential-search" class="headerlink" title="指数搜索 - exponential search"></a>指数搜索 - exponential search</h3><p>特点：</p><ul><li>找到目标元素可能出现的区间；</li><li>使用二分查找在区间上查找目标元素;</li><li>时间复杂度： $logn$;</li></ul><p><strong>[notice]</strong>:</p><ol><li>适用于目标数组元素大小趋向于无限大的情况；</li><li>当目标出现在目标数组左边时，指数搜索速度比二分查找快。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">exponentialSearch</span><span class="params">(Comparable[] a, Comparable key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n  = a.length;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n &amp;&amp; a[i].compareTo(key) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"> i = i * <span class="number">2</span>;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> binarySearch(a, key, i/<span class="number">2</span>, Math.min(i, n-<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插值搜索-interpolation-search"><a href="#插值搜索-interpolation-search" class="headerlink" title="插值搜索 - interpolation search"></a>插值搜索 - interpolation search</h3><p>特点：</p><ul><li><p>原理： 假设查找数组的元素是均匀分布的，使用<strong>直线插值搜索</strong>，不像二分查找那样每次都是搜索区间中间元素。它能够快速的接近目标元素。</p></li><li><p>当元素均匀分布的情况，时间复杂度为: $O(log(log n))$, 最坏情况: $O(n)$.</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java program to implement interpolatoin search.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">interpolationSearch</span><span class="params">(Comparable[] a, Comparable key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> lo = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> hi = a.length - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (lo &lt;= hi &amp;&amp; less(key, a[hi]) &amp;&amp; less(a[lo], key)) &#123;</span><br><span class="line">    <span class="keyword">int</span> pos = lo + (hi - lo) * (key - a[lo]) / (a[hi] - a[lo]);</span><br><span class="line">        <span class="keyword">if</span> (a[pos].compareTo(key) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> pos;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[pos].compareTo(key) &gt; <span class="number">0</span>)</span><br><span class="line">        hi = pos - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            lo = pos + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="NOTICE"><a href="#NOTICE" class="headerlink" title="NOTICE"></a>NOTICE</h3><p>本文中，涉及的算法详细实现和使用，请移步到github<a href="https://github.com/rovo98/ds-and-algs#searching-algorithms----go-back-to-top" target="_blank" rel="noopener">查看</a>。</p>]]></content>
    
    <summary type="html">
    
      使用java实现并简要分析抽象的基本静态查找算法。notes, learning from algs4.
    
    </summary>
    
      <category term="Algorithms" scheme="http://rovo98.github.io/categories/Algorithms/"/>
    
      <category term="searching algs" scheme="http://rovo98.github.io/categories/Algorithms/searching-algs/"/>
    
    
      <category term="basical searching algs" scheme="http://rovo98.github.io/tags/basical-searching-algs/"/>
    
  </entry>
  
  <entry>
    <title>快速排序 - quickSort</title>
    <link href="http://rovo98.github.io/posts/d9de8e4c/"/>
    <id>http://rovo98.github.io/posts/d9de8e4c/</id>
    <published>2018-03-05T16:00:00.000Z</published>
    <updated>2018-07-07T03:33:04.521Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>快速排序的主要特点是：</p><ol><li>原地排序 (in-place);</li><li>将长度为 N 的数组排序所需的时间和NlgN成正比；</li><li>排序内循环比大多数排序算法都要短小，意味着无论是在理论上还是实际中都要更快。</li></ol><p>缺点：<br>快速排序非常的脆弱，在实现时要非常小心才能避免低劣的性能。</p><h3 id="基本算法"><a href="#基本算法" class="headerlink" title="基本算法"></a>基本算法</h3><p>快速排序是一种<strong>分治</strong>排序算法，它将一个数组分成两个子数组，将两部分独立地排序。不同于归并排序，快速排序的递归调用发生在处理子数之前。</p><p>快速排序方法抽象实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Quick</span> </span>&#123;</span><br><span class="line"><span class="comment">// quick sort java implement.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">    sort(a, <span class="number">0</span>, a.length-<span class="number">1</span>);</span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">isSorted</span><span class="params">(a)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hi &lt;= lo)<span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> j = partition(a, lo, hi);</span><br><span class="line">        sort(a, lo, j-<span class="number">1</span>);</span><br><span class="line">        sort(a, j+<span class="number">1</span>, hi);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">partition</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = lo;</span><br><span class="line">        <span class="keyword">int</span> j = hi + <span class="number">1</span>;</span><br><span class="line">        Comparable v = a[lo];</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (less(a[++i], v)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lo == hi) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (less(v, a[--j])) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == lo) <span class="keyword">break</span>; <span class="comment">// redundant since a[lo] is sentinel.</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Check if pointers cross.</span></span><br><span class="line">            <span class="keyword">if</span> (j &lt;= i)<span class="keyword">break</span>;</span><br><span class="line">            exch(a, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        exch(a, lo, j);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述切分方法示意图: [from algs4]</p><p><img src="quickSort_partition_1.png" alt="切分示意图"></p><p>切分轨迹图: [from algs4]</p><p><img src="quickSort_partition_2.png" alt="切分轨迹图"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">命题 K： 将长度为N的无重复的数组排序，快速</span><br><span class="line">排序平均需要 ~2NlnN 次比较(以及1/6的交换)</span><br></pre></td></tr></table></figure><p><strong>[notice]</strong>: 尽管快速排序有很多优点，它的基本实现仍有一个潜在的缺点：</p><p>在切分不平衡时该算法可能及其低效。例如： 如果第一个次从最小的元素切分，第二次从第二小的元素切分，则这样每次只会移除一个元素。<br>[solution] : <strong>在快速排序之前将数组随机排序可以避免这种情况的发生</strong>。</p><h3 id="算法改进"><a href="#算法改进" class="headerlink" title="算法改进"></a>算法改进</h3><h4 id="1-切换到插入排序"><a href="#1-切换到插入排序" class="headerlink" title="1.切换到插入排序"></a>1.切换到插入排序</h4><p>和大多数递归排序算法一样(如归并)，改进快速排序的简单方法基于以下两点：</p><ul><li>对于小数组，快速排序比插入排序慢；</li><li>以为递归，快速排序的sort()方法在小数组中也会调用自己。</li></ul><p>改进 ： 将<strong>sort()方法</strong>中的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (hi &lt;= lo) <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><p>改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (hi &lt;= lo + M) &#123;</span><br><span class="line">insertion.sort(a, lo, hi);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[<strong>notice</strong>] : 这里的切换参数 M 的最佳值是和系统相关的，但是5 ~ 15 之间的任意值在大多数情况下都能令人满意。</p><h4 id="2-三取样切分"><a href="#2-三取样切分" class="headerlink" title="2. 三取样切分"></a>2. 三取样切分</h4><p>改进快速排序性能的第二个方法是<strong>使用子数组的一小部分的中位数来切分数组</strong>。这样的切分的效果更好，但代价是需要计算中位数。</p><ul><li>人们发现将取样设为 3 并用大小居中的元素切分效果<strong>最好</strong>； 我们还可以将取样元素放在数组末尾作为哨兵(sentinel)。</li></ul><p>三取样切分抽象实现 : <a href="https://github.com/rovo98/ds-and-algs/blob/master/ds/sorting/exercises/QuickSortImprovedTwo.java" target="_blank" rel="noopener">详细查看</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSortImproved</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">sort(a, <span class="number">0</span>, a.length-<span class="number">1</span>);</span><br><span class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">isSorted</span><span class="params">(a)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> staic <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">dealPivot(a, lo, hi);</span><br><span class="line">    <span class="keyword">int</span> i = lo;</span><br><span class="line">    <span class="keyword">int</span> j = hi - <span class="number">1</span>;</span><br><span class="line">    Comparable v = a[hi - <span class="number">1</span>]; <span class="comment">// set the  pivot at hi -1 as a sentinel.</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (less(a[++i], v)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == hi-<span class="number">1</span>) <span class="keyword">break</span>; <span class="comment">// redundant since a[hi - 1] is sentinel.</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; lo &amp;&amp; less(v, a[--j])) &#123;  &#125;</span><br><span class="line">        </span><br><span class="line">       <span class="comment">// check if pointers cross.</span></span><br><span class="line">        <span class="keyword">if</span> (j &lt;= i) <span class="keyword">break</span>;</span><br><span class="line">        exch(a, i, j);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (i &lt; hi-<span class="number">1</span>) &#123;</span><br><span class="line">   exch(a, i, hi - <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   sort(a, lo, i - <span class="number">1</span>);</span><br><span class="line">   sort(a, i + <span class="number">1</span>, hi);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 三取样并将切分元素放在数组末尾</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dealPivot</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (less(a[mid], a[lo]))</span><br><span class="line">    exch(a, lo, mid);</span><br><span class="line">    <span class="keyword">if</span> (less(a[hi], a[lo]))</span><br><span class="line">    exch(a, lo, hi);</span><br><span class="line">    <span class="keyword">if</span> (less(a[hi], a[mid]))</span><br><span class="line">    exch(a, mid, hi);</span><br><span class="line">    <span class="comment">// put the pivot to hi - 1 as a sentinel.</span></span><br><span class="line">    exch(a, mid, hi - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="熵最优的排序"><a href="#熵最优的排序" class="headerlink" title="熵最优的排序"></a>熵最优的排序</h4><p>实际应用中经常会出现含有大量重复元素的数组，我们实现的快速排序性能尚可，但是<strong>还有巨大的改进空间</strong>。例如：一个元素全部重复的子数组就不需要继续排序了，但我们的快速排序还是会继续将它切分为更小的数组。</p><p>[solution] : <strong>一个简单想法是将数组切分为三个部分，分别为小于、等于和大于切分元素的数组元素</strong>。</p><p>DIjkstra 解法 ： 从左到右遍历数组一次，维护一个指针 lt 使得 a[lo .. lt-1]中的元素都小于v, 一个 gt 使得a[gt+1 .. hi]中的元素都大于v, 一个指针 i 使得a[lt .. i-1]中的元素都等于v, a[i .. gt]中的元素都未确定。</p><ul><li>a[i] 小于 v, 将a[lt]和a[i]交换，将lt 和 i加一；</li><li>a[i] 大于 v, 将a[gt]和a[i]交换， 将gt减一；</li><li>a[i] 等于 v, i++.</li></ul><p>熵最优排序抽象实现： <a href="https://github.com/rovo98/ds-and-algs/blob/master/ds/sorting/exercises/Quick3Ways.java" target="_blank" rel="noopener">详细查看</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">sort(a, <span class="number">0</span>, a.length-<span class="number">1</span>);</span><br><span class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">isSorted</span><span class="params">(a)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (hi &lt;= lo) <span class="keyword">return</span>;</span><br><span class="line">    Comparable v = a[lo];</span><br><span class="line">    <span class="keyword">int</span> lt = lo;</span><br><span class="line">    <span class="keyword">int</span> i = lo + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> gt = hi;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (i &lt;= gt) &#123;</span><br><span class="line">    <span class="keyword">if</span> (less(a[i], v)) exch(a, i++,  lt++);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (less(v, a[i]))exch(a, gt--, i);</span><br><span class="line">        <span class="keyword">else</span> i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// since a[lt .. i-1] is sorted.</span></span><br><span class="line">    <span class="comment">// sort the other subarrays recursively.</span></span><br><span class="line">    sort(a, lo, lt-<span class="number">1</span>);</span><br><span class="line">    sort(a, gt+<span class="number">1</span>, hi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[notice] : <strong>三向切分的最坏情况是所有主键均不相同。</strong>对于标准的快速排序，随着数组规模的增大其运行时间会趋于平均时间，大幅偏离的情况是非常罕见的，因此可以肯定<strong>三向切分的快速排序运行时间和输入的信息量的N倍是成正比的。</strong> ———— 因为对于包含大量重复元素的数组，它将排序时间从线性对数级降到了线性级别。</p><h3 id="NOTICE"><a href="#NOTICE" class="headerlink" title="NOTICE"></a>NOTICE</h3><p>本文中，涉及的算法详细实现和使用，请移步到github<a href="https://github.com/rovo98/ds-and-algs#sorting-algorithms----go-back-to-top" target="_blank" rel="noopener">查看</a>。</p>]]></content>
    
    <summary type="html">
    
      快速排序 notes for algs4.
    
    </summary>
    
      <category term="Algorithms" scheme="http://rovo98.github.io/categories/Algorithms/"/>
    
      <category term="sorting algs" scheme="http://rovo98.github.io/categories/Algorithms/sorting-algs/"/>
    
    
      <category term="sorting algs" scheme="http://rovo98.github.io/tags/sorting-algs/"/>
    
  </entry>
  
  <entry>
    <title>归并排序 - mergeSort</title>
    <link href="http://rovo98.github.io/posts/1368334/"/>
    <id>http://rovo98.github.io/posts/1368334/</id>
    <published>2018-03-04T16:00:00.000Z</published>
    <updated>2018-07-05T14:50:09.234Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>归并排序属于<strong>分治算法(Divide and Conquer)</strong>。通过递归不断把待排序数组分成两个部分，将有序的两部分再重新归并一起来实现对数组的排序。</p><p><strong>[pseudo code for 2-way merge sort]</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MergeSort(arr[], aux[], lo, hi)</span><br><span class="line">If hi &gt; lo</span><br><span class="line">1. Find the middle point to divide the array into two halves;</span><br><span class="line">int mid = lo + (hi - lo) / 2;</span><br><span class="line">2. Call MergeSort for first half;</span><br><span class="line">MergeSort(arr, aux, lo, mid);</span><br><span class="line">3. Call MergeSort for second half;</span><br><span class="line">MergeSort(arr, aux, mid+1, hi);</span><br><span class="line">4. Merge the two halves sorted in step 2 and 3;</span><br><span class="line">Call merge(arr, aux, lo, mid, hi);</span><br></pre></td></tr></table></figure><h3 id="原地归并的抽象方法"><a href="#原地归并的抽象方法" class="headerlink" title="原地归并的抽象方法"></a>原地归并的抽象方法</h3><p>要实现上述的归并方法 — <strong>merge()</strong>很简单，创建一个数组将需要归并的<strong>原数组的两个部分</strong>中的元素放到这个数组中，然后再归并按大小顺序放回原数组。</p><blockquote><p>但是，这里我们要考虑一个问题，当我们用归并排序对一个比较大的数组进行排序时，我们需要进行很多次归并，因此在每一次归并时都创建一个新的数组来存储排序结果会带来问题。我们可以考虑只创建一个<strong>辅助数组aux[]</strong>, 在每一个归并时，将原数组需要归并的两个部分复制到aux[]中，再把归并结果放回原数组。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(Comparable[] a, Comparable[] aux, <span class="keyword">int</span> lo, <span class="keyword">int</span> mid, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line"><span class="comment">// precondition: a[lo .. mid] and a[mid+1 .. hi] is sorted.</span></span><br><span class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">isSorted</span><span class="params">(a, lo, mid)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">isSorted</span><span class="params">(a, mid+<span class="number">1</span>, hi)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// copy a[lo .. hi] to aux[lo .. hi].</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = lo; k &lt;= hi; k++) &#123;</span><br><span class="line">    aux[k] = a[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = lo;</span><br><span class="line">    <span class="keyword">int</span> j = mid+<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = lo; k &lt;= hi; k++) &#123;</span><br><span class="line">    <span class="keyword">if</span>      (i &gt; mid)               a[k] = aux[j++];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; hi)                a[k] = aux[i++];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (less(aux[j], aux[i]))  a[k] = aux[j++];</span><br><span class="line">        <span class="keyword">else</span>                a[k] = aux[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// postcondition: a[lo .. hi] is sorted.</span></span><br><span class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">isSorted</span><span class="params">(a, lo, hi)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[说明] : 该方法先将原数组两个需要归并的部分复制到aux[]中，然后<strong>从两个部分的起始位置开始取元素，一直选择两个部分中较小的元素放回原数组中，当有一部分元素取完了，则将另一部分剩余的元素全部放回原数组</strong>。</p><p>原地归并抽象方法轨迹： [from algs4]</p><p><img src="mergeSort_merge.png" alt="原地归并抽象方法轨迹"></p><h3 id="自顶向下的归并排序"><a href="#自顶向下的归并排序" class="headerlink" title="自顶向下的归并排序"></a>自顶向下的归并排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = a.length;</span><br><span class="line">    Comparable[] aux = <span class="keyword">new</span> Comparable[n];</span><br><span class="line">    sort(a, aux, <span class="number">0</span>, a.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, Comparable[] aux, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line"><span class="comment">// If array size is 1 then return.</span></span><br><span class="line"><span class="keyword">if</span> (hi &lt;= lo)    <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// Find the middle point to divide array into two halves.</span></span><br><span class="line">    <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// Call the mergeSort for first half.</span></span><br><span class="line">    sort(a, aux, lo, mid);</span><br><span class="line">    <span class="comment">// Call the mergeSort for second half.</span></span><br><span class="line">    sort(a, aux, mid+<span class="number">1</span>, hi);</span><br><span class="line">    <span class="comment">// Merge two halves sorted.</span></span><br><span class="line">    merge(a, aux, lo, mid, hi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自顶向下归并结果轨迹 : [from algs4]</p><p><img src="mergeSort_ubSort_1.png" alt="自顶向下归并结果轨迹"></p><p>自顶向下归并排序调用轨迹 : [from algs4]</p><p><img src="mergeSort_ubSort_2.png" alt="自顶向下归并排序调用轨迹"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">命题 F: 对于长度为 N 的任意数组， 自顶向下归并排序需要 1/2NlgN 至 NlgN 次比较。</span><br><span class="line"></span><br><span class="line">自顶向下的所需时间表达式为 : $T(N) = 2T(N/2) + O(n)$使用解决</span><br><span class="line">递归式的 Master method 解得 T(N) = $\Theta(n log n)$</span><br></pre></td></tr></table></figure><p>我们可以通过下图来理解命题F, 每个节点都表示一个sort()方法通过merge()方法归并而成的子数组。<strong>这棵树正好有 n 层。对于0 ~ n-1 之间的任意 k, 自顶向下的第 k 层有 $2^k$个子数组，每个数组长度为 $2^{n-k}$, 归并最多需要 $2^{n-k}$ 次比较。</strong>因此每层的比较次数为$2^k X 2^{n-k} = 2^n$, n 层总共为 $n2^n = NlgN$。</p><p>子数组树状图 : [from algs4]</p><p><img src="mergeSort_ubSort_3.png" alt="子数组树状图"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">命题 G : 对于长度为 N 的任意数组，自顶向下的归并排序最多需要</span><br><span class="line">访问数组 6NlgN 次。</span><br><span class="line"></span><br><span class="line">证明： 每次归并最多需要访问数组 6N 次（2N 次用来复制， 2N次</span><br><span class="line">用来将排好序的元素移动回去，另外最多比较2N次），根据命题F即</span><br><span class="line">可得到这个命题的结果。</span><br></pre></td></tr></table></figure><p><strong>[小结]</strong>: 归并排序排序算法的缺点是辅助数组所使用的额外空间和N的大小成正比。一些能够大幅度缩短归并排序的运行时间的想法：</p><ul><li>对小规模子数组进行插入排序；</li><li>测试数组是否已经有序；</li><li>不将元素复制到辅助数组中。</li></ul><h3 id="自底向上的归并排序"><a href="#自底向上的归并排序" class="headerlink" title="自底向上的归并排序"></a>自底向上的归并排序</h3><p>实现归并排序另外一种方法是<strong>先归并那些微型数组， 然后再成对归并得到的子数组，直到将整个数组归并在一起</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MergeBU</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = a.length;</span><br><span class="line">    Comparable[] aux = <span class="keyword">new</span> Comparable[n];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> sz = <span class="number">1</span>; sz &lt; n; sz += sz) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> lo = sz; lo &lt; n-sz; lo += sz+sz) &#123;</span><br><span class="line">        merge(a, aux, lo, lo+sz-<span class="number">1</span>, Math.min(lo+sz+sz-<span class="number">1</span>, n-<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#123;</span><br></pre></td></tr></table></figure><p>[注] : 自底向上的归并排序会多次遍历整个数组，根据子数组大小进行两两归并。子数组的大小 sz 的初始值为 1， 每次加倍。最后一个子数组的大小只有在数组大小是 sz 的偶数倍的时候才会等于 sz(否则它会比sz小)。</p><p>自底向上归并排序结果轨迹 ： [from algs4]</p><p><img src="mergeSort_buSort_1.png" alt="自底向上归并排序结果轨迹"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">命题 H : 对于长度为 N 的任意数组， 自底向上的归并排序需要 </span><br><span class="line">1/2NlgN 至 NlgN次比较，最多访问数组 6NlgN 次。</span><br><span class="line"></span><br><span class="line">证明 ： 处理一个数组的遍数正好是 [lgN] (即 2^n &lt;= N &lt;</span><br><span class="line">2^n+1 中的 n)。每一遍会访问数组6N次。</span><br><span class="line">比较次数在 N/2 和 N 之间。</span><br></pre></td></tr></table></figure><p>【补充】： 当数组长度为 2 的幂时，自顶向下和自底向上的归并排序所用的比较次数和数组访问次数正好相同，只是顺序不同。其他时候，两种方法的比较和数组访问的次序会有所不同。</p><h3 id="NOTICE"><a href="#NOTICE" class="headerlink" title="NOTICE"></a>NOTICE</h3><p>本文中，涉及的算法详细实现和使用，请移步到github<a href="https://github.com/rovo98/ds-and-algs#sorting-algorithms----go-back-to-top" target="_blank" rel="noopener">查看</a>。</p>]]></content>
    
    <summary type="html">
    
      归并排序 notes, learning from algs4.
    
    </summary>
    
      <category term="Algorithms" scheme="http://rovo98.github.io/categories/Algorithms/"/>
    
      <category term="sorting algs" scheme="http://rovo98.github.io/categories/Algorithms/sorting-algs/"/>
    
    
      <category term="sorting algs" scheme="http://rovo98.github.io/tags/sorting-algs/"/>
    
  </entry>
  
  <entry>
    <title>基本排序算法 - basial sorting algorithms with java implementation</title>
    <link href="http://rovo98.github.io/posts/57d02cec/"/>
    <id>http://rovo98.github.io/posts/57d02cec/</id>
    <published>2018-03-04T16:00:00.000Z</published>
    <updated>2018-07-05T14:49:04.204Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我们关注的主要对象是<strong>重新排列数组元素的算法</strong>， 其中每个元素都有一个<strong>主键</strong>。排序算法的目的就是将所有元素的主键按照某种方式排列(通常按照大小或是字母顺序)。</p></blockquote><a id="more"></a><p>在java中元素通常都是对象，对主键的抽象描述则是通过一种内置的机制(<code>Comparable</code>接口)来完成的。</p><h4 id="排序算法类模板"><a href="#排序算法类模板" class="headerlink" title="排序算法类模板"></a>排序算法类模板</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(Comparable[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    Comparable temp = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*排序算法，如InsertionSort、BubbleSort、</span></span><br><span class="line"><span class="comment">        SelectionSort、ShellSort等*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">        System.out.print(a[i] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(Comparable v, Comparable w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v.compareTo(w) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSorted</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (less(a[i], a[i-<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Unit tests the &#123;<span class="doctag">@code</span> Example&#125; sorting algorithm.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@args</span> command-line arguments.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 测试代码...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这个类展示的是数组排序实现的框架。代码中实现的排序方法适用于任意实现了<code>Comparable</code>接口的数据类型</strong>。</p><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>无论数组的初始状态是什么，我们都无法确保排序算法都能成功。所以谨慎起见，我们会在测试代码中添加一条语句<code>assert isSorted(a);</code>来确保排序后的数组都是有序的。</p><h4 id="运行时间"><a href="#运行时间" class="headerlink" title="运行时间"></a>运行时间</h4><p>评估算法的性能。首先，要计算各个排序算法在不同的随机输入下的基本操作的次数(包括比较和交换，或者是读写数组的次数)。</p><blockquote><p>排序成本模型 : 在研究排序算法时，我们需要计算比较和交换的数量。<br>对于不交换元素的算法，我们会计算访问数组的次数。</p></blockquote><h4 id="额外的内存使用"><a href="#额外的内存使用" class="headerlink" title="额外的内存使用"></a>额外的内存使用</h4><p>排序算法的额外内存开销和运行时间是同等重要的。排序算法可以分为两类:</p><ul><li>除了函数调用所需的栈和固定数目的实例变量之外无需额外内存的<strong>原地排序算法</strong>。</li><li>需要额外内存空间来存储另一份数组副本的其他排序算法。</li></ul><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p>上面的排序模板适用于实现了Comparable接口的数据类型。例如, java中封装数字类型的<code>Integer</code>、<code>Double</code>、以及<code>String</code>和其他许多高级数据类型。<br>而对于自己创建的数据类型，我们是要实现Comparable接口就能够保证能够使用排序算法进行排序。</p><p>自定义数据类型样例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Date</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Date</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> day;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> month;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> year;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Date</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> m, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123; day = d; month = m; year = y; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">day</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> day; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">month</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> month; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">year</span><span class="params">()</span>   </span>&#123; <span class="keyword">return</span> year;  &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Date that)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.year &gt; that.year) <span class="keyword">return</span> +<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.year &lt; that.year) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.month &gt; that.month) <span class="keyword">return</span> +<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.month &lt; that.month) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.day &gt; that.day) <span class="keyword">return</span> +<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.day &lt; that.day) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> month + <span class="string">"/"</span> + day + <span class="string">"/"</span> + year;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>首先，找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置(如果第一个元素就是最小的元素那么它就和自己交换)。 再次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到整个数组排序完成。<strong>不断地选择剩余元素中的最小者</strong>。</p><blockquote><p><strong>命题 A: 对于长度为 $N$ 的数组，选择排序需要大约 $N^2/2$ 次比较和 $N$ 次交换。</strong><br>证明： 可以通过算法的排序轨迹来证明，用一张$N X N$的表格来表示排序的轨迹，其中每个非灰色字符都表示一次比较。表格中大约有一半的元素不是 灰色的 — 即对角线和其上部分的元素。对角巷上的每个元素都对应真一次交换。通过查看代码我们可以更精确地得到，$0$ 到 $N-1$ 的任意 $i$ 都会 进行一次交换和 $N-1-i$ 次比较，因此 总共有$N$次交换以及 $(N-1)+（N-2)+…+2+1 = N(N-1)/2 ~ N^2/2$。</p></blockquote><p>算法轨迹图示（from algs4)：</p><p><img src="bs_selectionSort_1.png" alt="插入排序算法轨迹例子"></p><p>算法实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Selection</span> </span>&#123;</span><br><span class="line"><span class="comment">/* 其他的方法同排序算法模板*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = a.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> min = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (less(a[j], a[min]) &#123;</span><br><span class="line">                min = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            exch(a, i, min);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>与选择排序一样，当前索引左边的所有元素都是有序的，但他们的最终位置不确定，为了给更小的元素腾出空间，它们可能会移动。当索引到达数组的右端时，数组排序就完成了。</p><p>和选择排序不同的是，插入排序<strong>所需的时间取决于输入中元素的初始顺序</strong>。例如对于一个很大且其中的元素已经有序（或接近有序）的数组进行插入排序将会比对随机数组或逆序数组进行排序要快得多。</p><blockquote><p><strong>命题 B : 对于随机排列的长度为 $N$ 且主键不重复的数组, 平均情况下插入排序需要 ~ $N^2/4$次比较以及 $~N^2/4$次交换。最坏情况下需要 ~N^2 /2 次比较和 ~ $N^2/2$次交换，最好情况下需要$N-1$次比较和$0$次交换。</strong><br>证明： 和证明命题A一样，通过一个$N X N$的算法轨迹表可以很容易就得到交换和比较的次数。最坏的情况下对角线之下所有元素都需要移动位置，最 好情况下都不需要。对于随机排列的数组，在平均情况下每个元素都可能向后移动半个数组的长度 ，因此交换总数是对角线之下的元素总数的二分之。 比较的总次数是交换的次数加上一个额外的项，该项为 $N$ 减去被插入的元素正好是已知的最小 元 素的次数。在最坏情况下（逆序数组），这一 项相对于总数可以忽略不计；在最好的情况下（数组已经有序），这一项等于$N-1$。</p></blockquote><p>插入排序算法轨迹图示（from algs4):</p><p><img src="bs_insertionSort_1.png" alt="插入排序算法轨迹图例"></p><p>算法实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Insertion</span> </span>&#123;</span><br><span class="line"><span class="comment">/*其他的方法同排序算法模板*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = a.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j&gt;<span class="number">0</span>&amp;&amp;less(a[j], a[j-<span class="number">1</span>]; j--) &#123;</span><br><span class="line">            exch(a, j, j-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>附加：</strong></p><p>对于插入排序，我们要考虑的更一般情况是<strong>部分有序的数组</strong>。<br><strong>倒置</strong>指的是数组中的两个顺序颠倒的元素。比如EXAMPLE中有11对倒置：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">E-A  X-A  X-M  X-P  X-LX-E</span><br><span class="line">M-L M-E  P-L  P-E L-E</span><br></pre></td></tr></table></figure><p></p><p>如果数组中倒置的数量小于数组大小的某个倍数，那么我们说这个数组是<strong>部分有序</strong>的。<br>几种典型的部分有序的数组:</p><ul><li>数组中每个元素距离它的最终位置不远；</li><li>一个有序数组接一个小数组；</li><li>数组中只有几个元素位置不正确。</li></ul><p><strong>插入排序对这样的数组很有效，而选择排序则不然。当倒置的数量很少时，插入排序比大部分的其他排序算法都要快</strong>。</p><blockquote><p><strong>命题 C: 插入排序需要的交换的操作和数组的中倒置的数量相同，需要的比较次数大于等于倒置的数量，小于等于倒置的数量加上数组的大小再减一</strong>。<br>证明： 每次交换都改变了两个顺序颠倒的元素的位置，相当于减少了一对倒置，当倒置数量为0时，排序就完成了。每次交换都对应着一次比较，且$1$ 到$N -1$之间的每个$i$都可能需要一次额外的比较(在<code>a[i]</code>没有达到数组的左端时)。</p></blockquote><p><strong>[算法改进]</strong> : 大幅提高插入排序的速度，在内循环中将较大的元素都向右移动而不是总是交换两个元素(这样访问数组的次数就能减半)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = a.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    Comparable key = a[i];</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span> (j = i-<span class="number">1</span>; j &gt;= <span class="number">0</span>&amp;&amp;less(key, a[j]); j--) &#123;</span><br><span class="line">        a[j+<span class="number">1</span>] = a[j];</span><br><span class="line">        &#125;</span><br><span class="line">        a[j+<span class="number">1</span>] = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>希尔排序是基于插入排序的快速排序算法.<br>对于规模乱序数组插入排序很慢，因为它只会交换相邻的元素，因此元素只能一点一点地从数组的一端移动到另外一端。<br>希尔排序为了加快速度简单地改进了插入排序 —— 交换不相邻的元素以对数组的<strong>局部</strong>进行排序，并最终使用插入排序将局部有序的数组排序。</p><p><strong>希尔排序的思想</strong>:使任意间隔为h的元素都是有序的。<br>这样的数组称为<strong>h有序数组</strong>。对于任意以1为结尾的h序列（递增序列），我们使用它都能将数组排序。</p><p>算法实现： —— 使用的递增序列来自 algs4.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shell</span> </span>&#123;</span><br><span class="line"><span class="comment">/*其他排序算法方法同模板*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> n = a.length;</span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (h &lt; n/<span class="number">3</span>) h = <span class="number">3</span> * h + <span class="number">1</span>; <span class="comment">// 1， 4， 13， 40， 121， ...</span></span><br><span class="line">        <span class="keyword">while</span> (h &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= h&amp;&amp;less(a[j], a[j-h]); j -= h) &#123;</span><br><span class="line">                exch(a, j, j-h);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            h /= <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>[递增序列的选择]</strong> : 算法的性能不仅取决于h，还取决与h之间的数学性质。目前还没有人能证明某个递增序列是”最好的”。以上算法实现使用的递增序列（使用序列 $1/2(3^k-1)$,从N/3开始递减至1.）的计算和使用都很简单且和复杂的递增序列的性能接近。</p><p>算法轨迹图例 — example (from algs4):</p><p><img src="bs_shellSort_1.png" alt="希尔排序算法轨迹图例"></p><p><strong>实际应用</strong>: 对于中等大小的数组它的运行时间是可以接受的且它的代码量小，不需要额外的内存空间。<em>所以在面临一个排序问题而没有系统排序函数可用时，可先用希尔排序，然后再考虑是否将它替换为更加复杂的排序算法</em>。</p><p><strong>[算法改进]</strong> : 由于希尔排序是基于插入排序，所以我们可以参照插入排序的改进，对希尔排序进行改进 — 把内循环中较大的元素右移而不是交换两个元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = a.length;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (h &lt; n/<span class="number">3</span>) h = <span class="number">3</span> * h + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (h &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h; i &lt; n; i++) &#123;</span><br><span class="line">        Comparable key = a[i];</span><br><span class="line">            <span class="keyword">int</span> j;</span><br><span class="line">            <span class="keyword">for</span> (j = i-h; j &gt;= <span class="number">0</span>&amp;&amp;less(key, a[j]); j -= h) &#123;</span><br><span class="line">            a[j+h] = a[j];</span><br><span class="line">            &#125;</span><br><span class="line">            a[j+h] = key;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="附加-——-冒泡排序"><a href="#附加-——-冒泡排序" class="headerlink" title="附加 —— 冒泡排序"></a>附加 —— 冒泡排序</h3><p>冒泡排序相对比较简单，这里直接给出它的实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bubble</span> </span>&#123;</span><br><span class="line"><span class="comment">/*其他排序算法方法同排序算法模板*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">int</span> n = a.length;</span><br><span class="line"> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n&amp;&amp;flag == <span class="keyword">true</span>; i++) &#123;</span><br><span class="line"> flag = <span class="keyword">false</span>;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n-i; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (less(a[j+<span class="number">1</span>], a[j]) &#123;</span><br><span class="line">        exch(a, j+<span class="number">1</span>, j);</span><br><span class="line">           flag = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>算法分析</strong>: 对于冒泡排序，最坏情况下，算法需要进行N-1趟排序，总的数组元素比较的次数为$(N-1)+(N-2)+…+1$ ~ $N^2/2$， 总的交换次数为数组中<strong>倒置</strong>的数量。</p><h3 id="NOTICE"><a href="#NOTICE" class="headerlink" title="NOTICE"></a>NOTICE</h3><p>本文中，涉及的算法详细实现和使用，请移步到github<a href="https://github.com/rovo98/ds-and-algs#sorting-algorithms----go-back-to-top" target="_blank" rel="noopener">查看</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;我们关注的主要对象是&lt;strong&gt;重新排列数组元素的算法&lt;/strong&gt;， 其中每个元素都有一个&lt;strong&gt;主键&lt;/strong&gt;。排序算法的目的就是将所有元素的主键按照某种方式排列(通常按照大小或是字母顺序)。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Algorithms" scheme="http://rovo98.github.io/categories/Algorithms/"/>
    
      <category term="sorting algs" scheme="http://rovo98.github.io/categories/Algorithms/sorting-algs/"/>
    
    
      <category term="sorting algs" scheme="http://rovo98.github.io/tags/sorting-algs/"/>
    
  </entry>
  
  <entry>
    <title>概率论与数理统计 Chapter Two - 随机变量及其分布</title>
    <link href="http://rovo98.github.io/posts/19e3879c/"/>
    <id>http://rovo98.github.io/posts/19e3879c/</id>
    <published>2017-10-12T14:00:12.000Z</published>
    <updated>2018-07-13T13:57:34.509Z</updated>
    
    <content type="html"><![CDATA[<p>随机变量是概率论与数理统计研究的基本对象，它是定义在样本空间上的实函数.我们关心的是<strong>它取哪些值</strong>以及<strong>以怎样的概率取这些值</strong>，而分布函数完整地描述了随机变量取值的统计规律，且具有良好的分析性质，因此<strong>第二章 随机变量及其分布</strong>的主题是: <strong>求随机变量的分布函数</strong>.</p><a id="more"></a><p>下面我们围绕如下三个问题讨论:</p><ol><li>什么是随机变量?</li><li>何谓分布函数?</li><li>如何求分布?</li></ol><p><img src="xmind_2_structure.png" alt=""></p><h3 id="一、什么是随机变量？"><a href="#一、什么是随机变量？" class="headerlink" title="一、什么是随机变量？"></a>一、什么是随机变量？</h3><p>将随机试验的样本空间$\small\mathbf{\Omega}$中的每个样本点$\small\mathbf{\omega}$, 按照某种对应法则$\small\mathbf{X}$, 对应数轴上唯一确定的一个实数$\small\mathbf{X(\omega)}$, 则称$\small\mathbf{X = X(\omega) (\omega \in \Omega)}$为<strong>随机变量</strong>.</p><p><img src="random_val.png" alt=""></p><h3 id="二、何谓分布函数？"><a href="#二、何谓分布函数？" class="headerlink" title="二、何谓分布函数？"></a>二、何谓分布函数？</h3><h4 id="1-分布函数的定义"><a href="#1-分布函数的定义" class="headerlink" title="1.分布函数的定义"></a>1.分布函数的定义</h4><p>设$\small\mathbf{X}$为随机变量，对任意的$\small\mathbf{x \in (-\infty,+\infty)}$, 称$\small\mathbf{F(x) = P\{X \leq x\}}$为随机变量$\small\mathbf{X}$的分布函数.</p><h4 id="2-分布函数的性质"><a href="#2-分布函数的性质" class="headerlink" title="2.分布函数的性质"></a>2.分布函数的性质</h4><ol><li>$0 \leq F(x) \leq 1$;</li><li>$F(x)$为单调不减函数;</li><li>$F(x)$右连续;</li><li>$F(-\infty) = 0, F(+\infty) = 1$.</li></ol><h4 id="3-分布律-amp-概率密度"><a href="#3-分布律-amp-概率密度" class="headerlink" title="3. 分布律&amp;概率密度"></a>3. 分布律&amp;概率密度</h4><div class="table-container"><table><thead><tr><th style="text-align:center">离散型</th><th style="text-align:center">连续型</th></tr></thead><tbody><tr><td style="text-align:center"><table><tr><td>$X$</td><td>$x_1,x_2,...,x_n,...$</td></tr><tr><td>$p$</td><td>$p_1,p_2,...,p_n,...$</td></tr></table></td><td style="text-align:center">概率密度$f(x)$</td></tr><tr><td style="text-align:center">$F(x) = \sum_{x_k \leq x}p(x_k)$</td><td style="text-align:center">$F(x) = \lmoustache_{-\infty}^xf(t)dt$</td></tr><tr><td style="text-align:center">$0 \leq p_i \leq 1\\\sum_{i=1}^{+\infty}p_i = 1$</td><td style="text-align:center">$f(x) \geq 0\\\lmoustache_{-\infty}^{+\infty}f(x)dx = 1\\P\{a \lt X \leq b\} = \lmoustache_a^bf(x)dx\\F^{‘}(x) = f(x)$</td></tr></tbody></table></div><h4 id="4-八大分布"><a href="#4-八大分布" class="headerlink" title="4. 八大分布"></a>4. 八大分布</h4><h5 id="离散型"><a href="#离散型" class="headerlink" title="离散型"></a>离散型</h5><div class="table-container"><table><thead><tr><th style="text-align:center">离散型</th><th style="text-align:center">分布律</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><strong>0-1</strong>分布</td><td style="text-align:center">$P\{X = k\}=p^k(1-p)^{1-k}\\\qquad(k = 0,1)$</td><td style="text-align:center"><table><tr><td>$X$</td><td>$0\quad1$</td></tr><tr><td>$P$</td><td>$q\quad p$</td></tr></table></td></tr><tr><td style="text-align:center">二项分布</td><td style="text-align:center">$P\{X=k\}=C_n^kp^k(1-p)^{n-k}\\\qquad(k=0,1,…,n)$</td><td style="text-align:center">n重贝努利试验<br>$X\sim B(n,p)$</td></tr><tr><td style="text-align:center">泊松分布</td><td style="text-align:center">$P\{X=k\}=\frac{\lambda^k}{k!}e^{-\lambda}\\\quad(k=0,1,2,…)$</td><td style="text-align:center">单位时间人流数<br>$X\sim P(\lambda)/\pi(\lambda)$</td></tr><tr><td style="text-align:center">几何分布</td><td style="text-align:center">$P\{X=k\}=p(1-p)^{k-1}\\\qquad(k=1,2,…)$</td><td style="text-align:center">等待型分布<br>$X\sim G(p)$</td></tr><tr><td style="text-align:center">超几何分布</td><td style="text-align:center">$P\{X=k\}=C^k_MC^{n-k}_{N-M}/C_N^n\\\quad(k=0,1,2,…,min\{n,M\})$</td><td style="text-align:center">从$\small{N}$件产品中任取n件<br>, 抽到k件次品的概率</td></tr></tbody></table></div><h5 id="连续型"><a href="#连续型" class="headerlink" title="连续型"></a>连续型</h5><p><strong>(1)均匀分布</strong>：设随机变量$\small\mathbf{X}$的概率密度为<br><br>$\displaystyle \mathbf{f(x)} = \left\{\begin{array}{cc}\displaystyle\mathbf{\frac{1}{b-a},\qquad x\in (a,b)}\\\displaystyle\mathbf{<br>0,\qquad\qquad 其它}\end{array}\right.$<br><br>则称$\small\mathbf{X}$在$\small\mathbf{(a,b)}$内服从均匀分布，记为$\small\mathbf{X\sim U(a,b)}$,其分布函数为<br><br>$\displaystyle\mathbf{F(x)=\left\{\begin{array}{cc}\mathbf{0,\qquad x \lt a}\\<br>\mathbf{\frac{x-a}{b-a},\quad a\leq x\lt b}\\<br>\mathbf{1,\qquad x\geq b}\end{array}\right.}$</p><p><strong>(2)指数分布</strong>: 设随机变量$\small\mathbf{X}$的概率密度为<br><br>$\displaystyle\mathbf{f(x)=\left\{\begin{array}{cc}<br>\mathbf{\lambda e^{-\lambda x},\qquad x \gt 0}\\<br>\mathbf{0,\qquad\qquad 其它}\end{array}\right.}\quad\mathbf{(\lambda \gt 0)}$<br><br>则称$\small\mathbf{X}$服从参数为$\small\mathbf{\lambda}$的指数分布，记为$\small\mathbf{X\sim E(\lambda)}$, 其分布函数为<br><br>$\displaystyle\mathbf{F(x)}=\left\{\begin{array}{cc}<br>\mathbf{1-e^{-\lambda x},\qquad x \geq 0}\\<br>\mathbf{0,\qquad\qquad\quad 其它}\end{array}\right.$</p><p><strong>[注]</strong>:指数分布具有<strong>无记忆性</strong>，即<br><br>$\qquad P\{X\gt a+b|x\gt a\} = P\{X\gt b\}$</p><p><strong>(3)正态分布</strong>: 设随机变量$\small\mathbf{X}$的概率密度为<br><br>$\large\mathbf{\quad f(x)=\frac{1}{\sqrt{2\pi \sigma}}e^{\frac{(x-\mu)^2}{2\sigma^2}}\quad(\sigma\gt 0,x\in (-\infty,+\infty)}$<br><br>则称$\small\mathbf{X}$服从正态分布，记为$\small\mathbf{X\sim N(\mu,\sigma^2)}$.<br><br>特别地，当$\small\mathbf{\mu=0,\sigma=1}$时，称$\small\mathbf{X}$服从标准正太分布，其概率密度为<br><br>$\displaystyle\mathbf{\quad\varphi(x)=\frac{1}{\sqrt{2\pi}}e^{-\frac{x^2}{2}}\qquad x\in(-\infty,+\infty)}$</p><p><strong>[注记]</strong>：</p><ol><li>$\mathbf{\Phi(0)=1/2}$;</li><li>$\mathbf{\Phi(-a)=1-\Phi(a)}$;</li><li>$\mathbf{P\{X\leq \mu\}=P\{X\gt \mu\}=1/2}$;</li><li>若$\mathbf{X\sim N(\mu,\sigma^2)}$,则$\displaystyle\mathbf{F(x)=\Phi\lgroup\frac{x-\mu}{\sigma}\rgroup},$<br><br>$\displaystyle\mathbf{P\{a\lt X\leq b\}=F(b)-F(a)\\\qquad\qquad\qquad=\Phi\lgroup\frac{b-\mu}{\sigma}\rgroup}-\Phi\lgroup\frac{a-\mu}{\sigma}\rgroup$</li><li>若$\mathbf{X\sim N(\mu,\sigma^2)}$, 则$\displaystyle\mathbf{\frac{x-\mu}{\sigma}\sim N(0,1)}.$</li></ol><h3 id="三、如何求分布？"><a href="#三、如何求分布？" class="headerlink" title="三、如何求分布？"></a>三、如何求分布？</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;随机变量是概率论与数理统计研究的基本对象，它是定义在样本空间上的实函数.我们关心的是&lt;strong&gt;它取哪些值&lt;/strong&gt;以及&lt;strong&gt;以怎样的概率取这些值&lt;/strong&gt;，而分布函数完整地描述了随机变量取值的统计规律，且具有良好的分析性质，因此&lt;strong&gt;第二章 随机变量及其分布&lt;/strong&gt;的主题是: &lt;strong&gt;求随机变量的分布函数&lt;/strong&gt;.&lt;/p&gt;
    
    </summary>
    
      <category term="数学学习" scheme="http://rovo98.github.io/categories/%E6%95%B0%E5%AD%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="概率论与数理统计" scheme="http://rovo98.github.io/categories/%E6%95%B0%E5%AD%A6%E5%AD%A6%E4%B9%A0/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/"/>
    
    
      <category term="学习笔记" scheme="http://rovo98.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="概率论" scheme="http://rovo98.github.io/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>概率论与数理统计 Chapter One - 随机事件与概率</title>
    <link href="http://rovo98.github.io/posts/76a9cf42/"/>
    <id>http://rovo98.github.io/posts/76a9cf42/</id>
    <published>2017-10-12T07:15:20.000Z</published>
    <updated>2018-07-13T04:07:48.331Z</updated>
    
    <content type="html"><![CDATA[<p>《概率论与数理统计》是利用微积分为工具，研究随机现象的统计规律性！而第一章 <strong>随机事件和概率</strong>是整个概率论和数理统计的工具和基础，必须踏实地学好！这一章的中心主题是: <strong>求事件的概率</strong>。</p><a id="more"></a><p>下面将围绕如下三个问题讨论:</p><ol><li>什么是事件?</li><li>何谓概率？</li><li>如何求概率？</li></ol><p><img src="xmind_1_structure.png" alt=""></p><h3 id="什么是事件？"><a href="#什么是事件？" class="headerlink" title="什么是事件？"></a>什么是事件？</h3><h4 id="1-随机试验"><a href="#1-随机试验" class="headerlink" title="1.随机试验"></a>1.随机试验</h4><p>称满足如下三个条件的试验为<strong>随机试验</strong>，简称试验:</p><ol><li>相同条件下可重复；</li><li>所有基本结果确定；</li><li>试验前结果未知.</li></ol><h4 id="2-样本空间"><a href="#2-样本空间" class="headerlink" title="2.样本空间"></a>2.样本空间</h4><p>随机试验$\mathbf{E}$的所有可能的基本结果构成的集合称为$\mathbf{E}$的<strong>样本空间</strong>，记作$\mathbf{\Omega}$.</p><p>每一个基本结果称为<strong>样本点</strong>，记作$\mathbf{\omega}$.</p><h4 id="3-随机事件"><a href="#3-随机事件" class="headerlink" title="3.随机事件"></a>3.随机事件</h4><p>样本空间$\mathbf{\Omega}$的子集称为<strong>随机事件</strong>.</p><p>$\mathbf{\Omega}$ : 必然事件</p><p>$\mathbf{\emptyset}$ : 不可能事件</p><h4 id="4-事件的运算"><a href="#4-事件的运算" class="headerlink" title="4.事件的运算"></a>4.事件的运算</h4><div class="table-container"><table><thead><tr><th style="text-align:center">运算</th><th style="text-align:center">符号</th></tr></thead><tbody><tr><td style="text-align:center">和(并)</td><td style="text-align:center">$A + B$或$A \cup B$</td></tr><tr><td style="text-align:center">积(交)</td><td style="text-align:center">$AB$或$A \cap B$</td></tr><tr><td style="text-align:center">差</td><td style="text-align:center">$A - B$</td></tr><tr><td style="text-align:center">逆(补)</td><td style="text-align:center">$\bar{A}$</td></tr></tbody></table></div><h4 id="5-事件的关系"><a href="#5-事件的关系" class="headerlink" title="5. 事件的关系"></a>5. 事件的关系</h4><div class="table-container"><table><thead><tr><th style="text-align:center">关系</th><th style="text-align:center">符号</th></tr></thead><tbody><tr><td style="text-align:center">包含</td><td style="text-align:center">$A \supset B$</td></tr><tr><td style="text-align:center">相等</td><td style="text-align:center">$A = B$</td></tr><tr><td style="text-align:center">互斥(不相容)</td><td style="text-align:center">$AB = \emptyset$</td></tr><tr><td style="text-align:center">对立</td><td style="text-align:center">$AB = \emptyset且A + B = \Omega$</td></tr></tbody></table></div><h4 id="6-事件运算的性质"><a href="#6-事件运算的性质" class="headerlink" title="6.事件运算的性质"></a>6.事件运算的性质</h4><p>德摩根律 ： $\mathbf{\overline{A + B} = \bar{A}\bar{B}, \overline{AB} = \bar{A} + \bar{B}}.$</p><h3 id="何谓概率？"><a href="#何谓概率？" class="headerlink" title="何谓概率？"></a>何谓概率？</h3><h4 id="1-概率的公理化定义"><a href="#1-概率的公理化定义" class="headerlink" title="1.概率的公理化定义"></a>1.概率的公理化定义</h4><p>设$\mathbf{E}$为随机试验，$\mathbf{\Omega}$为样本空间，称随机事件函数$\small \mathbf{P(x)}$为概率，若$\small \mathbf{P(x)}$满足:</p><ol><li><strong>非负性</strong> : $\small \mathbf{P(A) \ge 0}$,对于任意的事件$\small \mathbf{A}$;</li><li><strong>规范性</strong> : $\small \mathbf{P(\Omega) = 1}$;</li><li><strong>可列可加性</strong> : 设$\small \mathbf{A_1,A_2,…,A_n,…}$为两两互斥事件，<br><br>$\small \mathbf{P(A_1 + A_2 + … + A_n + …) = P(A_1) + P(A_2) + … + P(A_n)} $</li></ol><h4 id="2-概率的性质"><a href="#2-概率的性质" class="headerlink" title="2.概率的性质"></a>2.概率的性质</h4><ol><li>$P(\emptyset) = 0$;</li><li>$设A_1,A_2,A_3,…,A_n为两两互斥事件，P(A_1 + A_2 + A_3 + … + A_n)\\= P(A_1) + P(A_2) + P(A_3) + … + P(A_n);$</li><li>$0 \le P(A) \le 1, 对于任意事件A$;</li><li>$P(\bar{A}) = 1 - P(A)$;</li><li>$若A \subset B, 则 P(A) \le P(B)$.</li></ol><h4 id="3-条件概率-amp-事件的独立性"><a href="#3-条件概率-amp-事件的独立性" class="headerlink" title="3.条件概率&amp;事件的独立性"></a>3.条件概率&amp;事件的独立性</h4><h5 id="1-条件概率"><a href="#1-条件概率" class="headerlink" title="1.条件概率"></a>1.条件概率</h5><p>设$P(A) \gt 0$, 则在事件$A$发生的条件下，事件$B$发生的概率定义为:<br><br>$\qquad \qquad \qquad \qquad \displaystyle P(B|A) \triangleq \frac{P(AB)}{P(A)}$</p><p><strong>条件概率$\displaystyle P(x|A)$也是概率，因此具有概率的所有性质</strong>，比如：</p><p>$\qquad P(B+C|A) = P(B|A) + P(C|A) - P(BC|A)$<br><br>$\qquad \displaystyle P(\bar{B}|A) = 1 - P(B|A)$<br><br>$\qquad \displaystyle P(B-C|A) = P(B|A) - P(BC|A)$</p><h5 id="2-事件的独立性"><a href="#2-事件的独立性" class="headerlink" title="2.事件的独立性"></a>2.事件的独立性</h5><p>若$\small \mathbf{P(AB) = P(A) P(B)}$, 则称事件$\small \mathbf{A, B}$相互独立.<br><br>若$\left\{ \begin{array}{rcl} \small \mathbf{P(AB) = P(A)P(B)}\\<br>\small \mathbf{P(BC) = P(B)P(C)}\\<br>\small \mathbf{P(AC) = P(A)P(C)}\\<br>\small \mathbf{P(ABC) = P(A)P(B)P(C)}\end{array}\right.$,则称事件$\small \mathbf{A,B,C}$相互独立.</p><p><strong>[注]</strong><br></p><ol><li>三个事件两两独立，则三个事件不一定相互独立;</li><li>若$\small \mathbf{A,B}$相互独立，则$\small \mathbf{\bar{A},B; A,\bar{B}; \bar{A},\bar{B}}$都相互独立;</li><li>若$\small \mathbf{ P(A)= 0}$或$\small \mathbf{P(A) = 1}$, 则事件$\small \mathbf{A}$与任意事件独立;</li><li>事件独立的等价条件<br><ol><li>设$\small \mathbf{P(A) = 0}$,则$\small \mathbf{A,B}$独立的充要条件为:$\small \mathbf{P(B|A) = P(B)}$.<br></li><li>设$\small \mathbf{0 \lt P(A) \lt 1}$, 则$\small \mathbf{A, B}$独立的充要条件为:$\small \mathbf{P(B|A) = P(B|\bar{A})}$.</li></ol></li><li>互斥、对立&amp;独立事件的比较<br><div style="text-align:center"><table><tr bgcolor="#949494" style="font-weight:700"><td>事件</td><td>定义</td><td>概率性质</td></tr><tr><td>互斥</td><td>$\small \mathbf{AB = \emptyset}$</td><td>$\small \mathbf{P(A+B) = P(A) + P(B)}$</td></tr><tr><td>对立</td><td>$\small \mathbf{AB = \emptyset}$且$\small \mathbf{A+B = \Omega}$</td><td>$\small \mathbf{P(B) = 1 - P(A)}$</td></tr><tr><td>独立</td><td colspan="2">$\small \mathbf{P(AB) = P(A)P(B)}$</td></tr></table></div></li></ol><h3 id="如何求概率？"><a href="#如何求概率？" class="headerlink" title="如何求概率？"></a>如何求概率？</h3><h4 id="1-古典概型"><a href="#1-古典概型" class="headerlink" title="1.古典概型"></a>1.古典概型</h4><p>样本空间$\small \mathbf{\Omega}$<strong>有限</strong>且每个基本结果等可能发生.则随机事件$\small \mathbf{A}$的概率为:<br><br>$\displaystyle \quad \mathbf{P(A) = \frac{k}{n}}$<br><br>其中，$\small \mathbf{n}$为样本空间$\small \mathbf{\Omega}$的样本点总数，<strong>k</strong>为随机事件$\small \mathbf{A}$中样本点的总数.</p><h4 id="2-几何概型"><a href="#2-几何概型" class="headerlink" title="2.几何概型"></a>2.几何概型</h4><p>样本空间$\small \mathbf{\Omega}$<strong>无限</strong>且每个基本结果等可能发生.则随机事件$\small \mathbf{A}$的概率为:<br><br>$\displaystyle \quad \mathbf{P(A) = \frac{A的几何度量}{\Omega的几何度量}}$</p><h4 id="3-贝努利概型"><a href="#3-贝努利概型" class="headerlink" title="3.贝努利概型"></a>3.贝努利概型</h4><p>若随机试验$\mathbf{E}$满足:<br></p><ol><li>每次试验只有两种可能结果({$\small \mathbf{A, \bar{A}}$)；</li><li>概率不发生变化($\small \mathbf{P(A) = p}$);</li><li>各次试验相互独立.</li></ol><p>试验$\mathbf{E}$重复<strong>n</strong>次，则称这样的试验为<strong>n</strong>重贝努利试验，事件$\small \mathbf{A}$发生<strong>k</strong>次的概率为:<br><br>$\quad \displaystyle \mathbf{P_n(k) = C^k_np^k(1-p)^{n-k}}$</p><h4 id="4-五大公式"><a href="#4-五大公式" class="headerlink" title="4.五大公式"></a>4.五大公式</h4><h5 id="1-加法公式"><a href="#1-加法公式" class="headerlink" title="1.加法公式"></a>1.加法公式</h5><p>$\displaystyle \mathbf{P(A+B) = P(A) + P(B) - P(AB)\\P(A+B+C) = P(A) + P(B)+P(C)\\ \qquad\qquad\qquad\qquad-P(AC)-P(BC)-P(AB)+P(ABC)}$.</p><h5 id="2-减法公式"><a href="#2-减法公式" class="headerlink" title="2.减法公式"></a>2.减法公式</h5><p>$\displaystyle \mathbf{P(A-B) = P(A) - P(AB) = P(A\bar{B})}$</p><h5 id="3-乘法公式"><a href="#3-乘法公式" class="headerlink" title="3.乘法公式"></a>3.乘法公式</h5><p>$\displaystyle \mathbf{P(AB) = P(A)P(B|A) = P(B)P(A|B)\\P(ABC) = P(A)P(B|A)P(C|AB)}$</p><h5 id="4-全概率公式"><a href="#4-全概率公式" class="headerlink" title="4.全概率公式"></a>4.全概率公式</h5><p>设$\small \mathbf{A_1,A_2,…,A_n}$为两两互斥，且$\small \mathbf{A_1+A_2+…+A_n = \Omega}$(称$\small \mathbf{A_1,A_2,…,A_n}$为<strong>完备事件组</strong>)，则<br><br>$\displaystyle\mathbf{P(B) = P(A_1)P(B|A_1)+P(A_2)P(B|A_2)\\<br>\qquad\qquad+…+P(A_n)P(B|A_n)}$</p><h5 id="5-贝叶斯公式"><a href="#5-贝叶斯公式" class="headerlink" title="5.贝叶斯公式"></a>5.贝叶斯公式</h5><p>设$\small \mathbf{A_1,A_2,…,A_n}$为完备事件组，则<br><br>$\displaystyle \mathbf{P(A_k|B) = \frac{P(A_k)P(B|A_k)}{\sum_{i=1}^nP(A_i)P(B|A_i)}}$</p><p><strong>[注]</strong>:<br><br>$\mathbf{P(AB)} = \left\{ \begin{array}{cc} \small \mathbf{P(A)P(B|A)\qquad\qquad\qquad\quad P(A) \gt 0}\\<br>\small \mathbf{P(B)P(A|B)\qquad\qquad\qquad\quad P(B) \gt 0}\\<br>\small \mathbf{P(A)P(B)\qquad\qquad\qquad\qquad A,B}\normalsize\mathbf{独立}\\<br>\small \mathbf{0\qquad\qquad\qquad\qquad\qquad\qquad}\normalsize\mathbf{互斥}\\<br>\small \mathbf{P(B)\qquad\qquad\qquad\qquad\qquad A \subset B}\\<br>\small \mathbf{P(A)+P(B)-P(A+B)\qquad}\normalsize\mathbf{加法公式}\end{array}\right.$</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《概率论与数理统计》是利用微积分为工具，研究随机现象的统计规律性！而第一章 &lt;strong&gt;随机事件和概率&lt;/strong&gt;是整个概率论和数理统计的工具和基础，必须踏实地学好！这一章的中心主题是: &lt;strong&gt;求事件的概率&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="数学学习" scheme="http://rovo98.github.io/categories/%E6%95%B0%E5%AD%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="概率论与数理统计" scheme="http://rovo98.github.io/categories/%E6%95%B0%E5%AD%A6%E5%AD%A6%E4%B9%A0/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/"/>
    
    
      <category term="学习笔记" scheme="http://rovo98.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="概率论" scheme="http://rovo98.github.io/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>jsp基础学习</title>
    <link href="http://rovo98.github.io/posts/67d7cfb7/"/>
    <id>http://rovo98.github.io/posts/67d7cfb7/</id>
    <published>2017-10-12T03:40:34.000Z</published>
    <updated>2018-07-20T12:01:08.360Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/jsp基础学习/JSP.png" alt=""></p><p>Java 服务器页面(jsp) 是用来开发动态页面的一项技术。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>JSP 允许开发人员使用指定的 JSP 标签来向html页面中插入java源代码，标签通常是<strong>以 <code>&lt;%</code> 开头并以 <code>%&gt;</code></strong> 结束。</p><h3 id="为什么使用-JSP？"><a href="#为什么使用-JSP？" class="headerlink" title="为什么使用 JSP？"></a>为什么使用 JSP？</h3><p>使用Java服务器页面(jsp)与使用实现 Common Gateway Interface(<a href="https://baike.baidu.com/item/CGI/607810" target="_blank" rel="noopener">CGI</a>)的程序目的是大致相同的。但对比CGI，jsp有以下优点：</p><ol><li>性能较好。因为JSP允许直接在html页面中嵌入动态元素，而不需要独立持有CGI文件；</li><li>JSP在服务器处理前都会进行预编译，不像 CGI/<a href="https://baike.baidu.com/item/perl" target="_blank" rel="noopener">Perl</a>, 每次页面被请求时，服务器都需要加在一个解释器(interperter) 以及目标脚本(target script);</li><li>JSP是基于 Java Servlets API 构建的，因此，和Servlets一样，JSP也可以使用这些强大的Enterprise Java API, ：<code>JDBC</code>, <code>JNDI</code>, <code>EJB</code>, <code>JAXP</code>, 等等**；</li><li><strong>JSP 页面可以和处理业务逻辑的servlets结合使用</strong>，该模型由<code>java servlet</code> 模板引擎提供支持。</li></ol><p>最后，JSP是JavaEE(企业级应用程序的完整平台)的一个组成部分。这意味着JSP可以在最简单的应用程序中扮演最复杂和最苛刻的角色。</p><h3 id="使用JSP的优势"><a href="#使用JSP的优势" class="headerlink" title="使用JSP的优势"></a>使用JSP的优势</h3><p>下面通过对比不同的技术来体现使用JSP的优点：</p><h4 id="vs-Active-Server-Pages-ASP"><a href="#vs-Active-Server-Pages-ASP" class="headerlink" title="vs. Active Server Pages (ASP)"></a>vs. Active Server Pages (ASP)</h4><p>对比<a href="https://baike.baidu.com/item/asp/128906" target="_blank" rel="noopener">ASP</a>, JSP有两大优点：第一是页面的动态部分是用java写的，而不是Visual Basic或其他MS特定的语言编写，所以它更强有力且易于使用；第二是它可以移植到其他的操作系统和非Microsoft的Web 服务器上，这使它更加健壮。</p><h4 id="vs-Pure-Servets（纯Servlets"><a href="#vs-Pure-Servets（纯Servlets" class="headerlink" title="vs. Pure Servets（纯Servlets)"></a>vs. Pure Servets（纯Servlets)</h4><p>使用JSP可以更容易编写和修改常规的html代码，而不是使用大量的 <strong>println</strong>语句来生成HTML。</p><h4 id="vs-Server-Side-Includes-SSI"><a href="#vs-Server-Side-Includes-SSI" class="headerlink" title="vs. Server-Side Includes (SSI)"></a>vs. Server-Side Includes (<a href="https://baike.baidu.com/item/SSI" target="_blank" rel="noopener">SSI</a>)</h4><p>SSI 实际上只适用于处理简单内容的程序，而不适用于使用表单数据，进行数据库连接等的程序。</p><h4 id="vs-Javascript"><a href="#vs-Javascript" class="headerlink" title="vs. Javascript"></a>vs. Javascript</h4><p>JavaScript 可以在客户端生成HTML，但很难和Web 服务器实现复杂任务的交互，例如：数据库访问以及图像处理等。</p><h4 id="vs-静态HTML"><a href="#vs-静态HTML" class="headerlink" title="vs. 静态HTML"></a>vs. 静态HTML</h4><p>常规的HTML不能包含动态的内容，无法动态地改变页面展示的数据。</p><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>Web服务器需要<code>JSP</code>引擎（容器）才能处理<code>JSP</code>页面。<code>JSP</code>容器负责拦截<code>JSP</code>页面的请求。<code>JSP</code>容器和Web服务器一起可以为<code>JSP</code>提供运行环境和其他服务。使服务器可以识别<code>JSP</code>中的特殊元素。</p><p>下面展示的是<code>JSP</code>容器和<code>JSP</code>文件在Web应用程序中的位置：</p><p><img src="jsp-arch.jpg" alt=""></p><h3 id="JSP处理过程"><a href="#JSP处理过程" class="headerlink" title="JSP处理过程"></a>JSP处理过程</h3><p>下面的步骤是Web服务器处理<code>JSP</code>生成Web页面的过程：</p><ul><li>和普通的页面一样，客户端的浏览器会向Web服务器发起一个<code>HTTP</code>请求。</li><li>Web服务器识别出该<code>HTTP</code>请求是<code>JSP</code>请求，然后将请求转发给<code>JSP</code>引擎处理。即请求链接是以<code>.jsp</code>结尾的URL。</li><li><code>JSP</code>引擎从硬盘中加载<code>JSP</code>页面并将它转换为<code>Servlet</code>文件。该转换过程非常简单，将所有的模板内容都转换为<code>println()</code>语句，所有的<code>JSP</code>元素都转换为Java代码。这些Java代码实现了页面中的动态行为。</li><li><code>JSP</code>引擎将<code>Servlet</code>文件编译成可执行<code>class</code>文件，并将原始请求转发给<code>servlet</code>引擎。</li><li><code>Servlet</code>引擎加载<code>Servlet</code>class文件并执行。执行期间，生成<code>HTML</code>文件并放在<code>HTTP response</code>中，随后通过<code>servlet</code>引擎移交给Web服务器。</li><li>Web服务器将包含静态<code>HTML</code>内容的<code>HTTP</code>响应转发到客户端浏览器。</li><li>最后，客户端浏览器<code>HTTP</code>响应中由服务器动态生成的静态<code>HTML</code>内容。</li></ul><p>以上的步骤的流程图示：</p><p><img src="jsp-processing.jpg" alt=""></p><p>通常，<code>JSP</code>引擎会检查<code>JSP</code>文件对应的<code>Servlet</code>文件是否已经存在，若是，如果<code>JSP</code>文件的修改日期旧于对应的<code>Servlet</code>文件，<code>JSP</code>引擎则认为<code>JSP</code>没有改变且已经的生成的<code>Servlet</code>文件仍然匹配<code>JSP</code>文件的内容。这中处理使得<code>JSP</code>的处理和运行速度比其他的脚本语言(如：<code>PHP</code>）更高效、更快。</p><p>其实，<code>JSP</code>页面是编写<code>servlet</code>的另外一种方式，不需要Java编程。除了上述的<code>JSP</code>处理过程中的翻译转换过程，<code>JSP</code>和一般的<code>servlet</code>处理方式一样。</p><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>理解<code>JSP</code>低级功能的关键就是简单了解<code>JSP</code>的生命周期。<code>JSP</code>的生命周期就是<code>jsp</code>从创建到销毁的过程。该过程与<code>servlet</code>的生命周期类似，不过多了一个将<code>JSP</code>编译转换为<code>servlet</code>文件的步骤。</p><h3 id="JSP遵循的过程"><a href="#JSP遵循的过程" class="headerlink" title="JSP遵循的过程"></a>JSP遵循的过程</h3><ul><li>编译 (Compilation)</li><li>初始化 (Initialization)</li><li>执行 (Execution)</li><li>销毁 (Cleanup)</li></ul><p><code>JSP</code>生命周期的四个主要阶段：</p><p><img src="jsp_life_cycle.jpg" alt=""></p><h3 id="JSP编译阶段"><a href="#JSP编译阶段" class="headerlink" title="JSP编译阶段"></a>JSP编译阶段</h3><p>当浏览器请求<code>JSP</code>页面时，<code>JSP</code>引擎首先检查是否需要编译该<code>JSP</code>页面。如果页面还为编译过，或者<code>JSP</code>文件被修改，<code>JSP</code>引擎就编译该页面。</p><p>编译阶段包含下面三个步骤：</p><ul><li>解析JSP页面</li><li>将<code>JSP</code>转换为<code>servlet</code></li><li>编译<code>servlet</code>为<code>class</code>文件</li></ul><h3 id="JSP初始化阶段"><a href="#JSP初始化阶段" class="headerlink" title="JSP初始化阶段"></a>JSP初始化阶段</h3><p>当<code>JSP</code>容器加载<code>JSP</code>时，它会在处理任何请求之前调用<code>jspInit()</code>方法。如果需要执行特定的<code>JSP</code>初始化，直接覆盖<code>jspInit()</code>方法就行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jspInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// Initialization code...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常，和<code>servlet</code>的<code>init()</code>方法一样，该初始化方法只执行一次，一般是初始化数据库连接，打开文件和创建查找表格(look-up table)。</p><h3 id="JSP执行阶段"><a href="#JSP执行阶段" class="headerlink" title="JSP执行阶段"></a>JSP执行阶段</h3><p>这一阶段表示在销毁<code>JSP</code>之前与请求的所有交互。每当浏览器请求<code>JSP</code>并且页面已加载以及初始化时，<code>JSP</code>引擎就会调用<code>JSP</code>的<code>_jspService()</code>方法。</p><p><code>_jspService()</code>方法拥有两个参数<code>HttpServletRequest</code>和<code>HttpServletResponse</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">_jspService</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Service handling code...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_jspService()</code>方法在<code>request</code>的基础上调用。主要负责生成请求的响应，同时也可以生成所有的七种HTTP请求方式对应的响应，<strong>GET, POST, DELETE</strong> 等。</p><h3 id="JSP销毁阶段"><a href="#JSP销毁阶段" class="headerlink" title="JSP销毁阶段"></a>JSP销毁阶段</h3><p><code>JSP</code>生命周期的销毁阶段表示从容器中移除<code>JSP</code>。<code>JSP</code>中的<code>jspDestroy()</code>方法等价于<code>servlet</code>中的<code>destroy()</code>方法。通过覆盖<code>jspDestroy()</code>方法可以实现特定的销毁需求，例如：释放数据库连接， 关闭文件等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jspDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// cleanup code goes here.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>简单了解<code>JSP</code>开发中涉及到的语法(JSP元素的使用)。</p><h3 id="小脚本-Scriptlet-元素"><a href="#小脚本-Scriptlet-元素" class="headerlink" title="小脚本(Scriptlet)元素"></a>小脚本(Scriptlet)元素</h3><p>小脚本可以包含任意多行Java语句，变量， 方法申明，以及表达式。</p><p>使用<code>Scriptlet</code>的语法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%</span> <span class="attr">code</span> <span class="attr">fragment</span> %&gt;</span></span><br></pre></td></tr></table></figure><p><code>XML</code>方式语法的等价表达方式:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">jsp:scriptlet</span>&gt;</span></span><br><span class="line">code fragment</span><br><span class="line"><span class="tag">&lt;/<span class="name">jsp:scriptlet</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其他编写的任何文本，HTML标签或JSP元素都必须为与<code>Scriptlet</code>之外。下面是<code>JSP</code>使用<code>Scriptlet</code>的简单示例:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;title&gt;Hello World&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;body&gt;</span><br><span class="line">    Hello World!&lt;br /&gt;</span><br><span class="line">        &lt;%</span><br><span class="line">        out.println(<span class="string">"Your IP address is "</span> + request.getRemoteAddr());</span><br><span class="line">        %&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="申明-Declarations-元素"><a href="#申明-Declarations-元素" class="headerlink" title="申明(Declarations)元素"></a>申明(Declarations)元素</h3><p>一个申明(declaration)可以的申明一个或多个变量，方法，以便在后续的Java代码中使用。在我们是使用<code>Scriptlet</code>编写Java代码之前，应该申明变量或方法。</p><p><code>JSP</code>申明语法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%!</span> <span class="attr">declaration</span>; [<span class="attr">declaration</span>; ] + <span class="attr">...</span> %&gt;</span></span><br></pre></td></tr></table></figure><p><code>XML</code>等价于语法：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">jsp:declaration</span>&gt;</span></span><br><span class="line">declarations define here.</span><br><span class="line"><span class="tag">&lt;/<span class="name">jsp:declaration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>简单例子：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;%! <span class="keyword">int</span> i = <span class="number">0</span>; %&gt;</span><br><span class="line">&lt;%! <span class="keyword">int</span> a, b, c; %&gt;</span><br><span class="line">&lt;%! Circle a = <span class="keyword">new</span> Circle(<span class="number">2.0</span>); %&gt;</span><br></pre></td></tr></table></figure><h3 id="JSP表达式元素"><a href="#JSP表达式元素" class="headerlink" title="JSP表达式元素"></a>JSP表达式元素</h3><p>一个<code>JSP</code>表达式元素可以包含一个脚本语言表达式，该表达式可以通过计算，转换为<code>String</code>，并插入表达式出现在<code>JSP</code>文件中的位置。</p><p>因为表达式中的值最终是转换为<code>String</code>，所以我们可以在<code>JSP</code>文件中使用一行文本编写表达式，无论是否使用<code>HTML</code>标签都可以。表达式可以包含Java语言规范有效的任何表达式，但不能使用分号来结束表达式。</p><p>使用<code>JSP</code>表达式的语法:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%=</span> <span class="attr">expression</span> %&gt;</span></span><br></pre></td></tr></table></figure><p><code>XML</code>语法等价表达方式:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">jsp:expression</span>&gt;</span></span><br><span class="line">expression</span><br><span class="line"><span class="tag">&lt;/<span class="name">jsp:expression</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用<code>JSP</code>表达式例子:</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;title&gt;A Comment Test&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;p&gt;Today<span class="string">'s date: &lt;%= (new java.util.Date()).toLocaleString()%&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure><p>上面例子的运行结果可能是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Today&apos;s date: 11-Sep-2017 21:24:11</span><br></pre></td></tr></table></figure><h3 id="JSP注释元素"><a href="#JSP注释元素" class="headerlink" title="JSP注释元素"></a>JSP注释元素</h3><p><code>JSP</code>容器会忽略使用<code>JSP</code>注释标记的文本和语句。</p><p>使用语法:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%--</span> <span class="attr">This</span> <span class="attr">is</span> <span class="attr">JSP</span> <span class="attr">comment</span> <span class="attr">--</span>%&gt;</span></span><br></pre></td></tr></table></figure><p>简单使用例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;title&gt;A Comment Test! &lt;/title&gt;&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h2&gt;A Test of Comments&lt;/h2&gt;</span><br><span class="line">&lt;%-- This comment will not be visible in the page source --%&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>我们可以在各种情况下使用少量的特殊结构来插入注释和字符，否则这些注释或字符将被特殊处理.</p><div class="table-container"><table><thead><tr><th style="text-align:center">Syntax</th><th style="text-align:center">Purpose</th></tr></thead><tbody><tr><td style="text-align:center"><code>&lt;%-- comment --%&gt;</code></td><td style="text-align:center">JSP注释，文本内容被JSP引擎忽略</td></tr><tr><td style="text-align:center"><code>&lt;!-- comment --&gt;</code></td><td style="text-align:center">HTML注释，文本内容被浏览器忽略</td></tr><tr><td style="text-align:center"><code>&lt;\%</code></td><td style="text-align:center">表示静态的字符<code>&lt;%</code></td></tr><tr><td style="text-align:center"><code>%\&gt;</code></td><td style="text-align:center">表示静态的字符<code>%&gt;</code></td></tr><tr><td style="text-align:center"><code>\&#39;</code></td><td style="text-align:center">在属性中使用单引号</td></tr><tr><td style="text-align:center"><code>\&quot;</code></td><td style="text-align:center">在属性中使用双引号</td></tr></tbody></table></div><h3 id="JSP指令-Directives-元素"><a href="#JSP指令-Directives-元素" class="headerlink" title="JSP指令(Directives)元素"></a>JSP指令(Directives)元素</h3><p><code>JSP</code>指令元素会影响<code>Servlet</code>class文件的整体结构。使用方式:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">directive</span> <span class="attr">attribute</span>=<span class="string">"value"</span> %&gt;</span></span><br></pre></td></tr></table></figure><p><code>JSP</code>中的三种指令元素：</p><div class="table-container"><table><thead><tr><th style="text-align:center">Directive</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td style="text-align:center"><code>&lt;%@ page ... %&gt;</code></td><td style="text-align:center">定义页面相关属性，例如使用脚本语言，错误页面和缓冲请求等</td></tr><tr><td style="text-align:center"><code>&lt;%@ include ... %&gt;</code></td><td style="text-align:center">在翻译转换阶段导入文件</td></tr><tr><td style="text-align:center"><code>&lt;%@taglib ... %&gt;</code></td><td style="text-align:center">申明包含页面中使用的自定义标签的标签库</td></tr></tbody></table></div><h4 id="page-指令元素"><a href="#page-指令元素" class="headerlink" title="page 指令元素"></a>page 指令元素</h4><p><code>page</code>指令用于向容器提供指令。这些指令适用于当前的<code>JSP</code>页面。我们可以在<code>JSP</code>页面中的任何位置编写<code>page</code>指令，但是按照惯例，该指令一般写在<code>JSP</code>的顶部。</p><p>使用<code>page</code>指令的基本语法:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">page</span> <span class="attr">attribute</span> = <span class="string">"value"</span> %&gt;</span></span><br></pre></td></tr></table></figure><p><code>XML</code>语法等价表达方式:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">jsp:directive.page</span> <span class="attr">attribute</span> = <span class="string">"value"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h5 id="page-指令属性"><a href="#page-指令属性" class="headerlink" title="page 指令属性"></a>page 指令属性</h5><p>下面的表格列出的是跟<code>page</code>指令相关的属性:</p><div class="table-container"><table><thead><tr><th style="text-align:center">Attribute</th><th style="text-align:center">Purpose</th></tr></thead><tbody><tr><td style="text-align:center"><code>buffer</code></td><td style="text-align:center">指定输出流的缓冲模式</td></tr><tr><td style="text-align:center"><code>autoFlush</code></td><td style="text-align:center">控制<code>servlet</code>输出缓冲区的行为</td></tr><tr><td style="text-align:center"><code>contentType</code></td><td style="text-align:center">定义字符编码模式</td></tr><tr><td style="text-align:center"><code>errorPage</code></td><td style="text-align:center">定义报告Java未检查的运行时异常的另一个JSP的<code>URL</code></td></tr><tr><td style="text-align:center"><code>isErrorPage</code></td><td style="text-align:center">指示此<code>JSP</code>页面是否由另一个<code>JSP</code>页面的<code>errorPage</code>属性指定</td></tr><tr><td style="text-align:center"><code>extends</code></td><td style="text-align:center">指定生成的<code>servlet</code>需要继承的超类</td></tr><tr><td style="text-align:center"><code>import</code></td><td style="text-align:center">指定<code>JSP</code>中是使用的包或类的列表，如Java<code>import</code>语句那样</td></tr><tr><td style="text-align:center"><code>info</code></td><td style="text-align:center">定义一个能被<code>servlet</code>的<code>getServletInfo()</code>方法访问的字符串</td></tr><tr><td style="text-align:center"><code>isThreadSafe</code></td><td style="text-align:center">定义生成的<code>servlet</code>的线程模式</td></tr><tr><td style="text-align:center"><code>language</code></td><td style="text-align:center">定义<code>JSP</code>页面中使用的编程语言，默认java</td></tr><tr><td style="text-align:center"><code>session</code></td><td style="text-align:center">指定<code>JSP</code>页面是否使用HTTP<code>session</code></td></tr><tr><td style="text-align:center"><code>isELIgnored</code></td><td style="text-align:center">指定<code>JSP</code>页面内的<code>EL</code>表达式是否忽略</td></tr><tr><td style="text-align:center"><code>isScriptingEnabled</code></td><td style="text-align:center">确定是否允许使用脚本元素</td></tr></tbody></table></div><h4 id="include-指令元素"><a href="#include-指令元素" class="headerlink" title="include 指令元素"></a>include 指令元素</h4><p><code>include</code>指令用于告诉容器在翻译阶段将其他的外部文件与当前<code>JSP</code>文件合并。我们可能在<code>JSP</code>页面中任何位置使用该指令元素。</p><p>普通的语法:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">include</span> <span class="attr">file</span> = <span class="string">"relative url"</span> &gt;</span></span><br></pre></td></tr></table></figure><p><code>XML</code>语法等价表达方式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">jsp:directive.include</span> <span class="attr">file</span> = <span class="string">"relative url"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p><code>include</code>指令中的文件名实际上是一个相对<code>URL</code>。如果文件名没有指定关联路径的话，<code>JSP</code>编译器会认为文件与当前<code>JSP</code>页面在同一目录下。</p><h4 id="taglib-指令元素"><a href="#taglib-指令元素" class="headerlink" title="taglib 指令元素"></a>taglib 指令元素</h4><p><code>JSP</code>API允许我们定义像HTML或XML标签那样的自定义标签，标签库就是实现用户行为的自定义标签的集合。</p><p>常规使用语法:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">taglib</span> <span class="attr">uri</span> = <span class="string">"uri"</span> <span class="attr">prefix</span> = <span class="string">"prefixOfTag"</span> &gt;</span></span><br></pre></td></tr></table></figure><p>这里的<code>uri</code>属性值解析为容器能够理解的位置，<code>prefix</code>属性告诉容器哪些标记是自定义的。</p><p>同样它也是可以使用<code>XML</code>语法的形式的：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">jsp:directive.taglib</span> <span class="attr">uri</span> = <span class="string">"uri"</span> <span class="attr">prefix</span> = <span class="string">"prefixOfTag"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h3 id="JSP动作-Actions-元素"><a href="#JSP动作-Actions-元素" class="headerlink" title="JSP动作(Actions)元素"></a>JSP动作(Actions)元素</h3><p><code>JSP</code>动作元素使用<code>XML</code>语法结构，可以控制<code>servlet</code>引擎的行为。通过它，我们可以动态插入一个文件，服用<code>JavaBeans</code>，跳转到另一个页面，或者为Java插件生成HTML。</p><p>使用<code>JSP</code>动作元素只用一种语法，符合<code>XML</code>标准:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">jsp:action_name</span> <span class="attr">attribute</span>=<span class="string">"value"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>动作元素其实预定义的基础函数，下面的表格展示了我们可以使用的<code>JSP</code>动作元素:</p><div class="table-container"><table><thead><tr><th style="text-align:center">Syntax</th><th style="text-align:center">Purpose</th></tr></thead><tbody><tr><td style="text-align:center"><code>jsp:include</code></td><td style="text-align:center">在页面被请求时，动态导入一个文件</td></tr><tr><td style="text-align:center"><code>jsp:useBean</code></td><td style="text-align:center">查找或实例化一个<code>JavaBean</code></td></tr><tr><td style="text-align:center"><code>jsp:setproperty</code></td><td style="text-align:center">为一个<code>JavaBean</code>设置属性</td></tr><tr><td style="text-align:center"><code>jsp:getProperty</code></td><td style="text-align:center">将<code>JavaBean</code>的属性插入到输出中</td></tr><tr><td style="text-align:center"><code>jsp:forward</code></td><td style="text-align:center">将用户转发到一个新的页面</td></tr><tr><td style="text-align:center"><code>jsp:plugin</code></td><td style="text-align:center">用于生成特定的浏览器代码，为Java插件生成<code>OBJECT</code>或<code>EMBED</code>标记</td></tr><tr><td style="text-align:center"><code>jsp:element</code></td><td style="text-align:center">动态定义一个<code>XML</code>元素</td></tr><tr><td style="text-align:center"><code>jsp:attribute</code></td><td style="text-align:center">定义动态定义的<code>XML</code>元素的属性</td></tr><tr><td style="text-align:center"><code>jsp:body</code></td><td style="text-align:center">定义动态定义的<code>XML</code>元素的主体(body)</td></tr><tr><td style="text-align:center"><code>jsp:text</code></td><td style="text-align:center">用于在JSP页面和文档中写模板文本</td></tr></tbody></table></div><h4 id="共同属性-Common-Attributes"><a href="#共同属性-Common-Attributes" class="headerlink" title="共同属性(Common Attributes)"></a>共同属性(Common Attributes)</h4><p>对于所有的动作元素, 它们都有两个共同的属性, 即<code>id</code>和<code>scope</code>属性。</p><h5 id="Id-属性"><a href="#Id-属性" class="headerlink" title="Id 属性"></a>Id 属性</h5><p><code>id</code>属性用于唯一标识动作元素，并允许在<code>JSP</code>页面中因引用该动作元素。<strong>如果动作元素创建某个对象的实例，则可以使用<code>id</code>值通过隐式对象<code>PageContext</code>来引用它。</strong></p><h5 id="Scope-属性"><a href="#Scope-属性" class="headerlink" title="Scope 属性"></a>Scope 属性</h5><p><code>scope</code>属性申明了动作元素的生命周期。<code>id</code>属性和<code>scope</code>属性是直接相关的，因为<code>scope</code>属性确定了与<code>id</code>相关联的对象的生命周期。<code>scope</code>属性有四种取值:</p><ol><li><code>page</code></li><li><code>request</code></li><li><code>session</code></li><li><code>application</code></li></ol><h4 id="lt-jsp-include-gt-动作元素"><a href="#lt-jsp-include-gt-动作元素" class="headerlink" title="&lt;jsp:include&gt;动作元素"></a><code>&lt;jsp:include&gt;</code>动作元素</h4><p>该动作元素允许我们将文件插入到正在生成的页面中。使用语法如下：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:include page = <span class="string">"relative URL"</span> flush = <span class="string">"true"</span> /&gt;</span><br></pre></td></tr></table></figure><p><strong>[notice]</strong>:不像<code>include</code>指令元素，只在<code>JSP</code>页面的翻译阶段插入文件，该动作元素是在每次页面被请求时都将文件进行插入。</p><p>下面的表格列出的是与<code>include</code>动作元素相关的属性:</p><div class="table-container"><table><thead><tr><th style="text-align:center">Attribute</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td style="text-align:center"><code>page</code></td><td style="text-align:center">需要被包含的页面的相对路径</td></tr><tr><td style="text-align:center"><code>flush</code></td><td style="text-align:center">确定包含的资源是否在其被包含之前刷新其缓冲区</td></tr></tbody></table></div><p>例子：</p><p>定义两个<code>JSP</code>页面，<code>date.jsp</code>和<code>main.jsp</code>， 并将<code>date.jsp</code>插入<code>main.jsp</code>中.</p><p><code>date.jsp</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;Today&apos;s date: &lt;%= (new java.util.Date()).toLocaleString()%&gt;</span><br></pre></td></tr></table></figure><p><code>main.jsp</code>:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;The include Action Example&lt;/title&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">    &lt;center&gt;</span><br><span class="line">        &lt;h2&gt;The include action Example&lt;/h2&gt;</span><br><span class="line">            &lt;jsp:include page = <span class="string">"data.jsp"</span> flush = <span class="string">"true"</span> /&gt;</span><br><span class="line">        &lt;/center&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h4 id="lt-jsp-useBean-gt-动作元素"><a href="#lt-jsp-useBean-gt-动作元素" class="headerlink" title="&lt;jsp:useBean&gt;动作元素"></a><code>&lt;jsp:useBean&gt;</code>动作元素</h4><p><code>useBean</code>动作元素非常常用，它首先使用<code>id</code>和<code>scope</code>变量搜索现有对象，如果找不到对象，则会尝试创建指定的对象。</p><p>使用语法:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">jsp:useBean</span> <span class="attr">id</span>  = <span class="string">"name"</span> <span class="attr">class</span> = <span class="string">"package.class"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>一旦<code>bean</code>类被加载后，就可以通过<code>jsp:setProperty</code>和<code>jsp:getProperty</code>动作元素来修改和检索<code>bean</code>的属性。</p><p>下面的表格列出了与<code>jsp;useBean</code>相关的属性:</p><div class="table-container"><table><thead><tr><th style="text-align:center">Attribute</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td style="text-align:center"><code>class</code></td><td style="text-align:center">指定<code>bean</code>的完整包名称</td></tr><tr><td style="text-align:center"><code>type</code></td><td style="text-align:center">指定引用该对象的变量类型</td></tr><tr><td style="text-align:center"><code>beanName</code></td><td style="text-align:center">给出<code>java.beans.Beans</code>类中<code>instantiate()</code>方法指定的<code>bean</code>的名称</td></tr></tbody></table></div><h4 id="lt-jsp-setProperty-gt-动作元素"><a href="#lt-jsp-setProperty-gt-动作元素" class="headerlink" title="&lt;jsp:setProperty&gt;动作元素"></a><code>&lt;jsp:setProperty&gt;</code>动作元素</h4><p><code>jsp:setProperty</code>动作元素用于设置<code>bean</code>的属性。在使用该动作元素之前，<code>bean</code>类必须预先定义。下面是使用<code>jsp:setProperty</code>动作元素的两种方式。</p><p>1.我们可以在<code>jsp:useBean</code>之后，且在其元素外使用<code>jsp:setProperty</code>动作元素。如：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:useBean id = <span class="string">"myName"</span> ... /&gt;</span><br><span class="line">...</span><br><span class="line">&lt;jsp:setProperty name = <span class="string">"myName"</span> property = <span class="string">"someProperty"</span> ... /&gt;</span><br></pre></td></tr></table></figure><p>在上面的例子的情况下，无论是否实例化新<code>bean</code>或找到现有<code>bean</code>，都会执行<code>jsp:setProperty</code>动作元素。</p><p>第二种方式是<code>jsp:setProperty</code>可以出现在<code>jsp:useBean</code>元素的主体中。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">jsp:useBean</span> <span class="attr">id</span> = <span class="string">"myName"</span> &gt;</span></span><br><span class="line">...</span><br><span class="line">    <span class="tag">&lt;<span class="name">jsp:setProperty</span> <span class="attr">name</span> = <span class="string">"myName"</span> <span class="attr">property</span> = <span class="string">"someProperty"</span> <span class="attr">...</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">jsp:useBean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这种情况下，<code>jsp:setProperty</code>元素只有在创建新的<code>bean</code>时，才会被执行。</p><p>下面是与<code>jsp:setProperty</code>元素相关的属性:</p><div class="table-container"><table><thead><tr><th style="text-align:center">Attribute</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td style="text-align:center"><code>name</code></td><td style="text-align:center">指定设置属性的<code>bean</code>，<code>bean</code>必须预先定义</td></tr><tr><td style="text-align:center"><code>property</code></td><td style="text-align:center">申明想要设置的属性。取值<code>*</code>的话，则表示名称与<code>bean</code>属性匹配的所有请求参数将传递给相应的<code>setter</code>方法</td></tr><tr><td style="text-align:center"><code>value</code></td><td style="text-align:center">要分配给指定属性的值。参数值为<code>null</code>，或者参数不存在，将忽略<code>jsp:setProperty</code>操作</td></tr><tr><td style="text-align:center"><code>param</code></td><td style="text-align:center"><code>param</code>属性是请求参数的名称，该属性将接受其值。不能同时使用<code>value</code>和<code>param</code>属性</td></tr></tbody></table></div><h4 id="jsp-getProperty动作元素"><a href="#jsp-getProperty动作元素" class="headerlink" title="jsp:getProperty动作元素"></a><code>jsp:getProperty</code>动作元素</h4><p><code>jsp:getProperty</code>动作元素用于检索给定属性的值，并将它转换为<code>String</code>字符串，最后插入到输出中。</p><p>该动作元素只有两个属性，且它们都是必须的。使用语法如下:</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:useBean id = <span class="string">"myName"</span> ... /&gt;</span><br><span class="line">...</span><br><span class="line">&lt;jsp:getProperty name = <span class="string">"myName"</span> property = <span class="string">"someProperty"</span> ... /&gt;</span><br></pre></td></tr></table></figure><p>下面的表格给出了与<code>getProperty</code>元素的相关属性:</p><div class="table-container"><table><thead><tr><th style="text-align:center">Attribute</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td style="text-align:center"><code>name</code></td><td style="text-align:center">要检索属性的<code>bean</code>的名称。<code>bean</code>必须预先定义</td></tr><tr><td style="text-align:center"><code>property</code></td><td style="text-align:center">要检索的属性名称</td></tr></tbody></table></div><p><code>jsp:setProperty</code>和<code>jsp:getProperty</code>使用例子：</p><p>定义一个简单的<code>TestBean.java</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test.beans;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBean</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String message  = <span class="string">"No message specified"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> vodi <span class="title">setMessage</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>main.jsp</code>页面中做测试：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Using JavaBeans in JSP&lt;/title&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;body&gt;</span><br><span class="line">    &lt;center&gt;</span><br><span class="line">        &lt;h2&gt;using JavaBeans in JSP&lt;/h2&gt;</span><br><span class="line">        &lt;jsp:useBean id = <span class="string">"test"</span> <span class="class"><span class="keyword">class</span> </span>= <span class="string">"test.beans.TestBean"</span> /&gt;</span><br><span class="line">        &lt;jsp:setProperty name = <span class="string">"test"</span> property = <span class="string">"message"</span> value = <span class="string">"Hello JSP"</span> /&gt;</span><br><span class="line">        </span><br><span class="line">        &lt;p&gt;Got message....&lt;/p&gt;</span><br><span class="line">        &lt;jsp:getProperty name = <span class="string">"test"</span> property = <span class="string">"message"</span> /&gt;</span><br><span class="line">        &lt;/center&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h4 id="jsp-forward动作元素"><a href="#jsp-forward动作元素" class="headerlink" title="jsp:forward动作元素"></a><code>jsp:forward</code>动作元素</h4><p><code>jsp:forward</code>动作元素会终止当前页面的操作，并将请求转发到另一个资源，例如：静态页面，另一个<code>JSP</code>页面或<code>Java Servlet</code>。</p><p>使用<code>jsp:forward</code>动作元素的语法：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:forward page = <span class="string">"Relative URL"</span> /&gt;</span><br></pre></td></tr></table></figure><p>下面的表格给出了与该动作元素相关的必须属性:</p><div class="table-container"><table><thead><tr><th style="text-align:center">Attribute</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td style="text-align:center"><code>page</code></td><td style="text-align:center">另一个资源的相对<code>URL</code>，例如：静态页面，另一个JSP页面，或者一个Java Servlet</td></tr></tbody></table></div><p>使用例子: 定义<code>date.jsp</code>和<code>main.jsp</code>，并使用在<code>main.jsp</code>页面中跳转到<code>date.jsp</code>页面:</p><p><code>date.jsp</code>:</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;Today<span class="string">'s date: &lt;%= (new java.util.Date()).toLocaleString()%&gt;&lt;/p&gt;</span></span><br></pre></td></tr></table></figure><p><code>main.jsp</code>:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;The include Action Example&lt;/title&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;body&gt;</span><br><span class="line">    &lt;center&gt;</span><br><span class="line">        &lt;h2&gt;The include action Example&lt;/h2&gt;</span><br><span class="line">        &lt;jsp:forward page = <span class="string">"date.jsp"</span> /&gt;</span><br><span class="line">        &lt;/center&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>运行结果可能是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Today&apos;s date: 12-July-2017 14:54:22</span><br></pre></td></tr></table></figure><h4 id="jsp-plugin动作元素"><a href="#jsp-plugin动作元素" class="headerlink" title="jsp:plugin动作元素"></a><code>jsp:plugin</code>动作元素</h4><p><code>jsp:plugin</code>动作元素用于在<code>JSP</code>页面中插入Java组件。它确定浏览器的类型，并根据需要插入的<code>&lt;object&gt;</code>或<code>&lt;embed&gt;</code>标签。</p><p>如果所需的插件不存在，则下载插件然后执行Java组件。Java组件可以是<code>Applet</code>或<code>JavaBean</code>。</p><p>该动作元素有几个属性，对应用于格式化java组件的常用<code>HTML</code>标签元素。<code>&lt;param&gt;</code>元素也可用于将参数发送到<code>Applet</code>或<code>Bean</code>中。</p><p>以下是使用<code>jsp:plugin</code>元素的语法：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:plugin type = <span class="string">"applet"</span> codebase = <span class="string">"dirname"</span> code = <span class="string">"MyApplet.class"</span> width = <span class="string">"60"</span> height = <span class="string">"80"</span> &gt;</span><br><span class="line">&lt;jsp:param name = <span class="string">"fontcolor"</span> value = <span class="string">"red"</span> /&gt;</span><br><span class="line">    &lt;jsp:param name = <span class="string">"background"</span> value = <span class="string">"black"</span> /&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;jsp:fallback&gt;</span><br><span class="line">    Unable to initialize Java Plugin</span><br><span class="line">    &lt;/jsp:fallback&gt;</span><br><span class="line">&lt;/jsp:plugin&gt;</span><br></pre></td></tr></table></figure><p>上面的<code>&lt;jsp:fallback&gt;</code>元素可用于指定在组件发生故障时要发送给用户的错误字符串。</p><p><code>&lt;jsp:element&gt;</code>, <code>&lt;jsp:attribute&gt;</code>和<code>&lt;jsp:body&gt;</code>动作元素主要用于动态定义<code>XML</code>元素。这意味着<code>XML</code>元素可以在请求时动态生成，而不是在编译时静态生成。</p><p>下面是动态定义<code>XML</code>元素的一个简单例子:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;%<span class="meta">@page</span> language = <span class="string">"java"</span> contentType = <span class="string">"text/html"</span>%&gt;</span><br><span class="line">&lt;html xmlns = <span class="string">"http://www.w3c.org/1999/xhtml"</span></span><br><span class="line">   xmlns:jsp = <span class="string">"http://java.sun.com/JSP/Page"</span>&gt;</span><br><span class="line">   </span><br><span class="line">   &lt;head&gt;&lt;title&gt;Generate XML Element&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">   </span><br><span class="line">   &lt;body&gt;</span><br><span class="line">      &lt;jsp:element name = <span class="string">"xmlElement"</span>&gt;</span><br><span class="line">         &lt;jsp:attribute name = <span class="string">"xmlElementAttr"</span>&gt;</span><br><span class="line">            Value <span class="keyword">for</span> the attribute</span><br><span class="line">         &lt;/jsp:attribute&gt;</span><br><span class="line">         </span><br><span class="line">         &lt;jsp:body&gt;</span><br><span class="line">            Body <span class="keyword">for</span> XML element</span><br><span class="line">         &lt;/jsp:body&gt;</span><br><span class="line">      </span><br><span class="line">      &lt;/jsp:element&gt;</span><br><span class="line">   &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>在运行时就会生成下面的<code>HTML</code>代码；</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;html xmlns = <span class="string">"http://www.w3c.org/1999/xhtml"</span> xmlns:jsp = <span class="string">"http://java.sun.com/JSP/Page"</span>&gt;</span><br><span class="line">   &lt;head&gt;&lt;title&gt;Generate XML Element&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">   </span><br><span class="line">   &lt;body&gt;</span><br><span class="line">      &lt;xmlElement xmlElementAttr = <span class="string">"Value for the attribute"</span>&gt;</span><br><span class="line">         Body <span class="keyword">for</span> XML element</span><br><span class="line">      &lt;/xmlElement&gt;</span><br><span class="line">   &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h4 id="jsp-text动作元素"><a href="#jsp-text动作元素" class="headerlink" title="jsp:text动作元素"></a><code>jsp:text</code>动作元素</h4><p><code>&lt;jsp:text&gt;</code>动作元素主要用于在<code>JSP</code>页面中编写模板文本。使用语法如下:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">jsp:text</span>&gt;</span>Tempate data <span class="tag">&lt;/<span class="name">jsp:text</span>&gt;</span></span><br></pre></td></tr></table></figure><p>模板的主体不能包含其他元素，只能包含<code>EL</code>表达式。在<code>XML</code>文件中，不能使用<code>${whatever &gt; 0}</code>, 因为<code>&gt;</code>在这里是不允许的，需要书写成<code>${whatever gt 0}</code>，另一种方法是将值嵌入<code>CDATA</code>部分。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">jsp:text</span>&gt;</span>&lt;![CDATA[&lt;br&gt;]]&gt;<span class="tag">&lt;/<span class="name">jsp:text</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果需要包含<code>DOCTYPE</code>申明(例如<code>XHTML</code>)，可以使用<code>&lt;jsp:text&gt;</code>元素，如下所示:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:text&gt;&lt;![CDATA[&lt;!DOCTYPE html PUBLIC <span class="string">"-//W3C//DTD XHTML 1.0 Strict//EN"</span></span><br><span class="line">   "DTD/xhtml1-strict.dtd"&gt;]]&gt;&lt;/jsp:text&gt;</span><br><span class="line"></span><br><span class="line">   &lt;head&gt;&lt;title&gt;jsp:text action&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">   </span><br><span class="line">   &lt;body&gt;</span><br><span class="line">      &lt;books&gt;&lt;book&gt;&lt;jsp:text&gt;  </span><br><span class="line">         Welcome to JSP Programming</span><br><span class="line">      &lt;/jsp:text&gt;&lt;/book&gt;&lt;/books&gt;</span><br><span class="line">   &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="JSP隐式-Implicit-对象"><a href="#JSP隐式-Implicit-对象" class="headerlink" title="JSP隐式(Implicit)对象"></a>JSP隐式(Implicit)对象</h3><p><code>JSP</code>支持九个自动定义的变量，它们被称为隐式对象。</p><div class="table-container"><table><thead><tr><th style="text-align:center">Object</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td style="text-align:center"><code>request</code></td><td style="text-align:center">与请求关联的<code>HttpServletRequest</code>对象</td></tr><tr><td style="text-align:center"><code>response</code></td><td style="text-align:center">与客户端响应关联的<code>HttpServletResponse</code>对象</td></tr><tr><td style="text-align:center"><code>out</code></td><td style="text-align:center"><code>PrintWriter</code>对象，用于输出文本到客户端</td></tr><tr><td style="text-align:center"><code>session</code></td><td style="text-align:center">与请求关联的<code>HttpSession</code>对象</td></tr><tr><td style="text-align:center"><code>application</code></td><td style="text-align:center">与应用程序上下文(application context)关联的<code>ServletContext</code>对象</td></tr><tr><td style="text-align:center"><code>config</code></td><td style="text-align:center">与页面关联的<code>ServletConfig</code>对象</td></tr><tr><td style="text-align:center"><code>pageContext</code></td><td style="text-align:center">封装了特定的服务器功能，如性能更高的<code>JspWriters</code></td></tr><tr><td style="text-align:center"><code>page</code></td><td style="text-align:center">与Java中的<code>this</code>一样，主要用于调用已转换为<code>servlet</code>类中定义的方法</td></tr><tr><td style="text-align:center"><code>Exception</code></td><td style="text-align:center"><code>Exception</code>对象允许指定的<code>JSP</code>访问异常数据</td></tr></tbody></table></div><h4 id="request对象"><a href="#request对象" class="headerlink" title="request对象"></a><code>request</code>对象</h4><p><code>request</code>对象是<code>javax.servlet.http.HttpServletRequest</code>对象的一个实例。每次客户端发起请求时，<code>JSP</code>引擎都会创建一个新的<code>request</code>对象来表示请求。<code>request</code>提供获取<code>HTTP</code>头部信息（如：表单数据、<code>cookies</code>、<code>HTTP</code>方法等）的方法。</p><h4 id="response对象"><a href="#response对象" class="headerlink" title="response对象"></a><code>response</code>对象</h4><p><code>response</code>对象是<code>javax.servlet.http.HttpServletResponse</code>对象的实例。和<code>request</code>一样，服务器也会创建<code>response</code>来代表客户端响应。</p><p><code>response</code>对象还定义了处理创建新<code>HTTP</code>头部的接口。通过这个对象，<code>JSP</code>开发人员可以添加新的<code>cookie</code>或者时间戳，<code>HTTP</code>状态码等。</p><h4 id="out对象"><a href="#out对象" class="headerlink" title="out对象"></a><code>out</code>对象</h4><p><code>out</code>隐式对象是<code>javax.servlet.jsp.JspWriter</code>对象的一个实例。用于向<code>response</code>发送内容。</p><p>初始的<code>JspWriter</code>兑现过的实例化取决于页面是否缓冲。通过使用<code>page</code>指令元素的<code>buffered=&#39;false&#39;</code>属性，可以轻松关闭缓冲。</p><p><code>JspWriter</code>对象包含很多和<code>java.io.PrintWriter</code>类相同的方法。但是，<code>JspWriter</code>拥有额外的方法用于处理缓冲(buffering)。不同与<code>PrintWriter</code>对象，<code>JspWriter</code>还会抛出<code>IOExceptions</code>。</p><p>下面的表格列出了使用<code>out</code>对象写入<code>char</code>, <code>int</code>, <code>double</code>, <code>object</code>, <code>String</code>等的重要方法。</p><div class="table-container"><table><thead><tr><th style="text-align:center">Method</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td style="text-align:center"><code>out.print(dataType dt)</code></td><td style="text-align:center">打印数据类型值</td></tr><tr><td style="text-align:center"><code>out.println(dataType dt)</code></td><td style="text-align:center">打印数据类型值，并换行</td></tr><tr><td style="text-align:center"><code>out.flush()</code></td><td style="text-align:center">刷新流，清楚缓冲区</td></tr></tbody></table></div><h4 id="session对象"><a href="#session对象" class="headerlink" title="session对象"></a><code>session</code>对象</h4><p><code>session</code>对象是<code>javax.servlet.http.HttpSession</code>对象的一个实例，其行为和<code>Java Servlets</code>下的<code>Session</code>对象行为完全相同。<code>session</code>对象主要用于跟踪客户端请求之间的客户端回话。</p><h4 id="application对象"><a href="#application对象" class="headerlink" title="application对象"></a><code>application</code>对象</h4><p><code>application</code>对象是生成<code>servlet</code>的<code>ServletContext</code>对象的直接包装器(direct wrapper),实际上是<code>javax.servlet.ServletContext</code>对象的实例。</p><p>该对象是<code>JSP</code>页面整个生命周期的表示。初始化<code>JSP</code>页面时会创建对象，并且在<code>jspDestroy()</code>方法执行删除<code>JSP</code>页面时，该对象也会被删除。</p><p>通过向<code>application</code>添加属性，可以使Web应用程序中所有<code>JSP</code>页面都可以访问该属性。</p><h4 id="config对象"><a href="#config对象" class="headerlink" title="config对象"></a><code>config</code>对象</h4><p><code>config</code>对象是<code>javax.servlet.ServletConfig</code>对象的实例，是生成<code>servlet</code>的<code>ServletConfig</code>对象的直接包装器。使用该对象可以使<code>JSP</code>开发人员访问<code>Servlets</code>或<code>JSP</code>引擎的初始化参数（如：文件路径等）。</p><p>下面是<code>config</code>对象中我们唯一会使用到的方法，用法也很简单:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config.getServletName();</span><br></pre></td></tr></table></figure><p>该方法返回<code>servlet</code>的名字，这些名字一般定义在<code>WEB-INF\web.xml</code>中的<code>&lt;servlet-name&gt;</code>的元素内。</p><h4 id="pageContext对象"><a href="#pageContext对象" class="headerlink" title="pageContext对象"></a><code>pageContext</code>对象</h4><p><code>pageContext</code>对象是<code>javax.servlet.jsp.PageContext</code>对象的一个实例。<code>pageContext</code>对象用于表示整个<code>JSP</code>页面。</p><p>该对象旨在获取有关页面的相关信息，同时避免大多数的实现细节。<code>pageContext</code>会保存每个请求对应的<code>request</code>和<code>response</code>对象的引用。<code>application</code>, <code>config</code>, <code>session</code>以及<code>out</code>对象都是通过访问该对象的属性派生的。</p><p><code>pageContext</code>对象还包含有关发布到<code>JSP</code>页面的指令的信息，包括缓冲信息，<code>errorPageURL</code>和<code>page Scope</code>。</p><p><code>PageContext</code>类中定义了许多属性，其中包含<code>PAGE_SCOPE</code>, <code>REQUEST_SCOPE</code>, <code>SESSION_SCOPE</code>和<code>APPLICATION_SCOPE</code>,这些刚好对应页面的页面范围(scope)。它还拥有40多种方法，大约一一半是从<code>javax.servlet.jsp.JspContext</code>类继承来的。其中一个重要的方法是 :<code>removeAttribute</code>，该方法接受一个或两个参数。例如：<code>pageContext.removeAttribute(&quot;attrName&quot;);</code>从所有范围中删除该属性，下面的代码是从指定范围中移除属性:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pageContext.removeAttribute(<span class="string">"attrName"</span>, PAGE_SCOPE);</span><br></pre></td></tr></table></figure><h4 id="page对象"><a href="#page对象" class="headerlink" title="page对象"></a><code>page</code>对象</h4><p><code>page</code>对象是对页面的实际引用。它可以被认为是代表整体<code>JSP</code>页面的对象。<code>page</code>对象实际上是<code>this</code>对象的直接同义词。</p><h4 id="exception对象"><a href="#exception对象" class="headerlink" title="exception对象"></a><code>exception</code>对象</h4><p><code>exception</code>对象是一个包装器(wrapper),包含从上一个页面抛出的异常。它通常用于生成针对特定错误的<code>response</code>对象。</p><h3 id="控制流语句-Control-Flow-Statements"><a href="#控制流语句-Control-Flow-Statements" class="headerlink" title="控制流语句 (Control-Flow Statements)"></a>控制流语句 (Control-Flow Statements)</h3><p>我们可以在<code>JSP</code>编程中使用Java的所有API，例如：流程控制语句等。</p><h3 id="决策语句-Decision-Making-Statements"><a href="#决策语句-Decision-Making-Statements" class="headerlink" title="决策语句 (Decision-Making Statements)"></a>决策语句 (Decision-Making Statements)</h3><p><code>if ... else</code>块像普通的<code>Scriptlet</code>一样开始，但<code>Scriptlet</code>在每一行都关闭，<code>Scriptlet</code>标签之间包含有HTML文本。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;%! <span class="keyword">int</span> day = <span class="number">3</span>; %&gt;</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;title&gt;IF ... ELSE Example&lt;/title&gt;&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;% <span class="keyword">if</span> (day == <span class="number">1</span> || day == <span class="number">7</span>) &#123; %&gt;</span><br><span class="line">    &lt;p&gt;Today is weekend&lt;/p&gt;</span><br><span class="line">    &lt;% &#125; <span class="keyword">else</span> &#123; %&gt;</span><br><span class="line">    &lt;p&gt;Today is not weekend&lt;/p&gt;</span><br><span class="line">    &lt;% &#125; %&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>上面的程序代码输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Today is not weekend</span><br></pre></td></tr></table></figure><p>下面看一下如何使用<code>switch ... case</code>块并使用<code>out.println()</code>：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;%! <span class="keyword">int</span> day = <span class="number">3</span>; %&gt;</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;title&gt;SWITCH .. CASE Example&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    <span class="keyword">switch</span>(day) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        out.println(<span class="string">"It\'s Sunday."</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        out.println(<span class="string">"it\'s Mondya."</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        out.println(<span class="string">"It\'s Tuesday."</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        out.println(<span class="string">"it\'s WEdnesday."</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        out.println(<span class="string">"It\' Thursday."</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        out.println(<span class="string">"It\'s Friday."</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        out.println(<span class="string">"it\'s Saturday."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    %&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">It&apos;s Wednesday.</span><br></pre></td></tr></table></figure><h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><p>同样在<code>JSP</code>中使用循环语句块也是可以的，例如：<code>for</code>, <code>while</code>,以及<code>do ... while</code>。</p><p>简单的使用<code>for</code>循环语句的例子：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;%! <span class="keyword">int</span> fontSize; %&gt;</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;title&gt;FOR LOOP Example&lt;/title&gt;&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;% <span class="keyword">for</span> (fontSize = <span class="number">1</span>; fontSize &lt; - <span class="number">3</span>; fontSize++) &#123; %&gt;</span><br><span class="line">    &lt;font color = <span class="string">"green"</span> size = &lt;%= fontSize %&gt;<span class="string">"&gt;</span></span><br><span class="line"><span class="string">    JSP Test</span></span><br><span class="line"><span class="string">        &lt;/font&gt;&lt;br /&gt;</span></span><br><span class="line"><span class="string">&lt;% &#125; %&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure><h3 id="JSP数据类型-Literals"><a href="#JSP数据类型-Literals" class="headerlink" title="JSP数据类型 (Literals)"></a>JSP数据类型 (Literals)</h3><p><code>JSP</code>表达式定义了下面的数据类型:</p><ul><li><code>Boolean</code> — true 或者 false</li><li><code>Integer</code> — 与Java中一样</li><li><code>Floating point</code> — 与Java中一样</li><li><code>String</code> — 以单引号或双引号包围起来的字符串</li><li><code>Null</code> — null</li></ul><h2 id="客户端请求-Client-Request"><a href="#客户端请求-Client-Request" class="headerlink" title="客户端请求(Client Request)"></a>客户端请求(Client Request)</h2><p>当浏览器请求网页时，它会向Web服务器发送大量的信息。一般无法直接读取这些信息，因为它们是作为<code>HTTP</code>请求的头部的一部分来发送的。</p><p>下面的表格列出了来自浏览器的重要头部信息。它们经常用于Web编程:</p><div class="table-container"><table><thead><tr><th style="text-align:center">Header</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td style="text-align:center"><code>Accept</code></td><td style="text-align:center">此<code>header</code>指定浏览器或其他客户端可以处理的<code>MIME</code>类型。<code>image/png</code>或<code>image/jpeg</code>是两种常见的取值</td></tr><tr><td style="text-align:center"><code>Accept-Charset</code></td><td style="text-align:center">此<code>header</code>指定浏览器可用于显示信息的字符集, 例如: <code>ISO-8859-1</code></td></tr><tr><td style="text-align:center"><code>Accept-Encoding</code></td><td style="text-align:center">此<code>header</code>指定浏览器能够处理的编码类型, <code>gizp</code>和<code>compress</code>是两种常见的取值</td></tr><tr><td style="text-align:center"><code>Accept-Language</code></td><td style="text-align:center">此<code>header</code>指定客户端的首选语言，<code>servlet</code>可以使用多种语言来生成结果。例如：<code>en</code>, <code>en-us</code>, <code>ru</code>等</td></tr><tr><td style="text-align:center"><code>Authorization</code></td><td style="text-align:center">在访问受密码保护的网页时，浏览器使用此<code>header</code>来标识自己</td></tr><tr><td style="text-align:center"><code>Connection</code></td><td style="text-align:center">此<code>header</code>指定客户端是否可以处理持久<code>HTTP</code>连接。使用持久连接可以使客户端或其他浏览器在单个请求内检索多个文件。取值<code>keep-Alive</code>表示使用持久连接</td></tr><tr><td style="text-align:center"><code>Content-Length</code></td><td style="text-align:center">此<code>header</code>只适用于<code>POST</code>请求，并以字节为单位给出<code>POST</code>数据的大小</td></tr><tr><td style="text-align:center"><code>Cookie</code></td><td style="text-align:center">此<code>header</code>将<code>cookie</code>返回给先前已将其发送到浏览器的服务器</td></tr><tr><td style="text-align:center"><code>Host</code></td><td style="text-align:center">此<code>header</code>指定原始URL中给出的主机和端口</td></tr><tr><td style="text-align:center"><code>If-Modified-Since</code></td><td style="text-align:center">此<code>header</code>申明客户端仅在指定日期之后更改页面时才需要该页面。如果没有可用的更新结果，服务器会发送代码<code>304</code>，意味着<code>header</code> 为<code>Not Modified</code></td></tr><tr><td style="text-align:center"><code>If-Unmodified-Since</code></td><td style="text-align:center">此<code>header</code>与<code>If-Modified-Since</code>相反，它指定仅当文档早于指定日期时操作才会成功</td></tr><tr><td style="text-align:center"><code>Referer</code></td><td style="text-align:center">此<code>header</code>指定引用网页的URL。例如，如果在网页1中并单机指向网页2的链接，则当浏览器请求网页2时，网页1的URL将包含在<code>Referer</code> <code>header</code>中</td></tr><tr><td style="text-align:center"><code>User-Agent</code></td><td style="text-align:center">该<code>header</code>用于标识发出请求的浏览器或者其他客户端，可用于将不同内容返回到不同类型的浏览器</td></tr></tbody></table></div><h3 id="HttpServletRequest对象"><a href="#HttpServletRequest对象" class="headerlink" title="HttpServletRequest对象"></a><code>HttpServletRequest</code>对象</h3><p>之前已经了解到，<code>request</code>对象是<code>HttpServletRequest</code>对象的实例。每次客户端发起请求时，<code>JSP</code>引擎都会创建一个<code>request</code>对象来表示该请求。</p><p><code>request</code>对象提供了获取<code>HTTP header</code>信息的方法。<code>header</code>信息包括表单数据, <code>cookie</code>, <code>HTTP</code>方法等等。</p><p>下面的表格列出了<code>JSP</code>程序用于读取<code>HTTP header</code>信息的重要方法。这些方法适用于<code>HttpServletRequest</code>对象。</p><div class="table-container"><table><thead><tr><th style="text-align:center">Method</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td style="text-align:center"><code>Cookie[] getCookies()</code></td><td style="text-align:center">返回一个包含客户端使用该请求发送的所有<code>Cookie</code>对象</td></tr><tr><td style="text-align:center"><code>Enumeration getAttributeNames()</code></td><td style="text-align:center">返回包含此请求中所有可用属性名称的<code>Enumeration</code>对象</td></tr><tr><td style="text-align:center"><code>Enumeration getHeaderNames()</code></td><td style="text-align:center">返回包含此请求中包含的所有<code>header</code>名称的<code>Enumeration</code>对象</td></tr><tr><td style="text-align:center"><code>Enumeration getParameterNames()</code></td><td style="text-align:center">返回<code>String</code>对象的<code>Enumeration</code>对象，其中包含此请求中包含的参数的名称</td></tr><tr><td style="text-align:center"><code>HttpSession getSession()</code></td><td style="text-align:center">返回与当前请求相关联的<code>HttpSession</code>对象，如果该请求没有对应的<code>session</code>对象，则创建一个</td></tr><tr><td style="text-align:center"><code>HttpSession getSession(boolean create)</code></td><td style="text-align:center">返回与此请求关联的当前的<code>HttpSession</code>对象，如果没有当前<code>session</code>且<code>create</code>为<code>true</code>，则返回一个新<code>HttpSession</code>对象</td></tr><tr><td style="text-align:center"><code>Locale getLocale()</code></td><td style="text-align:center">根据<code>Accept-Language</code> <code>header</code>返回客户端将接受内容的的首选语言环境</td></tr><tr><td style="text-align:center"><code>Object getAttribute(String name)</code></td><td style="text-align:center">以<code>Object</code>形式返回指定属性的值，如果不存在给定名称的属性，则返回<code>null</code></td></tr><tr><td style="text-align:center"><code>ServletInputStream getInputStream()</code></td><td style="text-align:center">使用<code>ServletInputeStream</code>以二进制数据的形式检索请求的主体</td></tr><tr><td style="text-align:center"><code>String getAuthType()</code></td><td style="text-align:center">返回用于保护<code>servlet</code>的身份验证方案的名称，例如<code>&quot;BASIC&quot;</code>或<code>&quot;SSL&quot;</code>,如果<code>JSP</code>未受保护，则返回<code>null</code></td></tr><tr><td style="text-align:center"><code>String getCharacterEncoding()</code></td><td style="text-align:center">返回该请求正文中使用的字符编码的名称</td></tr><tr><td style="text-align:center"><code>String getContentType()</code></td><td style="text-align:center">返回请求正文的<code>MIME</code>类型，如果类型未知，则返回<code>null</code></td></tr><tr><td style="text-align:center"><code>String getContextPath()</code></td><td style="text-align:center">返回请求<code>URI</code>的一部分，代表请求的上下文</td></tr><tr><td style="text-align:center"><code>String getHeader(String name)</code></td><td style="text-align:center">以<code>String</code>的形式返回指定<code>header</code>的值</td></tr><tr><td style="text-align:center"><code>String getMethod()</code></td><td style="text-align:center">返回用于发出该请求的<code>HTTP</code>方法的名称，例如:<code>GET</code>, <code>POST</code>, <code>PUT</code></td></tr><tr><td style="text-align:center"><code>String getParameter(String name)</code></td><td style="text-align:center">以<code>String</code>形式返回请求中的参数的值，如果参数不存在，则返回<code>null</code></td></tr><tr><td style="text-align:center"><code>String getPathInfo()</code></td><td style="text-align:center">返回与客户端发出此请求时发送的<code>URL</code>关联的任何额外的路径信息</td></tr><tr><td style="text-align:center"><code>String getProtocol()</code></td><td style="text-align:center">返回请求使用的协议的名称和版本</td></tr><tr><td style="text-align:center"><code>String getQueryString()</code></td><td style="text-align:center">返回路径后面请求<code>URL</code>中包含的查询字符串</td></tr><tr><td style="text-align:center"><code>String getRemoteAddr()</code></td><td style="text-align:center">返回发送请求的客户端的Internet协议(IP)地址</td></tr><tr><td style="text-align:center"><code>String getRemoteHost()</code></td><td style="text-align:center">返回发送请求的客户端的完全限定名称</td></tr><tr><td style="text-align:center"><code>String getRemoteUser()</code></td><td style="text-align:center">如果用户已通过身份验证，则返回发出此请求的用户的登录名； 如果用户尚未通过身份验证，则返回<code>null</code></td></tr><tr><td style="text-align:center"><code>String getRequestURI()</code></td><td style="text-align:center">从协议名称到<code>HTTP</code>请求第一行中的查询字符串返回此请求的<code>URL</code>部分</td></tr><tr><td style="text-align:center"><code>String getRequestedSessionId()</code></td><td style="text-align:center">返回客户端指定的回话(session)ID</td></tr><tr><td style="text-align:center"><code>String getServletPath()</code></td><td style="text-align:center">返回该请求中调用的<code>JSP</code>的<code>URL</code>的一部分</td></tr><tr><td style="text-align:center"><code>String[] getParameterValues(String name)</code></td><td style="text-align:center">返回包含给定请求参数所具有的所有值的<code>String</code>对象数组，如果参数不存在，则返回<code>null</code></td></tr><tr><td style="text-align:center"><code>boolean isSecure()</code></td><td style="text-align:center">返回一个<code>boolean</code>值，表示该请求是否使用安全隧道, 如<code>HTTPS</code></td></tr><tr><td style="text-align:center"><code>int getContentLength()</code></td><td style="text-align:center">返回请求正文的长度(以字节为单位)，并使输入流能够访问，如果长度未知，则返回-1</td></tr><tr><td style="text-align:center"><code>int getIntHeader(String name)</code></td><td style="text-align:center">以<code>int</code>形式返回指定<code>header</code>的值</td></tr><tr><td style="text-align:center"><code>int getServerPort()</code></td><td style="text-align:center">返回接受该请求的端口号</td></tr></tbody></table></div><h3 id="HTTP-Header请求示例"><a href="#HTTP-Header请求示例" class="headerlink" title="HTTP Header请求示例"></a><code>HTTP Header</code>请求示例</h3><p>下面的例子，使用<code>HttpServletRequest</code>的<code>getHeaderNames()</code>方法来读取<code>HTTP</code>的头部信息。该方法返回一个<code>Enumeration</code>对象，其中包含与当前<code>HTTP</code>请求关联的<code>header</code>的信息。</p><p>一旦我们有了<code>Enumeration</code>对象，我们就可以使用标准方式循环打印其中的信息。这里使用<code>hasMoreElement()</code>来判断什么时候停止循环，并用<code>nextElement()</code>返回获取每个参数对应的值。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page <span class="keyword">import</span> = <span class="string">"java.io.*,java.util.*"</span> %&gt;</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">   &lt;head&gt;</span><br><span class="line">      &lt;title&gt;HTTP Header Request Example&lt;/title&gt;</span><br><span class="line">   &lt;/head&gt;</span><br><span class="line"></span><br><span class="line">   &lt;body&gt;</span><br><span class="line">      &lt;center&gt;</span><br><span class="line">         &lt;h2&gt;HTTP Header Request Example&lt;/h2&gt;</span><br><span class="line">         </span><br><span class="line">         &lt;table width = <span class="string">"100%"</span> border = <span class="string">"1"</span> align = <span class="string">"center"</span>&gt;</span><br><span class="line">            &lt;tr bgcolor = <span class="string">"#949494"</span>&gt;</span><br><span class="line">               &lt;th&gt;Header Name&lt;/th&gt;</span><br><span class="line">               &lt;th&gt;<span class="function">Header <span class="title">Value</span><span class="params">(s)</span>&lt;/th&gt;</span></span><br><span class="line"><span class="function">            &lt;/tr&gt;</span></span><br><span class="line"><span class="function">            &lt;%</span></span><br><span class="line"><span class="function">               Enumeration headerNames </span>= request.getHeaderNames();</span><br><span class="line">               <span class="keyword">while</span>(headerNames.hasMoreElements()) &#123;</span><br><span class="line">                  String paramName = (String)headerNames.nextElement();</span><br><span class="line">                  out.print(<span class="string">"&lt;tr&gt;&lt;td&gt;"</span> + paramName + <span class="string">"&lt;/td&gt;\n"</span>);</span><br><span class="line">                  String paramValue = request.getHeader(paramName);</span><br><span class="line">                  out.println(<span class="string">"&lt;td&gt; "</span> + paramValue + <span class="string">"&lt;/td&gt;&lt;/tr&gt;\n"</span>);</span><br><span class="line">               &#125;</span><br><span class="line">            %&gt;</span><br><span class="line">         &lt;/table&gt;</span><br><span class="line">      &lt;/center&gt;</span><br><span class="line">   </span><br><span class="line">   &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="HeaderTest.png" alt=""></p><h2 id="服务器响应-Server-Response"><a href="#服务器响应-Server-Response" class="headerlink" title="服务器响应(Server Response)"></a>服务器响应(Server Response)</h2><p>下面我们主要是在<code>JSP</code>中讨论服务器响应。当<code>Web</code>服务器响应<code>HTTP</code>请求时，响应通常由状态行，一些响应头，空行和文档组成。典型的响应如下面所示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Header2: ...</span><br><span class="line">...</span><br><span class="line">HeaderN: ...</span><br><span class="line">   (Blank Line)</span><br><span class="line">&lt;!doctype ...&gt;</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">   &lt;head&gt;...&lt;/head&gt;</span><br><span class="line">   &lt;body&gt;</span><br><span class="line">      ...</span><br><span class="line">   &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>状态行包含了<code>HTTP</code>的版本(<code>HTTP/1.1</code>)以及状态码(<code>200</code>), 此外还有非常短的信息来对应状态码(<code>OK</code>).</p><p>以下是从<code>Web</code>服务器返回到浏览器的最有用的<code>HTTP/1.1</code>响应<code>header</code>的摘要。这些<code>header</code>经常用于<code>Web</code>编程:</p><div class="table-container"><table><thead><tr><th style="text-align:center">Header</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td style="text-align:center"><code>Allow</code></td><td style="text-align:center">该<code>header</code>指定了服务器支持的请求方法(<code>GET</code>, <code>POST</code>等)</td></tr><tr><td style="text-align:center"><code>Cache-Control</code></td><td style="text-align:center">此<code>header</code>指定可以安全地缓存响应文档的环境。它的取值可以为<code>public</code>,<code>private</code>,和<code>no-cache</code>.<code>public</code>意味着文档是可以缓存的，<code>private</code>意味着文档是针对单个用户的，并且只能存储在私有(非共享)缓存中，而<code>no-cache</code>意味着文档不能被缓存</td></tr><tr><td style="text-align:center"><code>Connection</code></td><td style="text-align:center">该<code>header</code>指定浏览器是否使用持久化<code>HTTP</code>链接。<code>close</code>意味着不使用，而<code>keep-alive</code>则使用持久化链接</td></tr><tr><td style="text-align:center"><code>Content-Disposition</code></td><td style="text-align:center">该<code>header</code>允许您请求浏览器要求用户将响应保存到给定的文件中</td></tr><tr><td style="text-align:center"><code>Content-Encoding</code></td><td style="text-align:center">此<code>header</code>指定页面在传输过程中的的编码方式</td></tr><tr><td style="text-align:center"><code>Content-Language</code></td><td style="text-align:center">该<code>header</code>标明文档是以何种语言编写的.例如: <code>en</code>, <code>en-us</code>, <code>ru</code>等等</td></tr><tr><td style="text-align:center"><code>Content-Length</code></td><td style="text-align:center">该<code>header</code>表明了响应包含的字节数。它只有在浏览器使用持久化链接时才会被用到</td></tr><tr><td style="text-align:center"><code>Content-Type</code></td><td style="text-align:center">此<code>header</code>提供响应文档的<code>MIME</code>(<strong>Multipurpose Internet Mail Extentsion, 多用途Internet邮件扩展</strong>)类型</td></tr><tr><td style="text-align:center"><code>Expires</code></td><td style="text-align:center">此<code>header</code>指定响应内容被视为过期的时间，即不被缓存</td></tr><tr><td style="text-align:center"><code>Last-Modified</code></td><td style="text-align:center">该<code>header</code>标明文档上次更改的时间。然后，客户端可以缓存文档，并在以后的请求中通过<code>If-Modified-Since</code> <code>header</code>来提供日期</td></tr><tr><td style="text-align:center"><code>Location</code></td><td style="text-align:center">此<code>header</code>包含在状态码为<code>300s</code>的所以响应中。这回通知浏览器文档的地址。浏览器会自动重新连接到此位置并检索新文档</td></tr><tr><td style="text-align:center"><code>Refresh</code></td><td style="text-align:center">该<code>header</code>指定浏览器应该多久请求更新页面。可以指定刷新页面的时间(以秒为单位)</td></tr><tr><td style="text-align:center"><code>Retry-After</code></td><td style="text-align:center">该<code>header</code>可以和<code>503</code>（服务不可用）响应结合使用，以告知客户端它可以多快重复进行请求</td></tr><tr><td style="text-align:center"><code>Set-Cookie</code></td><td style="text-align:center">此<code>header</code>指定页面是否关联一个<code>cookie</code></td></tr></tbody></table></div><h3 id="HttpServletResponse对象"><a href="#HttpServletResponse对象" class="headerlink" title="HttpServletResponse对象"></a><code>HttpServletResponse</code>对象</h3><p><code>response</code>对象是<code>javax.servlet.http.HttpServletResponse</code>的一个实例。和创建<code>request</code>对象一样，服务器同样会创建一个<code>response</code>对象来对应对客户端的响应.</p><p>响应对象还定义了处理创建新<code>HTTP header</code>的接口。通过这个对象，<code>JSP</code>开发人员可以添加新的<code>cookie</code>和日期戳，<code>HTTP</code>状态码等。</p><p>我们可以使用以下的方法在<code>servlet</code>程序中设置<code>HTTP</code>响应头。这些方法可用于<code>HttpServletResponse</code>对象。次该对象表示服务器响应。</p><div class="table-container"><table><thead><tr><th style="text-align:center">Method</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td style="text-align:center"><code>String encodeRedirectURL(String url)</code></td><td style="text-align:center">对指定的<code>URL</code>进行编码以在<code>sendRedirect</code>方法中使用，如果不需要编码，则返回的<code>URL</code>不变</td></tr><tr><td style="text-align:center"><code>String encodeURL(String url)</code></td><td style="text-align:center">通过在其中包含<code>Session ID</code>来对指定的<code>URL</code>进行编码，如果不需要编码，则返回<code>URL</code>不变</td></tr><tr><td style="text-align:center"><code>boolean containsHeader(String name)</code></td><td style="text-align:center">返回一个<code>boolean</code>值，表明是否设置指定的响应头</td></tr><tr><td style="text-align:center"><code>boolean isCommitted()</code></td><td style="text-align:center">返回一个<code>boolean</code>，标明响应是否已提交</td></tr><tr><td style="text-align:center"><code>void addCookie(Cookie cookie)</code></td><td style="text-align:center">向响应中添加指定的<code>cookie</code></td></tr><tr><td style="text-align:center"><code>void addDateHeader(String name, long date)</code></td><td style="text-align:center">添加一个具有给定名称和日期值的响应<code>header</code></td></tr><tr><td style="text-align:center"><code>void addIntHeader(String name, int value)</code></td><td style="text-align:center">添加一个具有给定名称和<code>Integer</code>值的响应<code>header</code></td></tr><tr><td style="text-align:center"><code>vodi flushBuffer()</code></td><td style="text-align:center">强制将缓冲区中的任何内容写入到客户端</td></tr><tr><td style="text-align:center"><code>void reset()</code></td><td style="text-align:center">清楚缓冲中的所有数据以及状态码和<code>header</code></td></tr><tr><td style="text-align:center"><code>void resetBuffer()</code></td><td style="text-align:center">清楚响应中底层缓冲区中的内容，而不清楚<code>header</code>和状态码</td></tr><tr><td style="text-align:center"><code>void sendError(int sc, String msg)</code></td><td style="text-align:center">使用指定的状态码向客户端发送一个错误响应</td></tr><tr><td style="text-align:center"><code>void sendRedirect(String location)</code></td><td style="text-align:center">使用指定的重定向位置<code>URL</code>向客户端发送临时重定向响应</td></tr><tr><td style="text-align:center"><code>void setBufferSize(int size)</code></td><td style="text-align:center">设置响应正文的首选缓冲区的大小</td></tr><tr><td style="text-align:center"><code>void setCharacterEncoding(String charset)</code></td><td style="text-align:center">设置发送到客户端的响应的字符编码(MIME字符集)，例如： <code>UTF-8</code></td></tr><tr><td style="text-align:center"><code>void setContentLength(int len)</code></td><td style="text-align:center">在<code>HTTP servlet</code>中设置响应中内容主体的长度，此方法还设置HTTP<code>Content-Length</code> <code>header</code></td></tr><tr><td style="text-align:center"><code>void setContentType(String type)</code></td><td style="text-align:center">如果尚未提交响应，则设置发送到客户端响应的内容类型</td></tr><tr><td style="text-align:center"><code>void setDateHeader(String name, long date)</code></td><td style="text-align:center">设置具有给定名称和日期值的响应<code>header</code></td></tr><tr><td style="text-align:center"><code>void setHeader(String name, String value)</code></td><td style="text-align:center">设置具有给定名称和值的响应<code>header</code></td></tr><tr><td style="text-align:center"><code>void setIntHeader(String name, int value)</code></td><td style="text-align:center">设置具有给定名称和<code>int</code>值的响应<code>header</code></td></tr><tr><td style="text-align:center"><code>void setLocale(Locale loc)</code></td><td style="text-align:center">如果尚未提交响应，则设置响应的区域设置</td></tr><tr><td style="text-align:center"><code>void setStatus(int sc)</code></td><td style="text-align:center">设置该响应的状态码</td></tr></tbody></table></div><h3 id="HTTP-Header响应示例"><a href="#HTTP-Header响应示例" class="headerlink" title="HTTP Header响应示例"></a><code>HTTP Header</code>响应示例</h3><p>下面的示例将使用<code>setIntHeader()</code>方法设置<code>Refresh</code> <code>header</code>来模拟数字时钟。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page <span class="keyword">import</span> = <span class="string">"java.io.*, java.util.*"</span> %&gt;</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Auto Refresh Header Example&lt;/title&gt;</span><br><span class="line">        &lt;body&gt;</span><br><span class="line">        &lt;center&gt;</span><br><span class="line">            &lt;h2&gt;Auto Refresh Header Example&lt;/h2&gt;</span><br><span class="line">                &lt;%</span><br><span class="line">                <span class="comment">// Set refresh, autoload time as 5 seconds</span></span><br><span class="line">                    response.setIntHeader(<span class="string">"Refresh"</span>, <span class="number">5</span>);</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// Get current time</span></span><br><span class="line">                    Calendar clendar = <span class="keyword">new</span> Gregoriancalendar();</span><br><span class="line">                    String am_pm;</span><br><span class="line">                    <span class="keyword">int</span> hour = calendar.get(Calendar.HOUR);</span><br><span class="line">                    <span class="keyword">int</span> minute = alendar.get(Calendar.MINUTE);</span><br><span class="line">                    <span class="keyword">int</span> second = calendar.get(Calendar.SECOND);</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span> (calendar.get(Calendar.AM_PM == <span class="number">0</span>)</span><br><span class="line">                    am_pm = <span class="string">"AM"</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    am_pm = <span class="string">"PM"</span>;</span><br><span class="line">                    String CT = hour + <span class="string">":"</span> + minute + <span class="string">":"</span> + second + <span class="string">" "</span> + am_pm;</span><br><span class="line">                    out.println(<span class="string">"Current Time is: "</span> + CT + <span class="string">"\n"</span>);</span><br><span class="line">                %&gt;</span><br><span class="line">            &lt;/center&gt;</span><br><span class="line">        &lt;/body&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>运行结果:(每隔5秒刷新页面)</p><p><img src="responseHeader.png" alt=""></p><h2 id="Http-状态码-Status-Codes"><a href="#Http-状态码-Status-Codes" class="headerlink" title="Http 状态码(Status Codes)"></a>Http 状态码(Status Codes)</h2><p>下面我们将在<code>JSP</code>范围内讨论<code>HTTP</code>状态码。HTTP请求的格式和HTTP响应消息类似，具有如下结构:</p><ol><li>初始状态行 + <code>CRLF</code>(回车符+换行符，即新行)</li><li>零个或多个<code>header</code>行 + <code>CRLF</code></li><li>一个空行，即一个<code>CRLF</code></li><li>可选的消息体，如文件，查询数据或查询输出</li></ol><p>例如，一个服务器响应<code>header</code>可能是下面这样子的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Header2: ...</span><br><span class="line">...</span><br><span class="line">HeaderN: ...</span><br><span class="line">   (Blank Line)</span><br><span class="line">&lt;!doctype ...&gt;</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">   &lt;head&gt;...&lt;/head&gt;</span><br><span class="line">   </span><br><span class="line">   &lt;body&gt;</span><br><span class="line">      ...</span><br><span class="line">   &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>状态行包含了<code>HTTP</code>的版本（HTTP/1.1）, 状态码(200)，以及一条非常短的消息对应着状态码.</p><p>下面的表格列出了Web服务器可能返回的状态码及其对应的消息:</p><div class="table-container"><table><thead><tr><th style="text-align:center">Code</th><th style="text-align:center">Message</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td style="text-align:center">100</td><td style="text-align:center">Continue</td><td style="text-align:center">服务器只收到请求的一部分，但只要它没有别拒绝，客户端就应该继续请求</td></tr><tr><td style="text-align:center">101</td><td style="text-align:center">Switching Protocols</td><td style="text-align:center">服务器切换协议</td></tr><tr><td style="text-align:center">200</td><td style="text-align:center">OK</td><td style="text-align:center">表示请求没有问题</td></tr><tr><td style="text-align:center">201</td><td style="text-align:center">Created</td><td style="text-align:center">请求已完成，并且已创建新资源</td></tr><tr><td style="text-align:center">202</td><td style="text-align:center">Accepted</td><td style="text-align:center">请求被接受并在处理中，但处理还未完成</td></tr><tr><td style="text-align:center">203</td><td style="text-align:center">Non-authoritative<br>Information</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">204</td><td style="text-align:center">No Content</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">205</td><td style="text-align:center">Reset Content</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">206</td><td style="text-align:center">Partial Content</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">300</td><td style="text-align:center">Multiple Choices</td><td style="text-align:center">一个链接列表，用户可以选择一个链接并转到该位置。最多五个地址</td></tr><tr><td style="text-align:center">301</td><td style="text-align:center">Moved Permanently</td><td style="text-align:center">请求的页面被永久地移动到一个新的url</td></tr><tr><td style="text-align:center">302</td><td style="text-align:center">Found</td><td style="text-align:center">请求的页面被临时地移动到一个新的url</td></tr><tr><td style="text-align:center">303</td><td style="text-align:center">See Other</td><td style="text-align:center">请求的页面可以在不同的url中找到</td></tr><tr><td style="text-align:center">304</td><td style="text-align:center">Not Modified</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">305</td><td style="text-align:center">Use Proxy</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">306</td><td style="text-align:center">Unused</td><td style="text-align:center">此状态码用于以前的HTTP版本。它已经不再使用，但被保留了下来</td></tr><tr><td style="text-align:center">307</td><td style="text-align:center">Temporary Redirect</td><td style="text-align:center">请求的也main暂时移动到新的url</td></tr><tr><td style="text-align:center">400</td><td style="text-align:center">Bad Request</td><td style="text-align:center">服务器无法解析请求</td></tr><tr><td style="text-align:center">401</td><td style="text-align:center">Unauthorized</td><td style="text-align:center">请求的页面需要一个用户名和密码</td></tr><tr><td style="text-align:center">402</td><td style="text-align:center">Payment Required</td><td style="text-align:center">此状态码已能使用</td></tr><tr><td style="text-align:center">403</td><td style="text-align:center">Forbidden</td><td style="text-align:center">请求的页面禁止访问</td></tr><tr><td style="text-align:center">404</td><td style="text-align:center">Not Found</td><td style="text-align:center">请求页面找不到</td></tr><tr><td style="text-align:center">405</td><td style="text-align:center">Method Not Allowed</td><td style="text-align:center">请求方法不允许</td></tr><tr><td style="text-align:center">406</td><td style="text-align:center">Not Acceptable</td><td style="text-align:center">服务器只能生成客户端不能接收的响应</td></tr><tr><td style="text-align:center">407</td><td style="text-align:center">Proxy Authentication<br>Required</td><td style="text-align:center">在提供此请求之前，必须使用代理服务器进行身份验证</td></tr><tr><td style="text-align:center">408</td><td style="text-align:center">Request Timeout</td><td style="text-align:center">请求花费的时间比服务器准备等待的时间长</td></tr><tr><td style="text-align:center">409</td><td style="text-align:center">Conflict</td><td style="text-align:center">由于冲突，请求无法完成</td></tr><tr><td style="text-align:center">410</td><td style="text-align:center">Gone</td><td style="text-align:center">请求页面不再可达</td></tr><tr><td style="text-align:center">411</td><td style="text-align:center">Length Required</td><td style="text-align:center"><code>Content-Length</code> <code>header</code>没有定义，服务器不接收该请求</td></tr><tr><td style="text-align:center">412</td><td style="text-align:center">PreCondition Failed</td><td style="text-align:center">请求中给出的前提条件有服务器评估为<code>false</code></td></tr><tr><td style="text-align:center">413</td><td style="text-align:center">Request Entity Too<br>Large</td><td style="text-align:center">服务器不接受请求，因为请求实体太大</td></tr><tr><td style="text-align:center">414</td><td style="text-align:center">Request-url Too Long</td><td style="text-align:center">服务器不接受该请求，因为请求的url过长。这通过出现在将<code>post</code>改为<code>get</code>请求的情况下</td></tr><tr><td style="text-align:center">415</td><td style="text-align:center">Unsupported Media Type</td><td style="text-align:center">服务器不接受请求，由于媒体类型不支持</td></tr><tr><td style="text-align:center">417</td><td style="text-align:center">Expectation Failed</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">500</td><td style="text-align:center">Internal Server Error</td><td style="text-align:center">请求未完成。服务器遇到意外情况</td></tr><tr><td style="text-align:center">501</td><td style="text-align:center">Not Implemented</td><td style="text-align:center">请求未完成。服务器对请求的需求体提供支持</td></tr><tr><td style="text-align:center">502</td><td style="text-align:center">Bad Gateway</td><td style="text-align:center">请求未完成。服务器从上游服务器收到无效响应</td></tr><tr><td style="text-align:center">503</td><td style="text-align:center">Service Unavailable</td><td style="text-align:center">请求未完成。服务器暂时超载或关闭</td></tr><tr><td style="text-align:center">504</td><td style="text-align:center">Gateway Timeout</td><td style="text-align:center">网关已超时</td></tr><tr><td style="text-align:center">505</td><td style="text-align:center">HTTP Version Not<br>Supported</td><td style="text-align:center">服务器不支持该<code>HTTP</code>协议版本</td></tr></tbody></table></div><h3 id="设置HTTP状态码的方法"><a href="#设置HTTP状态码的方法" class="headerlink" title="设置HTTP状态码的方法"></a>设置HTTP状态码的方法</h3><p>我们可以使用<code>HttpServletResponse</code>对象下面的这些方法在<code>servlet</code>程序中设置<code>HTTP</code>状态码。</p><div class="table-container"><table><thead><tr><th style="text-align:center">Method</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td style="text-align:center"><code>public void setStatus(int statusCode)</code></td><td style="text-align:center">该方法可以设置任意状态代码。<code>int</code>(状态代码)作为参数.如果响波包含特殊状态代码和文档，务必使用<code>PrintWriter</code>实际返回任何内容之前调用<code>setStatus</code>方法</td></tr><tr><td style="text-align:center"><code>public void sendRedirect(String url)</code></td><td style="text-align:center">该方法生成一个302响应以及提供新文档的URL的<code>Location</code> <code>header</code></td></tr><tr><td style="text-align:center"><code>public void sendError(int code, String message)</code></td><td style="text-align:center">此方法发送状态代码(通常为404)以及在HTML文档中自动格式化并发送到客户端的短消息</td></tr></tbody></table></div><h3 id="HTTP状态码示例"><a href="#HTTP状态码示例" class="headerlink" title="HTTP状态码示例"></a>HTTP状态码示例</h3><p>下面的例子使用<code>setError()</code>方法向客户端发送<code>403</code>状态代码以及短消息<code>Forbidden</code>.</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">   &lt;head&gt;</span><br><span class="line">      &lt;title&gt;Setting HTTP Status Code&lt;/title&gt;</span><br><span class="line">   &lt;/head&gt;</span><br><span class="line">   </span><br><span class="line">   &lt;body&gt;</span><br><span class="line">      &lt;%</span><br><span class="line">         <span class="comment">// Set error code and reason.</span></span><br><span class="line">         response.sendError(<span class="number">403</span>, <span class="string">"Forbidden"</span> );</span><br><span class="line">      %&gt;</span><br><span class="line">   &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>页面运行结果:</p><p><img src="forbidden.png" alt=""></p><h2 id="表单处理-Form-Handling"><a href="#表单处理-Form-Handling" class="headerlink" title="表单处理(Form Handling)"></a>表单处理(Form Handling)</h2><p>这里我们主要讨论在<code>JSP</code>中的表单处理。当我们需要将某些信息从浏览器传递到Web服务器并最终传递到后端程序时，肯定会遇到很多情况。浏览器使用两种方法将此信息传递给Web服务器。即<code>POST</code>和<code>GET</code>方法。</p><h3 id="表单处理的方法"><a href="#表单处理的方法" class="headerlink" title="表单处理的方法"></a>表单处理的方法</h3><h4 id="GET-方法"><a href="#GET-方法" class="headerlink" title="GET 方法"></a>GET 方法</h4><p><code>GET</code>方法发送附加到页面请求的以编码的用户信息。页面和编码信息由<code>?</code>分隔。格式如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.test.com/hello?key1=value1&amp;key2=value2</span><br></pre></td></tr></table></figure><p><code>GET</code>方法是将信息从浏览器传递到Web服务器的默认方法，它会生成一个长字符串，显示在浏览器的地址栏中。</p><p><code>GET</code>方法生成的字符长有大小限制，<strong>请求的字符串中只能包含1024个字符。</strong></p><p>此信息使用<code>QUERY_STRING</code> <code>header</code>传递，并且可以通过<code>QUERY_STRING</code>环境变量访问，该变量可以使用<code>request</code>对象的<code>getQueryString()</code>和<code>getParameter()</code>方法进行处理。</p><h4 id="POST-方法"><a href="#POST-方法" class="headerlink" title="POST 方法"></a>POST 方法</h4><p>将信息传递给后端程序的一般更可靠的方法是<code>POST</code>方法。该方法以与<code>GET</code>方法完全相同的方式打包信息，但不是将其作为以<code>?</code>组成的文本字符串发送，而是作为单独的消息发送。传递消息以标准输入的形式提供给后端程序，服务器可以解析并用于处理。</p><p><code>JSP</code>使用<code>getParameter()</code>方法处理此类请求以读取简单参数，并使用<code>getInputStream()</code>方法读取来自客户端的二进制数据流。</p><h4 id="使用JSP读取表单数据"><a href="#使用JSP读取表单数据" class="headerlink" title="使用JSP读取表单数据"></a>使用JSP读取表单数据</h4><p><code>JSP</code>可以根据具体情况使用一下的方法自动处理表单数据并进行解析 -</p><ul><li><code>getParameter()</code> - 可以调用<code>request.getParameter()</code>方法来读取一个表单数据的对应值;</li><li><code>getParameterValues()</code> - 如果参数出现多次并返回多个值(例如复选框)可以调用此方法;</li><li><code>getParameterNames()</code> - 如果需要获取当前请求中的所有参数的完整列表，可以调用此方法;</li><li><code>getIntputStream()</code> - 调用此方法可以同客户端读取二进制数据.</li></ul><h4 id="GET-使用示例-使用URL的方式"><a href="#GET-使用示例-使用URL的方式" class="headerlink" title="GET 使用示例(使用URL的方式)"></a>GET 使用示例(使用URL的方式)</h4><p>下面的URL会向<code>getMethodTest.jsp</code>页面传递两个值，通过<code>GET</code>的方式 -</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/getMethodTest.jsp?username=rovo98&amp;msg=hello</span><br></pre></td></tr></table></figure><p>下面的<code>getMethodTest.jsp</code>页面使用<code>getParameter()</code>方法来处理传递过来的数据 -</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Using GET Method to Read Form Data&lt;/title&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;Using GET Method to Read Form Data&lt;/h1&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">        &lt;li&gt;&lt;p&gt;&lt;b&gt;Username:&lt;/b&gt;</span><br><span class="line">            &lt;%= request.getParameter(<span class="string">"username"</span>)%&gt;</span><br><span class="line">            &lt;/p&gt;&lt;/li&gt;</span><br><span class="line">            &lt;li&gt;&lt;p&gt;&lt;b&gt;Message:&lt;/b&gt;</span><br><span class="line">            &lt;%= request.getParameter(<span class="string">"msg"</span>)%&gt;</span><br><span class="line">            &lt;/p&gt;&lt;/li&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>在浏览器的地址栏中输入上面的URL，即可获得结果:</p><p><img src="getMethodTest.png" alt=""></p><h4 id="GET-方法示例-使用表单提交方式"><a href="#GET-方法示例-使用表单提交方式" class="headerlink" title="GET 方法示例(使用表单提交方式)"></a>GET 方法示例(使用表单提交方式)</h4><p>下面的例子是通过HTML的表单向上面的<code>getMethodTest.jsp</code>传递同样的两个参数 -</p><p><code>main.jsp</code>:<br><br></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form action=<span class="string">"getMethodTest.jsp"</span> method=<span class="string">"GET"</span> &gt;</span><br><span class="line">    Username: &lt;input type=<span class="string">"text"</span> name=<span class="string">"username"</span> /&gt;&lt;br /&gt;</span><br><span class="line">        Message: &lt;input type=<span class="string">"text"</span> name=<span class="string">"msg"</span> /&gt;</span><br><span class="line">        &lt;input type=<span class="string">"submit"</span> value=<span class="string">"Submit"</span> /&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p></p><p>运行成功的话，应该可以得到和上面同样的结果。</p><h4 id="POST-方法示例"><a href="#POST-方法示例" class="headerlink" title="POST 方法示例"></a>POST 方法示例</h4><p>修改一下上面的<code>main.jsp</code>页面以使用<code>POST</code>请求方法，实际上，修改后和之前的<code>JSP</code>没有多大区别，只是传递参数方法发生改变而已，在没有传递二进制数据的情况下。</p><p><code>getAndPostMethod.jsp</code>:<br><br></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Using GET and POST Method to Read Form Data&lt;/title&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">    &lt;h1&gt;Using POST Method to Read Form Data&lt;/h1&gt;</span><br><span class="line">        </span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">        &lt;li&gt;&lt;p&gt;&lt;b&gt;Username: &lt;/b&gt;</span><br><span class="line">            &lt;%= request.getParameter(<span class="string">"username"</span>) %&gt;</span><br><span class="line">            &lt;/p&gt;&lt;/li&gt;</span><br><span class="line">            &lt;li&gt;&lt;p&gt;&lt;b&gt;Message: &lt;/b&gt;</span><br><span class="line">            &lt;%= request.getParameter(<span class="string">"msg"</span>)%&gt;</span><br><span class="line">            &lt;/p&gt;&lt;/li&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p></p><p>修改后的<code>main.jsp</code>文件 -</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;form action=<span class="string">"getAndPostMethod.jsp"</span> method = <span class="string">"POST"</span>&gt;</span><br><span class="line">        Username: &lt;input type = <span class="string">"text"</span> name = <span class="string">"username"</span> /&gt;&lt;br /&gt;</span><br><span class="line">            Message: &lt;input type = <span class="string">"text"</span> name = <span class="string">"msg"</span> /&gt;</span><br><span class="line">            &lt;input type=<span class="string">"submit"</span> value = <span class="string">"Submit"</span> /&gt;</span><br><span class="line">        &lt;/form&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>运行结果与之前的<code>GET</code>请求方法得到的结果类似。</p><h4 id="向JSP程序传递复选框数据"><a href="#向JSP程序传递复选框数据" class="headerlink" title="向JSP程序传递复选框数据"></a>向JSP程序传递复选框数据</h4><p>当需要选择多个选项时，我们通常会在页面中使用复选框(checkbox)。以下是一个示例HTML代码<code>checkBox.html</code>，其中有包含两个复选框的表单 -</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"checkbox.jsp"</span> <span class="attr">method</span>=<span class="string">"POST"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"maths"</span> <span class="attr">checked</span>=<span class="string">"checked"</span> /&gt;</span>Maths</span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"physics"</span> /&gt;</span>Physics</span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span> = <span class="string">"chemistry"</span> <span class="attr">checked</span>=<span class="string">"checked"</span> /&gt;</span> Chemistry</span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"Select Subject"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>页面显示如下 -</p><p><img src="checkbox_forTest.png" alt=""></p><p>用于接受数据的<code>JSP</code>页面 <code>checkbox.jsp</code> -</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Reading Checkbox Data &lt;/title&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">    &lt;h1&gt;Reading Checkbox Data&lt;/h1&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">        &lt;li&gt;&lt;p&gt;&lt;b&gt;Maths Flag:&lt;/b&gt;</span><br><span class="line">            &lt;$= request.getParameter(<span class="string">"maths"</span>)%&gt;</span><br><span class="line">            &lt;/p&gt;&lt;/li&gt;</span><br><span class="line">            &lt;li&gt;&lt;p&gt;&lt;b&gt;Physics Flag:&lt;/b&gt;</span><br><span class="line">            &lt;$= request.getParameter(<span class="string">"physics"</span>)%&gt;</span><br><span class="line">            &lt;/p&gt;&lt;/li&gt;</span><br><span class="line">            &lt;li&gt;&lt;p&gt;&lt;b&gt;Chemistry Flag:&lt;/b&gt;</span><br><span class="line">            &lt;$= request.getParameter(<span class="string">"chemistry"</span>)%&gt;</span><br><span class="line">            &lt;/p&gt;&lt;/li&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>运行结果如下 -</p><p><img src="readingCheckboxData.png" alt=""></p><h4 id="读取所有表单参数"><a href="#读取所有表单参数" class="headerlink" title="读取所有表单参数"></a>读取所有表单参数</h4><p>下面是一个通用的示例，使用<code>HttpServletRequest</code>的<code>getParameterNames()</code>方法来读取所有可用的表单参数。此方法返回一个<code>Enumeration</code>对象，其中包含未指定顺序的参数名称。</p><p>在获得<code>Enumeration</code>对象后，我们可以通过循环的方式依次打印参数内容。</p><p><code>allParameters.jsp</code> -</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page <span class="keyword">import</span> = <span class="string">"java.io.*,java.util.*"</span> %&gt;</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Reading All Parameters&lt;/title&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">    &lt;center&gt;</span><br><span class="line">        &lt;h2&gt;Reading All Parameters&lt;/h2&gt;</span><br><span class="line">            &lt;table width = <span class="string">"100%"</span> border = <span class="string">"1"</span> align = <span class="string">"center"</span>&gt;</span><br><span class="line">            &lt;tr bgcolor = <span class="string">"$949494"</span>&gt;</span><br><span class="line">                &lt;th&gt;Param Name&lt;/th&gt;</span><br><span class="line">                    &lt;th&gt;<span class="function">Param <span class="title">Value</span><span class="params">(s)</span>&lt;/th&gt;</span></span><br><span class="line"><span class="function">                &lt;/tr&gt;</span></span><br><span class="line"><span class="function">                &lt;%</span></span><br><span class="line"><span class="function">                Enumeration paramNames </span>= request.getParameterNames();</span><br><span class="line">                    <span class="keyword">while</span> (paramNames.hasMoreElements()) &#123;</span><br><span class="line">                    String paramName = (String)paramNames.nextElement();</span><br><span class="line">                        out,print(<span class="string">"&lt;tr&gt;&lt;td&gt;"</span> + paramName + <span class="string">"&lt;/td&gt;\n"</span>);</span><br><span class="line">                        String paramValue = request.getParameter(paramName);</span><br><span class="line">                        out.println(<span class="string">"&lt;td&gt;"</span> + paramValue + <span class="string">"&lt;/td&gt;&lt;/tr&gt;\n"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                %&gt;</span><br><span class="line">            &lt;/table&gt;</span><br><span class="line">        &lt;/center&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>请求页面使用之前的复选框页面 - <code>checkBox.html</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">      </span><br><span class="line">      <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span> = <span class="string">"main.jsp"</span> <span class="attr">method</span> = <span class="string">"POST"</span> <span class="attr">target</span> = <span class="string">"_blank"</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">"checkbox"</span> <span class="attr">name</span> = <span class="string">"maths"</span> <span class="attr">checked</span> = <span class="string">"checked"</span> /&gt;</span> Maths</span><br><span class="line">         <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">"checkbox"</span> <span class="attr">name</span> = <span class="string">"physics"</span>  /&gt;</span> Physics</span><br><span class="line">         <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">"checkbox"</span> <span class="attr">name</span> = <span class="string">"chemistry"</span> <span class="attr">checked</span> = <span class="string">"checked"</span> /&gt;</span> Chem</span><br><span class="line">         <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">"submit"</span> <span class="attr">value</span> = <span class="string">"Select Subject"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">   </span><br><span class="line">   <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行测试结果如下 -</p><p><img src="readingAllParams.png" alt=""></p><h2 id="过滤器-Filters"><a href="#过滤器-Filters" class="headerlink" title="过滤器(Filters)"></a>过滤器(Filters)</h2><h2 id="Cookies-处理-Cookies-Handing"><a href="#Cookies-处理-Cookies-Handing" class="headerlink" title="Cookies 处理(Cookies Handing)"></a>Cookies 处理(Cookies Handing)</h2><h2 id="Session-跟踪-Session-Tracking"><a href="#Session-跟踪-Session-Tracking" class="headerlink" title="Session 跟踪(Session Tracking)"></a>Session 跟踪(Session Tracking)</h2><h2 id="文件上传-File-Uploading"><a href="#文件上传-File-Uploading" class="headerlink" title="文件上传(File Uploading)"></a>文件上传(File Uploading)</h2><h2 id="日期处理-Handing-Date"><a href="#日期处理-Handing-Date" class="headerlink" title="日期处理(Handing Date)"></a>日期处理(Handing Date)</h2><h2 id="页面重定向-Page-Redirect"><a href="#页面重定向-Page-Redirect" class="headerlink" title="页面重定向(Page Redirect)"></a>页面重定向(Page Redirect)</h2><h2 id="自动刷新-Auto-Refresh"><a href="#自动刷新-Auto-Refresh" class="headerlink" title="自动刷新(Auto Refresh)"></a>自动刷新(Auto Refresh)</h2><h2 id="发送邮件-Sending-Mail"><a href="#发送邮件-Sending-Mail" class="headerlink" title="发送邮件(Sending Mail)"></a>发送邮件(Sending Mail)</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/jsp基础学习/JSP.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;Java 服务器页面(jsp) 是用来开发动态页面的一项技术。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaWeb" scheme="http://rovo98.github.io/categories/JavaWeb/"/>
    
      <category term="JSP" scheme="http://rovo98.github.io/categories/JavaWeb/JSP/"/>
    
    
      <category term="学习笔记" scheme="http://rovo98.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="jsp" scheme="http://rovo98.github.io/tags/jsp/"/>
    
  </entry>
  
  <entry>
    <title>CSS 基础学习</title>
    <link href="http://rovo98.github.io/posts/c452f057/"/>
    <id>http://rovo98.github.io/posts/c452f057/</id>
    <published>2017-04-12T04:00:00.000Z</published>
    <updated>2018-07-20T07:58:33.886Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/css基础学习/css.jpg" alt=""></p><p>层叠样式表(<strong>C</strong>ascading <strong>S</strong>tyle <strong>S</strong>heets),简称<code>CSS</code>, 是一种简单的设计语言，旨在简化是网页呈现的过程。</p><a id="more"></a><p><code>CSS</code>处理网页的外观部分。使用<code>CSS</code>，可以控制文本的颜色，字体的样式，段落的间距，列的大小和布局，使用的背景图像和颜色，布局设计，不同的设备的显示变化和屏幕尺寸以及的其他各种影响。</p><p><code>CSS</code>易于学习和理解，但它提供了对<code>HTML</code>文档的强大控制。<code>CSS</code>一般与标记语言<code>HTML</code>或<code>XHTML</code>结合使用。</p><h2 id="概述-Introduction"><a href="#概述-Introduction" class="headerlink" title="概述(Introduction)"></a>概述(Introduction)</h2><h3 id="一、CSS-的优点"><a href="#一、CSS-的优点" class="headerlink" title="一、CSS 的优点"></a>一、CSS 的优点</h3><ul><li><strong>节省时间</strong> - 我们可以编写一次<code>CSS</code>，然后在多个<code>HTML</code>页面中重复使用相同的样式表。可以为每个<code>HTML</code>元素定义样式，并将其应用于任意数量的Web页面中;</li><li><strong>页面加载更快</strong> - 如果使用<code>CSS</code>，则不需要每次都编写<code>HTML</code>的标签属性。只需要编写一个标签的<code>CSS</code>规则并将其应用于该标签的所有实例中。因此代码越少意味着加载的速度会变快;</li><li><strong>易于维护</strong> - 要进行全局更改，只需要更改样式，所有网页中的所有元素都将自动更新;</li><li><strong>HTML的高级风格</strong> - <code>CSS</code>具有比<code>HTML</code>更广泛的属性，因此与<code>HTML</code>属性相比，可以更好地渲染页面;</li><li><strong>多设备兼容性</strong> - 样式表允许针对多种类型的设备优化内容。通过使用相同的<code>HTMl</code>文档，可以为诸如<em>PDA</em>和<em>手机</em>之类的手持设备呈现不同版本的网站或用于打印;</li><li><strong>全球Web标准</strong> - 现在<code>HTML</code>属性已被弃用，建议使用<code>CSS</code>。因此，最好在所有<code>HTML</code>页面中开始使用<code>CSS</code>,以使它们与未来的浏览器兼容;</li><li><strong>离线浏览</strong> - <code>CSS</code>可以在离线<code>catche</code>的帮助下在本地缓存Web应用程序。使用此功能，我们可以查看离线网站。缓存还可以确保更快的加载速度和更好的网站整体性能;</li><li><strong>平台独立性</strong> - 脚本提供一致的平台独立性，也可以支持最新的浏览器.</li></ul><h3 id="二、谁创建和维护CSS"><a href="#二、谁创建和维护CSS" class="headerlink" title="二、谁创建和维护CSS?"></a>二、谁创建和维护CSS?</h3><p><code>CSS</code>是由<em>HåkonWiumLie</em>于1994年10月10日发明的，由W3c内的一组人员(称为CSS工作组)维护。<code>CSS</code>工作组创建称为规范(<strong>specifications</strong>)的文档，当<code>W3C</code>成员讨论并正式批准规范时，它就成为了建议(<strong>recommendation</strong>)。</p><p><strong>NOTE</strong> - 万维网联盟(<code>W3C</code>)是一个小组，就互联网如何运作以及互联网如何发展提出建议。</p><h3 id="三、CSS-的版本"><a href="#三、CSS-的版本" class="headerlink" title="三、CSS 的版本"></a>三、CSS 的版本</h3><p><code>CSS1</code>层叠样式表在1996年1月作为建议(<strong>recommendation</strong>)出自<code>W3C</code>。该版本描述了<code>CSS</code>语言以及所有<code>HTML</code>标签的简单可视化模型。</p><p><code>CSS2</code>于1998年5月成为<code>W3C</code>建议标准，并以<code>CSS1</code>为基础。此版本增加了对媒体特定样式表的支持，例如打印机和听觉设备，可下载字体，元素定位和表格。</p><p><code>CSS3</code>与1999年6月成为<code>W3C</code>建议，并以旧版<code>CSS</code>为基础。它分为文档，称为模块，这里每个模块都有<code>CSS2</code>中定义的新扩展功能。</p><h4 id="CSS3-模块"><a href="#CSS3-模块" class="headerlink" title="CSS3 模块"></a>CSS3 模块</h4><p><code>CSS3</code>模块具有旧版的<code>CSS</code>规范以及扩展功能 -</p><ul><li>选择器 (Selectors)</li><li>盒子模型 (Box Model)</li><li>背景和边框 (Backgrounds and Borders)</li><li>图像值和替换内容 (Image Values and Replaced Content)</li><li>文本效果 (Text Effects)</li><li>2D/3D转换 (2D/3D Transformations)</li><li>动画 (Animations)</li><li>多列布局 (Multiple Column Layout)</li><li>用户界面 (User Interface)</li></ul><h2 id="语法-Syntax"><a href="#语法-Syntax" class="headerlink" title="语法(Syntax)"></a>语法(Syntax)</h2><h2 id="CSS使用方式-Inclusion"><a href="#CSS使用方式-Inclusion" class="headerlink" title="CSS使用方式(Inclusion)"></a>CSS使用方式(Inclusion)</h2><h2 id="测量单位-Measurement-Units"><a href="#测量单位-Measurement-Units" class="headerlink" title="测量单位(Measurement Units)"></a>测量单位(Measurement Units)</h2><h2 id="颜色-Colors"><a href="#颜色-Colors" class="headerlink" title="颜色(Colors)"></a>颜色(Colors)</h2><h2 id="背景-Backgrouds"><a href="#背景-Backgrouds" class="headerlink" title="背景(Backgrouds)"></a>背景(Backgrouds)</h2><h2 id="字体-Fonts"><a href="#字体-Fonts" class="headerlink" title="字体(Fonts)"></a>字体(Fonts)</h2><h2 id="文本-Text"><a href="#文本-Text" class="headerlink" title="文本(Text)"></a>文本(Text)</h2><h2 id="图像-Images"><a href="#图像-Images" class="headerlink" title="图像(Images)"></a>图像(Images)</h2><h2 id="链接-Links"><a href="#链接-Links" class="headerlink" title="链接(Links)"></a>链接(Links)</h2><h2 id="表格-Tables"><a href="#表格-Tables" class="headerlink" title="表格(Tables)"></a>表格(Tables)</h2><h2 id="边框-Borders"><a href="#边框-Borders" class="headerlink" title="边框(Borders)"></a>边框(Borders)</h2><h2 id="外边距-Margins"><a href="#外边距-Margins" class="headerlink" title="外边距(Margins)"></a>外边距(Margins)</h2><h2 id="列表-Lists"><a href="#列表-Lists" class="headerlink" title="列表(Lists)"></a>列表(Lists)</h2><h2 id="内边距-Padding"><a href="#内边距-Padding" class="headerlink" title="内边距(Padding)"></a>内边距(Padding)</h2><h2 id="游标-Cursors"><a href="#游标-Cursors" class="headerlink" title="游标(Cursors)"></a>游标(Cursors)</h2><h2 id="纲要-Outlines"><a href="#纲要-Outlines" class="headerlink" title="纲要(Outlines)"></a>纲要(Outlines)</h2><h2 id="尺寸-Dimension"><a href="#尺寸-Dimension" class="headerlink" title="尺寸(Dimension)"></a>尺寸(Dimension)</h2><h2 id="滚动条-Scrollbars"><a href="#滚动条-Scrollbars" class="headerlink" title="滚动条(Scrollbars)"></a>滚动条(Scrollbars)</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/css基础学习/css.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;层叠样式表(&lt;strong&gt;C&lt;/strong&gt;ascading &lt;strong&gt;S&lt;/strong&gt;tyle &lt;strong&gt;S&lt;/strong&gt;heets),简称&lt;code&gt;CSS&lt;/code&gt;, 是一种简单的设计语言，旨在简化是网页呈现的过程。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaWeb" scheme="http://rovo98.github.io/categories/JavaWeb/"/>
    
      <category term="Web Basic" scheme="http://rovo98.github.io/categories/JavaWeb/Web-Basic/"/>
    
      <category term="CSS" scheme="http://rovo98.github.io/categories/JavaWeb/Web-Basic/CSS/"/>
    
    
      <category term="web dev" scheme="http://rovo98.github.io/tags/web-dev/"/>
    
  </entry>
  
  <entry>
    <title>HTML5 基础学习</title>
    <link href="http://rovo98.github.io/posts/9f461f83/"/>
    <id>http://rovo98.github.io/posts/9f461f83/</id>
    <published>2017-04-11T04:00:00.000Z</published>
    <updated>2018-07-20T11:52:33.330Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/html5基础学习/html5.jpg" alt=""></p><p><code>HTML5</code>是取代<code>HTML4.01</code>, <code>XHTML 1.0</code>和<code>XHTML 1.1</code>的HTML标准的下一个主要修订版。<code>HTML5</code>是在万维网上构建和呈现内容的标准。<br><a id="more"></a></p><h2 id="概述-Overview"><a href="#概述-Overview" class="headerlink" title="概述 (Overview)"></a>概述 (Overview)</h2><p><code>HTML5</code>是万维网联盟(World Wide Web Consortium, W3C)和Web超文本应用技术工作组(Web Hypertext Application Technology Working Group, WHATWG)合作的成果。</p><p>新标准包含了以前依赖于第三方浏览器插件(如： <em>Adobe Flash, Microsoft Sliverlight</em> 和 <em>Google Gears</em>)的视频播放和拖放等功能。</p><h3 id="一、浏览器支持"><a href="#一、浏览器支持" class="headerlink" title="一、浏览器支持"></a>一、浏览器支持</h3><p><em>Apple Safari, Google Chrome, Mozilla Firefox</em>和<em>Opera</em>的最新版本都支持许多<code>HTML5</code>功能，<em>Internet explorer 9.0</em>也支持某些<code>HTML5</code>功能。</p><p>预装在<em>Iphone, iPad</em>和<em>Android</em>手机上的移动网络浏览器都对<code>HTML5</code>提供了出色的支持。</p><h3 id="二、新特性"><a href="#二、新特性" class="headerlink" title="二、新特性"></a>二、新特性</h3><p><code>HTML5</code>引入了许多新元素和属性，可以帮助我们构建现代网站。以下是<code>HTML5</code>引入的一些最突出的功能.</p><ul><li><strong>新的语义元素(Semantic Elements)</strong> - 例如: <code>&lt;header&gt;, &lt;footer&gt;</code>和<code>&lt;section&gt;</code>等；</li><li><strong>表单2.0</strong> - 对HTML的网页表单的改进，其中为<code>&lt;input&gt;</code>标签引入了新属性;</li><li><strong>持久本地存储(Persistent Local Storage)</strong> - 无需借助第三方插件即可实现;</li><li><strong>WebSocket</strong> - 用于Web应用程序的下一代双向通信技术;</li><li><strong>服务器发送事件(Server sent Events)</strong> - <code>HTML5</code>引入了从Web服务器流向Web浏览器的事件，它们被称为<em>Server-Sent-Events(SSE)</em>;</li><li><strong>画布(Canvas)</strong> - 支持二维绘图，可以使用<code>Javascript</code>进行编程;</li><li><strong>声音&amp;视频(Audio&amp;Video)</strong> - 不需要使用第三方插件，就可以在网页中嵌入音频或视频;</li><li><strong>地理位置(Geolocation)</strong> - 网页的浏览者可以选择与Web应用程序共享物理位置;</li><li><strong>微数据(Microdata)</strong> - 这使得我们可以在<code>HTML5</code>之外创建自己的词汇变,并使用自定义的语义元素来扩展网页;</li><li><strong>拖放(Drag&amp;Drop)</strong> - 将项目从一个位置拖放到同一网页的另一个位置.</li></ul><h3 id="三、向后兼容性"><a href="#三、向后兼容性" class="headerlink" title="三、向后兼容性"></a>三、向后兼容性</h3><p><code>HTML5</code>尽可能设计为与现有Web浏览器向后兼容。它的新功能基于现有功能，允许为旧版浏览器提供后背内容。</p><p>使用<code>HTML5</code>时，建议使用几行<code>Javascript</code>代码检测对各个<code>HTML5</code>功能的支持。</p><h2 id="语法-Syntax"><a href="#语法-Syntax" class="headerlink" title="语法 (Syntax)"></a>语法 (Syntax)</h2><p><code>HTML5</code>具有“自定义”HTML语法，该语法与Web上发布的<code>HTML4</code>和<code>xHTML 1</code>文档兼容，但是与<code>HTML4</code>的更深奥的<code>SGML</code>功能不兼容。</p><p><code>HTML5</code>与<code>XHTML</code>没有相同的语法规则，<code>XHTML</code><strong>需要小写标签名称，属性需要用引号括起来，属性必须有一个值并关闭所有的空元素</strong>。</p><p><code>HTML5</code>具有很大的灵活性，它支持以下功能 -</p><ul><li>大写标签名称;</li><li>引号对于属性是可选的;</li><li>属性的值也是可选的;</li><li>空元素的关闭也是可选的.</li></ul><h3 id="一、DOCTYPE"><a href="#一、DOCTYPE" class="headerlink" title="一、DOCTYPE"></a>一、DOCTYPE</h3><p>旧版的<code>HTML</code>中<code>DOCTYPE</code>较长，因为<code>HTML</code>是基于<code>SGML</code>的，因此需要引用<code>DTD</code>。<code>HTML5</code>可以使用下面的简单的语法来指定<code>DOCTYPE</code> -</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br></pre></td></tr></table></figure><p>上面的语法<strong>不区分大小写</strong>。</p><h3 id="二、字符编码"><a href="#二、字符编码" class="headerlink" title="二、字符编码"></a>二、字符编码</h3><p>在<code>HTML5</code>中可以使用简单的语法指定字符编码 -</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span> = <span class="string">"UTF-8"</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="三、-lt-script-gt-标签"><a href="#三、-lt-script-gt-标签" class="headerlink" title="三、&lt;script&gt;标签"></a>三、<code>&lt;script&gt;</code>标签</h3><p>通过的做法是将一个值为<code>&quot;text/javascript&quot;</code>的<code>type</code>属性添加到脚本元素中，如下所示 -</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span> = <span class="string">"text/javascript"</span> <span class="attr">src</span> = <span class="string">"scriptfile.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但<code>HTML5</code>删除了除了所需的额外信息，只需要使用以下语法即可 -</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span> = <span class="string">"scriptfile.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="四、-lt-link-gt-标签"><a href="#四、-lt-link-gt-标签" class="headerlink" title="四、&lt;link&gt;标签"></a>四、<code>&lt;link&gt;</code>标签</h3><p>以前我们是这样写<code>&lt;link</code>标签元素的 -</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span> = <span class="string">"stylesheet"</span> <span class="attr">type</span> = <span class="string">"text/css"</span> <span class="attr">href</span> = <span class="string">"stylefile.css"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在<code>HTML5</code>中删除了所需的额外的信息，使用下面的简单的语法即可 -</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span> = <span class="string">"stylesheet"</span> <span class="attr">href</span> = <span class="string">"stylefile.css"</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="五、HTML5-元素"><a href="#五、HTML5-元素" class="headerlink" title="五、HTML5 元素"></a>五、HTML5 元素</h3><p><code>HTML5</code>元素使用开始标记和结束标记进行标记。标签是尖括号分隔，标签名称介于两者之间。不同于开始标记，结束标记在标签名名称中多了一个斜杠。<br>下面是使用<code>HTML5</code>元素的语法 -</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>HTML5</code>标签名称不区分大小写，<strong>可以全部大写或者混合大小写，但最常见的是使用小写</strong>。</p><p>大多数元素包含一些内容，如<code>&lt;p&gt;...&lt;/p&gt;</code>包含一个段落。但是，有些元素根本不包含任何内容，这些元素称为空元素。例如: <code>br</code>, <code>hr</code>, <code>link</code>, <code>meta</code>等。</p><h3 id="六、HTML5-属性"><a href="#六、HTML5-属性" class="headerlink" title="六、HTML5 属性"></a>六、HTML5 属性</h3><p>元素可能包含用于设置元素的各种属性的属性。某些元素是全局定义的，可以在任何元素上使用，而其他属性仅针对特定元素定义。所有属性都有一个名称和一个值，如下例所示 -</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span> = <span class="string">"example"</span> <span class="attr">id</span> = <span class="string">"wrapper"</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>HTML5</code>属性同样不区分大小写，可以全部使用大写或混合大小写，但约定俗成的是坚持使用小写。</p><h3 id="七、HTML5-文档"><a href="#七、HTML5-文档" class="headerlink" title="七、HTML5 文档"></a>七、HTML5 文档</h3><p><code>HTML5</code>中引入了下面的标签来更好的结构化文档 -</p><ol><li><strong>section</strong> - 该标签表示通用文档或应用程序部分。它可以与<code>h1-h6</code>一起使用来指示文档结构;</li><li><strong>article</strong> - 此标签表示文档的独立内容，例如博客条目或报纸文章;</li><li><strong>aside</strong> - 该标签表示一段仅与页面其余部分略有相关的内容;</li><li><strong>header</strong> - 此标签表示section的标题;</li><li><strong>footer</strong> - 该标签表示section的页脚，可以包含有关作者，版权信息等的信息;</li><li><strong>nav</strong> - 此标签表示用于导航的文档的一部分;</li><li><strong>dialog</strong> - 该标签可用于标记对话;</li><li><strong>figure</strong> - 此标签可以将标题与某些嵌入内容(例如图片或视频)相关联.</li></ol><p><code>HTML5</code>的文档结构简单例子如下 -</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span> = <span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>...<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">header</span>&gt;</span>...<span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">nav</span>&gt;</span>...<span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">aside</span>&gt;</span>...<span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">footer</span>&gt;</span>...<span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="属性-Attributes"><a href="#属性-Attributes" class="headerlink" title="属性 (Attributes)"></a>属性 (Attributes)</h2><p>之前已经提到，元素可能包含用于设置元素的各种属性的属性。某些元素是全局定义的，可以在任何元素上使用，而其他属性仅针对特定元素定义。所有属性都有一个名称和一个值。属性的设置只能在<strong>开始标签中设置</strong>。<code>HTML5</code>属性不区分大小写，可以混合大小写，但是约定俗成使用小写。</p><h3 id="一、标准属性"><a href="#一、标准属性" class="headerlink" title="一、标准属性"></a>一、标准属性</h3><p>几乎所有<code>HTML5</code>标签都支持下面列出的属性(常用部分属性) -</p><div class="table-container"><table><thead><tr><th style="text-align:center">Attribute</th><th style="text-align:center">Options</th><th style="text-align:center">Function</th></tr></thead><tbody><tr><td style="text-align:center">accesskey</td><td style="text-align:center">用户自定义</td><td style="text-align:center">指定用于访问元素的键盘快捷方式</td></tr><tr><td style="text-align:center">align</td><td style="text-align:center">right,left,center</td><td style="text-align:center">水平对齐标签</td></tr><tr><td style="text-align:center">backgroud</td><td style="text-align:center">URL</td><td style="text-align:center">在元素后面放置背景图像</td></tr><tr><td style="text-align:center">bgcolor</td><td style="text-align:center">数字，<br>颜色十六进制表示,<br>RGB值</td><td style="text-align:center">设置元素的背景颜色</td></tr><tr><td style="text-align:center">class</td><td style="text-align:center">用户自定义</td><td style="text-align:center">对用于层叠样式表的元素进行分类</td></tr><tr><td style="text-align:center">contenteditable</td><td style="text-align:center">true, false</td><td style="text-align:center">指定用户是否可以编辑元素内容</td></tr><tr><td style="text-align:center">contextmenu</td><td style="text-align:center">Menu id</td><td style="text-align:center">指定元素的上下文菜单</td></tr><tr><td style="text-align:center">data-XXXX</td><td style="text-align:center">用户自定义</td><td style="text-align:center">自定义属性。开发人员可以定义自己的属性。必须以<code>data-</code>开头</td></tr><tr><td style="text-align:center">draggable</td><td style="text-align:center">true, false, auto</td><td style="text-align:center">指定是否允许用户拖动元素</td></tr><tr><td style="text-align:center">height</td><td style="text-align:center">数值</td><td style="text-align:center">指定表格，图像，表格单元的高度</td></tr><tr><td style="text-align:center">hidden</td><td style="text-align:center">hidden</td><td style="text-align:center">指定元素是否可见</td></tr><tr><td style="text-align:center">id</td><td style="text-align:center">用户自定义</td><td style="text-align:center">命名用于层叠样式表的元素</td></tr><tr><td style="text-align:center">item</td><td style="text-align:center">元素列表</td><td style="text-align:center">用于分组元素</td></tr><tr><td style="text-align:center">itemprop</td><td style="text-align:center">项目列表</td><td style="text-align:center">用于分组项目</td></tr><tr><td style="text-align:center">spellcheck</td><td style="text-align:center">true,false</td><td style="text-align:center">指定元素是否必须检查拼写或语法</td></tr><tr><td style="text-align:center">style</td><td style="text-align:center">CSS 样式表</td><td style="text-align:center">指定元素的行内样式</td></tr><tr><td style="text-align:center">subject</td><td style="text-align:center">用户定义的id</td><td style="text-align:center">指定元素对应的项目</td></tr><tr><td style="text-align:center">tabindex</td><td style="text-align:center">Tab数字</td><td style="text-align:center">指定元素的Tab键顺序</td></tr><tr><td style="text-align:center">title</td><td style="text-align:center">用户自定义</td><td style="text-align:center">定义元素的“弹出”标题</td></tr><tr><td style="text-align:center">valign</td><td style="text-align:center">top,middle,bottom</td><td style="text-align:center">垂直对齐HTML元素中的标签</td></tr><tr><td style="text-align:center">width</td><td style="text-align:center">数值</td><td style="text-align:center">指定表格，图像，或者表格单元的宽度</td></tr></tbody></table></div><h3 id="二、自定义属性"><a href="#二、自定义属性" class="headerlink" title="二、自定义属性"></a>二、自定义属性</h3><p>用户可以添加自定义数据属性是<code>HTML5</code>中引入的新功能。自定义的数据属性一<code>data-</code>开头，并根据需求来命名，例如 -</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span> =<span class="string">"example"</span> <span class="attr">data-subject</span> = <span class="string">"physics"</span> <span class="attr">data-level</span> = <span class="string">"complext"</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面的代码在<code>HTML5</code>中是完全有效的，其中<code>data-subject</code>和<code>data-level</code>为自定义属性。可以使用<code>JavaScript API</code>或<code>CSS</code>以与标准属性类似的方式获取这些属性的值。</p><h2 id="事件-Events"><a href="#事件-Events" class="headerlink" title="事件 (Events)"></a>事件 (Events)</h2><p>当用户访问往网站时，他们会执行各种活动，例如单机文本和图像以及链接，将鼠标悬停在已定义的元素上等。这些在<code>Javascript</code>中被称为<strong>事件</strong>。</p><p>我们可以在<code>JavaScript</code>或<code>VBscript</code>中编写事件处理程序，可以将这些事件处理程序指定为事件标记属性的值。<code>HTML5</code>规范定义了下面列出的各种事件属性 -</p><p>当任何<code>HTML5</code>元素发生任何事件时，我们可以使用以下属性集来触发作为值给定的任何<code>javascript</code>或<code>vbscript</code>代码。</p><div class="table-container"><table><thead><tr><th style="text-align:center">Attribute</th><th style="text-align:center">Value</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td style="text-align:center">offline</td><td style="text-align:center">script</td><td style="text-align:center">文档脱机时触发</td></tr><tr><td style="text-align:center">onabort</td><td style="text-align:center">script</td><td style="text-align:center">中止事件时触发</td></tr><tr><td style="text-align:center">onafterprint</td><td style="text-align:center">script</td><td style="text-align:center">文档打印后触发</td></tr><tr><td style="text-align:center">onbeforeonload</td><td style="text-align:center">script</td><td style="text-align:center">文档加载前触发</td></tr><tr><td style="text-align:center">onbeforeprint</td><td style="text-align:center">script</td><td style="text-align:center">文档打印前触发</td></tr><tr><td style="text-align:center">onblur</td><td style="text-align:center">script</td><td style="text-align:center">窗口失去焦点时触发</td></tr><tr><td style="text-align:center">oncanplay</td><td style="text-align:center">script</td><td style="text-align:center">当媒体可以播放时触发，但可能必须停止缓冲</td></tr><tr><td style="text-align:center">oncanpalythrough</td><td style="text-align:center">script</td><td style="text-align:center">当媒体可以播放到最后时触发，而不停止缓冲</td></tr><tr><td style="text-align:center">onchange</td><td style="text-align:center">script</td><td style="text-align:center">元素内容改变时触发</td></tr><tr><td style="text-align:center">onclick</td><td style="text-align:center">script</td><td style="text-align:center">鼠标单击时触发</td></tr><tr><td style="text-align:center">oncontextmenu</td><td style="text-align:center">script</td><td style="text-align:center">触发上下文菜单时触发</td></tr><tr><td style="text-align:center">ondbclick</td><td style="text-align:center">script</td><td style="text-align:center">双击鼠标时触发</td></tr><tr><td style="text-align:center">ondrag</td><td style="text-align:center">script</td><td style="text-align:center">拖动元素时触发</td></tr><tr><td style="text-align:center">ondragend</td><td style="text-align:center">script</td><td style="text-align:center">拖动操作结束时触发</td></tr><tr><td style="text-align:center">ondragenter</td><td style="text-align:center">script</td><td style="text-align:center">将元素拖动到有效放置目标时触发</td></tr><tr><td style="text-align:center">ondragleave</td><td style="text-align:center">script</td><td style="text-align:center">元素离开有效放置目标时触发</td></tr><tr><td style="text-align:center">ondragstart</td><td style="text-align:center">script</td><td style="text-align:center">拖动操作开始时触发</td></tr><tr><td style="text-align:center">ondrop</td><td style="text-align:center">script</td><td style="text-align:center">放置元素时触发</td></tr><tr><td style="text-align:center">ondurationchange</td><td style="text-align:center">script</td><td style="text-align:center">媒体长度发生改变时触发</td></tr><tr><td style="text-align:center">onemptied</td><td style="text-align:center">script</td><td style="text-align:center">媒体资源元素突然变空时触发</td></tr><tr><td style="text-align:center">onended</td><td style="text-align:center">script</td><td style="text-align:center">媒体到达终点时触发</td></tr><tr><td style="text-align:center">onerror</td><td style="text-align:center">script</td><td style="text-align:center">发生错误时触发</td></tr><tr><td style="text-align:center">onfocus</td><td style="text-align:center">script</td><td style="text-align:center">窗口获得焦点时触发</td></tr><tr><td style="text-align:center">onformchange</td><td style="text-align:center">script</td><td style="text-align:center">表单发生改变时触发</td></tr><tr><td style="text-align:center">onforminput</td><td style="text-align:center">script</td><td style="text-align:center">用户输入表单内容时触发</td></tr><tr><td style="text-align:center">onhaschange</td><td style="text-align:center">script</td><td style="text-align:center">文档更改时触发</td></tr><tr><td style="text-align:center">oninput</td><td style="text-align:center">script</td><td style="text-align:center">元素获得用户输入时触发</td></tr><tr><td style="text-align:center">oninvalid</td><td style="text-align:center">script</td><td style="text-align:center">元素无效时触发</td></tr><tr><td style="text-align:center">onkeydown</td><td style="text-align:center">script</td><td style="text-align:center">某个键按下时触发</td></tr><tr><td style="text-align:center">onkeypress</td><td style="text-align:center">script</td><td style="text-align:center">某个键被按下并释放时触发</td></tr><tr><td style="text-align:center">onkeyup</td><td style="text-align:center">script</td><td style="text-align:center">某个键释放时触发</td></tr><tr><td style="text-align:center">onlaod</td><td style="text-align:center">script</td><td style="text-align:center">文档加载时触发</td></tr><tr><td style="text-align:center">onloadeddata</td><td style="text-align:center">script</td><td style="text-align:center">媒体数据加载时触发</td></tr><tr><td style="text-align:center">onloadedmetadata</td><td style="text-align:center">script</td><td style="text-align:center">加载媒体元素的持续时间和其他媒体数据时触发</td></tr><tr><td style="text-align:center">onlaodstart</td><td style="text-align:center">script</td><td style="text-align:center">浏览器开始加载媒体数据时触发</td></tr><tr><td style="text-align:center">onmessage</td><td style="text-align:center">script</td><td style="text-align:center">触发消息时触发</td></tr><tr><td style="text-align:center">onmousedown</td><td style="text-align:center">script</td><td style="text-align:center">按下鼠标按钮时触发</td></tr><tr><td style="text-align:center">onmousemove</td><td style="text-align:center">script</td><td style="text-align:center">鼠标指针移动时触发</td></tr><tr><td style="text-align:center">onmouseout</td><td style="text-align:center">script</td><td style="text-align:center">鼠标指针移开某个元素时触发</td></tr><tr><td style="text-align:center">onmouseover</td><td style="text-align:center">script</td><td style="text-align:center">鼠标指针移动到某个元素上时触发</td></tr><tr><td style="text-align:center">onmouseup</td><td style="text-align:center">script</td><td style="text-align:center">鼠标按钮释放时触发</td></tr><tr><td style="text-align:center">onmousewheel</td><td style="text-align:center">script</td><td style="text-align:center">鼠标滑轮滚动时触发</td></tr><tr><td style="text-align:center">onoffline</td><td style="text-align:center">script</td><td style="text-align:center">文档脱机时触发</td></tr><tr><td style="text-align:center">ononline</td><td style="text-align:center">script</td><td style="text-align:center">文档联机时触发</td></tr><tr><td style="text-align:center">onpagehide</td><td style="text-align:center">script</td><td style="text-align:center">隐藏窗口时触发</td></tr><tr><td style="text-align:center">onpause</td><td style="text-align:center">script</td><td style="text-align:center">媒体暂停时触发</td></tr><tr><td style="text-align:center">onpageshow</td><td style="text-align:center">script</td><td style="text-align:center">窗口可视时触发</td></tr><tr><td style="text-align:center">onplay</td><td style="text-align:center">script</td><td style="text-align:center">媒体数据即将开始播放时触发</td></tr><tr><td style="text-align:center">onplaying</td><td style="text-align:center">script</td><td style="text-align:center">媒体数据开始播放时触发</td></tr><tr><td style="text-align:center">onpopstate</td><td style="text-align:center">script</td><td style="text-align:center">窗口历史记录更改时触发</td></tr><tr><td style="text-align:center">onprogress</td><td style="text-align:center">script</td><td style="text-align:center">浏览器获取媒体数据时触发</td></tr><tr><td style="text-align:center">onratechange</td><td style="text-align:center">script</td><td style="text-align:center">媒体数据的播放速率发生变化时触发</td></tr><tr><td style="text-align:center">onreadystatechange</td><td style="text-align:center">script</td><td style="text-align:center">准备状态改变时触发</td></tr><tr><td style="text-align:center">onredo</td><td style="text-align:center">script</td><td style="text-align:center">文档执行重做时触发</td></tr><tr><td style="text-align:center">onresize</td><td style="text-align:center">script</td><td style="text-align:center">调整窗口大小时触发</td></tr><tr><td style="text-align:center">onscroll</td><td style="text-align:center">script</td><td style="text-align:center">滚动元素的滚动条时触发</td></tr><tr><td style="text-align:center">onseeked</td><td style="text-align:center">script</td><td style="text-align:center">当媒体元素的搜索属性不再为真时触发，并且搜索已经结束</td></tr><tr><td style="text-align:center">onseeking</td><td style="text-align:center">script</td><td style="text-align:center">当媒体元素的搜索属性为真时触发，并且搜索已经开始</td></tr><tr><td style="text-align:center">onselect</td><td style="text-align:center">script</td><td style="text-align:center">元素被选中时触发</td></tr><tr><td style="text-align:center">onstalled</td><td style="text-align:center">script</td><td style="text-align:center">在获取媒体数据时出现错误事触发</td></tr><tr><td style="text-align:center">onstorage</td><td style="text-align:center">script</td><td style="text-align:center">文档加载时触发</td></tr><tr><td style="text-align:center">onsubmit</td><td style="text-align:center">script</td><td style="text-align:center">表单提交时触发</td></tr><tr><td style="text-align:center">onsuspend</td><td style="text-align:center">script</td><td style="text-align:center">浏览器获取媒体数据时触发，但在获取整个每天文件之前停止</td></tr><tr><td style="text-align:center">ontimeupdate</td><td style="text-align:center">script</td><td style="text-align:center">媒体更改其播放位置时触发</td></tr><tr><td style="text-align:center">onundo</td><td style="text-align:center">script</td><td style="text-align:center">文档执行撤销时触发</td></tr><tr><td style="text-align:center">onunload</td><td style="text-align:center">script</td><td style="text-align:center">用户离开文档时触发</td></tr><tr><td style="text-align:center">onvolumechange</td><td style="text-align:center">script</td><td style="text-align:center">媒体更改音量时触发，当音量设置为“mute(静音)”时触发</td></tr><tr><td style="text-align:center">onwaiting</td><td style="text-align:center">script</td><td style="text-align:center">当媒体停止播放时触发，当预计会恢复</td></tr></tbody></table></div><h2 id="表单-Web-Forms-2-0"><a href="#表单-Web-Forms-2-0" class="headerlink" title="表单 (Web Forms 2.0)"></a>表单 (Web Forms 2.0)</h2><h2 id="矢量图-SVG"><a href="#矢量图-SVG" class="headerlink" title="矢量图 (SVG)"></a>矢量图 (SVG)</h2><h2 id="MathML"><a href="#MathML" class="headerlink" title="MathML"></a>MathML</h2><h2 id="Web-存储"><a href="#Web-存储" class="headerlink" title="Web 存储"></a>Web 存储</h2><h2 id="Web-SQL-数据库"><a href="#Web-SQL-数据库" class="headerlink" title="Web SQL 数据库"></a>Web SQL 数据库</h2><h2 id="服务器发送事件-Server-Sent-Events"><a href="#服务器发送事件-Server-Sent-Events" class="headerlink" title="服务器发送事件 (Server Sent Events)"></a>服务器发送事件 (Server Sent Events)</h2><h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><h2 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h2><h2 id="声音-amp-视频-Audio-amp-Video"><a href="#声音-amp-视频-Audio-amp-Video" class="headerlink" title="声音&amp;视频 (Audio&amp;Video)"></a>声音&amp;视频 (Audio&amp;Video)</h2><h2 id="地理位置-Geolocation"><a href="#地理位置-Geolocation" class="headerlink" title="地理位置 (Geolocation)"></a>地理位置 (Geolocation)</h2><h2 id="微数据-Microdata"><a href="#微数据-Microdata" class="headerlink" title="微数据 (Microdata)"></a>微数据 (Microdata)</h2><h2 id="拖放-Drag-amp-drop"><a href="#拖放-Drag-amp-drop" class="headerlink" title="拖放 (Drag &amp; drop)"></a>拖放 (Drag &amp; drop)</h2><h2 id="Web-Workers"><a href="#Web-Workers" class="headerlink" title="Web Workers"></a>Web Workers</h2><h2 id="IndexedDB"><a href="#IndexedDB" class="headerlink" title="IndexedDB"></a>IndexedDB</h2><h2 id="Web-通信-Messaging"><a href="#Web-通信-Messaging" class="headerlink" title="Web 通信 (Messaging)"></a>Web 通信 (Messaging)</h2><h2 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h2><h2 id="RTC"><a href="#RTC" class="headerlink" title="RTC"></a>RTC</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/html5基础学习/html5.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;HTML5&lt;/code&gt;是取代&lt;code&gt;HTML4.01&lt;/code&gt;, &lt;code&gt;XHTML 1.0&lt;/code&gt;和&lt;code&gt;XHTML 1.1&lt;/code&gt;的HTML标准的下一个主要修订版。&lt;code&gt;HTML5&lt;/code&gt;是在万维网上构建和呈现内容的标准。&lt;br&gt;
    
    </summary>
    
      <category term="JavaWeb" scheme="http://rovo98.github.io/categories/JavaWeb/"/>
    
      <category term="Web Basic" scheme="http://rovo98.github.io/categories/JavaWeb/Web-Basic/"/>
    
      <category term="HTML" scheme="http://rovo98.github.io/categories/JavaWeb/Web-Basic/HTML/"/>
    
    
      <category term="web dev" scheme="http://rovo98.github.io/tags/web-dev/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式基本使用</title>
    <link href="http://rovo98.github.io/posts/f85f3c07/"/>
    <id>http://rovo98.github.io/posts/f85f3c07/</id>
    <published>2017-03-15T05:12:38.000Z</published>
    <updated>2018-07-05T14:46:34.999Z</updated>
    
    <content type="html"><![CDATA[<p>regular expression regex RE</p><p>简介</p><p>正则表达式是用来<strong>简洁</strong>表达一组字符串的表达式。</p><blockquote><p>正则表达式——一行胜千言</p></blockquote><ul><li>通用的字符串表达框架</li><li>简洁表达一组字符串的表达式</li><li>针对字符串表达“简洁”和“特征”思想的工具</li><li>判断某一字符串的特征归属</li></ul><a id="more"></a><h3 id="正则表达式在文本处理中十分常用"><a href="#正则表达式在文本处理中十分常用" class="headerlink" title="正则表达式在文本处理中十分常用"></a>正则表达式在文本处理中十分常用</h3><ul><li>表达文本类型的特征(病毒、入侵等)</li><li>同时查找或替换一组字符串</li><li>匹配字符串的全部或部分</li><li><strong>正则表达式主要应用在字符串的匹配中</strong></li></ul><h3 id="正则表达式的使用"><a href="#正则表达式的使用" class="headerlink" title="正则表达式的使用"></a>正则表达式的使用</h3><ul><li>编译：将符合正则表达式语法的字符串转换成正则表达式特征。—— re.compile(regex)</li></ul><h3 id="正则表达式的语法"><a href="#正则表达式的语法" class="headerlink" title="正则表达式的语法"></a>正则表达式的语法</h3><h4 id="正则表达式常用的操作符"><a href="#正则表达式常用的操作符" class="headerlink" title="正则表达式常用的操作符"></a>正则表达式常用的操作符</h4><div class="table-container"><table><thead><tr><th style="text-align:center">操作符</th><th style="text-align:center">说明</th><th style="text-align:center">实例</th></tr></thead><tbody><tr><td style="text-align:center">.</td><td style="text-align:center">表示任何单个字符</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">[ ]</td><td style="text-align:center">字符集，对单个字符给出取值范围</td><td style="text-align:center">[abc]表示a、b、c, [a-z]表示a到z单个字符</td></tr><tr><td style="text-align:center">[^ ]</td><td style="text-align:center">非字符集，对单个字符给出排除范围</td><td style="text-align:center">[^abc]表示非a或b或c的单个字符</td></tr><tr><td style="text-align:center">*</td><td style="text-align:center">前一个字符0次或无限次扩展</td><td style="text-align:center">abc*表示ab、abc、abcc、abcc等</td></tr><tr><td style="text-align:center">+</td><td style="text-align:center">前一个字符1次或无限次扩展</td><td style="text-align:center">abc+表示abc、abcc、abccc等</td></tr><tr><td style="text-align:center">?</td><td style="text-align:center">前一个字符0次或1次扩展</td><td style="text-align:center">abc?表示ab、abc</td></tr><tr><td style="text-align:center">&#124;</td><td style="text-align:center">左右表达式任意一个</td><td style="text-align:center">abc &#124; def表示abc、def</td></tr><tr><td style="text-align:center">{m}</td><td style="text-align:center">扩展前一个字符m次</td><td style="text-align:center">ab{2}c表示abbc</td></tr><tr><td style="text-align:center">{m,n}</td><td style="text-align:center">扩展前一个字符m至n次</td><td style="text-align:center">ab{1,2}c表示abc、abbc</td></tr><tr><td style="text-align:center">^</td><td style="text-align:center">匹配字符串开头</td><td style="text-align:center">^abc表示abc且在一个字符串的开头</td></tr><tr><td style="text-align:center">$</td><td style="text-align:center">匹配字符串结尾</td><td style="text-align:center">abc$表示abc且在一个字符串的结尾</td></tr><tr><td style="text-align:center">( )</td><td style="text-align:center">分组标记，内部只能使用 &#124; 操作符</td><td style="text-align:center">(abc)表示abc ，(abc&#124;def)表示abc、def</td></tr><tr><td style="text-align:center">\d</td><td style="text-align:center">数字，等价于[0-9]</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">\w</td><td style="text-align:center">单词字符，等价于[A-Za-z0-9]</td></tr></tbody></table></div><h4 id="经典正则表达式实例"><a href="#经典正则表达式实例" class="headerlink" title="经典正则表达式实例"></a>经典正则表达式实例</h4><div class="table-container"><table><thead><tr><th style="text-align:center"><code>^[A-Za-z]+$</code></th><th style="text-align:center">由26个字母组成的字符串</th></tr></thead><tbody><tr><td style="text-align:center"><code>^[A-za-z0-9]+$</code></td><td style="text-align:center">由26个字母及数字组成的字符串</td></tr><tr><td style="text-align:center"><code>^-?\d+$</code></td><td style="text-align:center">整数形式的字符串</td></tr><tr><td style="text-align:center"><code>^[0-9]\*\[1-9][0-9]*$</code></td><td style="text-align:center">正整数形式的字符串</td></tr><tr><td style="text-align:center"><code>[1-9]\d{5}</code></td><td style="text-align:center">中国境内的邮政编码，6 位</td></tr><tr><td style="text-align:center"><code>[\u4e00-\u9fa5]</code></td><td style="text-align:center">匹配中文字符</td></tr><tr><td style="text-align:center">\d{3}-\d{8} &#124; \d{4}-\d{7}</td><td style="text-align:center">国内电话</td></tr></tbody></table></div><p>IP地址:</p><ul><li>不精确的写法：<ul><li><code>\d+.\d+.\d+.\d+</code> —— 以四个点进行分隔作为特点</li><li><code>\d{1,3}.\d{1,3}.\d{1,3}.\d{1,3}</code></li></ul></li><li>精确写法：<br>0-99 : <code>[0-9]?\d</code> 100-199 : <code>1\d{2}</code><br>200-249 : <code>2[0-4]\d</code> 250-255 : <code>25[0-5]</code><br><code>(([0-9]?\d|1\d{2}|2[0-4]\d|25[0-5]).){3}([0-9]?\d|1\d{2}|2[0-4]\d|25[0-5])</code></li></ul><h3 id="Re库的基本使用"><a href="#Re库的基本使用" class="headerlink" title="Re库的基本使用"></a>Re库的基本使用</h3><h4 id="Re库介绍"><a href="#Re库介绍" class="headerlink" title="Re库介绍"></a>Re库介绍</h4><p>Re库是Python的标准库，主要用于字符串匹配。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br></pre></td></tr></table></figure><h4 id="正则表达式的表示类型"><a href="#正则表达式的表示类型" class="headerlink" title="正则表达式的表示类型"></a>正则表达式的表示类型</h4><ul><li>raw string 类型(原生字符串类型) —— 不包含转义字符<br>re 库采用raw string 类型表示正则表达式，表示为：r’text’</li><li>string类型， 更繁琐 —— 需要双重转义</li></ul><h4 id="Re库的主要功能函数"><a href="#Re库的主要功能函数" class="headerlink" title="Re库的主要功能函数"></a>Re库的主要功能函数</h4><div class="table-container"><table><thead><tr><th style="text-align:center">函数</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>re.search()</code></td><td style="text-align:center">在一个字符串中搜索匹配正则表达式的第一个位置，返回match对象</td></tr><tr><td style="text-align:center"><code>re.match()</code></td><td style="text-align:center">在一个字符串开始位置起匹配正则表达式，返回match对象</td></tr><tr><td style="text-align:center"><code>re.findall()</code></td><td style="text-align:center">搜索字符串，以列表类型返回全部能匹配的子串</td></tr><tr><td style="text-align:center"><code>re.spilt()</code></td><td style="text-align:center">将一个字符串按照正则表达式匹配结果进行分割，返回列表类型</td></tr><tr><td style="text-align:center"><code>re.fiinditer()</code></td><td style="text-align:center">搜索字符串，返回一个匹配结果的迭代类型，每个迭代元素是match</td></tr><tr><td style="text-align:center"><code>re.sub()</code></td><td style="text-align:center">在一个字符串中替换所有匹配正则表达式的子串，返回替换后的字符串</td></tr></tbody></table></div><h5 id="re-search-pattern-string-flags-0"><a href="#re-search-pattern-string-flags-0" class="headerlink" title="re.search(pattern, string,flags=0)"></a><code>re.search(pattern, string,flags=0)</code></h5><ul><li>在一个字符串中搜索匹配正则表达式的第一个位置，返回<code>match</code>对象<ul><li><code>pattern</code>: 正则表达式的字符串或者原生字符串 表示</li><li><code>string</code> : 待匹配字符串</li><li><code>flags</code> : 正则表达式使用时的控制标记</li></ul></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">常用标记</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>re.I re.IGNORECASE</code></td><td style="text-align:center">忽略正则表达式的大小写，[A-Z]能够匹配小写字符</td></tr><tr><td style="text-align:center"><code>re.M RE.MULTILINE</code></td><td style="text-align:center">正则表达式中的^操作符能够将给定字符串的每行当作匹配开始</td></tr><tr><td style="text-align:center"><code>re.S RE.DOTALL</code></td><td style="text-align:center">正则表达式中的.操作符能够匹配所有字符，默认匹配除换行符外的所有字符</td></tr></tbody></table></div><h5 id="re-match-partern-string-flags-0"><a href="#re-match-partern-string-flags-0" class="headerlink" title="re.match(partern, string, flags=0)"></a><code>re.match(partern, string, flags=0)</code></h5><ul><li>从一个字符串的开始位置起匹配正则表达式，返回<code>match</code>对象</li></ul><h5 id="re-findall-pattern-string-flags-0"><a href="#re-findall-pattern-string-flags-0" class="headerlink" title="re.findall(pattern, string , flags=0)"></a><code>re.findall(pattern, string , flags=0)</code></h5><ul><li>搜索字符串，以列表类型返回全部能匹配的子串。<ul><li><code>pattern</code> ： 正则表达式的字符串或原生字符串表示</li><li><code>string</code> ： 待匹配字符串</li><li><code>flags:</code> 正则表达式使用时的控制标记</li></ul></li></ul><h5 id="re-split-pattern-string-maxsplit-0-flags-0"><a href="#re-split-pattern-string-maxsplit-0-flags-0" class="headerlink" title="re.split(pattern, string, maxsplit=0, flags=0)"></a><code>re.split(pattern, string, maxsplit=0, flags=0)</code></h5><ul><li>将一个字符串按照正则表达式匹配结果进行分割，返回列表类型。<ul><li><code>maxsplit</code>: 最大分割数</li></ul></li></ul><h5 id="re-finditer-patern-string-flags-0"><a href="#re-finditer-patern-string-flags-0" class="headerlink" title="re.finditer(patern, string, flags=0)"></a><code>re.finditer(patern, string, flags=0)</code></h5><ul><li>搜索字符串，返回一个匹配结果的迭代类型，每一个迭代元素是<code>match</code>对象。</li></ul><h5 id="re-sub-pattern-repl-string-count-0-flags-0"><a href="#re-sub-pattern-repl-string-count-0-flags-0" class="headerlink" title="re.sub(pattern, repl, string, count=0, flags=0)"></a><code>re.sub(pattern, repl, string, count=0, flags=0)</code></h5><ul><li>在一个字符串中替换所有匹配正则表达式的子串，返回替换后的字符串。<ul><li><code>repl</code>: 替换匹配字符串的字符串</li><li><code>count</code>： 替换的最大次数</li></ul></li></ul><h5 id="Re库的另一种等价用法"><a href="#Re库的另一种等价用法" class="headerlink" title="Re库的另一种等价用法"></a>Re库的另一种等价用法</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rst = re.search(<span class="string">r'[1-9]\d&#123;5&#125;'</span>, <span class="string">'BIT100081'</span>)</span><br><span class="line"><span class="comment">#函数式用法： 一次性操作</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#面向对象用法：编译后的多次操作</span></span><br><span class="line">pat = re.compile(<span class="string">r'[1-9]\d&#123;5&#125;'</span>)</span><br><span class="line">rst = pat.search(<span class="string">'BIT100081'</span>)</span><br></pre></td></tr></table></figure><h5 id="regex-re-compile-pattern-flags-0"><a href="#regex-re-compile-pattern-flags-0" class="headerlink" title="regex  = re.compile(pattern, flags=0)"></a><code>regex = re.compile(pattern, flags=0)</code></h5><ul><li>将正则表达式的字符串形式编译成正则表达式对象</li></ul><h4 id="Re库的match对象"><a href="#Re库的match对象" class="headerlink" title="Re库的match对象"></a>Re库的match对象</h4><h5 id="Match对象的属性"><a href="#Match对象的属性" class="headerlink" title="Match对象的属性"></a>Match对象的属性</h5><div class="table-container"><table><thead><tr><th style="text-align:center">属性</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>.string</code></td><td style="text-align:center">待匹配文本</td></tr><tr><td style="text-align:center"><code>.re</code></td><td style="text-align:center">匹配时使用的pattern对象()正则表达式</td></tr><tr><td style="text-align:center"><code>.pos</code></td><td style="text-align:center">正则表达式搜索文本的开始位置</td></tr><tr><td style="text-align:center"><code>.endpos</code></td><td style="text-align:center">正则表达式搜索文本的结束位置</td></tr></tbody></table></div><h5 id="Match对象的方法"><a href="#Match对象的方法" class="headerlink" title="Match对象的方法"></a>Match对象的方法</h5><div class="table-container"><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>.group(0)</code></td><td style="text-align:center">获得匹配后的字符串</td></tr><tr><td style="text-align:center"><code>.start()</code></td><td style="text-align:center">匹配字符串在原始字符串的开始位置</td></tr><tr><td style="text-align:center"><code>.end()</code></td><td style="text-align:center">匹配字符串在原始字符串的结束位置</td></tr><tr><td style="text-align:center"><code>.span()</code></td><td style="text-align:center">返回<code>(.start(),.end())</code> — 元组类型</td></tr></tbody></table></div><h4 id="Re库的贪婪匹配和最小匹配"><a href="#Re库的贪婪匹配和最小匹配" class="headerlink" title="Re库的贪婪匹配和最小匹配"></a>Re库的贪婪匹配和最小匹配</h4><ul><li>Re库默认采用贪婪匹配</li></ul><h5 id="最小匹配操作符"><a href="#最小匹配操作符" class="headerlink" title="最小匹配操作符"></a>最小匹配操作符</h5><div class="table-container"><table><thead><tr><th style="text-align:center">操作符</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">*?</td><td style="text-align:center">前一个字符0次或无限次扩展，最小匹配</td></tr><tr><td style="text-align:center">+?</td><td style="text-align:center">前一个字符1次或无限次扩展，最小匹配</td></tr><tr><td style="text-align:center">??</td><td style="text-align:center">前一个字符0次或1次扩展，最小匹配</td></tr><tr><td style="text-align:center">{m,n}?</td><td style="text-align:center">扩展前一个字符m至n次(含n)，最小匹配</td></tr></tbody></table></div><h3 id="高效的正则表达式技巧总结"><a href="#高效的正则表达式技巧总结" class="headerlink" title="高效的正则表达式技巧总结"></a>高效的正则表达式技巧总结</h3><h4 id="误匹配"><a href="#误匹配" class="headerlink" title="误匹配"></a>误匹配</h4><p>指<strong>正则表达式</strong>所匹配的内容范围超过了所需要范围，有些文本命名不符合要求，但是被所写的正则表达式“击中”了。例如：如果使用<code>\d{11}</code>去匹配11位手机号，<code>\d{11}</code>不单单能匹配正确的手机号，它还会匹配98824839344这样明显不是手机号的<strong>字符串</strong>。我们把这样的匹配称为<strong>误匹配</strong>。</p><h4 id="漏匹配"><a href="#漏匹配" class="headerlink" title="漏匹配"></a>漏匹配</h4><p>指正则表达式所匹配的内容所规定的范围太狭窄，有些文本确实是所需要的，但是所写的正则表达式没有将这种情况囊括在内。例如：使用\d{18}来匹配身份证号码，就会漏掉结尾是字母X的情况。<br>写出一条<strong>正则表达式</strong>，既可能出现<strong>误匹配</strong>(条件写得太宽松，范围大于目标文本)，也可能出现<strong>漏匹配</strong>(只描述了目标文本中多种情况的部分)，还可能既有<strong>误匹配</strong>又有<strong>漏匹配</strong>。例如：使用<code>\w+\.com</code>来匹配<code>.com</code>结尾的域名，既会误匹配<code>abc\_.com</code>(合法域名不包含<code>\_</code>,<code>\w</code>包含了这种情况),又会漏掉<code>ab-c.com</code>这样的域名(合法域名可以包含中划线，<code>\w</code>不包含中划线).</p><h4 id="应对方法"><a href="#应对方法" class="headerlink" title="应对方法"></a>应对方法</h4><h5 id="掌握语法细节"><a href="#掌握语法细节" class="headerlink" title="掌握语法细节"></a>掌握语法细节</h5><p>正则表达式在各种语言中，其语法大致相同，细节各有千秋。明确所使用语言的正则的语法的细节，是写出正确、高效<strong>正则表达式</strong>的基础。例如，perl中与<code>\w</code>等效的匹配范围是<code>[a-zA-Z0-9\_]</code>;perl正则表达式不支持肯定逆序视中使用可变的重复(variable repetition inside lookbehind,例如<code>( ?&lt;=.* )abc)</code>, 但是.Net语法是支持这一特性的；又如，JavaScript连逆序环视(lookbehind,如<code>(?&lt;=ab)c)</code>都不支持，而Perl和Python是支持的。&lt;&lt;精通正则表达式&gt;&gt;第三章&lt;&lt;正则表达式的特性和流派概览&gt;&gt;明确地列出了个大派系的正则表达式的异同。</p><h5 id="先粗后精，先减后加"><a href="#先粗后精，先减后加" class="headerlink" title="先粗后精，先减后加"></a>先粗后精，先减后加</h5><p>使用正则表达式语法对于目标文本进行描述和界定，可以像画素描一样，先大致勾勒出框架，在逐步在局部实现细节。仍举刚才的手机例子：先界定<code>\d{11}</code>,总不会错；再细化为<code>1[358]\d{9}</code>,就向前迈了一大步。先消除 <strong>漏匹配</strong>(刚开始先尽可能多的匹配，做加法)，然后再一点点去除<strong>误匹配</strong>(做减法)。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;regular expression regex RE&lt;/p&gt;&lt;p&gt;简介&lt;/p&gt;&lt;p&gt;正则表达式是用来&lt;strong&gt;简洁&lt;/strong&gt;表达一组字符串的表达式。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;正则表达式——一行胜千言&lt;/p&gt;&lt;/blockquote&gt;&lt;ul&gt;&lt;li&gt;通用的字符串表达框架&lt;/li&gt;&lt;li&gt;简洁表达一组字符串的表达式&lt;/li&gt;&lt;li&gt;针对字符串表达“简洁”和“特征”思想的工具&lt;/li&gt;&lt;li&gt;判断某一字符串的特征归属&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="Python" scheme="http://rovo98.github.io/categories/Python/"/>
    
      <category term="python爬虫" scheme="http://rovo98.github.io/categories/Python/python%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="学习笔记" scheme="http://rovo98.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="regex基础" scheme="http://rovo98.github.io/tags/regex%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
