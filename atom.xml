<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>rovo98&#39;s Blog</title>
  
  <subtitle>Leave your comfort zone!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://rovo98.github.io/"/>
  <updated>2019-04-18T09:00:12.756Z</updated>
  <id>http://rovo98.github.io/</id>
  
  <author>
    <name>rovo98</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JVM知识体系(二) | 内存管理</title>
    <link href="http://rovo98.github.io/posts/57a6bf72/"/>
    <id>http://rovo98.github.io/posts/57a6bf72/</id>
    <published>2019-04-12T05:22:00.000Z</published>
    <updated>2019-04-18T09:00:12.756Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/java/basic/run-time-data-areas.png" alt="run-time-data-areas"><br>主要简单的了解JVM的内存区(Memory Area)以及GC(Garbage Collection)垃圾回收机制。</p><a id="more"></a><h2 id="一、内存结构"><a href="#一、内存结构" class="headerlink" title="一、内存结构"></a>一、内存结构</h2><p>Java虚拟机定义了许多的<strong>运行时数据区(run-time data areas)</strong>, 供程序执行时使用。</p><p>其中，一些数据区域随着JVM的创建而创建，只有在JVM退出时在销毁，即属于JVM。<br>而其他的数据区随着进程(<em>Thread</em>)的创建而创建，进程销毁时也随之销毁(每个线程独有)。</p><h3 id="1-逻辑分区"><a href="#1-逻辑分区" class="headerlink" title="1. 逻辑分区"></a>1. 逻辑分区</h3><p>JVM 内存在应用<strong>逻辑上</strong>可以分为以下区域:</p><h4 id="1-1-pc-Register-程序计数器"><a href="#1-1-pc-Register-程序计数器" class="headerlink" title="1.1.pc Register - 程序计数器"></a>1.1.pc Register - 程序计数器</h4><p>存放当前执行语句(JVM instruction)的物理地址，随线程创建而创建。(每个线程均需要一个程序计数器)</p><h4 id="1-2-JVM-Stacks-虚拟机栈"><a href="#1-2-JVM-Stacks-虚拟机栈" class="headerlink" title="1.2.JVM Stacks - 虚拟机栈"></a>1.2.JVM Stacks - 虚拟机栈</h4><p>每个java虚拟机线程都有个私有的java虚拟机栈，与线程同创建。Java虚拟机栈存储<strong>帧(Frame)</strong>, Java虚拟机栈类似于C语言中的栈：它用于保存局部变量(<strong>Thread-local variables</strong>), 并在方法的调用和返回中发挥作用。</p><div class="note warning"><ul><li>java虚拟机栈的内存分配不需要是连续的。</li><li>栈的大小可以是固定或动态扩展/收缩的，JVM允许我们对栈的初始大小进行控制，在动态扩展情况下，可以指定栈允许的最大和最小分配空间(通过<code>-Xss</code>和<code>-Xsx</code>来配置)。</li></ul><p><strong>Notice:</strong></p><ul><li>当线程中的计算需求超出Java虚拟机允许的范围时(线程请求的栈深度超过JVM运行深度), 会抛出<code>StackOverflowError</code>;</li><li>在允许动态扩展栈的大小的情况下，当无法满足一次扩展需求或剩余的内存不足以为一个新线程创建栈时， JVM会抛出<code>OutOfMemoryError</code>。</li></ul></div><h4 id="1-3-Heap-堆"><a href="#1-3-Heap-堆" class="headerlink" title="1.3.Heap - 堆"></a>1.3.Heap - 堆</h4><p>堆作为运行时数据区，为所有的类实例和数组分配内存，属于所有Java线程共享的。<strong>堆在JVM启动时创建，对象的堆存储由自动存储管理系统(GC)来回收</strong>, 对象永远不会被显式的释放。</p><div class="note warning"><ul><li>和线程栈一样，堆的大小是可以固定或动态扩展的，堆的内存不需要是连续的;</li><li>堆的大小动态调整范围指定通过<code>-Xms</code>和<code>-Xmx</code>来指定;</li></ul><p><strong>Notice:</strong></p><ul><li>当堆无法申请到内存时(即GC无法申请到内存时), JVM会抛出<code>OutOfMemoryError</code>。</li></ul></div><h4 id="1-4-Method-Area-方法区"><a href="#1-4-Method-Area-方法区" class="headerlink" title="1.4.Method Area - 方法区"></a>1.4.Method Area - 方法区</h4><p>和堆一样，方法区同样是所有线程共享的(随着JVM的启动而创建)。方法区存放每个类的类结构，如运行常量池(run-time constant pool)、字段(<em>field</em>)、构造方法和方法代码(包括类实例化方法)。</p><div class="note warning"><ul><li>虽然方法区在逻辑上是堆的一部分，但是垃圾收集器不会对它进行收集，Java SE8版本的规范没有对方法区的位置和对方法区中已编译代码的管理策略提出强制要求;</li><li>方法区同样是可以是固定大小或动态扩展的，内存也不需要是连续的;</li></ul><p><strong>Notice:</strong></p><ul><li>当方法区的内存无法满足内存申请需求时，JVM会抛出<code>OutOfMemoryError</code>。</li></ul></div><h4 id="1-5-Run-time-Constant-Pool-运行时常量池"><a href="#1-5-Run-time-Constant-Pool-运行时常量池" class="headerlink" title="1.5.Run-time Constant Pool - 运行时常量池"></a>1.5.Run-time Constant Pool - 运行时常量池</h4><p>通过之前对类文件<code>.class</code>格式的了解，我们知道每个类文件中都是有一个<code>constant_pool[constant_count]</code>的表(<em>Table</em>)的, 存放字符串常量，类和接口名称，字段名称以及类文件结构及其结构中引用的其他常量。</p><p>它包含几种常量，从编译时已知的数字字面量(<em>numeric literals</em>)到必须在运行时解析的方法和字段引用。</p><p>每个运行时常量池都是在上文提到的方法区中创建的，当<strong>当JVM创建类或接口时，将创建类或接口的运行常量池</strong>(其实，通过我们已经了解到的类加载机制，知道当类加载时是将类文件以二进制数据的形式加载到方法区中，运行时常量池的创建在类加载过程中完成)。</p><div class="note warning"><p>创建类或接口时，如果创建运行时常量池所需的内存大于方法区中的可用内存，则JVM将抛出<code>OutOfMemoryError</code>。</p></div><h4 id="1-6-Native-Method-Stacks-本地方法栈"><a href="#1-6-Native-Method-Stacks-本地方法栈" class="headerlink" title="1.6. Native Method Stacks - 本地方法栈"></a>1.6. Native Method Stacks - 本地方法栈</h4><p>JVM实现的传统栈(conventional stack), 也称为”C栈”, 用于支持Java编程语言以外的语言编写的方法。</p><p>本地方法栈也可以供诸如C语言的Java虚拟机指令集解释器的实现来使用。对于无法加载本地方法且本身不依赖于传统栈的Java虚拟机实现来说，并不需要提供本地方法栈。</p><p>如果JVM实现提供了本地方法栈，和线程栈一样，通常也是在创建每个线程时为每个线程分配一个本地方法栈。</p><div class="note warning"><ul><li>本地方法栈可以是固定大小或动态扩展的，当是固定大小时，可以在创建栈时独立选择每个本地方法栈的大小;</li></ul><p><strong>Notice: (和线程栈类似)</strong></p><ul><li>当线程中的计算需求超出Java虚拟机允许的范围时(线程请求的本地方法栈深度超过JVM运行深度), 会抛出<code>StackOverflowError</code>;</li><li>在允许动态扩展栈的大小的情况下，当无法满足一次扩展需求或剩余的内存不足以为一个新线程创建本地方法栈时， JVM会抛出<code>OutOfMemoryError</code>。</li></ul></div><div class="note primary"><p>此部分内容主要参考 JAVA SE 8 Java Virtual Machine Specification</p><ul><li><a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html#jvms-2.5" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html#jvms-2.5</a><br>其他参考链接:</li><li><a href="https://www.geeksforgeeks.org/java-memory-management/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/java-memory-management/</a></li><li><a href="https://howtodoinjava.com/java/garbage-collection/jvm-memory-model-structure-and-components/" target="_blank" rel="noopener">https://howtodoinjava.com/java/garbage-collection/jvm-memory-model-structure-and-components/</a></li></ul></div><h3 id="2-内存模型"><a href="#2-内存模型" class="headerlink" title="2. 内存模型"></a>2. 内存模型</h3><p>JVM内存由以下的部分组成:</p><ul><li><strong>堆内存(Heap Memory)</strong>: 存放Java对象;</li><li><strong>非堆内存(Non-Heap Memory)</strong>: 用于java程序存储加载的类和其他元数据;</li><li>JVM本身代码，JVM内部结构，加载的探查器(Loaded profiler agent)代码和数据等。</li></ul><p><img src="jvm-2-jvm_memory_structure.gif" alt=""></p><h4 id="2-1-堆内存"><a href="#2-1-堆内存" class="headerlink" title="2.1 堆内存"></a>2.1 堆内存</h4><p>堆内存是运行时数据区，从中分配所有Java类实例和数组的内存，堆在JVM启动时创建，堆的大小可以是固定的或动态扩展的，堆的大小可以由以下的vm参数来指定:</p><ul><li><code>-Xms&lt;size&gt;</code>: 设置堆的初始大小;</li><li><code>-Xmx&lt;size&gt;</code>: 设置堆的最大内存大小.</li></ul><p>默认情况下，最大堆的大小设置为<code>64Mb</code>。</p><p>JVM 堆内存在物理上分为两个部分: 新生代(<strong>nursery or young generation</strong>)和老年代(<strong>old space or old generation</strong>)。<br>新生代是为分配新对象而保留的堆的部分空间。当新生代占满时，通过<strong>Minor GC</strong>对新生代区域执行垃圾回收动作，其中在新生代中生存足够长时间的所有对象(经历过若干次Minor GC后保留下来的对象)将被迁移到老年代, 从而释放新生代的空间以为更多的对象分配空间。</p><p><img src="jvm2-jvm-heap-memory-model.png" alt="jvm-heap-memory-model"></p><p><strong>Minor GC</strong>分为三个部分: <strong>伊甸园(Eden)</strong>区、和两个<strong>幸存区(Survivor) S0(from), S1(to)</strong></p><p><strong>关于新生代内存空间(Young Generation/Nursery):</strong></p><ul><li>大多数对象的创建都是位于<strong>Eden</strong>区的(因为有可能一些比较大的对象是直接在老年代中创建);</li><li>当Eden区填满对象时，执行Minor GC并将所有幸存对象移到其中一个幸存区空间;</li><li>Minor GC还会检查幸存区中的对象，并将幸存的对象移动到另一个幸存区，即幸存区总有一个是空的(即GC算法中的<code>mark-and-copy</code>算法);</li><li>在多次Minor GC中存活下来的对象会被移动到老年代中。至于经过多少次Minor GC能晋升到老年代由JVM决定，控制对象的“年龄阈值(这里的年龄指对象被移动的次数)”.</li></ul><p>Java 最近的版本中的新生代中还包含一个<strong>保留区(reserved)</strong>， 用于保存最近创建的对象，防止对象在Minor GC执行之前被提升。</p><p>关于老年代内存空间(<strong>Old Generation - Tenured</strong>)</p><p>当老年区填满时，老年区同样会执行垃圾收集，称为<strong>Major GC</strong>，老年代中包含那些从多次Minor GC中幸存的对象，通常执行一次Major GC 时间要比较长，因为Minor GC旨在快速找到在新生代中依然存活的对象并将它们移动，所以Minor GC执行的频率和速度都要Major GC的更大。</p><p>根据阈值限制，可以使用<code>-XX:+PrintTenuringDistribution</code>来检查，它按年龄来显示对象，将对象从<strong>Survivor</strong>空间移到<strong>Tenured</strong>空间中。</p><p>我们还有许多其他有用的参数设置，如<code>-XX:InitialTenuringThreshold</code>, <code>-XX:MaxTenuringThreshold</code>和<code>-XX:TargetSurvivorRatio</code>, 可以用它们来最大限度的利用<strong>tenured</strong>和<strong>survivor</strong>空间。<br>通过设置<code>-XX:InitialTenuringThreshold</code>和<code>-XX:MaxTenuringThreshold</code>来设置对象的“年龄”的初始值和允许的最大值。</p><p><img src="jvm2-jvm-java-memory-architecture.jpg" alt="java-memory-architecture"></p><h4 id="2-2-非堆内存"><a href="#2-2-非堆内存" class="headerlink" title="2.2 非堆内存"></a>2.2 非堆内存</h4><p>JVM堆以外内存，包含JVM缓存空间，类结构如运行常量池、字段和方法数据，方法构造方法。</p><h5 id="2-2-1-元空间-Metaspace"><a href="#2-2-1-元空间-Metaspace" class="headerlink" title="2.2.1.元空间(Metaspace)"></a>2.2.1.元空间(Metaspace)</h5><p>在Java8及以上版本已经没有了<strong>Permanent Generation 永久代</strong>这块区域，将不会再有关于<code>java.lang.OutOfMemoryError: PermGen</code>内存问题的存在。与驻留在Java堆中的<strong>Perm Gen</strong>不同，Metaspace 已经不是堆的一部分了。</p><p>类元数据多数情况下都是从本地内存中分配的。默认情况下，Metaspace会自动增加其大小(直接由底层操作系统提供支持), 而Perm Gen始终是有固定的上限的。我们可以是这两个vm参数来指定Metaspace 的大小: <code>-XX:MetaSpaceSize</code>和<code>-XX:MaxMetaspaceSize</code>。</p><p><strong>Metaspace</strong>背后的含义是类的生命周期机器元数据，这与类加载器的生命周期相匹配。也就是说只要类加载器处于活动中，元数据就会在Metaspace中保持活动状态且无法释放。</p><h5 id="2-2-2-代码缓存-Code-Cache"><a href="#2-2-2-代码缓存-Code-Cache" class="headerlink" title="2.2.2.代码缓存(Code Cache)"></a>2.2.2.代码缓存(Code Cache)</h5><p>运行Java程序时，它以分层的方式执行代码。在第一层，使用客户机编译器(C1 compiler)来编译代码。分析数据(<em>profiling data</em>)在服务器编译器的第二层中(C2 compiler)使用，以优化的方式编译该代码。默认情况下，Java7未启用分层编译，但在Java8中启用了分层编译。</p><p>即时编译器(JIT compiler)将编译的代码存储在称为<strong>代码缓存</strong>的区域中，它是一个用于保存已编译代码的特殊堆。如果该区域的大小超过阈值，则该区域将被刷新，且GC不会重新定位这些对象。</p><p>Java8中已经解决了一些性能问题和编译器未重新启用的问题，而在Java7中避免这些问题的方案之一是将代码缓存区域的大小增加到一个永远不会达到的程度。</p><h5 id="2-2-3-方法区-Method-Area"><a href="#2-2-3-方法区-Method-Area" class="headerlink" title="2.2.3.方法区(Method Area)"></a>2.2.3.方法区(Method Area)</h5><p>方法区是Perm Gen 空间的一部分，用于存储类结构(运行时常量池和静态变量)以及方法和构造方法的代码。</p><h5 id="2-2-4-内存池-Memory-Pool"><a href="#2-2-4-内存池-Memory-Pool" class="headerlink" title="2.2.4.内存池(Memory Pool)"></a>2.2.4.内存池(Memory Pool)</h5><p>内存池由JVM内存管理器创建，用于创建不可变对象池。内存池可以属于Heap或Perm Gen， 具体取决于JVM内存管理器的实现。</p><h5 id="2-2-5-运行时常量池-Run-time-Constant-Pool"><a href="#2-2-5-运行时常量池-Run-time-Constant-Pool" class="headerlink" title="2.2.5.运行时常量池(Run-time Constant Pool)"></a>2.2.5.运行时常量池(Run-time Constant Pool)</h5><p>运行时常量池，即每个类中的<code>constant_pool</code>表， 它包含类运行时常量和静态方法。运行时常量池是方法区的一部分。</p><h5 id="2-2-6-Java栈-Java-Stack"><a href="#2-2-6-Java栈-Java-Stack" class="headerlink" title="2.2.6.Java栈 (Java Stack)"></a>2.2.6.Java栈 (Java Stack)</h5><p>Java栈内存用于线程的执行。它们包含暂时的方法的特定值(Thread-local variables, 线程局部变量), 以及对从该方法引用的堆中其他对象的引用。</p><h4 id="2-3-Java-堆配置选项"><a href="#2-3-Java-堆配置选项" class="headerlink" title="2.3 Java 堆配置选项"></a>2.3 Java 堆配置选项</h4><p>Java提供了很多关于堆内存的配置选项，我们可以使用它们来设置内存大小及其比例。下面是一些常用的配置项:</p><div class="table-container"><table><thead><tr><th style="text-align:center">VM Switch</th><th style="text-align:center">VM Switch Description</th></tr></thead><tbody><tr><td style="text-align:center"><code>-Xms</code></td><td style="text-align:center">用于在JVM启动时设置初始堆大小</td></tr><tr><td style="text-align:center"><code>-Xmx</code></td><td style="text-align:center">用于设置最大堆大小</td></tr><tr><td style="text-align:center"><code>-Xmn</code></td><td style="text-align:center">设置新生代区域的大小，剩下的空间用于老年代</td></tr><tr><td style="text-align:center"><code>-XX:PermGen</code></td><td style="text-align:center">用于设置永久代 Perm Gen 的初始大小</td></tr><tr><td style="text-align:center"><code>-XX:MaxPermGen</code></td><td style="text-align:center">用于设置Perm Gen的最大内存空间</td></tr><tr><td style="text-align:center"><code>-XX:SurvivorRatio</code></td><td style="text-align:center">设置Eden区的比例(Eden/Survivor)，如新生代大小为10M, -XX:SurvivorRatio=2, 则Eden空间将预留5M, Survivor各预留2.5M。默认值是8</td></tr><tr><td style="text-align:center"><code>-XX:NewRatio</code></td><td style="text-align:center">设置老年代Tenured/新生代young Gen的比例，默认是2</td></tr></tbody></table></div><div class="note primary"><p>参考链接:</p><ul><li><a href="https://betsol.com/2017/06/java-memory-management-for-java-virtual-machine-jvm/" target="_blank" rel="noopener">https://betsol.com/2017/06/java-memory-management-for-java-virtual-machine-jvm/</a></li><li><a href="https://dzone.com/articles/java-8-permgen-metaspace" target="_blank" rel="noopener">https://dzone.com/articles/java-8-permgen-metaspace</a></li></ul></div><h2 id="二、垃圾回收"><a href="#二、垃圾回收" class="headerlink" title="二、垃圾回收"></a>二、垃圾回收</h2><h3 id="1-垃圾回收机制"><a href="#1-垃圾回收机制" class="headerlink" title="1. 垃圾回收机制"></a>1. 垃圾回收机制</h3><h4 id="1-1-流程"><a href="#1-1-流程" class="headerlink" title="1.1 流程"></a>1.1 流程</h4><p>垃圾回收一个释放堆内空间以创建新对象的过程。Java的最佳特性之一就是垃圾自动收集，垃圾收集器是JVM管理的进程，它可以查看内存中的所有对象，并找出程序中任何部分都没有引用的对象，删除并回收空间以分配给其他新创建的对象。通过垃圾收集有以下步骤:</p><ul><li><strong>Marking 标记</strong>: 标记哪些对象是可达对象(live objects)，哪些是不可达对象(dead objects), 垃圾收集器会以一个GC root开始遍历对象图(Object Graph)， 此过程会引起”Stop the World Pause”(将当前所有运行的线程挂起，直到对象图遍历完毕);<br><img src="jvm-1-gc-mark.png" alt="jvm-gc-marking"></li><li><strong>Normal Deletion 普通删除</strong>: 删除不可达对象并回收分配给其他对象的空闲空间;<br><img src="jvm-1-gc-mark-sweep.png" alt="jvm-gc-mark-sweep"></li><li><strong>Deletion with compacting</strong>: 性能考虑，在删除不可达对象之后，会将所有幸存对象移动到一起，腾出整段空闲的空间(内存碎片处理);<br><img src="jvm-1-gc-mark-sweep-compact.png" alt="jvm-gc-mark-sweep-compact"></li><li><strong>Copy 复制</strong>: 将堆内存分成两个相等大小的分区，每次只使用一个区域，当完成标记后，直接将幸存对象复制到另一个分区即可。(例如Young Gen 中两个Survivor区)<br><img src="jvm-1-gc-mark-copy.png" alt="jvm-gc-mark-copy"></li></ul><p>上面给出步骤涉及的内容其实就是Java垃圾收集中使用的算法。</p><div class="note danger"><p>自JDK 1发布以来，Java垃圾收集从未使用过<strong>引用计数算法 References Counting</strong>, 因为会出现”循环引用“，即对象<code>A</code>引用对象<code>B</code>, 而对象<code>B</code>引用对象<code>A</code>， 使得它们永远无法被垃圾收集器回收。</p><p>关于<strong>Stop the World Pause</strong>:<br>所有的垃圾收集都会引起”Stop the World Pause”，即应用中的所有线程都要被挂起，直到对象图遍历完成。(因为如果对象图发生变化的话，对象图将无法正确的遍历)。</p><p>对于新生代而言，由于存放的是短期对象，所以Minor GC过程非常快，应用程序可以说几乎不受它引起的”Stop the World Pause”的影响。</p><p>但是，Major GC 就需要很长时间了，它会检查所有的活动对象。我们应该尽量让Major GC最少执行，因为它会使应用程序持续很长时间没有响应。</p></div><h4 id="1-2-策略"><a href="#1-2-策略" class="headerlink" title="1.2 策略"></a>1.2 策略</h4><p>虚拟机栈、本地方法栈和程序计数器在编译完毕后已经可以确定所需内存空间，程序执行完毕后也会自动释放所有内存空间，所以不需要进行动态回收优化。JVM内存调优主要是针对堆和方法区的两大区域的内存。</p><p>通常对象分为<strong>Strong</strong>、<strong>Soft</strong>、<strong>weak</strong>、<strong>phantom</strong>四种类型，强引用不会被回收，软引用在内存达到溢出边界时回收，弱引用在每次回收周期时回收，虚引用专门被标记为回收对象，具体回收策略如下:</p><ul><li>对象优先在Eden区中分配;</li><li>新生对象回收策略Minor GC(频繁);</li><li>老年代(Tenured)对象回收策略Full GC/Major GC(慢);</li><li>大对象直接进入老年年代；超过<code>3m</code>的对象直接进入老年代 - <code>-XX:PretenuredSizeThreshold=3145728</code>(3M);</li><li>长期存活对象进入老年代(经过若干次Minor GC的对象): Survivor中的对象经过一次Minor GC后，年龄会增加一岁，超过15岁进入老年代 - <code>:XX:MaxTenuringThreshold=15</code>;</li><li>动态对象年龄判定: 设置Survivor区对象占用一般空间以上的对象进入老年代。</li></ul><h3 id="2-垃圾回收器"><a href="#2-垃圾回收器" class="headerlink" title="2. 垃圾回收器"></a>2. 垃圾回收器</h3><p>我们可以在应用程序中使用五种垃圾收集类型。只需要在执行JVM参数来启用相应的垃圾收集策略即可。</p><ol><li><strong>Serial GC(串行GC)</strong> - <code>-XX:UseSerialGC</code>: 串行GC使用简单的<code>mark-sweep-compact</code>算法，可以用于新生代和老年代的垃圾收集，例如Minor GC和 Major GC;</li><li><strong>Parallel GC(并行GC)</strong> - <code>-XX:UseParallelGC</code>: 并行GC和串行GC相同，不同之处在于它为新生代垃圾收集生成N个线程，其中N是系统中的CPU核心数。我们还可以使用<code>-XX:ParallelGCThreads=n</code>来控制线程数;</li><li><strong>Parallel Old GC(并行旧GC)</strong> - <code>-XX:UseParallelOldGC</code>: 这与并行GC相同，只不过它除了为新生代生成多个线程以外，同时也对老年代生成多个线程;</li><li><strong>Concurrent Mark Sweep(并发标记扫描, CMS)</strong> - <code>-XX:UseConcMarkSweepGC</code>: CMS也称为并发低暂停收集器。它为老年代做垃圾收集。CMS垃圾收集器尝试通过在应用程序线程呃逆同时执行大多数垃圾收集工作来最小化由于垃圾收集导致的暂停。年轻一代的CMS收集器使用与并行GC相同的算法，我们可以使用<code>-XX:ParallelCMSThreads=n</code>参数来控制CMS收集器的线程数;</li><li><strong>G1 Garbage Collector(G1垃圾收集器)</strong> - <code>-XX:+UseG1GC</code>: G1从长远来看是要替换CMS收集器的。G1收集器是并行，并发和递增紧凑的低暂停垃圾收集器。G1不像其他收集器那样工作，并且没有新生代和老年代的概念，它将堆空间划分为多个大小相同的堆区域。当调用垃圾收集器时，它首先收集具有较少实时数据的区域，因此称为”Garbage First”, 即G1。</li></ol><p>更多关于G1GC的内容可以<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/G1.html" target="_blank" rel="noopener">查看Oracle给出的文档</a>。</p><div class="note primary"><p>参考链接:</p><ul><li><a href="https://iq.opengenus.org/memory-management-in-java-mark-sweep-compact-copy/" target="_blank" rel="noopener">https://iq.opengenus.org/memory-management-in-java-mark-sweep-compact-copy/</a></li><li><a href="https://plumbr.io/handbook/garbage-collection-algorithms" target="_blank" rel="noopener">https://plumbr.io/handbook/garbage-collection-algorithms</a></li><li><a href="https://dzone.com/articles/java-memory-architecture-model-garbage-collection" target="_blank" rel="noopener">https://dzone.com/articles/java-memory-architecture-model-garbage-collection</a></li><li><a href="https://www.journaldev.com/2856/java-jvm-memory-model-memory-management-in-java#memory-management-in-java-8211-old-generation" target="_blank" rel="noopener">https://www.journaldev.com/2856/java-jvm-memory-model-memory-management-in-java#memory-management-in-java-8211-old-generation</a></li></ul></div><div class="note info"><p><strong>Related posts:</strong></p><ul><li><a href="/posts/4661f621/">JVM知识体系 (一) | 类的装载</a></li><li><a href="/posts/12448424/">JDK, JRE, JVM | 深入了解</a></li></ul></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/java/basic/run-time-data-areas.png&quot; alt=&quot;run-time-data-areas&quot;&gt;&lt;br&gt;主要简单的了解JVM的内存区(Memory Area)以及GC(Garbage Collection)垃圾回收机制。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://rovo98.github.io/categories/Java/"/>
    
    
      <category term="JVM" scheme="http://rovo98.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM知识体系 (一) | 类的装载</title>
    <link href="http://rovo98.github.io/posts/4661f621/"/>
    <id>http://rovo98.github.io/posts/4661f621/</id>
    <published>2019-04-04T04:00:00.000Z</published>
    <updated>2019-04-12T16:30:37.261Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/java/basic/class-loading-subsystem.png" alt="class-loading-subsystem"></p><p>了解Java中<strong>类的结构</strong>(class file struture, 这里指<code>.class</code>文件的结构)、<strong>类的加载机制</strong>、<strong>类的加载过程</strong>、<strong>类加载器的应用</strong>。</p><a id="more"></a><h2 id="一、类的结构"><a href="#一、类的结构" class="headerlink" title="一、类的结构"></a>一、类的结构</h2><p>我们知道除了<code>java</code>以外，还有许多的编程语言(如：Groovy/Kotlin/Scala等)同样也是编译成<code>.class</code>字节码文件，然后由JVM执行的。可以看出JVM只关心<code>.class</code>文件，所以我们有必要了解一下这个<strong>class</strong>文件中到底包含什么东西。</p><p>JVM规范严格定义了<strong>class</strong>文件的格式，有严格数据结构，下面是<code>.class</code>文件的结构:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">    u4             magic;</span><br><span class="line">    u2             minor_version;</span><br><span class="line">    u2             major_version;</span><br><span class="line">    u2             constant_pool_count;</span><br><span class="line">    cp_info        constant_pool[constant_pool_count-1];</span><br><span class="line">    u2             access_flags;</span><br><span class="line">    u2             this_class;</span><br><span class="line">    u2             super_class;</span><br><span class="line">    u2             interfaces_count;</span><br><span class="line">    u2             interfaces[interfaces_count];</span><br><span class="line">    u2             fields_count;</span><br><span class="line">    field_info     fields[fields_count];</span><br><span class="line">    u2             methods_count;</span><br><span class="line">    method_info    methods[methods_count];</span><br><span class="line">    u2             attributes_count;</span><br><span class="line">    attribute_info attributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="1-类文件的格式-The-class-file-format"><a href="#1-类文件的格式-The-class-file-format" class="headerlink" title="1. 类文件的格式(The class file format)"></a>1. 类文件的格式(The class file format)</h3><ul><li>每个类文件包含一个类或者接口的定义，虽然类或者接口不需要在文件中真正包含外部表示(因为类是由类加载器生成的)，但是我们通常<strong>类或接口的任何有效表示称为类文件格式</strong>；</li><li><strong>一个类文件由8位(bit)的字节流组成</strong>。所有16位，32位和64位字节分别通过读取两个，四个和八个连续8位字节构成。多字节数据项始终以大端顺序(big-endian)存储(即高字节位首先出现)。在Java SE平台中，接口<code>java.io.DataInput</code>和<code>java.io.DataOutput</code>以及<code>java.io.DataInputStream</code>和<code>java.io.DataOutputStream</code>等支持这种格式；</li><li>JVM规范中定义了一组表示类文件数据的数据类型:<code>u1</code>, <code>u2</code>, <code>u4</code>分别表示无符号的一个，两个和四个字节的数量。在Java SE平台中，可以通过诸如<code>readUnsignedByte</code>, <code>readUnsignedShort</code>和<code>java.io.DataInput</code>接口的<code>readInt</code>之类的方法来读取这些类型的数据;</li><li>规范中使用类似<strong>C</strong>语言结构符号编写的伪结构来表示类文件格式。为了避免与类的字段和类实例等混淆，将描述类文件结构的内容称为<strong>项(item)</strong>，多个连续的项按顺序存储在类文件中，无需填充和对齐；</li><li>一个<strong>表(Tables)</strong>包含一个或多个项(<em>item</em>)，用于表示多个类文件结构。<strong>尽管使用类似C语言的数组语法来引用表项，但表是不同大小结构的流这一事实，意味着无法将表索引直接转换为表中的字节偏移量</strong>。</li></ul><h3 id="2-项含义简单说明"><a href="#2-项含义简单说明" class="headerlink" title="2. 项含义简单说明"></a>2. 项含义简单说明</h3><ul><li>1、<strong>magic</strong></li></ul><p><code>magic</code>项提供标识类文件格式的<em>magic number</em>, 这是一个预先定义好的值，是JVM用来识别<code>.class</code>类文件是否由合法的编译器产生。 预先定义的值是16进制格式，例如: <code>0xCAFEBABE</code></p><p>我们可以做以下测试来进行简单的验证:</p><ul><li><p>首先编写一个简单的<code>Sample.java</code>源文件:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Magic Number"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li><li><p>使用<code>javac</code>将其编译成<code>Sample.class</code>文件，打开并随意删除或修改一个或多个字符，然后保存<br><img src="jvm-1-sample-class.png" alt="sample-class-file"></p></li><li><p><code>java sample</code>查看结果<br><img src="jvm-1-incompatible-magic-value.png" alt=""></p></li><li><p>2、<strong>minor_version 和 major_version</strong><br>它们合在一起表示<code>.class</code>类文件的版本。JVM使用这个版本信息来识别当前的类文件是由哪个版本的编译产生的。规范用<code>M.m</code>的格式来表示版本，<code>M</code>表示主版本(<code>major_version</code>)，而<code>m</code>表示次版本(<code>minor_version</code>)。</p></li></ul><div class="note warning"><p><strong>[Notice]</strong>: 低版本的编译器生成的<code>.class</code>类文件可以被高版本的JVM执行，但是高版本的编译器生成的<code>.class</code>类文件无法被较低版本的JVM执行。</p><p>会报错: <code>UnsupportedClassVersionError: ***</code></p></div><div class="note primary"><p>JDK 1.0.2版本中的Oracle Java 虚拟机支持包含45.0 ~ 45.3版本的类文件格式。</p><p>JDK发布1.1.*支持的类文件格式版本，范围为45.0 ~ 45.65535。 对于$k \gt 2$, JDK版本1.k 支持45.0 ~ 44 + k.0 范围内的类文件格式版本。</p><p>例如: JDK 1.8.0 版本支持的类文件格式版本范围为: 45.0 ~ 52.0</p></div><ul><li>3、<strong>constant_pool_count</strong></li></ul><p><code>constant_pool_count</code>项的值等于<code>constant_pool</code>表(<em>Table</em>)中的项(<em>item</em>)数加1。它表示常量池中存在的常量数(当编译Java文件时，对变量和方法的所有引用都存储在常量池作为符号引用-<em>Symbolic reference</em>)。</p><ul><li>4、<strong>constant_pool[]</strong></li></ul><p><code>constant_pool[]</code>是一个结构表(<em>Table</em>), 表示各种字符串常量，类和接口名称，字段名称以及在类文件结构及其子结构中引用的其他常量。每个常量池条目(<em>entry</em>)的格式由第一个”标记(<em>tag</em>)”字节表示。</p><ul><li>5、<strong>access_flags</strong></li></ul><p><code>access_flags</code>项提供关于类文件中声明的修饰符(<em>modifier</em>)的信息。<code>access_flags</code>的值用于表示对该类或接口属性的访问权限。</p><div class="table-container"><table><thead><tr><th style="text-align:center">Flag Name</th><th style="text-align:center">Value</th><th style="text-align:center">Interpretation</th></tr></thead><tbody><tr><td style="text-align:center">ACC_PUBLIC</td><td style="text-align:center">0x0001</td><td style="text-align:center">声明<code>public</code>，可以从包的外部进行访问</td></tr><tr><td style="text-align:center">ACC_FINAL</td><td style="text-align:center">0x0010</td><td style="text-align:center">声明<code>final</code>, 不允许子类继承</td></tr><tr><td style="text-align:center">ACC_SUPER</td><td style="text-align:center">0x0020</td><td style="text-align:center">在调用<code>invokespecial</code>指令时特别处理超类的方法</td></tr><tr><td style="text-align:center">ACC_INTERFACE</td><td style="text-align:center">0x0200</td><td style="text-align:center">标明是一个接口，而不是一个类</td></tr><tr><td style="text-align:center">ACC_ABSTRACT</td><td style="text-align:center">0x0400</td><td style="text-align:center">声明<code>abstract</code>，不能实例化</td></tr><tr><td style="text-align:center">ACC_SYNTHETIC</td><td style="text-align:center">0x1000</td><td style="text-align:center">声明<code>synthetic</code>，表示类或者接口由编译器生成，不会出现在源代码中</td></tr><tr><td style="text-align:center">ACC_ANNOTATION</td><td style="text-align:center">0x2000</td><td style="text-align:center">声明一个注解<code>annotation</code>类型</td></tr><tr><td style="text-align:center">ACC_ENUM</td><td style="text-align:center">0x4000</td><td style="text-align:center">声明一个枚举<code>enum</code>类型</td></tr></tbody></table></div><ul><li>6、<strong>this_class</strong></li></ul><p>该类项的值必须是常量池表(<code>constant_pool[]</code>)中的有效索引。索引处的常量池条目必须是一个<code>CONSTANT_Class_info</code>结构，表示此类文件定义的类或接口。简单的说，它表示类文件的完全限定名。</p><ul><li>7、<strong>super_class</strong></li></ul><p><code>super_class</code>表示当前类的直接超类的完全限定名。例如上面<code>Sample.java</code>文件。当我们编译它时，可以说<code>this_class</code>是<code>Sample</code>类，而<code>super_class</code>是<code>Object</code>类。</p><ul><li>8、<strong>interface_count</strong></li></ul><p><code>interface_count</code>表示当前类文件实现的接口数量。</p><ul><li>9、<strong>interface[]</strong></li></ul><p><code>interface[]</code>存放当前类文件实现的接口信息。</p><ul><li>10、<strong>fields_count</strong></li></ul><p><code>fields_count</code>表示当前类文件中的字段数(类或接口中声明的所有字段，包括类变量和实例变量)。</p><ul><li>11、<strong>fields[]</strong></li></ul><p><code>fields[]</code>表中的每个值必须是<code>field_info</code>结构，给出该类或接口中字段的完整描述。<code>fields</code>表仅包括由当前(<em>this</em>)类或接口声明的那些字段，不包括从超类(<em>super class</em>)或超接口(<em>super interface</em>)继承的字段的项。</p><ul><li>12、<strong>method_count</strong></li></ul><p><code>method_count</code>表示当前类文件中的方法的数量(即<code>methods[]</code>表中<code>method_info</code>项的数量)。</p><ul><li>13、<strong>methods[]</strong></li></ul><p><code>methods[]</code>表中的每个值必须是<code>method_info</code>结构，它给出了该类或接口中的方法的完整描述。<br><code>method_info</code>结构表示该类或接口中声明的所有方法，包括实例方法、类方法、实例初始化方法和任何类的或接口的初始化方法。但是<code>methods[]</code>表不包含表示从超类或超接口继承的方法的项。</p><ul><li>14、<strong>attributes_count</strong></li></ul><p>同上，<code>attributes_count</code>表示<code>attributes[]</code>表中<code>attribute_info</code>项的数量。</p><ul><li>15、<strong>attributes[]</strong></li></ul><p><code>attributes[]</code>表存放<code>attribute_info</code>结构项。提供当前类中所有属性的信息。</p><p><strong>类文件结构的整体布局</strong>:</p><p><img src="jvm-1-class-file-structure.png" alt="class-file-structure"></p><p>可以简单地将每个类的文件结构理解成一个个数据库，里面有常量池(<code>constant_pool</code>)、接口(<code>interfaces</code>)、字段(<code>fields</code>)、方法(<code>methods</code>)和属性(<code>attributes</code>)表，类似与数据库中的数据表，表与表之间存在关联，例如：常量池存放这其他表需要的所有字面量(<em>literal</em>)。</p><div class="note primary"><p>以上内容大多参照<em>The Java@ Virtual Machine Specification Java SE 8 Edition</em></p><p>详细的内容，可以仔细阅读Hotspot JVM规范说明书给出的Class文件格式说明。<br><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.1" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.1</a></p></div><div class="note primary"><p><strong>[参考链接]:</strong><br><a href="https://www.geeksforgeeks.org/java-class-file/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/java-class-file/</a></p></div><h2 id="二、加载机制"><a href="#二、加载机制" class="headerlink" title="二、加载机制"></a>二、加载机制</h2><h3 id="1-类的入口"><a href="#1-类的入口" class="headerlink" title="1. 类的入口"></a>1. 类的入口</h3><p>我们知道编程语言在计算机体系结构中的按功能的分层是属于上面三层的（汇编语言、高级语言、应用语言），在向低一级别虚拟机语言转换时，使用的是<strong>翻译(Translation)</strong>的方式，即将高一级别机器上的程序转换为低一级别机器上的一段等效程序，然后再执行。</p><p>Java、C等大多是用这种方式，例如我们回顾一下我们是如何运行一个C程序的:</p><ul><li><p>(1). 编写<code>helloworld.c</code>源文件:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello, world!"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li><li><p>(2). 使用<code>gcc/g++</code>编译器将它编译成机器指令集, 然后读取到内存直接在计算机的CPU上执行。从操作系统的层面上，就是一个进程的启动到结束的生命周期。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ gcc helloworld.c -o helloworld <span class="comment"># 默认输出 a.out</span></span><br><span class="line">$ ./helloworld</span><br><span class="line"></span><br><span class="line">hello, world!</span><br></pre></td></tr></table></figure></div></li></ul><p>下面我们再看Java的程序是如何运行的。</p><p><strong>简单的来说，编写Java程序源代码, 然后使用</strong><code>javac</code><strong>编译器将源代码编译成</strong><code>.class</code><strong>类文件，经过JVM的类加载子系统，将必要的数据装入内存区，然后由执行引擎执行（此过程是解释执行的，加上JIT及时编译）</strong>。</p><ul><li><p>(1)先有源码:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello, world!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li><li><p>(2) 编译执行:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ javac HelloWorld.java</span><br><span class="line">$ java HelloWorld</span><br><span class="line"></span><br><span class="line">hello, world!</span><br></pre></td></tr></table></figure></div></li></ul><p>对比C语言在命令行直接运行编译后的<code>helloworld</code>二进制文件，Java则是在命令执行<code>.class</code>类文件，<strong>从命令的区别，我们知道操作启动的其实是</strong><code>java</code><strong>进程, 而</strong><code>HelloWorld.class</code>类文件只是作为命令行参数，在操作系统看来<code>java</code>也是一个普通的进程而已，这个进程就是JVM的执行形态。</p><p>我们都是Java的入口方法是<code>public static void main(String[] args)</code>, 缺一不可，下面我们通过一个简单的例子来验证为什么？</p><ul><li>(1) 去掉<code>public</code>修饰:<br><img src="jvm-1-public-error.png" alt=""><br>说明JVM在调用<code>main</code>方法时是在外部调用的(JVM调用<code>main</code>方法是底层的JNI方法调用)，为了确保能够调用<code>main</code>，入口方法需声明为<code>public</code>。</li><li>(2) 去掉<code>static</code>修饰:<br><img src="jvm-1-static-error.png" alt=""><br>JVM调用<code>main</code>方法时不会创建类的实例，因此将<code>main</code>方法修饰为<code>static</code>。</li><li>(3) 修改方法的返回来类型为<code>int</code>:<br><img src="jvm-1-return-type-error.png" alt=""><br><code>void</code>类型JVM调用<code>main</code>方法后无需关心调用者的使用情况，执行完成就停止，简化JVM的设计。</li><li>(4) 修改<code>main</code>为<code>main1</code>:<br><img src="jvm-1-main1-error.png" alt=""><br><code>main</code>方法的命名其实是约定俗成的，毕竟也是<em>c-family</em>语言，与C语言相同。</li></ul><p>上面说了这么多，其实我们一般只关心下面这两点:</p><ul><li><code>HelloWorld</code>是如何被JVM使用的;</li><li><code>HelloWorld</code>类里面的<code>main</code>方法是如何被执行的.</li></ul><p>下面我们详细了解一下JVM是如何使用<code>HelloWorld</code>这个类文件的。</p><p>我们知道JVM的实现是由C/C++实现的(我们可以从下载的JDK中的<code>src</code>源代码中看到), JVM在跟<code>.class</code>打交道时需要用到JNI(<em>Java Native Interface</em>), 当我们在命令行执行java时，由C/C++实现的java应用程序通过JNI找到了<code>HelloWorld</code>中符合规范的<code>main</code>，然后开始调用。</p><ul><li>源代码:<br><img src="jvm-1-jdk8-launcher-source-codes.png" alt=""></li><li><code>int JNICALL javaMain(void *args)</code>方法:<br><img src="jvm-1-launcher-source-code-javaMain.png" alt=""></li></ul><h3 id="2-类加载器"><a href="#2-类加载器" class="headerlink" title="2. 类加载器"></a>2. 类加载器</h3><p>JVM在执行类的入口之前，首先必须找到类文件，然后将类文件装入JVM实例中，也就是JVM进程维护的内存区域(Runtime Data Area或Memory Area)中。我们都知道有一个叫做<strong>类加载器(<em>ClassLoader</em>)</strong>的工具负责把类加载到JVM实例中，抛开细节从操作系统层面观察，那么就是JVM实例在运行过程中通过IO从硬盘或者网络读取<code>.class</code>类文件，然后在JVM管辖的内存区域存放对应的文件。</p><p>我们对于类加载器的实现还不是很清楚，但是从功能需求上了解到，无非就是读取文件到内存，看起来是一个很简单的操作。</p><p>如果类加载器的实现是用C/C++实现的，那么大概可能是如下代码实现的:<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">fgets</span><span class="params">( <span class="keyword">char</span> *buf, <span class="keyword">int</span> n, FILE *fp )</span></span>;</span><br></pre></td></tr></table></figure></div></p><p>如果是JAVA实现的话(上面已经提到过我们可以用<code>java.io.InputStream</code>等接口来读取类文件中的数据), 那么也是很简单的:<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InputStream is = <span class="keyword">new</span> FileInputStream(<span class="string">"temporary/code/java/HelloWorld.class"</span>);</span><br></pre></td></tr></table></figure></div></p><p>从操作系统层面看，如果只是加载，以上的代码就足以把类文件加载到JVM内存中。但是缺乏良好的管理，还必须设计一套规则来管理存放到内存中的类文件, <strong>而这一套规则就是所谓的类的加载机制</strong>。</p><p>在启动JVM的时候会把JRE默认的一些类加载到内存，这部分的类加载使用的是系统提供的内置类加载器<code>Bootstrap</code>和<code>Extensions</code>类加载器，但是内置的类加载器只能加载指定路径下的jar包(类文件集合)。JRE只是提供了底层所需的类，更多的业务需要我们从外部加载类来支持，所以我们需要指定新的类加载规则，以方便加载我们所需的外部路径的类文件。</p><h4 id="2-1-系统默认加载器"><a href="#2-1-系统默认加载器" class="headerlink" title="2.1. 系统默认加载器"></a>2.1. 系统默认加载器</h4><h5 id="2-1-1-Bootstrap-class-loader"><a href="#2-1-1-Bootstrap-class-loader" class="headerlink" title="2.1.1 Bootstrap class loader"></a>2.1.1 Bootstrap class loader</h5><blockquote><p>作用: 启动类加载器， 加载JDK核心类<br>实现: C/C++实现<br>类加载路径: <code>/jre/lib</code>目录下的jar包和类文件</p></blockquote><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sun.misc.Launcher;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> rovo98</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoostrapClassLoaderTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        URL[] urls = Launcher.getBootstrapClassPath().getURLs();</span><br><span class="line">        <span class="keyword">for</span> (URL url : urls) &#123;</span><br><span class="line">            System.out.println(url.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ javac BoostrapClassLoaderTest.java</span><br><span class="line">$ java BoostrapClassLoaderTest</span><br><span class="line"></span><br><span class="line">file:/opt/jdk1.8.0_181/jre/lib/resources.jar</span><br><span class="line">file:/opt/jdk1.8.0_181/jre/lib/rt.jar</span><br><span class="line">file:/opt/jdk1.8.0_181/jre/lib/sunrsasign.jar</span><br><span class="line">file:/opt/jdk1.8.0_181/jre/lib/jsse.jar</span><br><span class="line">file:/opt/jdk1.8.0_181/jre/lib/jce.jar</span><br><span class="line">file:/opt/jdk1.8.0_181/jre/lib/charsets.jar</span><br><span class="line">file:/opt/jdk1.8.0_181/jre/lib/jfr.jar</span><br><span class="line">file:/opt/jdk1.8.0_181/jre/classes</span><br></pre></td></tr></table></figure></div><h5 id="2-1-2-Extensions-class-loader"><a href="#2-1-2-Extensions-class-loader" class="headerlink" title="2.1.2.Extensions class loader"></a>2.1.2.Extensions class loader</h5><blockquote><p>作用: 扩展类加载器，加载JAVA扩展类库<br>实现: Java实现<br>类加载器: <code>sun.misc.Launcher$ExtClassLoader</code><br>类加载路径: <code>/jre/lib/ext</code></p></blockquote><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(System.getProperty(<span class="string">"java.ext.dirs"</span>));</span><br><span class="line"></span><br><span class="line">/opt/jdk1.8.0_181/jre/lib/ext:/usr/java/packages/lib/ext</span><br></pre></td></tr></table></figure></div><p>实现原理：扩展类加载器<code>ExtClassLoader</code>本质上是<code>URLClassLoader</code>。</p><p>参考<code>jdk8</code>中的<code>sun.misc.Launcher.java</code>源码:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Launcher构造方法部分代码，获取类加载器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Launcher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Launcher.ExtClassLoader var1; <span class="comment">// ExtClassLoader 类加载器</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 获取Extensions 类加载器</span></span><br><span class="line">        var1 = Launcher.ExtClassLoader.getExtClassLoader();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException var10) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">"Could not create extension class loader"</span>, var10);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.loader = Launcher.AppClassLoader.getAppClassLoader(var1);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException var9) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">"Could not create application class loader"</span>, var9);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ExtClassLoader 实现</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtClassLoader</span> <span class="keyword">extends</span> <span class="title">URLClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Launcher.ExtClassLoader instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 获取Extensions类加载器实例(instance)</span></span><br><span class="line">    <span class="comment">// 可以看到是用了ClassLevelLock(类级别锁，在该类以及类的所有实例中，</span></span><br><span class="line">    <span class="comment">// 在同一时间内只有一个线程能够这一临界区Critical Section)实现实例的</span></span><br><span class="line">    <span class="comment">// 单例模式(Singleton Pattern)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Launcher.<span class="function">ExtClassLoader <span class="title">getExtClassLoader</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Class var0 = Launcher.ExtClassLoader.class;</span><br><span class="line">            <span class="keyword">synchronized</span>(Launcher.ExtClassLoader.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 3. 创建Extensions类加载器</span></span><br><span class="line">                    instance = createExtClassLoader();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4. 创建Extensions类加载器的具体实现</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Launcher.<span class="function">ExtClassLoader <span class="title">createExtClassLoader</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Launcher.ExtClassLoader)AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedExceptionAction&lt;Launcher.ExtClassLoader&gt;() &#123;</span><br><span class="line">                <span class="keyword">public</span> Launcher.<span class="function">ExtClassLoader <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                    <span class="comment">// 5. 获取Extensions类加载器加载目标类的目录</span></span><br><span class="line">                    File[] var1 = Launcher.ExtClassLoader.getExtDirs();</span><br><span class="line">                    <span class="keyword">int</span> var2 = var1.length;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> var3 = <span class="number">0</span>; var3 &lt; var2; ++var3) &#123;</span><br><span class="line">                        MetaIndex.registerDirectory(var1[var3]);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 7 构造Extensions类加载器</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> Launcher.ExtClassLoader(var1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (PrivilegedActionException var1) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (IOException)var1.getException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addExtURL</span><span class="params">(URL var1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.addURL(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8. Extensions类加载器构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExtClassLoader</span><span class="params">(File[] var1)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(getExtURLs(var1), (ClassLoader)<span class="keyword">null</span>, Launcher.factory);</span><br><span class="line">        SharedSecrets.getJavaNetAccess().getURLClassPath(<span class="keyword">this</span>).initLookupCache(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. Extensions类加载器加载目录路径</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> File[] getExtDirs() &#123;</span><br><span class="line">        <span class="comment">// 即 /jre/lib/ext 目录</span></span><br><span class="line">        String var0 = System.getProperty(<span class="string">"java.ext.dirs"</span>);</span><br><span class="line">        File[] var1;</span><br><span class="line">        <span class="keyword">if</span> (var0 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            StringTokenizer var2 = <span class="keyword">new</span> StringTokenizer(var0, File.pathSeparator);</span><br><span class="line">            <span class="keyword">int</span> var3 = var2.countTokens();</span><br><span class="line">            var1 = <span class="keyword">new</span> File[var3];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> var4 = <span class="number">0</span>; var4 &lt; var3; ++var4) &#123;</span><br><span class="line">                var1[var4] = <span class="keyword">new</span> File(var2.nextToken());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            var1 = <span class="keyword">new</span> File[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// var1(File[]):</span></span><br><span class="line">        <span class="comment">// /opt/jdk1.8.0_181/jre/lib/ext</span></span><br><span class="line">        <span class="comment">// /usr/java/packages/lib/ext</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span> var1;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> URL[] getExtURLs(File[] var0) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        Vector var1 = <span class="keyword">new</span> Vector();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> var2 = <span class="number">0</span>; var2 &lt; var0.length; ++var2) &#123;</span><br><span class="line">            <span class="comment">// File 对象的list()方法会返回一个当前目录下的所有文件</span></span><br><span class="line">            <span class="comment">// 这里会返回类加载目录下的所有jar包等</span></span><br><span class="line">            String[] var3 = var0[var2].list();</span><br><span class="line">            <span class="keyword">if</span> (var3 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> var4 = <span class="number">0</span>; var4 &lt; var3.length; ++var4) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!var3[var4].equals(<span class="string">"meta-index"</span>)) &#123;</span><br><span class="line">                        File var5 = <span class="keyword">new</span> File(var0[var2], var3[var4]);</span><br><span class="line">                        var1.add(Launcher.getFileURL(var5));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        URL[] var6 = <span class="keyword">new</span> URL[var1.size()];</span><br><span class="line">        var1.copyInto(var6);</span><br><span class="line">        <span class="keyword">return</span> var6;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">findLibrary</span><span class="params">(String var1)</span> </span>&#123;</span><br><span class="line">        var1 = System.mapLibraryName(var1);</span><br><span class="line">        URL[] var2 = <span class="keyword">super</span>.getURLs();</span><br><span class="line">        File var3 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> var4 = <span class="number">0</span>; var4 &lt; var2.length; ++var4) &#123;</span><br><span class="line">            URI var5;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                var5 = var2[var4].toURI();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (URISyntaxException var9) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            File var6 = Paths.get(var5).toFile().getParentFile();</span><br><span class="line">            <span class="keyword">if</span> (var6 != <span class="keyword">null</span> &amp;&amp; !var6.equals(var3)) &#123;</span><br><span class="line">                String var7 = VM.getSavedProperty(<span class="string">"os.arch"</span>);</span><br><span class="line">                File var8;</span><br><span class="line">                <span class="keyword">if</span> (var7 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    var8 = <span class="keyword">new</span> File(<span class="keyword">new</span> File(var6, var7), var1);</span><br><span class="line">                    <span class="keyword">if</span> (var8.exists()) &#123;</span><br><span class="line">                        <span class="keyword">return</span> var8.getAbsolutePath();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                var8 = <span class="keyword">new</span> File(var6, var1);</span><br><span class="line">                <span class="keyword">if</span> (var8.exists()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> var8.getAbsolutePath();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            var3 = var6;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> AccessControlContext <span class="title">getContext</span><span class="params">(File[] var0)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        PathPermissions var1 = <span class="keyword">new</span> PathPermissions(var0);</span><br><span class="line">        ProtectionDomain var2 = <span class="keyword">new</span> ProtectionDomain(<span class="keyword">new</span> CodeSource(var1.getCodeBase(), (Certificate[])<span class="keyword">null</span>), var1);</span><br><span class="line">        AccessControlContext var3 = <span class="keyword">new</span> AccessControlContext(<span class="keyword">new</span> ProtectionDomain[]&#123;var2&#125;);</span><br><span class="line">        <span class="keyword">return</span> var3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        ClassLoader.registerAsParallelCapable();</span><br><span class="line">        instance = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h5 id="2-1-3-System-class-loader"><a href="#2-1-3-System-class-loader" class="headerlink" title="2.1.3.System class loader"></a>2.1.3.System class loader</h5><blockquote><p>作用: 系统类加载器，加载应用指定环境变量(classpath)路径下的类<br>类加载器: <code>sun.misc.Launcher$AppClassLoader</code><br>实现原理: <code>AppClassLoader</code>本质上也是<code>URLClassLoader</code></p></blockquote><p>参考<code>jdk8</code>中的<code>sun.misc.Launcher.java</code>源码:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Launcher构造方法部分代码，获取类加载器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Launcher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Launcher.ExtClassLoader var1;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        var1 = Launcher.ExtClassLoader.getExtClassLoader();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException var10) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">"Could not create extension class loader"</span>, var10);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 获取系统类加载器AppClassLoader</span></span><br><span class="line">        <span class="keyword">this</span>.loader = Launcher.AppClassLoader.getAppClassLoader(var1);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException var9) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">"Could not create application class loader"</span>, var9);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AppClassLoader具体实现</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AppClassLoader</span> <span class="keyword">extends</span> <span class="title">URLClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> URLClassPath ucp = SharedSecrets.getJavaNetAccess().getURLClassPath(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 与上面提到的Extensions类加载器类似，实现逻辑差不多</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClassLoader <span class="title">getAppClassLoader</span><span class="params">(<span class="keyword">final</span> ClassLoader var0)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String var1 = System.getProperty(<span class="string">"java.class.path"</span>);</span><br><span class="line">        <span class="keyword">final</span> File[] var2 = var1 == <span class="keyword">null</span> ? <span class="keyword">new</span> File[<span class="number">0</span>] : Launcher.getClassPath(var1);</span><br><span class="line">        <span class="keyword">return</span> (ClassLoader)AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Launcher.AppClassLoader&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> Launcher.<span class="function">AppClassLoader <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                URL[] var1x = var1 == <span class="keyword">null</span> ? <span class="keyword">new</span> URL[<span class="number">0</span>] : Launcher.pathToURLs(var2);</span><br><span class="line">                <span class="comment">// 3. 构造AppClassLoader类加载器</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Launcher.AppClassLoader(var1x, var0);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AppClassLoader构造方法</span></span><br><span class="line">    AppClassLoader(URL[] var1, ClassLoader var2) &#123;</span><br><span class="line">        <span class="keyword">super</span>(var1, var2, Launcher.factory);</span><br><span class="line">        <span class="keyword">this</span>.ucp.initLookupCache(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; loadClass(String var1, <span class="keyword">boolean</span> var2) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">int</span> var3 = var1.lastIndexOf(<span class="number">46</span>);</span><br><span class="line">        <span class="keyword">if</span> (var3 != -<span class="number">1</span>) &#123;</span><br><span class="line">            SecurityManager var4 = System.getSecurityManager();</span><br><span class="line">            <span class="keyword">if</span> (var4 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                var4.checkPackageAccess(var1.substring(<span class="number">0</span>, var3));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.ucp.knownToNotExist(var1)) &#123;</span><br><span class="line">            Class var5 = <span class="keyword">this</span>.findLoadedClass(var1);</span><br><span class="line">            <span class="keyword">if</span> (var5 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (var2) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.resolveClass(var5);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> var5;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(var1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.loadClass(var1, var2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> PermissionCollection <span class="title">getPermissions</span><span class="params">(CodeSource var1)</span> </span>&#123;</span><br><span class="line">        PermissionCollection var2 = <span class="keyword">super</span>.getPermissions(var1);</span><br><span class="line">        var2.add(<span class="keyword">new</span> RuntimePermission(<span class="string">"exitVM"</span>));</span><br><span class="line">        <span class="keyword">return</span> var2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">appendToClassPathForInstrumentation</span><span class="params">(String var1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> Thread.holdsLock(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">super</span>.addURL(Launcher.getFileURL(<span class="keyword">new</span> File(var1)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> AccessControlContext <span class="title">getContext</span><span class="params">(File[] var0)</span> <span class="keyword">throws</span> MalformedURLException </span>&#123;</span><br><span class="line">        PathPermissions var1 = <span class="keyword">new</span> PathPermissions(var0);</span><br><span class="line">        ProtectionDomain var2 = <span class="keyword">new</span> ProtectionDomain(<span class="keyword">new</span> CodeSource(var1.getCodeBase(), (Certificate[])<span class="keyword">null</span>), var1);</span><br><span class="line">        AccessControlContext var3 = <span class="keyword">new</span> AccessControlContext(<span class="keyword">new</span> ProtectionDomain[]&#123;var2&#125;);</span><br><span class="line">        <span class="keyword">return</span> var3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        ClassLoader.registerAsParallelCapable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="2-2-自定义类加载器"><a href="#2-2-自定义类加载器" class="headerlink" title="2.2. 自定义类加载器"></a>2.2. 自定义类加载器</h4><p>JVM内置的类加载器只加载了最少需要的核心JAVA基础类和环境变量下的类，但是我们往往需要依赖第三方中间件来完成额外的业务，那么如何把它们的类加载进来就显得格外的重要。</p><p>幸好JVM提供了自定义的类加载器，可以很方便的完成自定义操作，最终的目的也是将我们需要的类加载到JVM内存中。</p><p>通过继承<code>ClassLoader</code>类并重写(<em>Override</em>)<code>findClass</code>方法和<code>loadClass</code>方法就可以达到自定义获取<code>.class</code>文件的目的。</p><p><code>ClassLoader</code>中的核心方法<code>loadClass</code>方法:</p><p><code>java.lang.ClassLoader</code></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Loads the class with the specified &lt;a href="#name"&gt;binary name&lt;/a&gt;.  The</span></span><br><span class="line"><span class="comment"> * default implementation of this method searches for classes in the</span></span><br><span class="line"><span class="comment"> * following order:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;ol&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&lt;p&gt; Invoke &#123;<span class="doctag">@link</span> #findLoadedClass(String)&#125; to check if the class</span></span><br><span class="line"><span class="comment"> *   has already been loaded.  &lt;/p&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&lt;p&gt; Invoke the &#123;<span class="doctag">@link</span> #loadClass(String) &lt;tt&gt;loadClass&lt;/tt&gt;&#125; method</span></span><br><span class="line"><span class="comment"> *   on the parent class loader.  If the parent is &lt;tt&gt;null&lt;/tt&gt; the class</span></span><br><span class="line"><span class="comment"> *   loader built-in to the virtual machine is used, instead.  &lt;/p&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;&lt;p&gt; Invoke the &#123;<span class="doctag">@link</span> #findClass(String)&#125; method to find the</span></span><br><span class="line"><span class="comment"> *   class.  &lt;/p&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;/ol&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; If the class was found using the above steps, and the</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;resolve&lt;/tt&gt; flag is true, this method will then invoke the &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * #resolveClass(Class)&#125; method on the resulting &lt;tt&gt;Class&lt;/tt&gt; object.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; Subclasses of &lt;tt&gt;ClassLoader&lt;/tt&gt; are encouraged to override &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * #findClass(String)&#125;, rather than this method.  &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; Unless overridden, this method synchronizes on the result of</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #getClassLoadingLock &lt;tt&gt;getClassLoadingLock&lt;/tt&gt;&#125; method</span></span><br><span class="line"><span class="comment"> * during the entire class loading process.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  name</span></span><br><span class="line"><span class="comment"> *         The &lt;a href="#name"&gt;binary name&lt;/a&gt; of the class</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  resolve</span></span><br><span class="line"><span class="comment"> *         If &lt;tt&gt;true&lt;/tt&gt; then resolve the class</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  The resulting &lt;tt&gt;Class&lt;/tt&gt; object</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  ClassNotFoundException</span></span><br><span class="line"><span class="comment"> *          If the class could not be found</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">        <span class="comment">// 先判断类是否已经加载</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 判断顶层parent类加载器是否为null, 不为空使用它进行加载</span></span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// parent 为 null, 使用系统内置类加载器</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="comment">// 仍找不到，执行findClass方法继续查找</span></span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;  <span class="comment">// 找到类，进行解析</span></span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回类类型对象</span></span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>一个自定义类加载的简单例子: <code>UserDefinedClassLoaderExample.java</code><br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> basical.test.userDefinedClassLoaderTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> rovo98</span></span><br><span class="line"><span class="comment"> * date: 2019.04.06 23:42</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDefinedClassLoaderExample</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Driver the program to test the methods</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args command-line arguments.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 定义要加载类的完全限定名</span></span><br><span class="line">            String className = <span class="string">"basical.test.userDefinedClassLoaderTest.UserDefinedClassLoaderExample$Demo"</span>;</span><br><span class="line">            Class&lt;?&gt; class1 = Demo.class; <span class="comment">// 用系统默认类加载器加载(AppClassLoader)</span></span><br><span class="line">            <span class="comment">// 用我们自定义的类加载器加载</span></span><br><span class="line">            Class&lt;?&gt; class2 = <span class="keyword">new</span> UserDefinedClassLoader(<span class="string">"/home/rovo98/rovo98-dev-resources/ideaProjects/JavaDataStructure/out/production/DataStructureAndAlgorithmWithJavaImplement"</span>)</span><br><span class="line">                    .loadClass(className);</span><br><span class="line">            System.out.println(<span class="string">"---------------------------Class Name--------------------------------------"</span>);</span><br><span class="line">            System.out.println(class1.getName());</span><br><span class="line">            System.out.println(class2.getName());</span><br><span class="line">            System.out.println(<span class="string">"---------------------------ClassLoader Name-------------------------------"</span>);</span><br><span class="line">            System.out.println(class1.getClassLoader());</span><br><span class="line">            System.out.println(class2.getClassLoader());</span><br><span class="line">            Demo.example = <span class="number">1</span>; <span class="comment">// 修改的是系统默认类加载器加载进去的类</span></span><br><span class="line">            System.out.println(<span class="string">"---------------------------Field Value------------------------------------"</span>);</span><br><span class="line">            System.out.println(class1.getDeclaredField(<span class="string">"example"</span>).get(<span class="keyword">null</span>));</span><br><span class="line">            System.out.println(class2.getDeclaredField(<span class="string">"example"</span>).get(<span class="keyword">null</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span>(ClassNotFoundException | NoSuchFieldException | IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A demo class to be loaded to test the &#123;<span class="doctag">@code</span> UserDefinedClassLoader&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> example = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * UserDefined class loader.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDefinedClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String classPath;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * default constructor</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> classPath the class path of the specify class to be loaded.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">UserDefinedClassLoader</span><span class="params">(String classPath)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.classPath = classPath;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">            <span class="keyword">if</span> (!name.contains(<span class="string">"java.lang"</span>)) &#123; <span class="comment">// 排除加载系统的核心类</span></span><br><span class="line">                <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data = loadByte(name);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> defineClass(name, data, <span class="number">0</span>, data.length);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Loading binary class file into the memory</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> name the name of the class file to be loaded.</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> binary data of the class file to be loaded.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"ResultOfMethodCallIgnored"</span>)</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">byte</span>[] loadByte(String name) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            name = name.replaceAll(<span class="string">"\\."</span>, <span class="string">"/"</span>);</span><br><span class="line">            String dir = classPath + <span class="string">"/"</span> + name + <span class="string">".class"</span>;</span><br><span class="line">            FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(dir);</span><br><span class="line">            <span class="keyword">int</span> len = fileInputStream.available();</span><br><span class="line">            <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[len];</span><br><span class="line">            fileInputStream.read(data);</span><br><span class="line">            fileInputStream.close();</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p><p>Console output:<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">---------------------------Class Name--------------------------------------</span><br><span class="line">basical.test.userDefinedClassLoaderTest.UserDefinedClassLoaderExample$Demo</span><br><span class="line">basical.test.userDefinedClassLoaderTest.UserDefinedClassLoaderExample$Demo</span><br><span class="line">---------------------------ClassLoader Name-------------------------------</span><br><span class="line">sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">basical.test.userDefinedClassLoaderTest.UserDefinedClassLoaderExample$UserDefinedClassLoader@6d6f6e28</span><br><span class="line">---------------------------Field Value------------------------------------</span><br><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure></div></p><p>从执行结果可以看到，加载到内存中的两个类的包名+全称限定名是相同的, 而对应的类加载器却是不同的，输出的被加载类的值也是不同的。</p><h3 id="3-加载机制"><a href="#3-加载机制" class="headerlink" title="3. 加载机制"></a>3. 加载机制</h3><p>类加载机制是规定类加载器如何加载<code>.class</code>类文件到JVM内存区域中以及如何管理的规则。</p><h4 id="3-1-双亲委派机制"><a href="#3-1-双亲委派机制" class="headerlink" title="3.1 双亲委派机制"></a>3.1 双亲委派机制</h4><blockquote><p>Parent-Delegation Principle or Delegation-Hierarchy principle</p></blockquote><p>定义：某个特定的类加载器在接到加载类的请求后，首先将请求委托给它的上一级父类加载器，依次递归，知道最顶层<code>Bootstrap</code>类加载器，如果能够加载，则成功返回，否则，将类的加载请求依次往下一级别的类加载器传递，递归，此过程中，如果类找到则成功加载，否则到最后将抛出<code>ClassNotFound</code>异常。</p><div class="note info"><p>简单的来说，双亲委派原则对于当前类加载器，首先会将加载类的请求(<em>classloading request</em>)委托给它的父类加载器，只有它父类加载器无法加载请求的类时，它才会去响应类加载请求并尝试加载类。</p></div><p>实现：参考<code>java.lang.ClassLoader.java</code>中的<code>loadClass</code>方法。</p><div class="note warning"><p>从Java SE JVM 规范文档中了解到，<code>java.lang.ClassLoader</code>及其子类中的构造函数允许我们在实例化新的类加载器时指定父级类加载器。如果未明确父级，则默认使用JVM的默认类加载器作为父级加载器。</p><p><code>ClassLoader</code>中的<code>loadClass</code>主要做三件事情(从上面给的源码我们也可以看到):</p><ul><li>1.如果已经类加载直接返回该类；</li><li>2.否则，将加载类的请求委托给父级类加载器；</li><li>3.如果父级类加载器未找到该类，则调用<code>findClass</code>方法来加载。</li></ul><p>如果父级类加载器找不到类，则<code>ClassLoader</code>的<code>findClass</code>方法将在当前类加载器中搜索该类。在应用程序中实例化类加载器子类，我们可能会覆盖(<code>Overriding</code>)此方法。</p><p><code>java.net.URLClassLoader</code>类作为基本类加载器的扩展和其他jar文件，覆盖<code>java.lang.ClassLoader</code>的<code>findClass</code>方法，可以搜索一个或多个指定的<code>URL</code>以获取类和资源。</p></div><ul><li><strong>visibility principle</strong><blockquote><p>Visibility principle allows child class loader to see all the classes loaded by parent ClassLoader, but parent class loader can not see classes loaded by child.</p></blockquote></li></ul><p>可见性原则: 父类加载器加载的所有类对于其子类加载器都是是可见的，但是自类加载器的加载的类对于父类加载器是不可见的。</p><p>简单验证：假设我们随便写一个类，然后显式地(explicitly)用这个类的类加载器(<code>AppClassLoader</code>)的父类加载器(<code>ExtClassLoader</code>)来加载同一个类，然后验证它们时候是同一个类。</p><blockquote><p>ps: 如果子类加载器加载的类对于其父类加载是可见的，那么应该是同一个类。</p></blockquote><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.rovo98.miscExamples.classLoading;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.logging.Level;</span><br><span class="line"><span class="keyword">import</span> java.util.logging.Logger;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> rovo98</span></span><br><span class="line"><span class="comment"> * date: 2019.04.08 22:36</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VisibilityPrincipleTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Driver the program to test the visibility principle in class loading.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args command-line arguments.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ClassLoader classLoader = VisibilityPrincipleTest.class.getClassLoader();</span><br><span class="line">            <span class="comment">// print out the class loader of this class.</span></span><br><span class="line">            System.out.println(<span class="string">"VisibilityPrincipleTest's class loader is "</span> + classLoader);</span><br><span class="line">            ClassLoader parentClassLoader = classLoader.getParent();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// loading this class using its parent class loader</span></span><br><span class="line">            Class.forName(<span class="string">"com.rovo98.miscExamples.classLoading.VisibilityPrincipleTest"</span>,</span><br><span class="line">                    <span class="keyword">true</span>, parentClassLoader);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            Logger.getLogger(VisibilityPrincipleTest.class.getName()).log(Level.SEVERE, <span class="keyword">null</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>Output</strong>:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">VisibilityPrincipleTest&apos;s class loader is sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">java.lang.ClassNotFoundException: com.rovo98.miscExamples.classLoading.VisibilityPrincipleTest</span><br><span class="line">at java.net.URLClassLoader.findClass(URLClassLoader.java:381)</span><br><span class="line">at java.lang.ClassLoader.loadClass(ClassLoader.java:424)</span><br><span class="line">at java.lang.ClassLoader.loadClass(ClassLoader.java:357)</span><br><span class="line">at java.lang.Class.forName0(Native Method)</span><br><span class="line">at java.lang.Class.forName(Class.java:348)</span><br><span class="line">at com.rovo98.miscExamples.classLoading.VisibilityPrincipleTest.main(VisibilityPrincipleTest.java:24)</span><br><span class="line">Apr 08, 2019 10:42:41 PM com.rovo98.miscExamples.classLoading.VisibilityPrincipleTest main</span><br><span class="line">SEVERE: null</span><br><span class="line">java.lang.ClassNotFoundException: com.rovo98.miscExamples.classLoading.VisibilityPrincipleTest</span><br><span class="line">at java.net.URLClassLoader.findClass(URLClassLoader.java:381)</span><br><span class="line">at java.lang.ClassLoader.loadClass(ClassLoader.java:424)</span><br><span class="line">at java.lang.ClassLoader.loadClass(ClassLoader.java:357)</span><br><span class="line">at java.lang.Class.forName0(Native Method)</span><br><span class="line">at java.lang.Class.forName(Class.java:348)</span><br><span class="line">at com.rovo98.miscExamples.classLoading.VisibilityPrincipleTest.main(VisibilityPrincipleTest.java:24)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure></div><ul><li><strong>uniqueness principle</strong><blockquote><p>Uniqueness principle allows to load a class exactly once, which i sbasically achieved by delegation and ensures that child ClassLoader doesn’t reload the class already loaded by parent.</p></blockquote></li></ul><p>唯一性原则，一个类只加载一次，双亲委派原则已经实现了这一原则。</p><p><img src="jvmclassloader.jpg" alt=""></p><p>双亲委派机制比较好理解，目的是为了<strong>不重复加载已经加载的类, 提高效率</strong>, 还有就是<strong>强制从最顶层的类加载器开始搜索类文件，确保核心基础类优先加载</strong>。</p><p>下面介绍<strong>破坏双亲委派机制</strong>, 了解为什幺要破坏看似很好的双亲委派机制。</p><h4 id="3-2-破坏双亲委派机制"><a href="#3-2-破坏双亲委派机制" class="headerlink" title="3.2 破坏双亲委派机制"></a>3.2 破坏双亲委派机制</h4><h5 id="3-2-1-唯一标识"><a href="#3-2-1-唯一标识" class="headerlink" title="3.2.1. 唯一标识"></a>3.2.1. 唯一标识</h5><p>对于任意的一个类，都需要由<strong>加载它的类加载器</strong>和这个<strong>类本身</strong>来一同确定其在Java虚拟机中<strong>唯一性</strong>。</p><p>验证例子: <code>DifferentClassLoaderTest.java</code></p><p>判断一个类是否相同，通常用<code>equals()</code>方法，<code>isInstance()</code>方法和<code>isAssignableFrom()</code>方法来判断，对于同一类，如果没用采用相同的类加载器来加载，那么即使是同一个类，JVM也是判断它为不同类的(唯一标识不同)。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> basical.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> rovo98</span></span><br><span class="line"><span class="comment"> * date: 2019.04.07 17:47</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DifferentClassLoaderTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Driver the program to test</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args command-line arguments.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception if ClassNotFoundException throws</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// a user defined classloader</span></span><br><span class="line">        ClassLoader classLoader = <span class="keyword">new</span> ClassLoader() &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"ResultOfMethodCallIgnored"</span>)</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">                String fileName = name.substring(name.lastIndexOf(<span class="string">"."</span>) + <span class="number">1</span>) + <span class="string">".class"</span>;</span><br><span class="line">                InputStream stream = getClass().getResourceAsStream(fileName);</span><br><span class="line">                <span class="keyword">if</span> (stream == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[stream.available()];</span><br><span class="line">                    <span class="comment">// 将流写入字节数组b中</span></span><br><span class="line">                    stream.read(b);</span><br><span class="line">                    <span class="keyword">return</span> defineClass(name, b, <span class="number">0</span>, b.length);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Object obj = classLoader.loadClass(<span class="string">"basical.test.DifferentClassLoaderTest"</span>).newInstance();</span><br><span class="line">        System.out.println(obj.getClass());</span><br><span class="line">        System.out.println(obj <span class="keyword">instanceof</span> DifferentClassLoaderTest);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>Output:</strong><br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class basical.test.DifferentClassLoaderTest</span><br><span class="line">false</span><br></pre></td></tr></table></figure></div></p><p>如果在通过实例化的使用，直接转化成<code>DifferentClassLoaderTest</code>对象:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object obj = (DifferentClassLoaderTest) classLoader.loadClass(<span class="string">"basical.test.DifferentClassLoaderTest"</span>).newInstance();</span><br></pre></td></tr></table></figure></div><p>就会报<code>java.lang.ClassCastException</code>, 因为两者不属于同一类加载器加载，所以不能转化。<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.ClassCastException: basical.test.DifferentClassLoaderTest cannot be cast to basical.test.DifferentClassLoaderTest</span><br><span class="line">at basical.test.DifferentClassLoaderTest.main(DifferentClassLoaderTest.java:40)</span><br></pre></td></tr></table></figure></div></p><h5 id="3-2-2-为什么需要破坏双亲委派机制"><a href="#3-2-2-为什么需要破坏双亲委派机制" class="headerlink" title="3.2.2. 为什么需要破坏双亲委派机制"></a>3.2.2. 为什么需要破坏双亲委派机制</h5><p>在某些时候父类加载器需要委托子类加载器去加载<code>.class</code>文件。受到加载范围的限制，父类加载器无法加载到需要的文件，以<code>Driver</code>接口为例，由于<code>Driver</code>接口定义在JDK中，而其实现由各个数据库的服务商来提供，比如MySQL的就写了<code>MySQL Connector</code>，那么问题来了，<code>DriverManager</code>（也由JDK提供）要加载各个实现<code>Driver</code>接口的实现类，然后进行管理，但是<code>DriverManager</code>由<code>Bootstrap</code>类加载器加载，只能记载<code>JAVA_HOME</code>的<code>lib</code>目录下的文件，而其实实现是由服务商提供的，由系统类加载器加载，这个时候就需要<code>Bootstrap</code>类加载器来委托子类加载器来加载<code>Driver</code>实现，从而破坏了双亲委派，这仅仅是破坏双亲委派机制的一个简单例子。</p><h5 id="3-2-3-破坏双亲委派机制的实现"><a href="#3-2-3-破坏双亲委派机制的实现" class="headerlink" title="3.2.3. 破坏双亲委派机制的实现"></a>3.2.3. 破坏双亲委派机制的实现</h5><p>既然我们已经知道了什么是双亲委派机制(<em>Delegation-Hierarchy Principle or Parent-Delegation principle</em>)， 那么实现破坏双亲委派机制要做的就是打破双亲委派机制指定的规则。</p><p>具体实现大概就是自定义类加载，通过复写<code>loadClass</code>和<code>findClass</code>来实现。这里就不再展开探讨。</p><div class="note primary"><p>参考连接:</p><ul><li><a href="https://www.geeksforgeeks.org/jvm-works-jvm-architecture/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/jvm-works-jvm-architecture/</a></li><li><a href="http://www.cnblogs.com/joemsu/p/9310226.html" target="_blank" rel="noopener">http://www.cnblogs.com/joemsu/p/9310226.html</a></li><li><a href="https://docs.oracle.com/javase/tutorial/ext/basics/load.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/tutorial/ext/basics/load.html</a></li><li><a href="https://dzone.com/articles/demystify-java-class-loading" target="_blank" rel="noopener">https://dzone.com/articles/demystify-java-class-loading</a></li></ul></div><h3 id="4-加载过程"><a href="#4-加载过程" class="headerlink" title="4. 加载过程"></a>4. 加载过程</h3><p>通过上面的介绍，我们已经大致了解了类加载器的工作原理。下面主要了解的是JVM加载类的过程。</p><p>即JVM类的加载子系统到底做了什么？</p><p>简单的来说，类的加载分为三个阶段: <em>loading</em>(<strong>加载</strong>)、<em>linking</em>(<strong>链接</strong>)、<em>intiailising</em>(<strong>初始化</strong>)。</p><p><img src="jvm-1-class-loading-phases.gif" alt=""></p><h4 id="4-1-加载-loading"><a href="#4-1-加载-loading" class="headerlink" title="4.1. 加载 - loading"></a>4.1. 加载 - loading</h4><p>这一阶段就是把<code>.class</code>类文件以二进制数据的形式加载到JVM的内存区中的方法区(Method Area, JVM内存区部分内容会讲到)中。由类加载器来完成，我们简单了解一下什么时候会触发JVM去加载外部的<code>.class</code>类文件:</p><ul><li>显式的字节码指令集(<code>new/getstatic/putstatic/invokestatic</code>): 对应的场景就是创建对象或者调用到类文件的静态变量/静态方法/静态代码块;</li><li>反射: 通过对象反射获取类对象时;</li><li>继承: 创建子类触发父类加载;</li><li>入口: 包含<code>main</code>方法的类首先被加载。</li></ul><p>需要知道的是，JVM只定了类加载器的规范，但是却不明确的规定类加载器的目标文件，也就是说，JVM把具体加载类的逻辑交给用户来处理，我们可以从硬盘、网络、中间文件等来加载<code>.class</code>文件，只要加载进去内存的二进制数据符合JVM规定的格式，都是合法的。</p><h4 id="4-2-链接-linking"><a href="#4-2-链接-linking" class="headerlink" title="4.2. 链接 - linking"></a>4.2. 链接 - linking</h4><p>类加载到JVM的内存区中后，在<strong>链接</strong> 阶段要经过<strong>验证(verifing)</strong>、<strong>准备(preparation)</strong>、<strong>解析(Resolving)</strong>三个阶段的处理。</p><ul><li><strong>验证(Bytecode verification)</strong>: 主要包含对类文件对应内存二进制数据的格式、语义关联、语法逻辑和符号引用(Symbolic Reference)的验证， 如果验证不通过则抛出<code>VerifyError</code>错误。但是该阶段是不强制性执行的，我们可以通过指定JVM的参数<code>-Xverify:none</code>来关闭，提高性能(在确保字节码数据无需再验证的情况下);</li><li><strong>准备(Class preparation)</strong>: 当我们通过验证阶段后，内存的方法区存放的是被“紧密压缩”的数据段，在这个阶段会对静态(<em>static</em>)变量进行内存分配，扩展内存段的空间，但是<strong>还未初始化数据，即还是</strong><code>0</code><strong>或</strong><code>null</code>;</li><li><strong>解析(Resolving)</strong>: 把方法区中的所有符号引用(<strong>Symbolic Reference</strong>)全部替换成直接引用(<strong>Direct Reference</strong>)， 经过解析阶段后，类在方法区中占用的空间将膨胀变大。</li></ul><h4 id="4-3-初始化-initializing"><a href="#4-3-初始化-initializing" class="headerlink" title="4.3. 初始化 - initializing"></a>4.3. 初始化 - initializing</h4><p>类加载过程的最后一个阶段，为所有的静态变量赋初值，并执行静态代码块(<em>static block</em>)</p><p><strong>misc</strong>:</p><p>类的使用对应这类加载的触发的条件，就是说的类的使用就是触发类加载的条件，不过对类的使用需要的初始化操作过后。</p><p>最后是类的卸载，我们都知道JVM有专门的垃圾回收机制来处理。以上就是类的生命周期了。</p><div class="note primary"><p>参考链接:</p><ul><li><a href="http://www.techjava.de/topics/2008/01/java-class-loading/" target="_blank" rel="noopener">http://www.techjava.de/topics/2008/01/java-class-loading/</a></li></ul><p>我之前写过的相关文章:</p><ul><li><a href="/posts/12448424/">JDK, JRE, JVM | 深入了解</a></li></ul></div><h2 id="三、应用场景"><a href="#三、应用场景" class="headerlink" title="三、应用场景"></a>三、应用场景</h2><p>通过前文，我们已经基本了解了类加载器的工作原理以及类的生命周期。</p><p>下面我们需要了解的是该如何利用类加载器的特点，最大限度地发挥它的作用。</p><h3 id="1-热部署"><a href="#1-热部署" class="headerlink" title="1. 热部署"></a>1. 热部署</h3><p>说到热部署，我们第一时间可能想到的是在生产机器上更新代码后，无需重启应用容器就能更新服务，这样的好处是服务无需中断可以持续运行，那么与之对应的<strong>冷部署</strong>就是需要重启容器实例的。</p><ul><li><strong>热部署(Hot Deployment)</strong>: 热部署是应用容器自动更新应用的一种能力。</li></ul><p>首先热部署应用是容器拥有的一种能力，这种能力是容器本身设计出来的，跟具体的IDE开发工具无关。而且热部署无需重启服务器，应用可以保持用户态不受影响。</p><div class="note danger"><p>有一种看似很像热部署的情况我们需要注意： 在使用IDE开发时也不需要重启服务，修改代码后即时生效，这看起来和热部署的服务无需重启一样，但是它背后的运行机制却是截然不同的。它应用的是JVM的本身附带的<strong>热替换(Hot Swap)</strong>能力。热部署和热替换是两个完全不同的概念。</p><p>由于在开发的时候，它们经常一起使用，所以非常容易把他们搞混。</p></div><h4 id="1-1-原理"><a href="#1-1-原理" class="headerlink" title="1.1. 原理"></a>1.1. 原理</h4><p>从热部署的定义来看，我们知道它其实应用容器的一种能力，要达到的目的是<strong>在服务没有重启的情况下更新应用，也就是把新的代码编译后产生的新类文件替换掉内存中的旧类文件</strong>。</p><p>结合前文已经介绍过的类加载器的特性，热部署的过程大概要分为两个步骤进行:</p><ul><li>由于同一类加载器只能加载一次类文件(同一类文件, 因为有缓存), 在没有把新类文件加载进内存之前，我们不能把旧的类文件卸载，所以我们需要通过一个心得类加载器来加载。(<strong>此时，内存存在两个新旧的类文件, 它们的类名路径相同但类加载器不同，即类的唯一标识不同</strong>)</li><li>最后一步，我们要做的就是如何使用新的类文件，并卸载旧的类文件及其对象。</li></ul><p>完成上面两个步骤，就可以达到新代码热部署的效果。</p><h4 id="1-2-实现"><a href="#1-2-实现" class="headerlink" title="1.2. 实现"></a>1.2. 实现</h4><p>下面通过一系列简单的例子来一步步实现热部署。</p><ul><li><strong>实现自定义类加载</strong></li></ul><p>使用不同的类加载器可以把同一个类文件加载到JVM的方法区中，但是注意它们本质还是不同的”类(一个类由它的全称限定名加上它的类加载器类来标识)”</p><ul><li><strong>替换自定义类加载器</strong></li></ul><p>既然一个类可以通过不同的类加载器多次的加载到JVM的方法区中，那么一个类经过修改编译后再加载进去，从应用的角度来看，这就做到了应用更新，那么如何在线程运行不中断的情况下更新类呢？</p><p>下面给出一个简单的例子，<code>ClassReloading</code>启动<code>main</code>方法通过死循环来不断创建类加载器，同时不断地加载类而且执行类的方法。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.rovo98.miscExamples.hotDeployment;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> rovo98</span></span><br><span class="line"><span class="comment"> * date: 2019.04.09 15:01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassReloading</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Driver the program to test the class reloading</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args command-line arguments.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"InfiniteLoopStatement"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException, InterruptedException, InstantiationException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="comment">// Using infinite loop to make the thread keep running.</span></span><br><span class="line">            String className = <span class="string">"com.rovo98.miscExamples.hotDeployment.ClassReloading$User"</span>;</span><br><span class="line">            Class&lt;?&gt; target = <span class="keyword">new</span> MyClassLoader().loadClass(className);</span><br><span class="line">            <span class="comment">// Invokes the method of the loaded class using Reflection</span></span><br><span class="line">            System.out.println(count + <span class="string">" round: loading target successfully, ready to invoke the method!"</span>);</span><br><span class="line">            target.getDeclaredMethod(<span class="string">"execute"</span>).invoke(target.newInstance());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If we use system class loader, it will be 'AppClassLoader'</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// Sleep to avoid the case happen that it will occurs 'ClassNotFoundException' error</span></span><br><span class="line">            <span class="comment">// if the target class had been removed.</span></span><br><span class="line">            <span class="comment">// so make the thread stop to avoid this case happen.</span></span><br><span class="line">            Thread.sleep(<span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The class to be tested for loading.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            ask();</span><br><span class="line"><span class="comment">//            say();</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">ask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"What is your name?"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"My name is rovo98!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// a user defined classloader</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"ResultOfMethodCallIgnored"</span>)</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">            String fileName = name.substring(name.lastIndexOf(<span class="string">"."</span>) + <span class="number">1</span>) + <span class="string">".class"</span>;</span><br><span class="line">            InputStream stream = getClass().getResourceAsStream(fileName);</span><br><span class="line">            <span class="keyword">if</span> (stream == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name); <span class="comment">// load the class using system default class loaders</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[stream.available()];</span><br><span class="line">                <span class="comment">// write the stream into the byte array b</span></span><br><span class="line">                stream.read(b);</span><br><span class="line">                <span class="keyword">return</span> defineClass(name, b, <span class="number">0</span>, b.length);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><code>ClassReloading</code>线程运行起来，然后通过修改代码来查看结果，这里可以简单通过交替注释<code>User</code>类中的<code>ask()</code>和<code>say()</code>方法来测试。</p><p><strong>Output</strong>:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1 round: loading target successfully, ready to invoke the method!</span><br><span class="line">What is your name?</span><br><span class="line">2 round: loading target successfully, ready to invoke the method!</span><br><span class="line">What is your name?</span><br><span class="line">3 round: loading target successfully, ready to invoke the method!</span><br><span class="line">My name is rovo98!</span><br><span class="line">4 round: loading target successfully, ready to invoke the method!</span><br><span class="line">What is your name?</span><br><span class="line">5 round: loading target successfully, ready to invoke the method!</span><br><span class="line">What is your name?</span><br><span class="line">6 round: loading target successfully, ready to invoke the method!</span><br><span class="line">My name is rovo98!</span><br><span class="line">7 round: loading target successfully, ready to invoke the method!</span><br><span class="line">My name is rovo98!</span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure></div><p>每次循环调用都新创建一个自定义的类加载器，然后通过反射创建对象调用方法，在修改代码编译后，新的类就会通过反射被创建，并执行新的代码业务，而主线程一直没有停过(死循环)。</p><p>到了这里，我们已经简单实现了热部署了，即实现了手动无中断部署，但是存在很明显的缺点，我们需要手动编译代码(当然在IDE中我们可以通过简单的设置, 使得类文件修改后随着保存操作而自动编译, 但这也是属于”手动编译”), 而且内存中会不断新增的类加载器和对象，如果速度过快而且过于频繁更新，就非常容易造成堆溢出(<code>OutOfMemoryError</code>), 下面的一个例子，我们将通过增加一些规则来保证旧的类和对象能够被垃圾收集器(GC, Garbage Collector)自动回收。</p><ul><li><strong>回收自定义类加载器</strong></li></ul><p>通常情况下，类加载器会持有该加载器加载过的所有类的引用, 所以如果类是经系统默认类加载器加载的话，那就很难被回收，除非符合根节点不可达原则(GC 算法内容，见下面给出的简单说明)才会被回收。</p><div class="note warning"><p>GC算法， 首先GC的垃圾回收算法使用的不是<strong>引用计数(Reference counting)原理</strong>, 因为会出现”循环引用“ -&gt; 如： 如果存在不可达对象(dead object)<code>A</code>和<code>B</code>, 它们互相指向对方，那么垃圾回收器将永远无法回收它们。</p><p>为此GC引入以下算法:</p><ul><li><strong>1.</strong><code>mark</code>标记， 即标记现有的可达对象(alive object), 选择一个对象(方法，线程局部变量等)作为<code>GC root</code>，然后从这个根开始遍历图，直到所有的结点遍历完，遍历过的结点标记为alive.<blockquote><p>为了确保这一步骤能够顺利进行，JVM需要挂起正在执行的线程，因为对象如果一直发生变化的话，图的遍历是无法成功遍历的。这一现象，我们一般称为<code>Stop the world pause</code></p></blockquote></li></ul><p><img src="jvm-1-gc-mark.png" alt=""></p><ul><li><strong>2.</strong><code>sweep</code>清除阶段：即清除不可达对象, 有直接对堆内存上的对象直接清除然后不管的，有清除之后，进行压缩的，有将堆内存分成两个分区，每次只使用一个分区，当<code>mark</code>操作结束后，将<strong>alive objects</strong>复制到另一个分区，然后清除当前分区，使用另一个分区，交替进行。 分别对应下面是三种情况。</li><li><code>mark-sweep</code><br><img src="jvm-1-gc-mark-sweep.png" alt=""></li><li><code>mark-sweep-compact</code><br><img src="jvm-1-gc-mark-sweep-compact.png" alt=""></li><li><code>mark-copy</code><br><img src="jvm-1-gc-mark-copy.png" alt=""></li></ul><p>当然，实际上JVM使用的GC算法还有更多，垃圾收集器也很多种，例如对堆内存分代(generations, young generation, old generation, permanent generation), 不同的生代使用不同的策略。</p><p>😅额。。。差点跑偏了，这里就不再做过多的解释了。</p></div><p>下面继续给出一个简单的例子，我们知道上文的<code>ClassReloading</code>只是不断创建心得类加载器类加载新类，从而更新类的方法。下面的例子，通过模拟WEB应用，更新整个应用的上下文<code>Context</code>。其实代码本质上和上面的是一样的，只不过我们通过加载<code>Model</code>层、<code>DAO</code>层和<code>Service</code>层来模拟WEB应用。</p><div class="note warning"><p>为了方便测试，所有的类均写在同一个类文件中。</p></div><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.rovo98.miscExamples.hotDeployment;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> rovo98</span></span><br><span class="line"><span class="comment"> * date: 2019.04.09 16:18</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextReloading</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Driver the program to test the &#123;<span class="doctag">@code</span> ContextReloading&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args command-line arguments.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"InfiniteLoopStatement"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException,</span></span><br><span class="line"><span class="function">         InstantiationException, IllegalAccessException, InvocationTargetException, InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            count++;</span><br><span class="line">           Object context = newContext();</span><br><span class="line">            System.out.println(count + <span class="string">" round: context loaded successfully, ready to invoke the methods!"</span>);</span><br><span class="line">           invokeContext(context);</span><br><span class="line"></span><br><span class="line">           Thread.sleep(<span class="number">8000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1. Create the Context</span></span><br><span class="line"><span class="comment">     * 2. Context object is used as a GC root</span></span><br><span class="line"><span class="comment">     * 3. Before returning the context object, we call the init() method.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a Context Object.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newContext</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException,</span></span><br><span class="line"><span class="function">         InvocationTargetException, IllegalAccessException, InstantiationException </span>&#123;</span><br><span class="line">        String className = <span class="string">"com.rovo98.miscExamples.hotDeployment.ContextReloading$Context"</span>;</span><br><span class="line">        Class&lt;?&gt; contextClass = <span class="keyword">new</span> MyClassLoader().loadClass(className);</span><br><span class="line">        Object context = contextClass.newInstance();</span><br><span class="line">        contextClass.getDeclaredMethod(<span class="string">"init"</span>).invoke(context);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Simply invokes the method of the context class</span></span><br><span class="line"><span class="comment">    since the method's rules will be update during the runtime</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeContext</span><span class="params">(Object context)</span> <span class="keyword">throws</span> NoSuchMethodException,</span></span><br><span class="line"><span class="function">         InvocationTargetException, IllegalAccessException </span>&#123;</span><br><span class="line">        context.getClass().getDeclaredMethod(<span class="string">"showUser"</span>).invoke(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">       <span class="keyword">private</span> UserService userService = <span class="keyword">new</span> UserService();</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           System.out.println(userService.getUserMessage());</span><br><span class="line">           System.out.println(<span class="string">"method invoked"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// initialize the object</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//            System.out.println("init successfully");</span></span><br><span class="line">           UserDao userDao = <span class="keyword">new</span> UserDao();</span><br><span class="line">           userDao.setUser(<span class="keyword">new</span> User());</span><br><span class="line">           userService.setUserDao(userDao);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// simple user service object</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">       <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> String <span class="title">getUserMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> userDao.getUserName();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserDao</span><span class="params">(UserDao userDao)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.userDao = userDao;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// simple user DAO object</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> User user;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getUserName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> user.getName();</span><br><span class="line"><span class="comment">//            return user.getAlias();</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.user = user;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// A simple model class</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name = <span class="string">"rovo98"</span>;</span><br><span class="line">        <span class="keyword">private</span> String alias = <span class="string">"testUser"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getAlias</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> alias;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAlias</span><span class="params">(String alias)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.alias = alias;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a user defined class loader.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"ResultOfMethodCallIgnored"</span>)</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">            String fileName = name.substring(name.lastIndexOf(<span class="string">"."</span>) + <span class="number">1</span>) + <span class="string">".class"</span>;</span><br><span class="line">            InputStream stream = getClass().getResourceAsStream(fileName);</span><br><span class="line">            <span class="keyword">if</span> (stream == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[stream.available()];</span><br><span class="line">                stream.read(b);</span><br><span class="line">                <span class="keyword">return</span> defineClass(name, b, <span class="number">0</span>, b.length);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>Output</strong>:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">1 round: context loaded successfully, ready to invoke the methods!</span><br><span class="line">rovo98</span><br><span class="line">2 round: context loaded successfully, ready to invoke the methods!</span><br><span class="line">rovo98</span><br><span class="line">3 round: context loaded successfully, ready to invoke the methods!</span><br><span class="line">rovo98</span><br><span class="line">4 round: context loaded successfully, ready to invoke the methods!</span><br><span class="line">testUser</span><br><span class="line">5 round: context loaded successfully, ready to invoke the methods!</span><br><span class="line">testUser</span><br><span class="line">6 round: context loaded successfully, ready to invoke the methods!</span><br><span class="line">testUser</span><br><span class="line">init successfully</span><br><span class="line">7 round: context loaded successfully, ready to invoke the methods!</span><br><span class="line">testUser</span><br><span class="line">init successfully</span><br><span class="line">8 round: context loaded successfully, ready to invoke the methods!</span><br><span class="line">testUser</span><br><span class="line">init successfully</span><br><span class="line">9 round: context loaded successfully, ready to invoke the methods!</span><br><span class="line">testUser</span><br><span class="line">init successfully</span><br><span class="line">10 round: context loaded successfully, ready to invoke the methods!</span><br><span class="line">testUser</span><br><span class="line">11 round: context loaded successfully, ready to invoke the methods!</span><br><span class="line">rovo98</span><br><span class="line">method invoked</span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure></div><p>输出结果和上一个例子类似，可以自己运行然后修改业务逻辑。不同与上一个例子，它解决了旧类的移除问题，因为<code>context</code>对象是作为GC root的，<code>context</code>又由我们自定义的类加载器加载, 由于<code>User/Dao/Service</code>的类都依赖于<code>context</code>，所以它们也是由自定义的类加载器加载的。</p><p>根据GC roots 原理，在创建新的自定义类加载后，旧的类加载器已经没有了任何引用链可达，符合GC回收规则，将会被GC收集器回收释放内存(注意不是马上回收)。</p><blockquote><p>运行程序，启动线程，用jvisualvm工具查看，并手动执行GC来验证</p></blockquote><ul><li>线程启动并运行一小会后(可以看到线程加载的类数量在持续增加):<br><img src="jvm-1-classreloading-vmdiagram-1.png" alt=""></li><li>手动执行GC来回收垃圾(从图中可以看到执行一次GC后卸载了56个类，而<code>1615</code>个类的加载刚刚就是一个类运行所需的基本的类(核心基础类等)):<br><img src="jvm-1-classreloading-vmdiagram-2.png" alt=""></li></ul><p>至此已经完成了热部署的流程，但是我们如果仔细看的话，这个热部署的实现的策略会把整个<code>context</code>对象也替换成新的, 那么用户的状态也将无法保留。而实际情况是我们只需要动态更新某些模块即可，而不是全局。这个也比较好处理，就是从业务上将需要热部署的交给自定义的类加载器加载，而持久化资源交给系统默认的类加载器去完成加载。</p><ul><li><strong>自动加载类加载器</strong></li></ul><p>其实涉及到代码涉及优雅问题，基本上我们就需要拿出设计模式(<strong>Design Pattern</strong>) 来对号入座的解决问题，毕竟这是前人经过千万实践锤炼出来的软件构建内功心法。</p><p>针对于我们热部署的场景，如果想把热部署细节封装起来，那代理模式无疑是最符合要求的，把类加载器的更替、回收，隔离等细节都放在代理对象里面来完成，而对于用户是透明的，对于终端用户而言，给他们的感觉就是纯粹的热部署了。</p><p>至于如何实现自动热部署，方式也相对比较简单吧，监听我们需要部署的目录，如果文件的时间和大小发生改变，即修改过后，则判断应用更新需求，触发类加载器的创建和旧对象的回收，此时也可以引入观察者模式来实现。</p><p>至于实现，我们参考现有的别人已经实现的热部署工具:</p><ul><li><a href="http://akhikhl.github.io/gretty-doc/Hot-deployment.html" target="_blank" rel="noopener">Gretty</a></li><li><a href="https://dcevm.github.io/" target="_blank" rel="noopener">DECVM</a><br>等等。。</li></ul><p>或者使用现成的热部署工具。<br>参考这篇文章即可:</p><ul><li><a href="https://dzone.com/articles/hot-swap-java-bytecode-on-runtime" target="_blank" rel="noopener">https://dzone.com/articles/hot-swap-java-bytecode-on-runtime</a></li></ul><p>其中有收费的商用工具JRabel, 免费开源的DECVM等。</p><div class="note primary"><p>参考链接:</p><ul><li><a href="https://stackoverflow.com/questions/35249234/how-hot-deployment-works-internally" target="_blank" rel="noopener">https://stackoverflow.com/questions/35249234/how-hot-deployment-works-internally</a></li><li><a href="https://iq.opengenus.org/memory-management-in-java-mark-sweep-compact-copy/" target="_blank" rel="noopener">https://iq.opengenus.org/memory-management-in-java-mark-sweep-compact-copy/</a></li><li><a href="https://plumbr.io/handbook/garbage-collection-algorithms" target="_blank" rel="noopener">https://plumbr.io/handbook/garbage-collection-algorithms</a></li><li><a href="https://developer.jboss.org/wiki/CurrentStateOfHotDeploymentInJava" target="_blank" rel="noopener">https://developer.jboss.org/wiki/CurrentStateOfHotDeploymentInJava</a></li><li><a href="https://www.future-processing.pl/blog/better-java-hot-code-replace-at-no-cost/" target="_blank" rel="noopener">https://www.future-processing.pl/blog/better-java-hot-code-replace-at-no-cost/</a></li></ul></div><h3 id="2-类隔离"><a href="#2-类隔离" class="headerlink" title="2. 类隔离"></a>2. 类隔离</h3><h4 id="2-1-背景介绍"><a href="#2-1-背景介绍" class="headerlink" title="2.1. 背景介绍"></a>2.1. 背景介绍</h4><p>通常我们的应用依赖不同的第三方类库会出现个不同版本的类库，如果只是使用系统内置的类加载器的话, 那么一个类库只能加载唯一的一个版本，下那个家在其他版本的时候，会从加载缓存里面发现类已经存在而停止加载。但是不同的业务往往又需要不同版本的类库，这是就会出现<code>ClassNotFoundException</code>。一般是在运行时才会出现异常，因为在编译的时候我们通常都使用<a href="https://maven.apache.org/" target="_blank" rel="noopener">MAVEN</a>等编译工具把冲突的版本给排除掉了。</p><p>另外一种情况是WEB容器的内核依赖的第三方类库需要跟应用依赖的类库隔离开来, 避免依稀而安全隐患，不然如果共用的话，应用升级依赖版本会导致WEB容器不稳定。</p><p>基于以上的介绍，我们已经基本知道了什么是<strong>类隔离(class isolation)</strong>以及它大概需要解决的问题。</p><h4 id="2-2-原理"><a href="#2-2-原理" class="headerlink" title="2.2. 原理"></a>2.2. 原理</h4><p>类隔离的原理其实也很简单，前文我们介绍过<strong>类的唯一标识</strong>(内存中定位一个类大概是这样的<code>&lt;类加载器, 类全称限定名&gt;</code>, 即一个类的标识有加载它的类加载器和它的全称限定名组成)。用不同的类加载器加载的相同的类(全称限定名一样，但是版本不一样), 在JVM看来，有通过这种方式加载进去的具有相同全称限定名的类是完全不同的。<strong>但是在业务视角上来看，我们可以把它们看作是相同的类。</strong></p><p>验证唯一标识的例子可以看上文讨论加载机制时提到的唯一标识。下面再提供一个简单的例子:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.rovo98.miscExamples.classLoading;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> rovo98</span></span><br><span class="line"><span class="comment"> * date: 2019.04.10 16:21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DifferentClassLoaders</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Driver the program to test loading the same class using different classloader</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args command-line arguments.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchFieldException,</span></span><br><span class="line"><span class="function">         IllegalAccessException, InstantiationException </span>&#123;</span><br><span class="line">       Class&lt;?&gt; clazz1 = Cat.class;</span><br><span class="line">       String className = <span class="string">"com.rovo98.miscExamples.classLoading.DifferentClassLoaders$Cat"</span>;</span><br><span class="line">       Class&lt;?&gt; clazz2 = <span class="keyword">new</span> MyClassLoader().loadClass(className);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Compare their class name(seems to be the same): "</span>);</span><br><span class="line">        System.out.println(<span class="string">"clazz1: "</span> + clazz1.getName());</span><br><span class="line">        System.out.println(<span class="string">"clazz2: "</span> + clazz2.getName());</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Compare their class loader: "</span>);</span><br><span class="line">        System.out.println(<span class="string">"clazz1's classloader: "</span> + clazz1.getClassLoader());</span><br><span class="line">        System.out.println(<span class="string">"clazz2's classloader: "</span> + clazz2.getClassLoader());</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"The static field value: "</span> + Cat.age);</span><br><span class="line">        Cat.age = <span class="number">3</span>; <span class="comment">// change the static field of the class Cat</span></span><br><span class="line">        System.out.println(<span class="string">"And to see the difference: "</span>);</span><br><span class="line">        Field f1 = clazz1.getDeclaredField(<span class="string">"age"</span>);</span><br><span class="line">        f1.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Field f2 = clazz2.getDeclaredField(<span class="string">"age"</span>);</span><br><span class="line">        f2.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        System.out.println(<span class="string">"clazz1's static field: "</span> + f1.getInt(clazz1.newInstance()) + <span class="string">"."</span>);</span><br><span class="line">        System.out.println(<span class="string">"clazz2's static field: "</span> + f2.getInt(clazz2.newInstance()) + <span class="string">"."</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A simple for testing</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> age = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"ResultOfMethodCallIgnored"</span>)</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">            String fileName = name.substring(name.lastIndexOf(<span class="string">"."</span>) + <span class="number">1</span>) + <span class="string">".class"</span>;</span><br><span class="line">            InputStream is = getClass().getResourceAsStream(fileName);</span><br><span class="line">            <span class="keyword">if</span> (is == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name); <span class="comment">// loading the class using system default classloader if MyClassLoader</span></span><br><span class="line">                                              <span class="comment">// can not the specify class.</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[is.available()];</span><br><span class="line">                is.read(b);</span><br><span class="line">                <span class="keyword">return</span> defineClass(name, b, <span class="number">0</span>, b.length);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>Output</strong>:<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Compare their class name(seems to be the same): </span><br><span class="line">clazz1: com.rovo98.miscExamples.classLoading.DifferentClassLoaders$Cat</span><br><span class="line">clazz2: com.rovo98.miscExamples.classLoading.DifferentClassLoaders$Cat</span><br><span class="line"></span><br><span class="line">Compare their class loader: </span><br><span class="line">clazz1&apos;s classloader: sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">clazz2&apos;s classloader: com.rovo98.miscExamples.classLoading.DifferentClassLoaders$MyClassLoader@7f31245a</span><br><span class="line"></span><br><span class="line">The static field value: 2</span><br><span class="line">And to see the difference: </span><br><span class="line">clazz1&apos;s static field: 3.</span><br><span class="line">clazz2&apos;s static field: 2.</span><br></pre></td></tr></table></figure></div></p><h4 id="2-3-实现"><a href="#2-3-实现" class="headerlink" title="2.3. 实现"></a>2.3. 实现</h4><p>虽然类隔离的原理很简单，但是实现一个高性能可扩展的高可用的隔离容器却不是简单的。就比如我们都知道Spring容器本质就是一个生产和管理<code>Bean</code>的集合对象，但是它包含了大量优秀的设计模式和复杂的框架实现。</p><p>上文提到的类隔离应用场景是在内存运行时才发现问题的，需要通过<strong>内存隔离</strong>来处理。而在这里，我们只先了解一下更为通用和简单的冲突解决方法。</p><ul><li><strong>冲突排除</strong></li></ul><p>冲突总是发生在编译时期，那么基本<a href="https://maven.apache.org/" target="_blank" rel="noopener">Maven</a>工具可以帮我们完成大部分的工作，Maven的工作模式就是将我们第三方类库的所有依赖都依次检索，最终排除掉产生冲突jar包的版本。</p><ul><li><strong>冲突匹配</strong></li></ul><p>当我们无法通过简单的排除来解决问题的时候，另外一个方法就是重新装配第三方类库，例如通过<a href="https://github.com/shevek/jarjar" target="_blank" rel="noopener">jarjar</a>开源工具类处理。它可以通过字节码技术将我们依赖的第三方类库重命名，同时修改代码里面对第三方类库引用的路径。这样如果出现同名第三方类库的话，通过该”硬编码“的方式修改其中一个类库，从而消除了冲突。</p><ul><li><strong>冲突隔离</strong></li></ul><p>上面的两种方式在小型系统中比较合适，也比较敏捷高效。但是对于分布式大型系统的话，通过硬编码方式来解决冲突就难以完成了。办法是通过隔离容器，从逻辑上区分类库的作用域，从而对内存的类进行隔离。</p><div class="note primary"><p>misc: </p><ul><li><a href="https://www.jcp.org/en/jsr/detail?id=121" target="_blank" rel="noopener">应用程序隔离规范 JSR 121 - https://www.jcp.org/en/jsr/detail?id=121</a></li><li><a href="https://www.flux.utah.edu/janos/jsr121-internal-review/java/lang/isolate/package-summary.html" target="_blank" rel="noopener">An implementation of JSR 121 - https://www.flux.utah.edu/janos/jsr121-internal-review/java/lang/isolate/package-summary.html</a></li></ul><p>相关开源项目:</p><ul><li><a href="https://github.com/chrisgleissner/jisolate" target="_blank" rel="noopener">https://github.com/chrisgleissner/jisolate</a></li></ul><p>参考链接:</p><ul><li><a href="https://www.toptal.com/java/java-wizardry-101-a-guide-to-java-class-reloading" target="_blank" rel="noopener">https://www.toptal.com/java/java-wizardry-101-a-guide-to-java-class-reloading</a></li><li><a href="https://stackoverflow.com/questions/3726635/using-classloader-for-isolating-two-static-classes" target="_blank" rel="noopener">https://stackoverflow.com/questions/3726635/using-classloader-for-isolating-two-static-classes</a></li></ul></div><p>有关于JVM中类加载的内容就先简单了解到这里了，后续再根据自己的需求深入学习吧!👆</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/java/basic/class-loading-subsystem.png&quot; alt=&quot;class-loading-subsystem&quot;&gt;&lt;/p&gt;
&lt;p&gt;了解Java中&lt;strong&gt;类的结构&lt;/strong&gt;(class file struture, 这里指&lt;code&gt;.class&lt;/code&gt;文件的结构)、&lt;strong&gt;类的加载机制&lt;/strong&gt;、&lt;strong&gt;类的加载过程&lt;/strong&gt;、&lt;strong&gt;类加载器的应用&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://rovo98.github.io/categories/Java/"/>
    
    
      <category term="JVM" scheme="http://rovo98.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JDK, JRE, JVM | 深入了解</title>
    <link href="http://rovo98.github.io/posts/12448424/"/>
    <id>http://rovo98.github.io/posts/12448424/</id>
    <published>2019-03-20T04:10:00.000Z</published>
    <updated>2019-04-10T13:21:20.504Z</updated>
    
    <content type="html"><![CDATA[<p>了解<strong>JDK, JRE, JVM之间的区别</strong>，<strong>JVM</strong>是如何工作的？什么是<strong>类加载器</strong>(<em>class loaders</em>), <strong>解释器</strong>(<em>interpreter</em>)和<strong>及时编译器</strong>(<em>JIT compilers</em>)</p><a id="more"></a><h2 id="1-Java程序的执行"><a href="#1-Java程序的执行" class="headerlink" title="1. Java程序的执行"></a>1. Java程序的执行</h2><p>在开始之前，让我们快速的回顾一下一个<em>Java</em>程序是如何执行的</p><ol><li>使用一个编辑器或者IDE(<strong>integrated development enviroment</strong>, 如<em>Eclipse</em>或<em>Intellij Idea</em>)编写<em>Java</em>源代码，假设是<code>Simple.java</code>文件；</li><li>程序需要编译成字节码(<em>bytecode</em>)。使用<em>Java</em>编译器(<code>javac</code>)将源代码文件编译成<code>Simple.class</code>文件；</li><li>在任意平台(e.g.<em>Mac, Windows, Linux</em>)上的<em>JVM</em>(<strong>java virtual machine</strong>)执行<code>.class</code>文件；</li><li><em>JVM</em>将字节码翻译成本机机器码(<em>native machine code</em>), 能够让本机执行。</li></ol><p><img src="Java-Execution-Flow.png" alt="java-execution-flow"></p><h2 id="2-什么是JVM"><a href="#2-什么是JVM" class="headerlink" title="2. 什么是JVM ?"></a>2. 什么是JVM ?</h2><p><strong>Java virtual machine</strong>(JVM) 是用于运行字节码的虚拟机。我们通过将<em>Java</em>源代码文件编译成<code>.class</code>字节码文件，之后由<em>JVM</em>执行。这也是为什么<em>Java</em>具有<strong>WORA(Write Once Run Anywhere)</strong>特性的原因。</p><p>在现实世界中，<em>JVM</em>是一种规范(<em>specification</em>)，它提供一种使<em>Java</em>字节码能够执行的运行环境(<em>runtime environment</em>)。不同的供应商这个规范的不同实现，例如：这个<em>wiki</em>页面列出的就是<a href="https://en.wikipedia.org/wiki/List_of_Java_virtual_machines" target="_blank" rel="noopener">JVM的不同实现</a>。</p><p>最流行的<em>JVM</em>实现是由<em>Oracle Corporation</em>拥有和提供的<a href="https://www.oracle.com/technetwork/java/javase/tech/index-jsp-136373.html" target="_blank" rel="noopener">Hotspot</a>。</p><p><em>JVM</em>使用了许多的先进技术为<em>Java</em>应用程序提供最佳性能，包括先进的内存模型(<em>memory model</em>)，<strong>垃圾收集器</strong>(<em>garbage collector</em>)和<strong>自适应优化器</strong>(<em>adaptive optimizer</em>)。</p><p><em>JVM</em>提供两种不同的版本 - 客户端(<code>-client</code>)和服务器(<code>-server</code>)。尽管它们很类似，但是服务器版本<em>JVM</em>经过专门调整，能够最大限度地提高运行速度峰值，它适用于在服务器上长期执行的应用程序，这些应用需要的是尽可能快的运行速度，而不是快速启动或较小的运行时内存占用。开发者可以指定<code>-client</code>或者<code>-server</code>来选择想要的<em>JVM</em>。</p><p><em>JVM</em>之所以说是虚拟(<strong>virtual</strong>)的, 是因为它提供的机器接口(<em>machine interface</em>)不依赖于底层的操作系统以及机器的硬件架构。</p><h3 id="2-1-JVM-架构"><a href="#2-1-JVM-架构" class="headerlink" title="2.1 JVM 架构"></a>2.1 JVM 架构</h3><p><em>JVM</em>可以分成三个主要的子系统(<em>subsystem</em>):</p><ol><li>类加载子系统(<strong>Class Loader Subsystem</strong>)</li><li>运行数据区(内存区)(<strong>Runtime Data Area</strong> or <strong>Memory Area</strong>)</li><li>执行引擎(<strong>Execution Engine</strong>)</li></ol><p><img src="JVM-Architecture.png" alt="JVM-Architecture"></p><h4 id="类加载子系统"><a href="#类加载子系统" class="headerlink" title="类加载子系统"></a>类加载子系统</h4><p>类加载子系统用于加载类文件(<em>class file</em>)。它的主要功能为: <strong>加载</strong>(<strong>loading</strong>)、<strong>链接</strong>(<strong>linking</strong>)、<strong>初始化</strong>(<strong>initialization</strong>)。</p><h5 id="1-加载-loading"><a href="#1-加载-loading" class="headerlink" title="1.加载(loading)"></a>1.加载(<em>loading</em>)</h5><ul><li>为了加载类文件，<em>JVM</em>提供了三种类加载器: <strong>Bootstrap</strong>, <strong>extension</strong> 和 <strong>application</strong> 类加载器;</li><li>当加载一个类文件时，<em>JVM</em>需要找出该类的依赖；</li><li>首先，<em>bootstrap</em>类加载器会在<code>$JAVA_HOME/jre/lib</code>目录下的<code>rt.jar</code>包中查找；</li><li>若有类文件未找到，<em>extension</em>类加载器会在<code>$JAVA_HOME/jre/lib/ext</code>目录下的类文件；</li><li>若仍有类文件未找到，<em>application</em>类加载器会搜索查找<code>CLASSPATH</code>环境变量下的所有类文件和<em>jar</em>包文件；</li><li>通过这些类加载找到的类文件会被加载，找不到的类文件则会抛出<code>ClassNotFoundException</code>异常。</li></ul><p>Java<strong>中类加载器的加载采用了双亲委托机制</strong>(<strong>Delegation-Hierarchy principle</strong>)。</p><p>当一个类加载接收到加载类的请求时，首先会将加载任务委托给上一级类加载器，依次递归，直到最后的<code>Bootstrap ClassLoader</code>，若<code>Boostrap ClassLoader</code>找不到时，则会将加载请求委托给下一级的类加载器，依次递归，直到最后的<code>Application ClassLoader</code>，在此过程中，若类被找到则直接返回，找不到则最终会抛出一个<code>java.lang.ClassNotFoundException</code>的运行时异常。</p><p><img src="jvmclassloader.jpg" alt=""></p><p>使用这种机制的好处非常好理解，目的就是为了<strong>避免重复加载已有的类，提高效率</strong>，还有就是强制从最高一级开始逐级搜索类文件，<strong>确保核心基础类优先加载</strong>。</p><div class="note primary"><p>JVM触发类加载器去加载外部类的情况:</p><ul><li>显示字节码指令集(<code>new/getstatic/putstatic/invokestatic</code>): 对应的场景是创建对象或者调用到类文件的静态变量/静态方法/静态代码块；</li><li>反射: 通过对象反射获取类对象时；</li><li>继承: 创建子类触发父类加载；</li><li>入口: 包含<code>main</code>方法的类首先加被加载。</li></ul></div><h5 id="2-链接-linking"><a href="#2-链接-linking" class="headerlink" title="2. 链接(linking)"></a>2. 链接(<em>linking</em>)</h5><p>此过程分为三个阶段:</p><ol><li><strong>验证阶段</strong>(<strong>Verify</strong>): 字节码验证器(<strong>Bytecode verifier</strong>)会验证生成的字节码是否正确，验证不通过则会抛出验证；<blockquote><p>验证阶段对于虚拟机的类加载机制来说，是一个非常重要但不一定是必要的阶段。如果所运行的全部代码都已经被反复使用和验证过，在实施阶段就可以考虑使用<code>-Xverify:none</code>参数来关闭大部分的类验证措施，从而缩短虚拟机类加载的时间。</p></blockquote></li><li><strong>准备阶段</strong>(<strong>Prepare</strong>): 为类中的静态变量(<em>static variables</em>)<strong>分配内存空间</strong>, 但还未初始化，也就是<code>0</code>或者<code>null</code>；</li><li><strong>解析阶段</strong>(<strong>Resolve</strong>): 将方法区(<strong>Method Area</strong>)的所有符号引用(<strong>symbolic memory references</strong>)全部替换为直接引用(<strong>Direct Reference</strong>)<div class="note primary"><p><strong>符号引用</strong>(<em>Symbolic Reference</em>): 符号引用以一组符号来描述所引用的目标，符号引用可以是任何形式的字面量，符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经在内存中。<br><strong>直接引用</strong>(<em>Direct Reference</em>): 直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用与虚拟机实现的内存布局相关，同一符号引用在不同的虚拟机上翻译出来的直接引用一般都不相同，如果有了直接引用，那引用的目标必定已经在内存中存在。</p></div></li></ol><h5 id="3-初始化-Initialization"><a href="#3-初始化-Initialization" class="headerlink" title="3. 初始化(Initialization)"></a>3. 初始化(<em>Initialization</em>)</h5><p>作为类加载过程的最后一个阶段，它为所有的静态变量赋初值，并执行静态代码块(<em>static blocks</em>)。</p><h4 id="JVM内存区域"><a href="#JVM内存区域" class="headerlink" title="JVM内存区域"></a>JVM内存区域</h4><p>在一个<em>Java</em>程序执行时，<em>JVM</em>为它定了许多<strong>运行时数据区</strong>(<strong>runtime data areas</strong>)。 其中一些数据区在<em>JVM</em>启动的时候创建，并在<em>JVM</em>退出的时才会销毁(<em>Destroy</em>)。其余的数据区是每个线程(<em>Thread</em>)各自都有的，在线程创建的时候创建，线程退出的时候销毁。</p><blockquote><p>在上面给出的<em>JVM</em>架构图就可以看到, 方法区(<em>Method Area</em>)、堆区(<em>Heap Area</em>)、本地方法区(Native Method Area)是随JVM启动而创建的(一个JVM只能有一个)； 栈区(Stack Area)和程序计数寄存器(PC Registers)是每个线程都有的，随线程创建而创建，销毁而销毁。</p></blockquote><ol><li><strong>方法区域</strong>(<em>Method Area</em>): 方法区存放类的结构数据，如运行常量池(<strong>runtime constant pool</strong>), 字段和方法数据，方法的代码，方法也包括类(<em>class</em>)、实例(<em>instance</em>)和接口初始化(<em>interface initialization</em>)的方法。<br><br>方法区在逻辑上实际是堆(<em>heap</em>)的一部分，但是不能被垃圾收集器收集，尽管垃圾收集在堆上是强制执行的。方法区的大小可以是固定的，或者可以根据需求进行扩展或缩小，且并不要求方法区的内存是连续的。<div class="note warning"><p>如果方法区的内存无法满足分配请求，<em>JVM</em>会抛出一个<code>OutOfMemoryError</code>。</p></div></li><li><strong>堆区域</strong>(<em>Heap Area</em>): 存放程序执行创建的所有对象，堆中存放的对象会有<strong>Garbage Collection</strong>来管理回收，堆的大小可以是固定，也可以动态大小的(取决系统的配置)，并且为堆分配的内存不需要是连续的。<div class="note warning"><p>如果自动存储管理系统(<strong>automatic storage management system</strong>)管理的堆内存空间无法满足分配需求，<em>JVM</em>会抛出一个<code>OutOfMemoryError</code>。<br>因为多个线程(<em>multiple threads</em>)共享方法区域和堆区域，所以数据的存储不是线程安全(<em>thread-safe</em>)的。</p></div></li><li><strong>栈区域</strong>(<em>Stack Area</em>): 每个线程均有一个独立的栈。对于每个方法的调用，都会在栈中创建一个条目(<em>entry</em>), 称为<strong>栈帧</strong>(<em>Stack Frame</em>); 所有的局部变量(local variables or thread-local variables)也会在栈内存中创建。<strong>栈区域是线程安全的，因为它不是共享资源</strong>。栈帧可以分为三种子实体(<em>subentities</em>):<ul><li>局部变量数组(<em>Local Variable Array</em>): 与方法相关的局部变量，它们相应的值将存放在这里；</li><li>操作数栈(<em>Operand stack</em>): 如果需要执行任何中间操作时，操作数栈充当执行操作的运行时工作区(<em>runtime workspace</em>)；</li><li>帧数据(<em>Frame data</em>): 对应方法的所有符号(<em>Symbols</em>)均存放在这里。在任何异常的情况下，捕获的块信息将保留在帧数据中。<div class="note warning"><ol><li>如果线程执行过程中，对栈区域的内存需求无法得到满足, JVM会抛出一个<code>StackOverflowError</code>异常；</li><li>若栈区域内存允许动态扩展，如果内存不足以实现扩展，或者当内存无法满足新创建线程的需求时，JVM会抛出一个<code>OutOfMemoryError</code>异常。</li></ol></div></li></ul></li><li><strong>程序计数器</strong>(<em>PC Registers</em>): 存放当前执行语句的物理内存地址，每个线程都有一个独立的程序计数器。</li><li><strong>本地方法栈</strong>(<em>Native Method stacks</em>): 存放本地方法(<em>native method</em>),信息，每个线程创建时，对应的本地方法栈也会创建。<div class="note warning"><ol><li>当本地方法栈无法满足一个线程执行时的需求时，JVM 会抛出一个<code>StackOverflowError</code>异常；</li><li>本地方法栈的大小可以是固定也可以是动态的，当扩展本地方法栈时或者为一个新的线程创建一个初始化的本地方法栈时，若内存需求无法得到满足，JVM会抛出<code>OutOfMemoryError</code>异常。</li></ol></div></li></ol><h4 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h4><p>存放到<strong>JVM内存区(Memory Area)或运行数据区(Runtime Data Area)</strong>中的字节码将由<strong>执行引擎</strong>(<em>Execution Engine</em>)执行。它使用两个内建的<strong>解释器</strong>(<em>inbuilt interpreter</em>)和一个<strong>及时编译器</strong>(<em>JIT compiler</em>)来将字节码转换成机器码，并执行。</p><p><img src="OS-Specific-Interpreters.png" alt=""></p><blockquote><p>不同平台有不同的解释器</p></blockquote><p>在<em>JVM</em>中，解释器和编译器都生成本地代码(<em>native code</em>),但它们生成代码的方式不同，代码优化也不同。</p><ol><li><strong>解释器</strong>(<em>Interpreter</em>):<br>JVM解释器根据预先定义好的<strong>JVM指令到机器指令的映射</strong>，将每一条字节码指令都转换成对应的本地指令(<em>native instruction</em>)。并且在没有对代码进行任何优化的情况下，直接执行。<div class="note primary"><p>解释器解释代码速度快；但是执行慢(代码未优化)，且对于重复的方法调用，每次都需要重新做解释再执行。</p></div></li><li><strong>JIT 编译器</strong>(<em>JIT compiler</em>):<br>为了提高性能，JIT 编译器会将合适的字节码序列(如上面提到的重复方法调用代码，以及其他的重复代码)编译成本地机器码，这些本地机器码可以被重复使用，以此来提高系统的性能。<br>JIT编译器由四个部分组成:<ul><li>中间代码生成器(<em>Intermediate Code Generator</em>): 用于生成中间代码；</li><li>代码优化器(<em>Code Optimizer</em>): 用于优化上面生成的中间代码；</li><li>目标代码生成器(<em>Target Code Generator</em>): 生成本地机器码；</li><li>配置器(<em>Profiler</em>): 一个特殊的部分，用于查找<em>hotspot</em>中的方法是否多次执行。</li></ul></li><li><strong>垃圾收集器</strong>(<em>Garbage Collector</em>): 收集和清除那些不可达对象(<em>unreferenced objects or dead objects</em>)。</li></ol><div class="note primary"><p><strong>[补充:]</strong></p><ol><li><strong>解释执行</strong>: 将高级语言编写的代码一条一条读取，解释成等价的低级语言代码并在对应的低级虚拟机上执行，在读取解释下一条代码，直到全部代码解释执行完毕。</li><li><strong>编译执行</strong>: 将所有的由高级语言编写的程序进行编译(转换成能够实现等价功能的低级语言程序)，并在低级虚拟机上执行。</li><li><strong>(JIT, Just-in-time)及时编译</strong>: 结合解释执行和编译执行的特点，它编译一部分代码，执行，再继续编译执行(不是一次性编译)。</li></ol><p>计算机体系结构中将计算机系统按功能划分层次结构:</p><blockquote><p>第6级(虚拟机) -&gt; 应用语言机器<br>第5级(虚拟机) -&gt; 高级语言机器<br>第4级(虚拟机) -&gt; 汇编语言机器<br>第3级(虚拟机) -&gt; 操作系统机器<br>第2级(物理机) -&gt; 传统机器语言机器<br>第1级(物理机) -&gt; 微程序机器</p><ol><li>翻译(<em>Translation</em>): 先用转换程序把高一级机器上的程序转换为低一级机器上的等效程序，然后再在该低级机器上运行，实现程序的功能。</li><li>解释(<em>Interpretation</em>): 是对于高一级机器上的程序的<strong>每一条语句或指令</strong>，都转成去执行低一级机器的<strong>一段等效程序</strong>. 执行完之后，再去高一级机器取下一条语句或指令，再进行解释执行，如此反复，知道解释执行完整个程序。<br><strong>在6级层次中，一般下面三层是用解释实现的，而上面三层是经常使用翻译的方式。</strong></li></ol></blockquote></div><h4 id="Java-Native-Interface-JNI"><a href="#Java-Native-Interface-JNI" class="headerlink" title="Java Native Interface(JNI)"></a>Java Native Interface(JNI)</h4><p>JNI处理本地方法库文件(<em>Native Method Libraries</em>)，为执行引擎提供需要的本地方法库文件。</p><h4 id="Native-Method-Libraries"><a href="#Native-Method-Libraries" class="headerlink" title="Native Method Libraries"></a>Native Method Libraries</h4><p>存放执行引擎需要用到的本地方法库文件的一个集合。</p><h2 id="3-什么是JRE"><a href="#3-什么是JRE" class="headerlink" title="3. 什么是JRE ?"></a>3. 什么是JRE ?</h2><p>JRE(<em>Java Runtime Environment</em>, Java运行环境)一个包含一些库文件(jar包)、用Java编写的用于运行程序的组件和Java虚拟机的软件包。</p><p>为了运行任何Java程序，我们至少需要在我们的机器上安装<em>JRE</em>。</p><p><em>JRE</em>绑定以下组件:</p><ol><li>Java HotSpot 客户端虚拟机需要用到的<em>DLL</em>动态链接库文件;</li><li>Java HotSpot 服务端虚拟机需要用的<em>DLL</em>动态链接库文件;</li><li>Java 运行环境用到的<strong>代码库文件</strong>(<em>Code libiraries</em>)、<strong>属性设置</strong>(<em>property settings</em>)以及<strong>资源文件</strong>(<em>resource files</em>)，例如: <code>rt.jar</code>和<code>charset.jar</code>;</li><li>Java 扩展文件，例如: <code>localedata.jar</code>。</li></ol><p>以及其他的安全管理用到的文件，<strong>applets</strong>使用的<em>jar</em>包等。</p><p>不同系统平台、64位和32位的系统拥有不同的JRE。</p><h2 id="4-什么是JDK"><a href="#4-什么是JDK" class="headerlink" title="4. 什么是JDK ?"></a>4. 什么是JDK ?</h2><p>JDK(<em>Java Development Kit</em>, Java 开发工具)，它包含<em>JRE</em>, 同时包含用于开发Java程序的工具。</p><p>下面列出的是<em>JDK</em>包含的一些重要的开发工具:</p><ul><li><strong>appletviewer</strong>: 用于运行和调试Java applet 程序，不需要Web浏览器；</li><li><strong>apt</strong>: 注解处理工具(<em>The annotation-processing-tool</em>)；</li><li><strong>extchecker</strong>: 检测jar包冲突的工具；</li><li><strong>javadoc</strong>: 文档生成工具，可以根据源代码编写的注释自动生成文档；</li><li><strong>jar</strong>: 打包工具，用于将相关的类库打包成一个jar包文件，也可以用于管理jar包；</li><li><strong>jarsigner</strong>: jar包签名和验证工具；</li><li><strong>javap</strong>: class 类文件反编译器(<em>class file disassembler</em>)；</li><li><strong>javaws</strong>: JNLP程序 Java Web 启动器；</li><li><strong>JConsole</strong>: Java 监视和管理console；</li><li><strong>jhat</strong>: Java 堆分析工具；</li><li><strong>jrunscript</strong>: Java 命令行脚本 shell；</li><li><strong>jstack</strong>: 用于打印Java线程栈踪迹的工具；</li><li><strong>keytool</strong>: 操作keystore的工具；</li><li><strong>policytool</strong>: 策略(policy)修改和管理工具；</li><li><strong>xjc</strong>: Java API 的一部分，JAXB(XML Binding API), 接受XML模式(<em>schema</em>)并生成Java类。</li></ul><p>和<em>JRE</em>一样，<em>JDK</em>也是平台独立的，需要为不同的机器下载不同的<em>JDK</em>。</p><h2 id="5-JDK-JRE-JVM之间的区别"><a href="#5-JDK-JRE-JVM之间的区别" class="headerlink" title="5. JDK, JRE, JVM之间的区别"></a>5. JDK, JRE, JVM之间的区别</h2><p>基于上面的讨论，我们可以简单下面一个图来展示它们的关系:</p><blockquote><p>JRE = JVM + libraries to run Java application.<br>JDK = JRE + tools to develop Java application.</p></blockquote><p><img src="JDK-JRE-JVM.png" alt=""></p><p>简单来说，Java开发人员需要在机器上安装<em>JDK</em>来开发Java程序；如果我们只需要能够运行Java程序，则只在机器上安装<em>JRE</em>即可。</p><p>参考链接:</p><ol><li><a href="https://dzone.com/articles/jvm-architecture-explained" target="_blank" rel="noopener">https://dzone.com/articles/jvm-architecture-explained</a></li><li><a href="https://stackoverflow.com/questions/11547458/what-is-the-difference-between-jvm-jdk-jre-openjdk" target="_blank" rel="noopener">https://stackoverflow.com/questions/11547458/what-is-the-difference-between-jvm-jdk-jre-openjdk</a></li><li><a href="https://www.geeksforgeeks.org/jvm-works-jvm-architecture/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/jvm-works-jvm-architecture/</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;了解&lt;strong&gt;JDK, JRE, JVM之间的区别&lt;/strong&gt;，&lt;strong&gt;JVM&lt;/strong&gt;是如何工作的？什么是&lt;strong&gt;类加载器&lt;/strong&gt;(&lt;em&gt;class loaders&lt;/em&gt;), &lt;strong&gt;解释器&lt;/strong&gt;(&lt;em&gt;interpreter&lt;/em&gt;)和&lt;strong&gt;及时编译器&lt;/strong&gt;(&lt;em&gt;JIT compilers&lt;/em&gt;)&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://rovo98.github.io/categories/Java/"/>
    
    
      <category term="JVM" scheme="http://rovo98.github.io/tags/JVM/"/>
    
      <category term="JRE" scheme="http://rovo98.github.io/tags/JRE/"/>
    
      <category term="JDK" scheme="http://rovo98.github.io/tags/JDK/"/>
    
  </entry>
  
  <entry>
    <title>GPG入门使用</title>
    <link href="http://rovo98.github.io/posts/7ea77913/"/>
    <id>http://rovo98.github.io/posts/7ea77913/</id>
    <published>2018-11-14T11:08:30.000Z</published>
    <updated>2019-03-26T03:01:29.760Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><blockquote><p>gpg  is the OpenPGP part of the GNU Privacy Guard (GnuPG). It is a tool to provide digital encryption and signing services using the OpenPGP standard.<br>gpg features: complete key management and all the bells and whistles you would expect from a full OpenPGP implementation.</p></blockquote><div class="note info"><p><code>GnuPG</code>(GPG) 是 基于<code>OpenPGP</code>(由<a href="https://www.ietf.org/rfc/rfc4880.txt" target="_blank" rel="noopener">RFC4880</a>定义,也被称为<code>PGP</code>)的一个完整的和免费的实现.我们可以使用<code>GPG</code>来对我们的数据和通信进行加密(encrypt)和签名(sign), 它具有通用的密钥管理系统，以及各种公钥目录的访问模块. 我们可以很容易地使用<code>GPG</code>提供的命令行工具(当前它还提供不同平台下的图形界面工具<em>frontends</em>,以及库文件<em>libraries</em>)与其他的应用进行结合.同时还对<code>S/MIME</code>和<code>SSH(Security Shell)</code>提供支持.</p></div><a id="more"></a><p>本文使用环境为Linux命令行，掌握命令行，Window(<code>Gpg4win</code>)等<a href="https://www.gnupg.org/download/index.html" target="_blank" rel="noopener">其他客户端</a>也很容易掌握。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><code>GPG</code>有两种安装方式。可以<a href="https://www.gnupg.org/download/index.html" target="_blank" rel="noopener">下载源码</a>, 自己编译安装:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure></div><p>更方便的方式是直接安装编译好的二进制包:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Arch 环境</span><br><span class="line">sudo pacman -S gnupg</span><br><span class="line"></span><br><span class="line"># Debian / Ubuntu 环境</span><br><span class="line">sudo apt-get install gnupg</span><br><span class="line"></span><br><span class="line"># Fedora 环境</span><br><span class="line">yum install gnupg</span><br></pre></td></tr></table></figure></div><p>安装完成后，键入下面的命令:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --help</span><br></pre></td></tr></table></figure></div><p>如果屏幕显示GPG的帮助信息，就表示安装成功。<br><img src="gpg-help.jpg" alt=""></p><h3 id="密钥管理"><a href="#密钥管理" class="headerlink" title="密钥管理"></a>密钥管理</h3><p>在使用<code>GPG</code>进行加密和签名之前，我们应该清楚的知道，它还是一个优秀的密钥管理工具(key Manager).</p><p>可以使用<code>gpg --list-keys</code>查看当前管理的所有密钥.</p><h4 id="生成密钥对"><a href="#生成密钥对" class="headerlink" title="生成密钥对"></a>生成密钥对</h4><p>使用<code>gpg --gen-key</code>或<code>gpg --full-gen-key</code>(设置完整的参数配置来生成密钥对)</p><p>以完整的生成密钥对为例,<code>gpg --full-gen-key</code></p><p>(1).选择加密的算法(默认<code>RSA</code>):<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">gpg (GnuPG) 2.2.11; Copyright (C) 2018 Free Software Foundation, Inc.</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.</span><br><span class="line"></span><br><span class="line">Please select what kind of key you want:</span><br><span class="line">   (1) RSA and RSA (default)</span><br><span class="line">   (2) DSA and Elgamal</span><br><span class="line">   (3) DSA (sign only)</span><br><span class="line">   (4) RSA (sign only)</span><br><span class="line">Your selection?</span><br></pre></td></tr></table></figure></div></p><p>(2).选择密钥的大小(默认2048位):</p><div class="note warning"><p>密钥的位数越大，对于防范暴力破解攻击就越安全,但是对于各种用途，使用默认的大小已经足够了，因为绕过加密比试图破解代价反而更少一些。此外，随着密钥大小的增加，加密和解密将变慢，较大的密钥位数可能会影响签名的长度。</p></div><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RSA keys may be between 1024 and 4096 bits long.</span><br><span class="line">What keysize do you want? (2048)</span><br></pre></td></tr></table></figure></div><p>(3). 配置密钥的失效时间(默认0, 永不失效)</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Please specify how long the key should be valid.</span><br><span class="line">         0 = key does not expire</span><br><span class="line">      &lt;n&gt;  = key expires in n days</span><br><span class="line">      &lt;n&gt;w = key expires in n weeks</span><br><span class="line">      &lt;n&gt;m = key expires in n months</span><br><span class="line">      &lt;n&gt;y = key expires in n years</span><br><span class="line">Key is valid for? (0) </span><br><span class="line">Key does not expire at all</span><br><span class="line">Is this correct? (y/N) y</span><br></pre></td></tr></table></figure></div><p>(4). 配置用户信息</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GnuPG needs to construct a user ID to identify your key.</span><br><span class="line"></span><br><span class="line">Real name: alice</span><br><span class="line">Email address: alice@gmail.com</span><br><span class="line">Comment: A Test case</span><br><span class="line">You selected this USER-ID:</span><br><span class="line">    &quot;alice (A Test case) &lt;alice@gmail.com&gt;&quot;</span><br><span class="line"></span><br><span class="line">Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? </span><br><span class="line"></span><br><span class="line"># 最后确认信息，若需要修改可进行更新，按O确认</span><br></pre></td></tr></table></figure></div><p>(5). 最后输入加密密码，完成密钥对的生成</p><p><img src="gpg-passphrase.png" alt=""></p><p>查看当前的所有密钥对:</p><p><img src="gpg-list-keys.jpg" alt=""></p><h4 id="密钥的导出和导入"><a href="#密钥的导出和导入" class="headerlink" title="密钥的导出和导入"></a>密钥的导出和导入</h4><p>导入公钥/私钥:</p><p>公钥和私钥的导入都是使用一样的命令<code>gpg --import</code></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#导入公钥</span><br><span class="line">gpg --import rovo98.pub</span><br><span class="line"># 导入私钥</span><br><span class="line">gpg --import rovo98.pri</span><br></pre></td></tr></table></figure></div><p>导入公钥之后，应进行验证。<code>GnuPG</code>提供了功能强大的信任模型，不需要我们亲自验证导入的每一个公钥。但是一些公钥还是需要亲自进行验证的，下面简单了解一下如何对导入的公钥进行验证。</p><div class="note danger"><p>通过验证公钥的指纹，然后签名(Sign)公钥以将其证明为有效公钥来验证密钥。可以使用<code>--fingerprint</code>命令行选项快速查看公钥的指纹，但为了验证公钥，必须对其进行编辑。</p></div><p>编辑公钥示例:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gpg --edit-key blake@cyb.org</span><br><span class="line"></span><br><span class="line">pub  1024D/9E98BC16  created: 1999-06-04 expires: never      trust: -/q</span><br><span class="line">sub  1024g/5C8CBD41  created: 1999-06-04 expires: never     </span><br><span class="line">(1)  Blake (Executioner) &lt;blake@cyb.org&gt;</span><br><span class="line"></span><br><span class="line">Command&gt; fpr</span><br><span class="line">pub  1024D/9E98BC16 1999-06-04 Blake (Executioner) &lt;blake@cyb.org&gt;</span><br><span class="line">             Fingerprint: 268F 448F CCD7 AF34 183E  52D8 9BDE 1A08 9E98 BC16</span><br></pre></td></tr></table></figure></div><blockquote><p>公钥的指纹验证需要通过公钥的所有者进行验证。可以通过电话或任何其他方式亲自完成，只要能够和公钥的真正所有者进行联系就行。<br><strong>如果获得指纹与公钥所有者的指纹相同，才可以确定我们得到是正确的公钥副本</strong></p></blockquote><p>检查指纹之后，最后进行公钥的签名(Sign)完成验证。由于公钥签名是公钥加密中的一个弱点，因此在进行签名验证之前，必须确保指纹验证是正确的。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Command&gt;&gt; sign</span><br><span class="line">             </span><br><span class="line">pub  1024D/9E98BC16  created: 1999-06-04 expires: never      trust: -/q</span><br><span class="line">             Fingerprint: 268F 448F CCD7 AF34 183E  52D8 9BDE 1A08 9E98 BC16</span><br><span class="line"></span><br><span class="line">     Blake (Executioner) &lt;blake@cyb.org&gt;</span><br><span class="line"></span><br><span class="line">Are you really sure that you want to sign this key</span><br><span class="line">with your key: <span class="string">"Alice (Judge) &lt;alice@cyb.org&gt;"</span></span><br><span class="line"></span><br><span class="line">Really sign?</span><br></pre></td></tr></table></figure></div><blockquote><p>签名之后，可以检查公钥，以列出其上面的签名，并查看我们添加的签名。公钥上的每个用户ID都可以具有一个或多个自签名以及已经通过公钥验证的签名。</p></blockquote><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Command&gt; check</span><br><span class="line">uid  Blake (Executioner) &lt;blake@cyb.org&gt;</span><br><span class="line">sig!       9E98BC16 1999-06-04   [self-signature]</span><br><span class="line">sig!       BB7576AC 1999-06-04   Alice (Judge) &lt;alice@cyb.org&gt;</span><br></pre></td></tr></table></figure></div><p><strong>导出公钥(Public key)</strong></p><p>要将公钥发送给对应的用户之前，我们需要将密钥对的公钥导出，在<code>GPG</code>中使用<code>gpg --export</code>命令导出</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --output alice.gpg --<span class="built_in">export</span> alice@gmail.com</span><br></pre></td></tr></table></figure></div><p>默认导出的文件是以<strong>二进制格式</strong>保存的，非常不方便进行传输，因此<code>GPG</code>还提供了<code>--armor</code>参数来指定以<code>ASCII</code>码形式导出。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --armor --output alice.gpg --<span class="built_in">export</span> alice@gmail.com</span><br></pre></td></tr></table></figure></div><p><img src="gpg-export-pub-key.jpg" alt=""></p><p><strong>导出私钥(Private key)</strong>:</p><p><code>GPG</code>还支持导出私钥，不过是对所有的私钥进行导出，同样可以二进制格式或<code>ASCII</code>格式导出.</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --<span class="built_in">export</span>-secret-keys --armor</span><br></pre></td></tr></table></figure></div><h4 id="上传公钥"><a href="#上传公钥" class="headerlink" title="上传公钥"></a>上传公钥</h4><p>公钥服务器是网络上专门储存用户公钥的服务器。send-keys参数可以将公钥上传到服务器。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --send-keys [用户ID] --keyserver [服务器域名]</span><br></pre></td></tr></table></figure></div><p>使用上面的命令，你的公钥就被传到了服务器，然后通过交换机制，所有的公钥服务器最终都会包含你的公钥。</p><p>由于公钥服务器没有检查机制，任何人都可以用你的名义上传公钥，所以没有办法保证服务器上的公钥的可靠性。通常，你可以在网站上公布一个公钥指纹，让其他人核对下载到的公钥是否为真。fingerprint参数生成公钥指纹。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --fingerprint [用户ID]</span><br></pre></td></tr></table></figure></div><p>从公钥服务器上获取公钥:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --receive-keys</span><br></pre></td></tr></table></figure></div><p>获取到的公钥需要进行验证,参考上面提到的导入公钥的验证方式。</p><h3 id="加密和解密文件"><a href="#加密和解密文件" class="headerlink" title="加密和解密文件"></a>加密和解密文件</h3><p>在加密和解密文件时，公钥和私钥各自具有特定的作用。</p><blockquote><p>公钥可以被认为是开放式保险箱。当通过公钥加密文件时，该文件被放入保险箱，安全关闭，并且组合锁经过多次旋转和组合。<br>相对应的私钥是可以重新打开保险箱并检索文件的组合(组合锁组合)。换句话说，之后持有私钥的人才能恢复和使用相关公钥加密文件。</p></blockquote><div class="note info"><p>因此加解密过程应该是这样的，假设你要给<code>alice</code>发送加密信息，使用<code>alice</code>的公钥对信息进行加密，则<code>alice</code>可以使用她的私钥对加密信息进行解密，而当她向你发送加密信息，加密信息时使用的应该是你的公钥。</p></div><p>加密例子: 使用<code>alice</code>的公钥对<code>sourceListforKali</code>进行加密</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --output sourceListforKali.en --encrypt sourceListforKali --recipient alice@gmail.com</span><br></pre></td></tr></table></figure></div><p><code>--recipient</code>指定使用的公钥</p><p>解密:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --output sourceListforKali.de --decrypt sourceListforKali.en</span><br></pre></td></tr></table></figure></div><p>输入之前创建该密钥对的密码就可以对文件进行解密。</p><p><img src="gpg-encrypt-decrypt.jpg" alt=""></p><div class="note warning"><p>我们还可以在不使用公钥的情况下，对文件进行加密，使用的是对称密码(symmetric chiper).使用<code>--symmetric</code>参数即可</p><p>手动输入加密密码即可。</p></div><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --output sourceListforKali.gpg --symmetric sourceListforKali</span><br></pre></td></tr></table></figure></div><h3 id="签名-signatures"><a href="#签名-signatures" class="headerlink" title="签名(signatures)"></a>签名(signatures)</h3><p>数字签名证明文档并为其加上时间戳。如果随后以任何方式修改了文档，则签名验证将失败。数字签名可以起到与手写签名相同的作用，并具有防篡改的额外好处。</p><p>例如：当你将文件签名并发布后，则接受到该文件的用户可以验证签名来查看文件是否被修改过。</p><h4 id="创建和验证签名"><a href="#创建和验证签名" class="headerlink" title="创建和验证签名"></a>创建和验证签名</h4><p>创建和验证签名使用公/私钥对的方式不同于加解密操作。使用签名者的私钥创建签名，使用相应的公钥验证签名。</p><p>使用数字签名的好处是一般情况下，签名人是确定的，除非签名者的私钥被泄露了。</p><p>使用<code>--sign</code>参数创建数字签名，例:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gpg --output doc.sig --sign doc</span><br><span class="line">You need a passphrase to unlock the private key <span class="keyword">for</span></span><br><span class="line">user: <span class="string">"Alice (Judge) &lt;alice@cyb.org&gt;"</span></span><br><span class="line">1024-bit DSA key, ID BB7576AC, created 1999-06-04</span><br><span class="line"></span><br><span class="line">Enter passphrase:</span><br></pre></td></tr></table></figure></div><p>签名的文件在签名之前会被进行压缩处理，并输出一个二进制格式的签名文件。根据给定的签名文件，可以检查签名或检查签名并恢复原始文件。</p><p>检查和验证签名使用<code>--verify</code>参数选项,验证签名并恢复原始文件使用<code>--decrypt</code>选项:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gpg --output doc --decrypt doc.sig</span><br><span class="line">gpg: Signature made Fri Jun  4 12:02:38 1999 CDT using DSA key ID BB7576AC</span><br><span class="line">gpg: Good signature from <span class="string">"Alice (Judge) &lt;alice@cyb.org&gt;"</span></span><br></pre></td></tr></table></figure></div><div class="note danger"><p>一般情况下，数字签名多数应用于对互联网上的帖子<em>post</em>以及<em>email</em>进行签名。这种情况下，我们一般不希望对需要签名的文件进行压缩处理，因此可以使用<code>--clearsign</code>选项，在不修改文件的情况下，将文件以<code>ASCII</code>的形式包装在签名文件中。</p></div><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">gpg --clearsign doc</span><br><span class="line"></span><br><span class="line">You need a passphrase to unlock the secret key <span class="keyword">for</span></span><br><span class="line">user: <span class="string">"Alice (Judge) &lt;alice@cyb.org&gt;"</span></span><br><span class="line">1024-bit DSA key, ID BB7576AC, created 1999-06-04</span><br><span class="line"></span><br><span class="line">-----BEGIN PGP SIGNED MESSAGE-----</span><br><span class="line">Hash: SHA1</span><br><span class="line"></span><br><span class="line">[...]</span><br><span class="line">-----BEGIN PGP SIGNATURE-----</span><br><span class="line">Version: GnuPG v0.9.7 (GNU/Linux)</span><br><span class="line">Comment: For info see http://www.gnupg.org</span><br><span class="line"></span><br><span class="line">iEYEARECAAYFAjdYCQoACgkQJ9S6ULt1dqz6IwCfQ7wP6i/i8HhbcOSKF4ELyQB1</span><br><span class="line">oCoAoOuqpRqEzr4kOkQqHRLE/b8/Rw2k</span><br><span class="line">=y6kj</span><br><span class="line">-----END PGP SIGNATURE-----</span><br></pre></td></tr></table></figure></div><div class="note primary"><p>分离的、独立的签名文件(<em>Detached signatures</em>): 一个签名过的文件的用途一般是很少的。</p><p>其他用户必须从签名文件中恢复原始文档，即使使用未压缩处理的签名文件(Clearsigned)，也必须编辑签名文档以恢复原始文档。</p><p>因此，<code>GPG</code>还提供用于对文档创建分离签名第三种签名方法，该签名是单独的文件。使用<code>--detach-sig</code>选项创建分离签名。</p></div><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gpg --output doc.sig --detach-sig doc</span><br><span class="line"></span><br><span class="line">You need a passphrase to unlock the secret key <span class="keyword">for</span></span><br><span class="line">user: <span class="string">"Alice (Judge) &lt;alice@cyb.org&gt;"</span></span><br><span class="line">1024-bit DSA key, ID BB7576AC, created 1999-06-04</span><br><span class="line"></span><br><span class="line">Enter passphrase:</span><br></pre></td></tr></table></figure></div><p>通过此方法创建的签名，在验证时就需要同时使用签名和对应原文件:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SH"><figure class="iseeu highlight /sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gpg --verify doc.sig doc</span><br><span class="line"></span><br><span class="line">gpg: Signature made Fri Jun  4 12:38:46 1999 CDT using DSA key ID BB7576AC</span><br><span class="line">gpg: Good signature from <span class="string">"Alice (Judge) &lt;alice@cyb.org&gt;"</span></span><br></pre></td></tr></table></figure></div><h3 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h3><p>以上就是<code>GnuPG</code>的简单入门使用，更多的可以详细阅读<code>GnuPG</code>提供的<a href="https://www.gnupg.org/documentation/index.html" target="_blank" rel="noopener">用户手册和文档</a>.</p><p>例如: 我们可以在加密文件的同时对文件进行签名(使用三种签名方法的其中一种)</p><div class="note primary"><p>参看链接:</p><ul><li><a href="https://www.gnupg.org/gph/en/manual.html" target="_blank" rel="noopener">https://www.gnupg.org/gph/en/manual.html</a></li><li><a href="https://futureboy.us/pgp.html" target="_blank" rel="noopener">https://futureboy.us/pgp.html</a></li></ul></div>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;引入&quot;&gt;&lt;a href=&quot;#引入&quot; class=&quot;headerlink&quot; title=&quot;引入&quot;&gt;&lt;/a&gt;引入&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;gpg  is the OpenPGP part of the GNU Privacy Guard (GnuPG). It is a tool to provide digital encryption and signing services using the OpenPGP standard.&lt;br&gt;gpg features: complete key management and all the bells and whistles you would expect from a full OpenPGP implementation.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;&lt;code&gt;GnuPG&lt;/code&gt;(GPG) 是 基于&lt;code&gt;OpenPGP&lt;/code&gt;(由&lt;a href=&quot;https://www.ietf.org/rfc/rfc4880.txt&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;RFC4880&lt;/a&gt;定义,也被称为&lt;code&gt;PGP&lt;/code&gt;)的一个完整的和免费的实现.我们可以使用&lt;code&gt;GPG&lt;/code&gt;来对我们的数据和通信进行加密(encrypt)和签名(sign), 它具有通用的密钥管理系统，以及各种公钥目录的访问模块. 我们可以很容易地使用&lt;code&gt;GPG&lt;/code&gt;提供的命令行工具(当前它还提供不同平台下的图形界面工具&lt;em&gt;frontends&lt;/em&gt;,以及库文件&lt;em&gt;libraries&lt;/em&gt;)与其他的应用进行结合.同时还对&lt;code&gt;S/MIME&lt;/code&gt;和&lt;code&gt;SSH(Security Shell)&lt;/code&gt;提供支持.&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://rovo98.github.io/categories/Linux/"/>
    
      <category term="softwares" scheme="http://rovo98.github.io/categories/Linux/softwares/"/>
    
    
      <category term="linux" scheme="http://rovo98.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>记录一次linux系统迁移过程</title>
    <link href="http://rovo98.github.io/posts/3babee60/"/>
    <id>http://rovo98.github.io/posts/3babee60/</id>
    <published>2018-10-07T06:00:00.000Z</published>
    <updated>2019-03-26T02:44:38.339Z</updated>
    
    <content type="html"><![CDATA[<p>就在最近，终于为自己的电脑加装了固态。在装完固态之后，首先面临的问题就是如何将原先安装在机械硬盘上的<code>linux</code>系统迁移到固态上。还要考虑后续配置的问题。</p><p>本文主要讲述在迁移<code>Linux</code>系统到新的固态硬盘上所遇到的问题以及找到的相应的解决方法。</p><p>这里先给出系统迁移以及相关配置完成之后的机械硬盘和固态硬盘的简单测速对比:</p><p><img src="/images/linux/hdparam.jpg" alt=""></p><a id="more"></a><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><div class="note info"><p>拆开电脑，直接加装固态,顺便清清灰尘，换一下硅脂(ps: 这不知道是我第几次拆电脑了…,表示以后再也不买GPU风扇了，这已经是第二次失败的购买经历了(<code>除非得到与原来匹配的风扇一致的风扇，不然我是不再换了</code>).</p></div><p>清尘换硅脂:</p><p><img src="install_ssd01.jpg" alt="install-ssd-01"><br>加装固态和散热板:</p><p><img src="install_ssd02.jpg" alt="install-ssd-01"></p><div class="note primary"><p>关于固态如何购买挑选，需要很好的了解自己电脑能够支持的固态类型和市场所提供的固态类型，并综合各种因素才能做出最好的选择。这里我推荐几篇个人觉得不错的文章:</p><ul><li><a href="https://www.laptopmag.com/articles/laptop-ssd-guide" target="_blank" rel="noopener">https://www.laptopmag.com/articles/laptop-ssd-guide</a></li><li><a href="https://www.tomshardware.com/reviews/ssd-buying-guide,5602.html" target="_blank" rel="noopener">https://www.tomshardware.com/reviews/ssd-buying-guide,5602.html</a></li><li><a href="https://www.velocitymicro.com/blog/nvme-vs-m-2-vs-sata-whats-the-difference/" target="_blank" rel="noopener">https://www.velocitymicro.com/blog/nvme-vs-m-2-vs-sata-whats-the-difference/</a></li><li><a href="https://blog.csdn.net/u010109732/article/details/79032845" target="_blank" rel="noopener">https://blog.csdn.net/u010109732/article/details/79032845</a></li><li><a href="https://www.zhihu.com/question/48972075" target="_blank" rel="noopener">https://www.zhihu.com/question/48972075</a></li><li><a href="https://www.pc841.com/article/20180914-92342_all.html" target="_blank" rel="noopener">https://www.pc841.com/article/20180914-92342_all.html</a></li><li><a href="https://www.techadvisor.co.uk/test-centre/storage/best-ssd-2018-3235200/" target="_blank" rel="noopener">https://www.techadvisor.co.uk/test-centre/storage/best-ssd-2018-3235200/</a></li></ul><p>以上推荐文章仅作为参考。</p></div><h3 id="迁移系统"><a href="#迁移系统" class="headerlink" title="迁移系统"></a>迁移系统</h3><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>进入原先的<code>linux</code>系统，对已经安装上的固态硬盘进行分区。因为我之前在没有固态之前，在机械硬盘上就已经安装了三个系统(<code>win10</code>, <code>manjaro</code>, <code>kali</code>),因此在分区时，我是考虑只把两个<code>linux</code>迁移到固态上，毕竟<code>win10</code>现在已经基本不使用了，并将机械硬盘上的<code>EFI</code>分区也迁移到固态上。分区这里，可以按照自己的需求对固态硬盘进行分区。</p><p>分区工具的选择，随意，哪个顺手用哪个，例如:<code>gparted</code>, <code>fdisk</code>, <code>parted</code>,还有各种桌面自带的分区工具。我是使用的是<code>fdisk</code>:<br>例如:<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo fdisk /dev/nvme0n1</span><br></pre></td></tr></table></figure></div></p><p><img src="fdisk_parted.png" alt="diskparted"></p><p>这里我已经分好区了的，具体的操作在<code>fdisk</code>中进行:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Generic</span><br><span class="line">   d   delete a partition</span><br><span class="line">   F   list free unpartitioned space</span><br><span class="line">   l   list known partition types</span><br><span class="line">   n   add a new partition</span><br><span class="line">   p   print the partition table</span><br><span class="line">   t   change a partition type</span><br><span class="line">   v   verify the partition table</span><br><span class="line">   i   print information about a partition</span><br><span class="line"></span><br><span class="line">  Misc</span><br><span class="line">   m   print this menu</span><br><span class="line">   x   extra functionality (experts only)</span><br><span class="line"></span><br><span class="line">  Script</span><br><span class="line">   I   load disk layout from sfdisk script file</span><br><span class="line">   O   dump disk layout to sfdisk script file</span><br><span class="line"></span><br><span class="line">  Save &amp; Exit</span><br><span class="line">   w   write table to disk and exit</span><br><span class="line">   q   quit without saving changes</span><br><span class="line"></span><br><span class="line">  Create a new label</span><br><span class="line">   g   create a new empty GPT partition table</span><br><span class="line">   G   create a new empty SGI (IRIX) partition table</span><br><span class="line">   o   create a new empty DOS partition table</span><br><span class="line">   s   create a new empty Sun partition table</span><br></pre></td></tr></table></figure></div><p>例如创建<code>EFI</code>分区:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Command (m for help): n</span><br><span class="line">Partition number (2-128, default 2): 2 # 创建一个分区作为EFI分区</span><br><span class="line">First sector (xxxxx-xxxxxxxxxxx, default xxxxx): </span><br><span class="line">Last sector, +sectors or +size&#123;K,M,G,T,P&#125; (34-2047, default xxxxxxx): +200M</span><br><span class="line">Created a new partition 2 of type &apos;Linux filesystem&apos; and of size 200 Mb.</span><br><span class="line">Command (m for help): t  # 修改EFI分区的分区类型为EFI系统分区</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"># 最后保存设置</span><br><span class="line">Command (m for help): w</span><br></pre></td></tr></table></figure></div><div class="note danger"><p>请注意先查看所执行的分区操作是不是你想要的再进行最后的保存设置</p></div><p>其他的分区创建类似<code>EFI</code>的创建，<code>swap</code>分区需要指定为<code>Linux swap</code>分区，作为<code>linux</code>数据分区的分区在创建时默认就是<code>linux filesystem</code>类型了，不需要更改，之后对创建的分区进行格式化:将<code>EFI</code>格式化为<code>fat32</code>，将<code>linux</code>数据分区格式化<code>ext4</code>； 先通过<code>sudo fdisk -l</code>或<code>lsblk</code>查看已经创建分区对应的设备名,例如:<br><code>sudo fdisk -l</code>:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Disk /dev/nvme0n1: 238.5 GiB, 256060514304 bytes, 500118192 sectors</span><br><span class="line">Units: sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disklabel type: gpt</span><br><span class="line">Disk identifier: 6D071E80-FF82-420B-A2D8-7A0BC4759F06</span><br><span class="line"></span><br><span class="line">Device             Start       End   Sectors  Size Type</span><br><span class="line">/dev/nvme0n1p1        34    262177    262144  128M Microsoft reserved</span><br><span class="line">/dev/nvme0n1p2    264192    673791    409600  200M EFI System</span><br><span class="line">/dev/nvme0n1p3    673792   9062399   8388608    4G Linux swap</span><br><span class="line">/dev/nvme0n1p4   9062400 428492799 419430400  200G Linux filesystem</span><br><span class="line">/dev/nvme0n1p5 428492800 500117503  71624704 34.2G Linux filesystem</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disk /dev/sda: 931.5 GiB, 1000204886016 bytes, 1953525168 sectors</span><br><span class="line">Units: sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 4096 bytes</span><br><span class="line">I/O size (minimum/optimal): 4096 bytes / 4096 bytes</span><br><span class="line">Disklabel type: gpt</span><br><span class="line">Disk identifier: D5CB68A7-96DA-4C61-84E2-61C98489BFF1</span><br><span class="line"></span><br><span class="line">Device          Start        End   Sectors   Size Type</span><br><span class="line">/dev/sda1          64  125829183 125829120    60G Microsoft basic data</span><br><span class="line">/dev/sda2   125829184  880802416 754973233   360G Microsoft basic data</span><br><span class="line">/dev/sda3   880803904 1596575151 715771248 341.3G Microsoft basic data</span><br><span class="line">/dev/sda4  1596575744 1953521663 356945920 170.2G Microsoft basic data</span><br></pre></td></tr></table></figure></div><p><code>lsblk</code> 查看分好的磁盘分区:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">NAME        MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sda           8:0    0 931.5G  0 disk </span><br><span class="line">├─sda1        8:1    0    60G  0 part /run/media/rovo98/System</span><br><span class="line">├─sda2        8:2    0   360G  0 part /run/media/rovo98/Mshinoda</span><br><span class="line">├─sda3        8:3    0 341.3G  0 part /run/media/rovo98/Chester bennington</span><br><span class="line">└─sda4        8:4    0 170.2G  0 part /run/media/rovo98/LSR</span><br><span class="line">sr0          11:0    1  1024M  0 rom  </span><br><span class="line">nvme0n1     259:0    0 238.5G  0 disk </span><br><span class="line">├─nvme0n1p1 259:1    0   128M  0 part </span><br><span class="line">├─nvme0n1p2 259:2    0   200M  0 part /boot/efi</span><br><span class="line">├─nvme0n1p3 259:3    0     4G  0 part [SWAP]</span><br><span class="line">├─nvme0n1p4 259:4    0   200G  0 part /</span><br><span class="line">└─nvme0n1p5 259:5    0  34.2G  0 part /run/media/rovo98/a002d542-c8c4-4c98-85af-8a4446dbaa1b</span><br></pre></td></tr></table></figure></div><p>对特定的分区进行格式化,例如:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 对于linux数据分区</span><br><span class="line">mkfs.ext4 /dev/nvme0n1p4</span><br><span class="line">mkfs.ext4 /dev/nvme0n1p5</span><br><span class="line"># EFI分区</span><br><span class="line">mkfs.fat /dev/nvme0n1p2</span><br></pre></td></tr></table></figure></div><div class="note danger"><p><strong>注意</strong>: 执行每条格式化命令前，必须确认指定的分区是否是你想要格式化的分区</p></div><p>做好这些准备之后，就可以进行系统的迁移了</p><h4 id="系统迁移操作"><a href="#系统迁移操作" class="headerlink" title="系统迁移操作"></a>系统迁移操作</h4><p>对于<code>Linux</code>系统，我们只需要知道<strong>Linux一切皆文件</strong>就行了。因此对于系统的迁移就变得简单了，可以使用<code>dd</code>,打包压缩然后解压缩，有关系统备份和恢复可以参看<code>Arch wiki</code>给出的:<a href="https://wiki.archlinux.org/index.php/System_backup" target="_blank" rel="noopener">https://wiki.archlinux.org/index.php/System_backup</a>.这里我是使用的是<code>tar</code>结合<code>pigz</code>(<a href="http://www.ywnds.com/?p=10332" target="_blank" rel="noopener">什么是pigz?</a>)解压缩工具进行备份和恢复:</p><p>备份(打包压缩)<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tar --use-compress-program=pigz -cvpf /run/media/rovo98/Chester\ bennington/LP/GHOST/manjaro_backup_2018.10.7.tgz --exclude=/proc --exclude=/sys --exclude=/mnt --exclude=/run/media --exclude=/lost+found /</span><br></pre></td></tr></table></figure></div></p><p>恢复到目标硬盘分区上(解包解压缩):<br>先目标分区挂载到<code>/mnt</code>下，如:<code>/mnt/manjaro</code></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount /dev/nvme0n1p4 /mnt/manjaro</span><br></pre></td></tr></table></figure></div><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tar --use-compress-program=pigz -xvpf /run/media/rovo98/Chester\ bennington/LP/GHOST/manjaro_backup_2018.10.7.tgz -C /mnt/manjaro</span><br></pre></td></tr></table></figure></div><p>完成后需要手动创建，上面打包压缩是排除的文件夹:<code>/proc</code>, <code>/sys</code>, <code>/mnt</code>, <code>/run</code>, <code>/lost+found</code>.</p><div class="note primary"><p>详细备份和恢复过程可以参考查看:<a href="https://www.jianshu.com/p/b03a51c682a5" target="_blank" rel="noopener">Arch上的备份还原</a></p></div><h4 id="修复Grub、fstab文件以及refind引导管理"><a href="#修复Grub、fstab文件以及refind引导管理" class="headerlink" title="修复Grub、fstab文件以及refind引导管理"></a>修复Grub、fstab文件以及refind引导管理</h4><p>首先将<code>/proc</code>,<code>/run</code>,<code>/dev</code>,<code>/sys</code>重新挂载，让目标分区上的系统也拥有这些内容:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mount /proc /mnt/manjaro/proc</span><br><span class="line">mount /sys /mnt/manjaro/sys</span><br><span class="line">mount /run /mnt/manjaro/run</span><br><span class="line">mount /dev /mnt/manjaro/dev</span><br></pre></td></tr></table></figure></div><div class="note warning"><p>这些目录必须重新挂载，不然，当<code>chroot</code>切换进入目标系统之后，将无法获取一些系统信息，如：设备, 磁盘分区信息等. </p></div><p><img src="mount-bind.png" alt=""></p><p>在<code>chroot</code>到目标系统之前，需要挂载<code>EFI</code>分区到<code>/mnt/manjaro/boot/efi</code>（refind管理文件默认位置）下：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount /dev/nvme0n1p2 /mnt/manjaro/boot/efi</span><br></pre></td></tr></table></figure></div><p><img src="efi_root.png" alt=""></p><p><code>chroot</code>到目标系统中，进行之后的操作</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chroot /mnt/manjaro</span><br></pre></td></tr></table></figure></div><h4 id="更新fstab文件"><a href="#更新fstab文件" class="headerlink" title="更新fstab文件"></a>更新fstab文件</h4><p>获取相应分区的<code>UUID</code>，以更新<code>fstab</code>文件和<code>/etc/default/grub</code>文件:<br><code>blkid</code>:</p><p><img src="blkid.png" alt=""></p><p>或</p><p><code>ls -l /dev/disk/by-uuid</code>:</p><p><img src="byuuid.png" alt=""></p><p>更新<code>fstab</code>文件:</p><p><img src="updated-fstab.png" alt=""></p><div class="note primary"><p>主要修改挂载项以及对应的<code>UUID</code>，有关<code>fstab</code>文件的详细内容可以参考<a href="https://wiki.archlinux.org/index.php/Fstab" target="_blank" rel="noopener">https://wiki.archlinux.org/index.php/Fstab</a></p></div><h4 id="修复Grub"><a href="#修复Grub" class="headerlink" title="修复Grub"></a>修复Grub</h4><ol><li><p>重新生成Grub</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo grub-install --target=x86_64-efi --efi-directory=/boot/efi --bootloader=Manjaro --recheck</span><br></pre></td></tr></table></figure></div></li><li><p>更新Grub配置文件</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo update-grub</span><br><span class="line">或</span><br><span class="line">sudo grub-mkconfig -o /boot/grub/grub.cfg</span><br></pre></td></tr></table></figure></div></li></ol><div class="note warning"><p><strong>注意</strong>：如果此过程中出现以下提示信息:</p><p><code>EFI variables are not supported on this system.</code></p><p>需要先安装<code>efibootmgr</code>, <code>dosfstools</code>以及<code>grub</code>包，然后重新尝试重新生成<code>Grub</code>并更新其配置文件.</p></div><p>若仍出现该信息，则先退出<code>chroot</code>环境，并加载<code>efivarfs</code>模块:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo modprobe efivarfs</span><br></pre></td></tr></table></figure></div><p>然后再进入<code>chroot</code>环境，执行:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -t efivarfs efivarfs /sys/firmware/efi/efivars</span><br></pre></td></tr></table></figure></div><p>再重新生成<code>Grub</code>并更新<code>Grub</code>配置文件就好了。</p><div class="note primary"><p>参考链接:<a href="https://wiki.manjaro.org/index.php/Restore_the_GRUB_Bootloader" target="_blank" rel="noopener">https://wiki.manjaro.org/index.php/Restore_the_GRUB_Bootloader</a></p></div><h4 id="重新配置refind"><a href="#重新配置refind" class="headerlink" title="重新配置refind"></a>重新配置refind</h4><p>对之前的<code>refind</code>配置文件进行备份，保留主题文件<code>themes</code>及<code>refind.conf</code>就好了，其余的文件在执行<code>refind-install</code>时会自动生成.</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 已经生成过了的,打印信息如下</span><br><span class="line">ShimSource is none</span><br><span class="line">Installing rEFInd on Linux....</span><br><span class="line">ESP was found at /boot/efi using vfat</span><br><span class="line">Found rEFInd installation in /boot/efi/EFI/refind; upgrading it.</span><br><span class="line">Installing driver for ext4 (ext4_x64.efi)</span><br><span class="line">Copied rEFInd binary files</span><br><span class="line"></span><br><span class="line">Notice: Backed up existing icons directory as icons-backup.</span><br><span class="line">Existing refind.conf file found; copying sample file as refind.conf-sample</span><br><span class="line">to avoid overwriting your customizations.</span><br><span class="line"></span><br><span class="line">Keeping existing NVRAM entry</span><br><span class="line">rEFInd is set as the default boot manager.</span><br><span class="line">Existing //boot/refind_linux.conf found; not overwriting.</span><br></pre></td></tr></table></figure></div><p><img src="refind.png" alt=""></p><p>可以使用<code>efibootmgr</code>管理启动项，例如:<br><code>efibootmgr</code>查看当前所有的启动项，<code>efibootmgr -Bb xxxx</code>来删除不要的启动项，详细使用可以<code>man efibootmgr</code>来查看。</p><p><img src="efibootmgr.png" alt=""></p><p>其中的<code>windows</code>系统启动项通过<code>PE</code>用<code>UEFI</code>引导修复生成即可(需要注意的是老旧的PE识别不了<code>nvme</code>固态)。</p><p>以上就是迁移Linux系统的完整过程了</p><h4 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h4><p>在做完上面的所有操作，并将之前机械硬盘上的<code>EFI</code>分区等等(除<code>Win10</code>系统之外)都删除之后，重新启动进入固态盘上的系统，在<code>Grub</code>引导过程出现<code>UUID=***************</code>找不到的信息，经过查看之后发现，在<code>Grub</code>引导时居然没有挂载我那块<code>nvme</code>固态。</p><p>通过了解发现<code>Grub2.2</code>版本并不支持<code>nvme</code>的固态，可以使用安装<code>bootloader</code>来进行引导。PS: 但我<code>Manjaro</code>安装的<code>Grub</code>是<code>2.3</code>版本的，理论上是支持的。</p><div class="note primary"><p>参考链接: <a href="https://bbs.archlinux.org/viewtopic.php?id=209653" target="_blank" rel="noopener">https://bbs.archlinux.org/viewtopic.php?id=209653</a></p></div><p>通过一番查找之后，终于找到了解决方法:</p><ol><li><p>添加加载模块 <code>sudo vim /etc/mkinitcpio.conf</code></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="DIFF"><figure class="iseeu highlight /diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="deletion">- MODULES = ""</span></span><br><span class="line"><span class="addition">+ MODULES="nvme"</span></span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure></div></li><li><p>更新<code>mkinitcpio</code></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#参数说明，详细可以通过man查看</span><br><span class="line">-p, --preset preset</span><br><span class="line">Build initramfs image(s) according to specified preset. This may be a file in /etc/mkinitcpio.d (without the .preset extension) or a full, absolute path to a file. This option may be specified multiple times to process multiple presets.</span><br></pre></td></tr></table></figure></div></li><li><p>更新Grub</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo update-grub</span><br><span class="line">或</span><br><span class="line">sudo grub-mkocnfig -o /boot/grub/grub.cfg</span><br></pre></td></tr></table></figure></div></li></ol><p>再次重启之后，便可以成功进入系统了。</p><div class="note primary"><p>参考链接:<a href="http://blog.51cto.com/shenfly231/1918426" target="_blank" rel="noopener">http://blog.51cto.com/shenfly231/1918426</a>, 若要安装<code>bootloader</code>也可以参考该链接。</p></div><h3 id="SSD优化"><a href="#SSD优化" class="headerlink" title="SSD优化"></a>SSD优化</h3><h4 id="开启Trim功能"><a href="#开启Trim功能" class="headerlink" title="开启Trim功能"></a>开启Trim功能</h4><p>关于什么是<code>TRIM</code>?：</p><blockquote><p>SSD TRIM is an Advanced Technology Attachment (ATA) command that enables an operating system to inform a NAND flash solid-state drive (SSD) which data blocks it can erase because they are no longer in use. The use of TRIM can improve the performance of writing data to SSDs and contribute to longer SSD life.</p></blockquote><div class="note primary"><p>了解可以参考: <a href="https://searchstorage.techtarget.com/definition/TRIM" target="_blank" rel="noopener">https://searchstorage.techtarget.com/definition/TRIM</a>，以及<code>Arch wiki</code>上的:<br><a href="https://wiki.archlinux.org/index.php/Solid_state_drive#TRIM" target="_blank" rel="noopener">https://wiki.archlinux.org/index.php/Solid_state_drive#TRIM</a></p></div><blockquote><p>Most SSDs support the <strong>ATA_TRIM command</strong> for <strong>sustained long-term performance and wear-leveling</strong>. A techspot article shows performance benchmark examples of before and after filling an SSD with data.</p><p>As of Linux kernel version 3.8 onwards, support for TRIM was continually added for the different filesystems. See the following table for an indicative overview:</p></blockquote><p><img src="trim-supported.png" alt=""></p><p>在使用<code>Trim</code>功能之前需要查看固态硬盘是否支持，否则可能造成数据丢失:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsblk --discard</span><br></pre></td></tr></table></figure></div><p><img src="lsblk-discard.png" alt=""></p><p><code>DISC-GRAN</code>和<code>DISC-MAX</code>不为<code>0</code>则表示支持，详细查看上面的<code>Arch Wiki</code>给出的文章。</p><p>关于使用的<code>Trim</code>方式，我使用的<code>Continuous TRIM</code>(详见<code>Arch Wiki</code>)<br>即在<code>/etc/fstab</code>文件的挂载项中添加参数<code>discard</code><br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="DIFF"><figure class="iseeu highlight /diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">- UUID=D942-EEB0                            /boot/efi      vfat    defaults,noatime 0 2</span></span><br><span class="line"><span class="deletion">- UUID=67180790-92d0-48d3-8f00-448161019f2d swap           swap    defaults,noatime 0 2</span></span><br><span class="line"><span class="deletion">- UUID=e2708091-5a07-47a6-bc26-5fdaa044c5f3 /              ext4    defaults,noatime 0 1</span></span><br><span class="line"><span class="addition">+ UUID=D942-EEB0                            /boot/efi      vfat    defaults,discard,noatime 0 2</span></span><br><span class="line"><span class="addition">+ UUID=67180790-92d0-48d3-8f00-448161019f2d swap           swap    defaults,discard,noatime 0 2</span></span><br><span class="line"><span class="addition">+ UUID=e2708091-5a07-47a6-bc26-5fdaa044c5f3 /              ext4    defaults,discard,noatime 0 1</span></span><br></pre></td></tr></table></figure></div></p><h4 id="IO调度器选择"><a href="#IO调度器选择" class="headerlink" title="IO调度器选择"></a>IO调度器选择</h4><p>一般来说，IO调度算法是为低速硬盘准备的，对于固态，最好是不使用任何IO调度器，或使用对硬盘干预程度最低的调度算法。</p><ol><li>查看当前固态的IO调度器:<br><img src="io-schedulers.png" alt=""><br>可以看到我当前固态没有使用任何调度器，而机械硬盘使用的是<code>bfq-sq</code>.</li><li><p>修改IO调度器(临时的):</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo noop &gt; /sys/block/sda/queue/scheduler</span><br></pre></td></tr></table></figure></div></li><li><p>要永久生效则需要添加编写开机自启动脚本<br>详见参考链接.</p></li></ol><div class="note primary"><p>更多信息以及详细的内容可以参考下面给出的参考链接.<br>参考链接:</p><ul><li><a href="https://wiki.archlinux.org/index.php/Improving_performance#Storage_devices" target="_blank" rel="noopener">https://wiki.archlinux.org/index.php/Improving_performance#Storage_devices</a></li><li><a href="https://blog.codeship.com/linux-io-scheduler-tuning/" target="_blank" rel="noopener">https://blog.codeship.com/linux-io-scheduler-tuning/</a></li><li><a href="https://www.ibm.com/developerworks/cn/linux/l-lo-io-scheduler-optimize-performance/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/linux/l-lo-io-scheduler-optimize-performance/index.html</a></li></ul></div><h4 id="另外"><a href="#另外" class="headerlink" title="另外"></a>另外</h4><div class="note primary"><p>更多有关<code>Linux VM</code>性能调优的可以参考:<br><a href="https://lonesysadmin.net/tag/linux-vm-performance-tuning/" target="_blank" rel="noopener">https://lonesysadmin.net/tag/linux-vm-performance-tuning/</a></p></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;就在最近，终于为自己的电脑加装了固态。在装完固态之后，首先面临的问题就是如何将原先安装在机械硬盘上的&lt;code&gt;linux&lt;/code&gt;系统迁移到固态上。还要考虑后续配置的问题。&lt;/p&gt;
&lt;p&gt;本文主要讲述在迁移&lt;code&gt;Linux&lt;/code&gt;系统到新的固态硬盘上所遇到的问题以及找到的相应的解决方法。&lt;/p&gt;
&lt;p&gt;这里先给出系统迁移以及相关配置完成之后的机械硬盘和固态硬盘的简单测速对比:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/linux/hdparam.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://rovo98.github.io/categories/Linux/"/>
    
    
      <category term="ssd" scheme="http://rovo98.github.io/tags/ssd/"/>
    
  </entry>
  
  <entry>
    <title>编译自己的Vim8.1</title>
    <link href="http://rovo98.github.io/posts/97c4fd12/"/>
    <id>http://rovo98.github.io/posts/97c4fd12/</id>
    <published>2018-08-27T12:12:13.000Z</published>
    <updated>2019-03-26T02:58:42.944Z</updated>
    
    <content type="html"><![CDATA[<p>最近换了<code>Manjaro</code> linux系统，发现通过系统<code>pacman -S vim</code>安装的无图形版本<code>vim</code>不支持<code>clipboard</code>功能。</p><p><img src="/images/linux/vim-version-original.jpg" alt=""></p><p>本想看能不能通过某种方式，来扩展现有安装好的<code>vim</code>,但是通过<code>google</code>了解到：<br><blockquote class="blockquote-center"><p>VIM is intended to be a portable editor that “just works” on all systems. By having the default version use the clipboard functionality, it will need to link against X11 libraries, and a separate version of VIM would need to be compiled for desktop versus server (no pre-installed X11/xorg) builds. This is why the vim and vim-gtk packages are provided.</p><p>VIM旨在成为一个可在所有系统上“正常工作”的便携式编辑器。通过使默认版本使用剪贴板功能，它将需要链接到X11库，并且需要针对桌面与服务器（没有预安装的X11 / xorg）构建编译单独版本的VIM。这就是提供vim和vim-gtk软件包的原因。</p></blockquote></p><a id="more"></a><p>虽然知道<code>gvim</code>带有支持<code>clipboard</code>的<code>vim</code>，但是我又不想装<code>gvim</code>。自己的系统又有<code>X11</code>库和 <code>Xorg</code>，所以决定自己编译一个<code>vim</code>.</p><div class="note warning"><p><strong>注意</strong>： 对于没有<code>X11</code>和<code>Xorg</code>的需要在编译前配置好，否则编译会出错.</p></div><h3 id="一、从github上获取vim的源码"><a href="#一、从github上获取vim的源码" class="headerlink" title="一、从github上获取vim的源码"></a>一、从github上获取vim的源码</h3><p>直接使用<code>git</code> clone <code>vim</code>仓库：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/vim/vim.git vim_source</span><br></pre></td></tr></table></figure></div><h3 id="二、配置、编译并安装"><a href="#二、配置、编译并安装" class="headerlink" title="二、配置、编译并安装"></a>二、配置、编译并安装</h3><p>我的编译配置：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">make clean</span><br><span class="line">./configure \</span><br><span class="line">    --enable-cscope \ </span><br><span class="line">    --enable-largefile \ </span><br><span class="line">    --enable-multibyte \ </span><br><span class="line">    --enable-mzschemeinterp \ </span><br><span class="line">    --enable-xim \ </span><br><span class="line">    --enable-tclinterp=dynamic \ </span><br><span class="line">    --enable-perlinterp=dynamic \ </span><br><span class="line">    --enable-python3interp=dynamic\ </span><br><span class="line">    --enable-pythoninterp=dynamic \ </span><br><span class="line">    --enable-rubyinterp=dynamic \ </span><br><span class="line">    --enable-luainterp=dynamic \</span><br><span class="line">    --enable-gui=no \</span><br><span class="line">    --enable-fontset \</span><br><span class="line">    --enable-terminal \</span><br><span class="line">    --with-features=huge \</span><br><span class="line">    --with-x \</span><br><span class="line">    --with-compiledby=&quot;rovo98&quot; \</span><br><span class="line">    --with-python-config-dir=/usr/lib/python2.7/config-$(uname-m)-linux-gnu</span><br><span class="line">    --with-python3-config-dir=/usr/lib/python3.7/config-$(uname -m)-linux-gnu</span><br></pre></td></tr></table></figure></div><p>编译并安装:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make &amp;&amp; sudo make install</span><br></pre></td></tr></table></figure></div><p><strong>编译配置的说明</strong>:</p><p>上面的参数中启用了对tcl、perl、python、ruby、lua的支持。同时为了使用系统的剪切板还启用了对X的支持， 安装位置默认是<code>/usr/local</code>下， 由<code>--perfix=PREFIX</code>参数指定。</p><p>更多详细可以使用<code>./configure --help</code>查看:</p><p><strong>删除编译产生的中间文件</strong> :</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make clean &amp;&amp; make distclean</span><br></pre></td></tr></table></figure></div><p><strong>成果:</strong></p><p><img src="vim_installed.jpg" alt=""></p><p><strong>为<code>vim</code>创建一个桌面图标</strong>:</p><p><code>vim.desktop</code>:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[Desktop Entry]</span><br><span class="line">Name=Vim[compiled by rovo98]</span><br><span class="line">Version=8.1</span><br><span class="line">Exec=vim %f</span><br><span class="line">Comment=Vim is a highly configurable text editor for efficiently creating and changing any kind of text.</span><br><span class="line">Icon=/usr/share/vim/vim81/src/vim.ico</span><br><span class="line">Type=Application</span><br><span class="line">MimeType=text/plain;</span><br><span class="line">Terminal=true</span><br><span class="line">Encoding=UTF-8</span><br><span class="line">Categories=Utility;</span><br></pre></td></tr></table></figure></div><p>把<code>vim.desktop</code>放到<code>/usr/share/applications/</code>下就行了。</p><p>现在可以享受你自己编译的vim了。</p><div class="note primary"><p>参考链接: </p><ul><li><a href="https://vi.stackexchange.com/questions/13564/why-is-vim-for-debian-compiled-without-clipboard" target="_blank" rel="noopener">https://vi.stackexchange.com/questions/13564/why-is-vim-for-debian-compiled-without-clipboard</a></li><li><a href="https://stackoverflow.com/questions/11416069/compile-vim-with-clipboard-and-xterm" target="_blank" rel="noopener">https://stackoverflow.com/questions/11416069/compile-vim-with-clipboard-and-xterm</a></li></ul></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近换了&lt;code&gt;Manjaro&lt;/code&gt; linux系统，发现通过系统&lt;code&gt;pacman -S vim&lt;/code&gt;安装的无图形版本&lt;code&gt;vim&lt;/code&gt;不支持&lt;code&gt;clipboard&lt;/code&gt;功能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/linux/vim-version-original.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;本想看能不能通过某种方式，来扩展现有安装好的&lt;code&gt;vim&lt;/code&gt;,但是通过&lt;code&gt;google&lt;/code&gt;了解到：&lt;br&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;VIM is intended to be a portable editor that “just works” on all systems. By having the default version use the clipboard functionality, it will need to link against X11 libraries, and a separate version of VIM would need to be compiled for desktop versus server (no pre-installed X11/xorg) builds. This is why the vim and vim-gtk packages are provided.&lt;/p&gt;
&lt;p&gt;VIM旨在成为一个可在所有系统上“正常工作”的便携式编辑器。通过使默认版本使用剪贴板功能，它将需要链接到X11库，并且需要针对桌面与服务器（没有预安装的X11 / xorg）构建编译单独版本的VIM。这就是提供vim和vim-gtk软件包的原因。&lt;/p&gt;
&lt;/blockquote&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://rovo98.github.io/categories/Linux/"/>
    
      <category term="softwares" scheme="http://rovo98.github.io/categories/Linux/softwares/"/>
    
    
      <category term="linux" scheme="http://rovo98.github.io/tags/linux/"/>
    
      <category term="vim" scheme="http://rovo98.github.io/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>Arch linux系列 安装 haroopad markdown 编辑器</title>
    <link href="http://rovo98.github.io/posts/63e58ebb/"/>
    <id>http://rovo98.github.io/posts/63e58ebb/</id>
    <published>2018-08-26T05:12:00.000Z</published>
    <updated>2018-10-08T05:08:41.445Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Haroopad 是一个优秀的 Markdown 编辑器，是一个用于创建适宜 Web 的文档的处理器。使用 Haroopad 可以创作各种格式的文档，比如博客文章、幻灯片、演示文稿、报告和电子邮件等。Haroopad 在 Windows、Mac OS X 和 Linux 上均可用。它有 Debian/Ubuntu 的软件包，也有 Windows 和 Mac 的二进制文件。该应用程序使用 node-webkit、CodeMirror，marked，以及 Twitter 的 Bootstrap 。</p><p>Haroo 在韩语中的意思是“一天”。</p></blockquote><p>本文主要介绍通过压缩包<code>**.tar.gz</code>的方式安装 <code>Haroopad</code>.</p><a id="more"></a><h3 id="一、下载-Haroopad"><a href="#一、下载-Haroopad" class="headerlink" title="一、下载 Haroopad"></a>一、下载 Haroopad</h3><p>我们可以从官网直接下载我们需要的压缩包，官网地址: <a href="http://pad.haroopress.com/user.html" target="_blank" rel="noopener">Haroopad官网地址</a></p><p><img src="haroopad_website.png" alt=""></p><p>这里我选择的是linux binary 64 位的压缩包。</p><h3 id="二、解压并安装Haroopad"><a href="#二、解压并安装Haroopad" class="headerlink" title="二、解压并安装Haroopad"></a>二、解压并安装Haroopad</h3><p>根据下载的压缩包格式进行解压： 例如 **.tar.gz格式</p><p>解压并放到<code>/opt/</code>目录下:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tar zxvf haroopad-v0.13.1.x64.tar.gz -C haroopad</span><br><span class="line">sudo cp -r haroopad /opt/</span><br><span class="line"></span><br><span class="line">tar zxvf data.tar.gz</span><br><span class="line">tar zxvf control.tar.gz</span><br></pre></td></tr></table></figure></div><p>把解压出来的 usr中的文件放到<code>/usr/</code>下：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo cp -r ./usr /</span><br><span class="line"><span class="comment"># 执行 postinst</span></span><br><span class="line">chmod 755 postinst</span><br><span class="line">sudo ./postinst</span><br></pre></td></tr></table></figure></div><p><img src="haroopad_install.png" alt=""></p><h3 id="三、修复桌面图标"><a href="#三、修复桌面图标" class="headerlink" title="三、修复桌面图标"></a>三、修复桌面图标</h3><p>为haroopad 换一个合适的桌面图标:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /usr/share/applications/Haroopad.desktop</span><br></pre></td></tr></table></figure></div><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[Desktop Entry]</span><br><span class="line">Name=haroopad</span><br><span class="line">Version=0.13.1</span><br><span class="line">Exec=haroopad</span><br><span class="line">Comment=The Next Document processor based on Markdown</span><br><span class="line">#Icon=haroopad</span><br><span class="line">Icon=/usr/share/icons/hicolor/128x128/apps/haroopad.png</span><br><span class="line">Type=Application</span><br><span class="line">Terminal=false</span><br><span class="line">StartupNotify=true</span><br><span class="line">Encoding=UTF-8</span><br><span class="line">Categories=Development;GTK;GNOME;</span><br></pre></td></tr></table></figure></div><h3 id="四、配置Haroopad"><a href="#四、配置Haroopad" class="headerlink" title="四、配置Haroopad"></a>四、配置Haroopad</h3><p>相关的Haroopad设置，可以打开 <code>偏好设置</code>进行配置:</p><p><img src="haroopad_settings.png" alt=""></p><p>到此，Haroopad 安装就完成了。</p><p>参考链接: <a href="https://www.jianshu.com/p/dba9acabf0a7" target="_blank" rel="noopener">https://www.jianshu.com/p/dba9acabf0a7</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Haroopad 是一个优秀的 Markdown 编辑器，是一个用于创建适宜 Web 的文档的处理器。使用 Haroopad 可以创作各种格式的文档，比如博客文章、幻灯片、演示文稿、报告和电子邮件等。Haroopad 在 Windows、Mac OS X 和 Linux 上均可用。它有 Debian/Ubuntu 的软件包，也有 Windows 和 Mac 的二进制文件。该应用程序使用 node-webkit、CodeMirror，marked，以及 Twitter 的 Bootstrap 。&lt;/p&gt;
&lt;p&gt;Haroo 在韩语中的意思是“一天”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文主要介绍通过压缩包&lt;code&gt;**.tar.gz&lt;/code&gt;的方式安装 &lt;code&gt;Haroopad&lt;/code&gt;.&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://rovo98.github.io/categories/Linux/"/>
    
      <category term="softwares" scheme="http://rovo98.github.io/categories/Linux/softwares/"/>
    
    
      <category term="linux" scheme="http://rovo98.github.io/tags/linux/"/>
    
      <category term="markdown" scheme="http://rovo98.github.io/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>Manjaro linux 安装与配置</title>
    <link href="http://rovo98.github.io/posts/a1898ce2/"/>
    <id>http://rovo98.github.io/posts/a1898ce2/</id>
    <published>2018-08-22T04:00:00.000Z</published>
    <updated>2019-04-21T06:31:28.608Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/linux/manjaro-installed.jpg" alt=""></p><blockquote><p>Manjaro是一款基于Arch Linux、对用户友好、全球排名第一的Linux发行版。（排名数据源于<a href="http://distrowatch.com/" target="_blank" rel="noopener">DistroWatch</a>，统计日期2018.08.22，时间段3个月。）<br>在Linux圈，Arch的确是一个异常强大的发行版。它有3个无与伦比的优势：</p><ol><li>滚动更新可以使软件保持最新；</li><li>AUR软件仓库有着世界上最齐全的Linux软件（<a href="https://www.lulinux.com/archives/2787" target="_blank" rel="noopener">参考《一张列表展示ArchLinux系软件有多丰富——看哭百万Debian、RedHat系同学》</a>）；</li><li>丰富的wiki和活跃的社区让所有问题都可以快速得到满意的答案。</li></ol></blockquote><p>相比于<code>Arch linux</code>, 不得感叹, <a href="http://www.manjaro.cn/451" target="_blank" rel="noopener">人生苦短,我用 <strong>Manjaro</strong>啊!</a></p><a id="more"></a><h3 id="一、Manjaro的安装"><a href="#一、Manjaro的安装" class="headerlink" title="一、Manjaro的安装"></a>一、Manjaro的安装</h3><h4 id="镜像下载"><a href="#镜像下载" class="headerlink" title="镜像下载"></a>镜像下载</h4><p>官方网站：<a href="https://manjaro.org/get-manjaro/" target="_blank" rel="noopener">https://manjaro.org/get-manjaro/</a><br>选择自己喜欢的桌面环境就好，目前官方支持包括xfce、kde、gnome三种桌面环境。而在官方的社区版本中提供更多桌面环境的支持，比如国产的deepin桌面环境</p><p>但是官方服务器在海外，所以我们也可以选择国内开源镜像进行下载<br>清华大学开源镜像：<a href="https://mirrors.tuna.tsinghua.edu.cn/manjaro-cd/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/manjaro-cd/</a></p><blockquote><p>由于我基本都把上述的版本和一些社区版本安装过(出于各种原因&gt;_&lt;)，我建议是从官方网站下载最新的官方版本进行安装(好像清华大学源的镜像并不是最新的)，至于桌面环境的选择，看个人，我选择的是<code>KDE</code>(其实，桌面环境在安装之后也是可以换的)。</p></blockquote><h4 id="制作U盘启动盘"><a href="#制作U盘启动盘" class="headerlink" title="制作U盘启动盘"></a>制作U盘启动盘</h4><p>manjaro官方提供的<a href="https://manjaro.github.io/homepage/public/support/userguide/" target="_blank" rel="noopener">Manjaro User Guide</a>手册里面介绍了使用 来制作镜像的方法许多方法，例如：</p><ul><li>Linux系统下，使用 <code>dd</code>命令来制作：<br><code>sudo dd if=manjaro-xfce-17.1-stable-x86_64.iso of=/dev/sdcbs=4M</code>, <code>of</code>指定烧录U盘的挂载位置;</li><li>在windows系统下使用烧录软件<code>Rufus</code>来进行烧录:<br> <img src="Rufus.png" alt=""></li></ul><p><strong>[注意]</strong>： 烧录完成后，在进入<code>Live</code>系统前，需要对<code>BIOS</code>进行一些设置，关闭安全启动。之后即可顺利进入这个界面(至于BIOS vs UEFI的启动进入的<code>Live</code>系统的方式，详见手册。由于我安装的是多个系统，所以是<code>GPT+UEFI</code>引导):</p><p><img src="manjaro-boot-menu.png" alt=""></p><h4 id="安装系统"><a href="#安装系统" class="headerlink" title="安装系统"></a>安装系统</h4><p>进入启动菜单界面后，可以对一些基本的选项进行配置，如，时区，语言，键盘布局等。</p><p>具体的安装步骤请直接参考官网的<code>Manjaro User Guide.pdf</code>,这里主要说说安装系统时可能遇到的问题(我基本踩过的坑…)。</p><ol><li><strong>对于双显卡的电脑,特别是有Nvidia卡的</strong>: 在进入<code>live</code>系统之前,可以将<code>Driver</code>选项设置为<code>no-free</code>(让系统自动安装合适的闭源驱动),并在<code>boot</code>项那里按<code>E</code>编辑, 在<code>boot</code>那一行将<code>nouveau.modeset=1</code>设置为<code>nouveau.modeset=0</code>来禁用开源<code>nouveau</code>驱动,然后进入<code>Live</code>安装系统。<br><strong>但是,安装完系统后重启还有可能进不去桌面</strong>,可以尝试在<code>Grub</code>菜单启动界面按[E]编辑,找到<code>quiet</code>并在后面加入(注意空格):<blockquote><p><code>acpi_osi=! acpi_osi=&#39;Windows 2009&#39;</code><br>或者<br><code>acpi_osi=! acpi_osi=Linux acpi_osi=&#39;Windows 2015&#39; pcie_port_pm=off</code><br><strong>(很多硬件厂商的BIOS驱动都对Linux不友好(我的电脑就是这样的…)，无法顺利加载ACPI模块，而导致无法驱动独立显卡,acpi_osi=’Windows 2009’的意思是告诉ACPI模块，我是‘Windows 7’，别闹情绪了，赶紧工作吧。)</strong><br>接着按 F10 进入系统。<br><br>顺利进入系统后,将这些内核启动参数配置永久生效(修改grub的配置文件):<br><code>sudo vim /etc/default/grub</code><br>在<code>GRUB_CMDLINE_LINUX</code>中添加参数:<br><img src="manjaro-grub.png" alt=""><br>之后更新 <code>grub</code>文件:<br><code>sudo update-grub</code><br>或<br><code>sudo grub-mkconfig -o /boot/grub/grub.cfg</code><br><img src="update-grub.png" alt=""><br>参考链接: </p><ol><li><a href="https://forum.manjaro.org/t/a-start-job-is-running-for-livemedia-mhwd-script/3395/15" target="_blank" rel="noopener">https://forum.manjaro.org/t/a-start-job-is-running-for-livemedia-mhwd-script/3395/15</a></li><li><a href="https://wiki.archlinux.org/index.php/Kernel_parameters" target="_blank" rel="noopener">https://wiki.archlinux.org/index.php/Kernel_parameters</a></li><li><a href="https://www.kernel.org/doc/Documentation/admin-guide/kernel-parameters.txt" target="_blank" rel="noopener">https://www.kernel.org/doc/Documentation/admin-guide/kernel-parameters.txt</a></li></ol></blockquote></li><li>启动时出现的<code>ACPI ERROR</code>问题，很多都说是内核版本的原因，有尝试过添加内核启动参数<code>acpi=off</code>，启动正常进入系统，但键盘无法使用，所以这个提示<code>ACPI</code>错误的问题，由于不影响使用，可以不管(强迫症的可以再看看)<blockquote><p><img src="boot-acpi-error.png" alt=""><br>参考链接: <a href="https://forum.manjaro.org/t/acpi-error-during-boot/35125" target="_blank" rel="noopener">https://forum.manjaro.org/t/acpi-error-during-boot/35125</a></p></blockquote></li><li>屏幕亮度无法调节或异常的问题： <code>Arch Wiki</code>已经给出很详细的解决方法:<br>链接: <a href="https://wiki.archlinux.org/index.php/backlight" target="_blank" rel="noopener">https://wiki.archlinux.org/index.php/backlight</a><br>例如：开机亮度设置: <code>vim /etc/rc.local</code>:<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="ZSH"><figure class="iseeu highlight /zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/sh -e</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># rc.local</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This script is executed at the end of the each multiuser runlevel.</span></span><br><span class="line"><span class="comment"># Make sure that the script will "exit 0" on successs or any other value on error</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># In order to enable or disable this script just change the execution bits.</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># By default this script does nothing.</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> 127 &gt;&gt; /sys/class/backlight/intel_backlight/brightness</span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure></div></li></ol><div class="note primary"><p>对于安装<code>Manjaro</code>系统出现的问题，大多数都可以在官方的论坛<a href="https://forum.manjaro.org/" target="_blank" rel="noopener">Manjaro Forum</a>以及<a href="https://wiki.manjaro.org/index.php?title=Main_Page" target="_blank" rel="noopener">Manjaro Wiki</a>，还有<code>Arch Linux</code>的<a href="https://wiki.manjaro.org" target="_blank" rel="noopener">Arch Wiki</a>以及上找到解决方法。</p></div><h3 id="二、Manjaro-配置"><a href="#二、Manjaro-配置" class="headerlink" title="二、Manjaro 配置"></a>二、Manjaro 配置</h3><p>简单说一下一些安装系统之后的一些常规配置。</p><h4 id="配置更新源并更新系统"><a href="#配置更新源并更新系统" class="headerlink" title="配置更新源并更新系统"></a>配置更新源并更新系统</h4><ol><li><p>配置中国的mirrors：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="ZSH"><figure class="iseeu highlight /zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman-mirrors -i -c China -m rank</span><br></pre></td></tr></table></figure></div></li><li><p>在 <code>/etc/pacman.conf</code>中添加<code>archlinuxcn</code>源:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[archlinuxcn]</span><br><span class="line">SigLevel= TrustedOnly</span><br><span class="line">Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch</span><br></pre></td></tr></table></figure></div></li><li><p>安装<code>archlinuxcn-keyring</code>:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S archlinuxcn-keyring</span><br></pre></td></tr></table></figure></div></li><li><p>同步并更新系统；</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="ZSH"><figure class="iseeu highlight /zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -Syyu</span><br></pre></td></tr></table></figure></div></li></ol><h4 id="安装配置中文输入法"><a href="#安装配置中文输入法" class="headerlink" title="安装配置中文输入法"></a>安装配置中文输入法</h4><ol><li><p>安装中文输入法和<code>fcitx</code>管理工具:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="ZSH"><figure class="iseeu highlight /zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S fcitx-sougoupinyin <span class="comment"># 输入法看个人</span></span><br><span class="line">sudo pacman -S fcitx-im</span><br><span class="line">sudo pacman -S fcitx-configtool</span><br></pre></td></tr></table></figure></div></li><li><p>解决中文输入法无法切换问题: 添加文件<code>~/.xprofile</code>:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export GTK_MODULE=fcitx</span><br><span class="line">export QT_IM_MODULE=fcitx</span><br><span class="line">export XMODIFIERS=&quot;@im=fcitx&quot;</span><br></pre></td></tr></table></figure></div></li></ol><p>重启即可。</p><h4 id="配置Intel-和-Nvidia-双显卡切换"><a href="#配置Intel-和-Nvidia-双显卡切换" class="headerlink" title="配置Intel 和 Nvidia 双显卡切换"></a>配置Intel 和 Nvidia 双显卡切换</h4><p>Manjaro 提供了强大的硬件检测模块<code>mhwd</code>，可以很方便的安装各种驱动，要实现Intel 和 Nvidia 双显卡切换，我们需要安装video-hybrid-intel-nvidia-bumblebee <code>nvidia</code>闭源驱动和intel驱动的混合版<code>bumblebee</code>。对于之前安装系统是在<code>Live</code>启动菜单选择<code>Driver=no-free</code>的可以看看这个驱动是否已经安装：<br>系统设置中的硬件设置:<br><img src="manjaro-graphic-cards.png" alt=""><br>或<br><br><img src="manjaro-mhwd-installed-pci.png" alt=""></p><p>对于未安装的，这里提供一个最为简单的方式，<strong>直接在硬件设置中，右键安装即可，这样可以省去自己去添加用户组和开机启动，以及切换状态初始化</strong></p><div class="note warning"><p><strong>[注意：]</strong> 下面的这些依赖必须安装，否则会出现独立显卡无法正常工作的问题(fps跟集成显卡差不多)：</p></div><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="ZSH"><figure class="iseeu highlight /zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S virtualgl lib32-virtualgl</span><br></pre></td></tr></table></figure></div><p>对于独立显卡的使用，可以使用<code>bbswitch</code>来进行切换开关，然后使用<code>optirun</code>来运行程序:</p><blockquote><ol><li>首先查看显卡的状态: <code>lspci | grep -i nvidia</code>(rev ff 表示关闭状态)<br><img src="nvidia-off.png" alt=""></li><li>打开独立显卡，并进行测试，对比集成显卡的fps：<ul><li>集成显卡 FPS:<br><img src="intel-fps.png" alt=""></li><li>打开独立显卡<code>sudo tee /proc/acpi/bbswitch &lt;&lt;&lt; &quot;ON&quot;</code>,测试FPS:<br><img src="nvidia-fps.png" alt=""></li></ul></li><li>独立显卡设置 nvidia-settings 需要用<code>optirun nvidia-setting -c :8</code>才能打开:<br><img src="nvidia-settings.png" alt=""></li></ol></blockquote><h4 id="使用-zsh-和-oh-my-zsh-配置终端"><a href="#使用-zsh-和-oh-my-zsh-配置终端" class="headerlink" title="使用 zsh 和 oh-my-zsh 配置终端"></a>使用 zsh 和 oh-my-zsh 配置终端</h4><p><code>zsh</code> shell(theme: rjkirch_mod)：</p><p><img src="my-zsh.png" alt=""></p><p>基本配置过程：</p><ul><li>查看系统安装了多少shell <code>cat /etc/shells</code></li><li>查看当前shell : <code>echo $SHELL</code></li><li>使用 <code>chsh</code>切换默认<code>shell</code>.</li></ul><p>配置 zsh，直接使用<strong>oh-my-zsh</strong>来进行配置: <a href="https://github.com/robbyrussell/oh-my-zsh" target="_blank" rel="noopener">Oh-my-zsh</a>.<br>zsh 主题可以自行按个人喜好配置，当然也可以随机(每次打开终端都随机选择一个主题).</p><p>插件推荐: (插件配置太多的话，会使shell启动速度变慢，适当就好)</p><p><img src="zsh-plugins.png" alt=""></p><ul><li><a href="https://github.com/wting/autojump" target="_blank" rel="noopener">Autojump</a></li><li><a href="https://github.com/zsh-users/zsh-syntax-highlighting" target="_blank" rel="noopener">zsh-syntax-highlighting</a></li><li><a href="https://github.com/zsh-users/zsh-autosuggestions" target="_blank" rel="noopener">zsh-autosuggestions</a></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>Manjaro</code>的安装和基本配置就到此结束。最后，简单说一下我安装此系统的缘由。在安装<code>manjaro</code>之前，我使用的是<code>win10 LTSB 2016</code>，之前接触过的的Linux发行版是<code>CentOS</code>, <code>Unbuntu</code>以及 <code>kali</code>， 前两者我不怎么想要，本来想直接换成<code>kali</code>，但是考虑到<code>kali</code>一般是作为一个工具来使用，并不适合我平时开发和日常使用，就再次寻找适合的Linux发行版，最后看上了<code>Arch Linux</code>，但是又因为<code>Arch</code>上手难度较高，退而求其次，选择了<code>Manjaro</code>。当然啦，<code>Win10</code>肯定是要保留的，<code>Kali</code>也是要的。</p><p>于是乎，在原先的<code>GPT+UEFI</code>引导方式的基础之上，我重新分配了我的磁盘，将原有的<code>Win10</code>系统盘缩小，把它当备用系统，<code>Manjaro</code>作为主要系统使用，而<code>Kali</code>只作为工具使用，其他的磁盘分区作为数据存放的分区，各个系统共用。</p><p><img src="win-manjaro-kali.jpg" alt=""></p><p><img src="disk-structure.png" alt=""></p><div class="note danger"><p>说明: 对于上面给出的分区方案仅供参考，<strong>例如: 对于<code>Linux</code>的<code>swap</code>分区(用于虚拟内存的置换)来说，由于系统启动时会对<code>swap</code>进行初始化，因此多个系统可以使用一个<code>swap</code>分区即可。只要配置<code>UUID</code>没错就行了，毕竟多系统主机每次也只能启动一个系统。。。</strong></p><p>上面的分区旨在演示，基于<code>GPT</code> (<em>GUID Partion Table</em> 分区表(可以分128主要分区，而<code>MBR</code>(<em>Master Boot Record</em>)分区表只能是4个主要分区, 请自行了解两者的区别) 使用<code>UEFI</code>(<em>Unified Extensible Firmware Interface</em>)如何为安装多系统做准备。</p></div><p>然后使用 <code>REfind</code>来管理和引导系统:</p><p><img src="refind-menu.jpg" alt=""></p><div class="note primary"><p>对于Refind有兴趣的可以直接<code>google</code>或<code>baidu</code>了解一下，选择一个现有的主题然后自己稍微进行配置一下，就可以了。<br>参考:</p><ul><li><a href="http://www.rodsbooks.com/refind/" target="_blank" rel="noopener">http://www.rodsbooks.com/refind/</a></li><li><a href="https://wiki.archlinux.org/index.php/REFInd_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87" target="_blank" rel="noopener">Arch Wiki 上关于refind的内容</a>)</li></ul></div><h4 id="各个系统桌面"><a href="#各个系统桌面" class="headerlink" title="各个系统桌面"></a>各个系统桌面</h4><ul><li>Win10 LTSB</li></ul><p><img src="win10.jpg" alt=""></p><ul><li>Manjaro(DE: KDE)</li></ul><p><img src="manjaro-desktop.jpg" alt=""></p><ul><li>Kali</li></ul><p><img src="kali.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/linux/manjaro-installed.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Manjaro是一款基于Arch Linux、对用户友好、全球排名第一的Linux发行版。（排名数据源于&lt;a href=&quot;http://distrowatch.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;DistroWatch&lt;/a&gt;，统计日期2018.08.22，时间段3个月。）&lt;br&gt;在Linux圈，Arch的确是一个异常强大的发行版。它有3个无与伦比的优势：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;滚动更新可以使软件保持最新；&lt;/li&gt;
&lt;li&gt;AUR软件仓库有着世界上最齐全的Linux软件（&lt;a href=&quot;https://www.lulinux.com/archives/2787&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;参考《一张列表展示ArchLinux系软件有多丰富——看哭百万Debian、RedHat系同学》&lt;/a&gt;）；&lt;/li&gt;
&lt;li&gt;丰富的wiki和活跃的社区让所有问题都可以快速得到满意的答案。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;相比于&lt;code&gt;Arch linux&lt;/code&gt;, 不得感叹, &lt;a href=&quot;http://www.manjaro.cn/451&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;人生苦短,我用 &lt;strong&gt;Manjaro&lt;/strong&gt;啊!&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://rovo98.github.io/categories/Linux/"/>
    
    
      <category term="linux" scheme="http://rovo98.github.io/tags/linux/"/>
    
      <category term="manjaro" scheme="http://rovo98.github.io/tags/manjaro/"/>
    
  </entry>
  
  <entry>
    <title>爬取校内腾讯企业邮箱通信录</title>
    <link href="http://rovo98.github.io/posts/e675b5d9/"/>
    <id>http://rovo98.github.io/posts/e675b5d9/</id>
    <published>2018-07-25T06:07:00.000Z</published>
    <updated>2018-10-08T05:08:42.451Z</updated>
    
    <content type="html"><![CDATA[<p>简单使用python <code>request</code> + <code>re</code> 爬取校内邮箱通信录(腾讯企业邮箱)的用户信息数据。</p><a id="more"></a><h3 id="一、分析需要爬取的数据"><a href="#一、分析需要爬取的数据" class="headerlink" title="一、分析需要爬取的数据"></a>一、分析需要爬取的数据</h3><p>通过手动打开浏览器，正常访问网站，判断需要爬取的数据是静态还是动态数据，制定不同的爬取方案。</p><h4 id="1-静态-动态-数据类型判断"><a href="#1-静态-动态-数据类型判断" class="headerlink" title="1. 静态/动态 数据类型判断"></a>1. 静态/动态 数据类型判断</h4><p>登陆企业校内邮箱，可以看到需要获取的内容主要呈现在该页面:<br><br><img src="step_01.png" alt=""></p><p><code>F12</code>打开控制台，查看<code>Elements</code>，可以很容易发现，用户数据在目录节点没有展开的情况下，html文档中并不会包含我们需要的数据，当点击展开目录节点后，才能获取到数据。<br><br><img src="step_02.png" alt=""><br>因此，可以判断，我们需要爬取的数据是动态生成的，可以初步认为是通过<code>AJAX</code>异步请求来从服务器端获取数据的。</p><h4 id="2-数据定位"><a href="#2-数据定位" class="headerlink" title="2. 数据定位"></a>2. 数据定位</h4><p>我们已经知道了需要爬取的数据是动态生成的，这时，同样<code>F12</code>打开控制台，到<code>Network</code>栏目下，查找类型为<code>XHR</code>(AJAX的请求链接)的请求链接，并按数据文件大小从到小排序，再次刷新页面，点击通讯录栏目，展开到具体的用户项，依次点击<code>XHR</code>以确定需要的数据是通过哪个链接获取的：<br><br><img src="step_03.png" alt=""></p><p>可以看到，请求链接格式为:<code>https://exmail.qq.com/cgi-bin/laddr_biz?t=memtree&amp;limit={limit}&amp;partyid={pid}&amp;action=show_party&amp;sid={sid}</code>,参数有 - <br></p><div class="table-container"><table><thead><tr><th style="text-align:center">Argument</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td style="text-align:center">t</td><td style="text-align:center">取值不变,<code>memtree</code>，具体含义就不管了</td></tr><tr><td style="text-align:center">limit</td><td style="text-align:center">链接中取值:<code>500</code>,单次获取用户的最大数量，<br>我们可以自己修改，再次发起请求来验证</td></tr><tr><td style="text-align:center">partyid</td><td style="text-align:center">变化值，为所属组的id,例如：<br>学生 -&gt; 专业 -&gt; 院系<br>学生所属专业<code>partyid</code>就是的专业的<code>id</code>,etc.</td></tr><tr><td style="text-align:center">action</td><td style="text-align:center">在此链接中不变，取值:<code>show_party</code></td></tr><tr><td style="text-align:center">sid</td><td style="text-align:center">用户登陆后生成的<code>sid</code>值，访问过程中不变</td></tr></tbody></table></div><p><img src="step_04.png" alt=""></p><p>通过上面的分析，我们可以知道，要获取所有学生的信息，主要是在获取所有的专业的<code>id</code>后，依次作为上面链接的<code>partyid</code>来发起请求即可。</p><p>尝试在html <code>Elements</code>文档中搜索，能够搜到相应的数据，但它也是动态生成的 - </p><p><img src="step_05.png" alt=""></p><p>继续在<code>Network</code>中将过滤类型设置为<code>doc</code>同时按文件大小排序，查找包含<code>oPartyList</code>的文件 -</p><p><img src="step_06.png" alt=""></p><p>到此，我们所有的分析任务已经结束了，接下来只需要编写相应的爬虫程序即可。</p><h3 id="二、爬虫程序设计"><a href="#二、爬虫程序设计" class="headerlink" title="二、爬虫程序设计"></a>二、爬虫程序设计</h3><p>这里只是编写一个简单的爬虫程序，不使用IP代理，爬虫发起请求所需的<code>sid</code>通过用户自己登陆后手动获取，相应的<code>cookie</code>也是如此。</p><h4 id="1-获取所有专业的id"><a href="#1-获取所有专业的id" class="headerlink" title="1. 获取所有专业的id"></a>1. 获取所有专业的id</h4><p>上面分析提到的，要获取用户数据，主要是要先获取到用户所在的组id<code>partyid</code>。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getAllPID</span><span class="params">()</span>:</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">    获取所有的专业id,作为用户的pid.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    sid = <span class="string">'xxx'</span>   <span class="comment"># 用户登陆后的sid</span></span><br><span class="line">    all_parties_url = <span class="string">'https://exmail.qq.com/cgi-bin/laddr_biz?action=show_party_list&amp;sid=&#123;sid&#125;&amp;t=contact&amp;view=biz'</span>.format(sid=sid)</span><br><span class="line">    cookies = dict(...) <span class="comment"># cookie参数和值</span></span><br><span class="line">    request = request.get(all_parties_url,cookies=cookies)</span><br><span class="line">    </span><br><span class="line">    regexp = <span class="string">r'&#123;id:"(\S*?)", pid:"(\S*?)", name:"(\S*?)", order:"(\S*?)"&#125;'</span></span><br><span class="line">    results = re.findall(regexp,text)</span><br><span class="line">    all_parties_ids = []       <span class="comment"># 所有pid</span></span><br><span class="line">    all_parties_info = dict() <span class="comment"># 所有组信息</span></span><br><span class="line">    root_party = <span class="keyword">None</span>      <span class="comment"># 根通信组</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> results:</span><br><span class="line">    all_parties_id.append(p[<span class="number">0</span>])</span><br><span class="line">        party = dict(id=item[<span class="number">0</span>], pid=item[<span class="number">1</span>], name=item[<span class="number">2</span>], order=item[<span class="number">3</span>])</span><br><span class="line">        all_parties_info[item[<span class="number">0</span>]] = party</span><br><span class="line">        <span class="keyword">if</span> p[<span class="number">1</span>] == <span class="number">0</span> <span class="keyword">or</span> p[<span class="number">1</span>] == <span class="string">'0'</span>:</span><br><span class="line">        root_party = party</span><br></pre></td></tr></table></figure></div><h4 id="2-获取学生信息数据"><a href="#2-获取学生信息数据" class="headerlink" title="2. 获取学生信息数据"></a>2. 获取学生信息数据</h4><p>依次遍历<code>pid</code>列表，构造不同的<code>pid</code>不同的链接，来获取全部的通讯录内容。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getAllUserInfo</span><span class="params">()</span>:</span></span><br><span class="line">...</span><br><span class="line">    获取所有通讯录用户信息</span><br><span class="line">    ...</span><br><span class="line">    all_user_info = []  <span class="comment"># 用于保存所有用户数据信息</span></span><br><span class="line">    <span class="comment"># 获取用户数据的链接</span></span><br><span class="line">    party_user_url = <span class="string">'https://exmail.qq.com/cgi-bin/laddr_biz?t=memtree&amp;limit=&#123;limit&#125;'</span>\</span><br><span class="line">    <span class="string">'&amp;partyid=&#123;pid&#125;&amp;action=show_party&amp;sid=&#123;sid&#125;'</span></span><br><span class="line">    regexp = <span class="string">r'&#123;uin:"(\S*?)", pid:"(\S*?)", alias:"(\S*?)", sex:"(\S*?), pos:"(\S*?)", tel:"(\S*?)",'</span>\</span><br><span class="line">    <span class="string">' birth:"(\S*?)(\S*?)(\S*?)(\S*?)", slave_alias:"(\S*?)(\S*?)(\S*?)", department:"(\S*?)(\S*?)", mobile:"(\S*?)"&#125;'</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> pid <span class="keyword">in</span> all_parites_ids:</span><br><span class="line">        <span class="comment"># 依次构造不同pid的请求链接</span></span><br><span class="line">    url = party_user_url.format(limit=limit, pid=pid, sid=sid)</span><br><span class="line">        request = requests.get(url, cookies=cookies)</span><br><span class="line">        text = request.text</span><br><span class="line">        results = re.findall(regexp, text)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> results:</span><br><span class="line">        user = dict(uin=item[<span class="number">0</span>], pid=item[<span class="number">1</span>], name=item[<span class="number">2</span>], alias=item[<span class="number">3</span>], sex=item[<span class="number">4</span>],</span><br><span class="line">            pos=item[<span class="number">5</span>], tel=item[<span class="number">6</span>],birth=item[<span class="number">7</span>], slave_alias=item[<span class="number">8</span>], department=item[<span class="number">9</span>],</span><br><span class="line">                   mobile=item[<span class="number">10</span>])</span><br><span class="line">         all_user_info.append(user)</span><br></pre></td></tr></table></figure></div><p>完整的程序，请移步到<a href="https://github.com/rovo98/python-learning/blob/master/web-spiders/tx_email_spider/tx_email_spider.py" target="_blank" rel="noopener">Github</a>查看.</p><h3 id="三、爬取结果"><a href="#三、爬取结果" class="headerlink" title="三、爬取结果"></a>三、爬取结果</h3><p><img src="step_07.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单使用python &lt;code&gt;request&lt;/code&gt; + &lt;code&gt;re&lt;/code&gt; 爬取校内邮箱通信录(腾讯企业邮箱)的用户信息数据。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://rovo98.github.io/categories/Python/"/>
    
      <category term="python爬虫" scheme="http://rovo98.github.io/categories/Python/python%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="Spider demo" scheme="http://rovo98.github.io/tags/Spider-demo/"/>
    
  </entry>
  
  <entry>
    <title>解决Github国内访问出现的问题</title>
    <link href="http://rovo98.github.io/posts/7e3029b3/"/>
    <id>http://rovo98.github.io/posts/7e3029b3/</id>
    <published>2018-06-10T07:58:34.000Z</published>
    <updated>2019-03-26T02:47:26.422Z</updated>
    
    <content type="html"><![CDATA[<p>主要通过修改hosts文件解决Github在国内访问不了、访问慢和页面加载异常的问题(没钱买vpn~)。</p><p>简单了解一下github, github是目前全球最大的男性同性交友网站(~滑稽~), 使用示例如下：</p><p><img src="/images/解决Github访问问题/communication.jpg" alt=""></p><a id="more"></a><p>开个玩笑，回归正题。</p><h3 id="为什么访问不了以及访问速度会很慢？"><a href="#为什么访问不了以及访问速度会很慢？" class="headerlink" title="为什么访问不了以及访问速度会很慢？"></a>为什么访问不了以及访问速度会很慢？</h3><p>GitHub在中国大陆访问速度慢的问题原因有很多，但最直接和最主要的原因是GitHub的分发加速网络的域名遭到DNS污染。</p><p>由于GitHub的加速分发CDN域名assets-cdn.github.com遭到DNS污染，导致无法连接使用GitHub的加速分发服务器，才使得中国大陆访问速度很慢。</p><p><img src="github_problem.png" alt="problem"></p><h3 id="如何解决DNS污染？"><a href="#如何解决DNS污染？" class="headerlink" title="如何解决DNS污染？"></a>如何解决DNS污染？</h3><p>一般的DNS问题都可以通过修改Hosts文件来解决，GitHub的CDN域名被污染问题也不例外，同样可以通过修改Hosts文件解决。</p><p>将域名解析直接指向IP地址来绕过DNS的解析，以此解决污染问题。</p><h4 id="获取被污染域名的实际IP地址"><a href="#获取被污染域名的实际IP地址" class="headerlink" title="获取被污染域名的实际IP地址"></a>获取被污染域名的实际IP地址</h4><p>访问<a href="https://www.ipaddress.com" target="_blank" rel="noopener">ipaddress.com</a>,使用ip lookup 工具获得相关域名的ip地址。</p><p>例如： github.com</p><p><img src="github_ipaddress.png" alt="ip address"></p><p>可以看到，我查出的域名ip地址为： <code>192.30.253.112</code> 和 <code>192.30.253.113</code> (任取一个即可)</p><h4 id="修改host文件，在文件中添加一行："><a href="#修改host文件，在文件中添加一行：" class="headerlink" title="修改host文件，在文件中添加一行："></a>修改host文件，在文件中添加一行：</h4><p><strong>[注] ： windows的hosts文件位置为： </strong><br><code>C:/windows/system32/drivers/etc/hosts</code></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">192.30.253.112 github.com</span><br></pre></td></tr></table></figure></div><h4 id="刷新dns缓存"><a href="#刷新dns缓存" class="headerlink" title="刷新dns缓存"></a>刷新dns缓存</h4><p>打开命令行cmd,输入如下命令：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig /flushdns</span><br></pre></td></tr></table></figure></div><p>此时再刷新页面即可。此时可以正常访问github，但是访问速度还是很慢，我们接着做优化。</p><h4 id="Github-访问提速"><a href="#Github-访问提速" class="headerlink" title="Github 访问提速"></a>Github 访问提速</h4><p>在hosts文件中继续加入，如下代码：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># GitHub Start</span><br><span class="line">192.30.253.112 github.com</span><br><span class="line">192.30.253.119 gist.github.com</span><br><span class="line">151.101.228.133 assets-cdn.github.com</span><br><span class="line">151.101.228.133 raw.githubusercontent.com</span><br><span class="line">151.101.228.133 gist.githubusercontent.com</span><br><span class="line">151.101.228.133 cloud.githubusercontent.com</span><br><span class="line">151.101.228.133 camo.githubusercontent.com</span><br><span class="line">151.101.228.133 avatars0.githubusercontent.com</span><br><span class="line">151.101.228.133 avatars1.githubusercontent.com</span><br><span class="line">151.101.228.133 avatars2.githubusercontent.com</span><br><span class="line">151.101.228.133 avatars3.githubusercontent.com</span><br><span class="line">151.101.228.133 avatars4.githubusercontent.com</span><br><span class="line">151.101.228.133 avatars5.githubusercontent.com</span><br><span class="line">151.101.228.133 avatars6.githubusercontent.com</span><br><span class="line">151.101.228.133 avatars7.githubusercontent.com</span><br><span class="line">151.101.228.133 avatars8.githubusercontent.com</span><br><span class="line">192.30.253.116  api.github.com</span><br><span class="line"># GitHub End</span><br></pre></td></tr></table></figure></div><div class="note warning"><p><strong>注意</strong> : 这里域名对应的ip是通过dns查询工具查询得到的，你应当选择的是延时相对较小且比较稳定的ip。</p></div><p>例如，上面的<code>151.101.228.133</code>是对我来说较好的ip:</p><p><img src="ping_test.png" alt="dns 查询检测"></p><div class="note info"><p>推荐的dns查询检测工具：</p><ul><li><a href="https://tool.lu/dns/" target="_blank" rel="noopener">DNS查询 - 在线工具</a></li><li><a href="http://tool.chinaz.com/dns/" target="_blank" rel="noopener">DNS检测|DNS查询-站长工具</a></li></ul><p>你可对单个域名多查询几次，以挑选稳定且速度较快的ip。</p></div><h4 id="快速地访问github"><a href="#快速地访问github" class="headerlink" title="快速地访问github"></a>快速地访问github</h4><p>再次刷新dns缓存后，你已经可以快速地访问github了。</p><p><img src="github_test.gif" alt=""></p><div class="note primary"><p>参考：<a href="https://github.com/chenxuhua/issues-blog/issues/3" target="_blank" rel="noopener">https://github.com/chenxuhua/issues-blog/issues/3</a></p></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要通过修改hosts文件解决Github在国内访问不了、访问慢和页面加载异常的问题(没钱买vpn~)。&lt;/p&gt;
&lt;p&gt;简单了解一下github, github是目前全球最大的男性同性交友网站(~滑稽~), 使用示例如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/解决Github访问问题/communication.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="tips" scheme="http://rovo98.github.io/categories/tips/"/>
    
    
      <category term="github" scheme="http://rovo98.github.io/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>PPP 点对点通信验证</title>
    <link href="http://rovo98.github.io/posts/28ff89ad/"/>
    <id>http://rovo98.github.io/posts/28ff89ad/</id>
    <published>2018-06-09T16:10:00.000Z</published>
    <updated>2018-10-08T05:08:42.645Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/ppp通信验证/structure.png" alt=""></p><p>使用Cisco Packet Tracer7 (思科网络模拟器)验证ppp点对点通信。</p><a id="more"></a><h3 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h3><p>使用<code>packet Tracer</code> 模拟两台路由器，进行点对点通信测试。</p><h3 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h3><h4 id="配置路由器"><a href="#配置路由器" class="headerlink" title="配置路由器"></a>配置路由器</h4><p>由于只需要验证点对点通信，对路由器的配置，相对比较简单，<br>路由器之间使用的是serial DCE 串口线相连。</p><p>配置Router1的<code>serial 2/0</code>串口为ip: <code>11.0.0.1</code> mask: <code>255.0.0.0</code>,并配置时钟频率为<code>64000</code></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Router&gt; enable</span><br><span class="line">Router# configure terminal</span><br><span class="line">Router(config) # hostname RA</span><br><span class="line">RA (config) # interface serial 2/0</span><br><span class="line">RA (config) # no shutdown</span><br><span class="line">RA (config-if) # ip address 11.0.0.1 255.0.0.0</span><br><span class="line">RA (config-if) # clock rate 64000</span><br></pre></td></tr></table></figure></div><p>配置Router2的<code>serial 3/0</code> 串口为ip: <code>11.0.0.2</code> mask： <code>255.0.0.0</code></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Router&gt; enable</span><br><span class="line">Router# configure terminal</span><br><span class="line">Router(config) # hostname RB</span><br><span class="line">RB (config) # interface serial 3/0</span><br><span class="line">RB (config) # no shutdown</span><br><span class="line">RB (config-if) # ip address 11.0.0.2 255.0.0.0</span><br></pre></td></tr></table></figure></div><ul><li>查看两个路由的串口状态：</li></ul><p><code>RA</code>:</p><p><img src="hdsl_rt1.png" alt="RA serial 2/0"></p><p><code>RB</code>:</p><p><img src="hdsl_rt2.png" alt="RB serial 3/0"></p><p>可以看到，路由器这里点对点通信默认使用的<code>HDLC</code>(High Level Data Link Control, 面向比特的同步协议)协议。</p><h4 id="HDLC情况下验证ping："><a href="#HDLC情况下验证ping：" class="headerlink" title="HDLC情况下验证ping："></a>HDLC情况下验证ping：</h4><p><code>11.0.0.1</code> ping <code>11.0.0.2</code>:</p><p><img src="hdlc_ping_rt1.png" alt="RA ping Test"></p><p><code>11.0.0.2</code> ping <code>11.0.0.1</code>:</p><p><img src="hdlc_ping_rt2.png" alt="RB ping Test"></p><p>ping 测试成功。</p><h4 id="配置RA-RB使用ppp协议，再做ping测试："><a href="#配置RA-RB使用ppp协议，再做ping测试：" class="headerlink" title="配置RA,RB使用ppp协议，再做ping测试："></a>配置RA,RB使用ppp协议，再做ping测试：</h4><ul><li>先配置<code>RA</code> 使用 <code>ppp</code>协议：</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RA # configure terminal</span><br><span class="line">RA (config) # interface serial 2/0</span><br><span class="line">RA (config-if) # encapsulation ppp</span><br></pre></td></tr></table></figure></div><p><img src="RA_ppp_setting.png" alt="RA serial 2/0"></p><p>可以看到<code>RA</code>当前使用的是<code>ppp</code>写协议，<code>LCP</code>处于<code>Closed</code>,此时，路由器应当无法进行点对点通信。</p><p><img src="RA_ppp_fTest.png" alt="ping Test"></p><ul><li>配置<code>RB</code>使用<code>ppp</code>协议：</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RB # configure terminal</span><br><span class="line">RB (config) # interface serial 3/0</span><br><span class="line">RB (config-if) # encapsulation ppp</span><br></pre></td></tr></table></figure></div><p><img src="RB_ppp_setting.png" alt="RB serial 3/0"></p><p>这时，可以看到<code>RB</code>也是使用了<code>ppp</code>协议，且<code>LCP</code>也处于<code>Open</code>状态，路由器之间可以进行通信。</p><p><img src="RB_ppp_sTest.png" alt="ping Test"></p><h4 id="给ppp协议添加authentication鉴别"><a href="#给ppp协议添加authentication鉴别" class="headerlink" title="给ppp协议添加authentication鉴别"></a>给ppp协议添加authentication鉴别</h4><ul><li>先配置<code>RA</code>，使其开启<code>ppp chap</code> (Challenge Handshake Authentication Protocol), 给<code>RB</code> 添加身份验证</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RA # config terminal</span><br><span class="line">RA (config) # username RB password password</span><br><span class="line">RA (config) # interface serial 2/0</span><br><span class="line">RA (config-if) # ppp authentication chap</span><br></pre></td></tr></table></figure></div><p><img src="RA_ppp_au.png" alt="RA serial 2/0"></p><p>此时，虽然<code>RA</code>和<code>RB</code>都是使用<code>ppp</code>协议，但是<code>RA</code>给<code>RB</code>添加了身份认证，而<code>RB</code>则没有，此时<code>LCP</code>处于<code>Closed</code>状态，它们之间无法进行通信。</p><ul><li>配置<code>RB</code>, 添加对<code>RA</code>的身份验证：</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RB # config terminal</span><br><span class="line">RB (config) # username RA password password</span><br><span class="line">RB (config) # interface serial 2/0</span><br><span class="line">RB (config-if) # ppp authentication chap</span><br></pre></td></tr></table></figure></div><p><img src="RB_ppp_au.png" alt="RB serial 3/0"></p><p>可以看到此时，<code>LCP</code>已经打开，路由器之间可以进行点对点通信。</p><p><img src="RB_ping_final.png" alt="ping"></p><h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><p>通过该实验，简单地验证了<code>ppp</code>协议在点对点信道中的使用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/ppp通信验证/structure.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;使用Cisco Packet Tracer7 (思科网络模拟器)验证ppp点对点通信。&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://rovo98.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="ppp通信" scheme="http://rovo98.github.io/tags/ppp%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>使用ensp进行简单的路由器互连实验</title>
    <link href="http://rovo98.github.io/posts/cc46ce96/"/>
    <id>http://rovo98.github.io/posts/cc46ce96/</id>
    <published>2018-06-06T16:00:00.000Z</published>
    <updated>2019-03-26T02:55:52.692Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/ensp_路由连接实验/route-structure.png" alt=""></p><p>使用ensp做华为AR1220路由进行简单的互连实验。</p><a id="more"></a><h3 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h3><ul><li>路由器设置</li><li>手动设置静态路由</li></ul><h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><ul><li>华为路由器AR1220</li><li>主机</li><li>Serial设备连接串口线和Copper以太网和千兆以太网连接线</li></ul><p>备注：所有实验设备均由<strong>ensp</strong>模拟。</p><h4 id="路由连接实验设计"><a href="#路由连接实验设计" class="headerlink" title="路由连接实验设计"></a>路由连接实验设计</h4><p>整体设计结构如下：</p><ul><li>1.其中分为六个不同的局域网；</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">192.168.11.0 网段 -&gt;</span><br><span class="line">    主机:   192.168.11.11</span><br><span class="line">            192.168.11.12</span><br><span class="line">    路由器AR6一个GigabitEthernet接口作为该网段的默认网关(192.168.11.1)</span><br><span class="line"></span><br><span class="line">192.168.12.0 网段 -&gt;</span><br><span class="line">    主机:   192.168.12.11</span><br><span class="line">            192.168.12.12</span><br><span class="line">    路由器AR4的一个GigabitEthernet接口作为该网段的默认网关(192.168.12.1)</span><br><span class="line"></span><br><span class="line">192.168.13.0 网段 -&gt;</span><br><span class="line">    主机:    192.168.13.11</span><br><span class="line">            192.168.13.12</span><br><span class="line">            192.168.13.13</span><br><span class="line">   路由器AR7的一个GigabitEthernet接口作为该网段的默认网关(192.168.13.1)</span><br><span class="line">   </span><br><span class="line">1.1.2.0 网段 -&gt; 路由器AR6和路由器AR7之间的接口</span><br><span class="line">1.1.1.0 网段 -&gt; 路由器AR6和AR4之间的接口</span><br><span class="line">1.1.3.0 网段 -&gt; 路由器AR6和AR7之间的接口</span><br></pre></td></tr></table></figure></div><ul><li>2.设备的连接：</li></ul><blockquote><p>除了路由器之间连接使用serial串口连接线外，其他均使用Copper连接线。</p></blockquote><h3 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h3><h4 id="配置各个局域网的ip及其网关"><a href="#配置各个局域网的ip及其网关" class="headerlink" title="配置各个局域网的ip及其网关"></a>配置各个局域网的ip及其网关</h4><ul><li>例如：<code>192.168.11.0</code>网段下的<code>192.168.11.11</code>主机：</li></ul><p><img src="pc1_setting.jpg" alt="PC1"></p><ul><li>配置 <code>192.168.11.1</code>作为<code>192.168.11.0</code>网段的网关：</li></ul><p><img src="gateway1.png" alt="设置网关"></p><p>所有主机经过配置后，他们应该可以ping通自己网段下的所有主机，如：<code>192.168.11.12</code> ping <code>192.168.11.11</code></p><p><img src="pingTest.jpg" alt="局域网ping测试"></p><p><strong>[需要注意的是]</strong>： 由于路由器互连时使用的是serial串口，所以路由器之间配置的是serial串口的ip。</p><p>例如：配置AR6的两个serial串口的接口ip为：<code>1.1.1.1</code>和<code>1.1.2.1</code>：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;Huawei&gt; system-view</span><br><span class="line">[Huawei] inter serial 2/0/1</span><br><span class="line">[Huawei-Servial2/0/1] ip address 1.1.1.1 255.255.255.0</span><br><span class="line">[Huawei-Servial2/0/1] quit</span><br><span class="line">[Huawei] inter serial 2/0/0</span><br><span class="line">[Huawei-Serial2/0/0] ip address 1.1.2.1 255.255.255.0</span><br></pre></td></tr></table></figure></div><h4 id="各个路由器的静态路由："><a href="#各个路由器的静态路由：" class="headerlink" title="各个路由器的静态路由："></a>各个路由器的静态路由：</h4><p>对于路由器AR6,我们希望所有<strong>目的网络</strong>为<code>192.168.12.0</code>的数据包都交付给AR4,即下一跳为<code>1.1.1.2</code>;所有目的网络为<code>192.168.13.0</code>的都交给AR7,下一跳为<code>1.1.2.2</code>：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Huawei&gt; system-view</span><br><span class="line">[Huawei] ip route-static 192.168.12.0 255.255.255.0 1.1.1.2</span><br><span class="line">[Huawei] ip route-static 192.168.13.0 255.255.255.0 1.1.2.2</span><br></pre></td></tr></table></figure></div><p>对于路由器AR4，所有目的网络为<code>192.168.11.0</code>的数据包交给AR6，下一跳为：<code>1.1.1.1</code>，目的网络为<code>192.168.13.0</code>的数据包交给AR7，下一跳为：<code>1.1.3.1</code>：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Huawei&gt; system-view</span><br><span class="line">[Huawei] ip route-static 192.168.11.0 255.255.255.0 1.1.1.1</span><br><span class="line">[Huawei] ip route-static 192.168.13.0 255.255.255.0 1.1.3.1</span><br></pre></td></tr></table></figure></div><p>对于路由器AR7， 所有目的网络为<code>192.168.11.0</code>的数据包都交给AR6，下一跳为：<code>1.1.2.1</code>，所有目的网络为<code>192.168.12.0</code>的数据包都交给AR4，下一跳为：<code>1.1.3.2</code>：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Huawei&gt; system-view</span><br><span class="line">[Huawei] ip route-static 192.168.11.0 255.255.255.0 1.1.2.1</span><br><span class="line">[Huawei] ip route-static 192.168.12.0 255.255.255.0 1.1.3.2</span><br></pre></td></tr></table></figure></div><p>经过以上对各个路由器的静态路由的配置后，我们可以通过<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">display ip routing-table</span><br></pre></td></tr></table></figure></div></p><p>来查看各个路由器的路由表：</p><ul><li>AR6路由表：</li></ul><p><img src="route1_info.jpg" alt="AR6路由表"></p><ul><li>AR4路由表：</li></ul><p><img src="route2_info.jpg" alt="AR4路由表"></p><ul><li>AR7路由表：</li></ul><p><img src="route3_info.jpg" alt="AR7路由表"></p><h3 id="测试实验结果"><a href="#测试实验结果" class="headerlink" title="测试实验结果"></a>测试实验结果</h3><p>使用任意一个局域网下的主机ping不同局域网下的主机：</p><p><code>192.168.11.11</code> ping <code>192.168.13.12</code> 和 <code>192.168.12.12</code>:</p><p><img src="tracert1.jpg" alt="tracert测试1"></p><p><code>192.168.12.11</code> ping <code>192.168.11.12</code> 和 <code>192.168.13.13</code>:</p><p><img src="tracert2.jpg" alt="tracert测试2"></p><p><code>192.168.13.11</code> ping <code>192.168.11.11</code> 和 <code>192.168.12.11</code>：</p><p><img src="tracert3.jpg" alt="tracert测试3"></p><p>由以上测试可以看出简单的路由器连接实验成功。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/ensp_路由连接实验/route-structure.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;使用ensp做华为AR1220路由进行简单的互连实验。&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://rovo98.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="路由器" scheme="http://rovo98.github.io/tags/%E8%B7%AF%E7%94%B1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>CentOS7通过yum(yellow dog update modifier) 安装mysql5.7</title>
    <link href="http://rovo98.github.io/posts/86d29d2c/"/>
    <id>http://rovo98.github.io/posts/86d29d2c/</id>
    <published>2018-04-22T16:00:00.000Z</published>
    <updated>2018-10-08T05:08:42.765Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h3 id="配置yum源"><a href="#配置yum源" class="headerlink" title="配置yum源"></a>配置yum源</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载mysql安装源包</span></span><br><span class="line">root @~&gt; wget http://dev.mysql.com/get/mysql57-community-release-el7-8.noarch.rpm</span><br><span class="line"><span class="comment"># 安装mysql源</span></span><br><span class="line">root @~&gt; yum localinstall mysql57-community-release-el7-8.noarch.rpm</span><br></pre></td></tr></table></figure></div><p>检查mysql源是否安装成功:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root @~&gt; yum repolist enabled | grep <span class="string">"mysql.*-community.*"</span></span><br></pre></td></tr></table></figure></div><p>如下图则安装成功:</p><p><img src="repo-resource.png" alt="mysql_source"></p><h3 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ ~&gt; yum install -y mysql-community-server</span><br></pre></td></tr></table></figure></div><h3 id="启动MySQL服务并设置开机自动启动"><a href="#启动MySQL服务并设置开机自动启动" class="headerlink" title="启动MySQL服务并设置开机自动启动"></a>启动MySQL服务并设置开机自动启动</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ ~&gt; systemctl start mysqld</span><br></pre></td></tr></table></figure></div><p>查看MySQL启动状态</p><p><img src="mysql-status.png" alt="mysqld进程状态"></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ ~&gt; systemctl <span class="built_in">enable</span> mysqld</span><br><span class="line">root@ ~&gt; systemctl daemon-reload</span><br></pre></td></tr></table></figure></div><h3 id="修改默认密码"><a href="#修改默认密码" class="headerlink" title="修改默认密码"></a>修改默认密码</h3><p>刚安装完的mysql会自动给root用户分配一个临时密码，而且必须重新设置密码(从5.5版本开始)</p><ul><li>先查看root用户的临时密码</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ ~&gt; grep <span class="string">"temporary password"</span> /var/<span class="built_in">log</span>/mysqld.log</span><br></pre></td></tr></table></figure></div><ul><li>使用临时的密码登录进mysql来设置新的密码</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="built_in">set</span> PASSWORD = PASSWORD(<span class="string">'[YOUR_NEW_PASSWORD]'</span>)</span><br></pre></td></tr></table></figure></div><p><img src="temporary-password.png" alt="查看临时密码"></p><ul><li>可能遇到的问题：设置的密码过于简单mysql报错:</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Your password does not satisfy the current policy requirements.</span><br></pre></td></tr></table></figure></div><p>解决方法：由于刚安装的mysql的密码默认强度是最高的，若想要设置简单的密码就要修改<strong>validate_password_policy</strong>的值，</p><h4 id="validate-password-policy有以下取值："><a href="#validate-password-policy有以下取值：" class="headerlink" title="validate_password_policy有以下取值："></a>validate_password_policy有以下取值：</h4><div class="table-container"><table><thead><tr><th style="text-align:center">Policy</th><th style="text-align:center">Tests Performed</th></tr></thead><tbody><tr><td style="text-align:center">0 or LOW</td><td style="text-align:center">Length</td></tr><tr><td style="text-align:center">1 or MEDIUM</td><td style="text-align:center">Length;numeric,lowercase/uppercase,and special characters</td></tr><tr><td style="text-align:center">2 or STRONG</td><td style="text-align:center">Length;numeric,lowercase/uppercase,and special characters; dictionary file</td></tr></tbody></table></div><p>操作：</p><ul><li>设置安全级别</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="built_in">set</span> global validate_password_policy=0;</span><br></pre></td></tr></table></figure></div><ul><li>设置密码长度为8，可以设置为其他值，最小为4位</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="built_in">set</span> global validate_password_length=4;</span><br></pre></td></tr></table></figure></div><p>之后就可以设置简单的密码了。</p><h3 id="允许root远程登录"><a href="#允许root远程登录" class="headerlink" title="允许root远程登录"></a>允许root远程登录</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; GRANT ALL PRIVILEGES ON *.* TO <span class="string">'root'</span>@<span class="string">'%'</span> IDENTIFIED BY <span class="string">'[YOUR_PASSWORD]'</span> WITH GRANT OPTION;</span><br><span class="line">mysql&gt; flush privileges;</span><br></pre></td></tr></table></figure></div><h3 id="修改字符集编码为UTF-8"><a href="#修改字符集编码为UTF-8" class="headerlink" title="修改字符集编码为UTF-8"></a>修改字符集编码为UTF-8</h3><ul><li>查看当前字符编码</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like <span class="string">"char%';</span></span><br></pre></td></tr></table></figure></div><p>检测是否都是utf-8(filesystem除外)，如果不是就需要修改。 <strong>character_set_server</strong>一般是lantin1。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 停止mysqld服务</span></span><br><span class="line">systemctl stop mysqld</span><br><span class="line"><span class="comment"># 进入my.cnf文件，一般是/etc/路径下</span></span><br><span class="line">vim /etc/my.cnf</span><br><span class="line"><span class="comment"># 在[mysqld]下追加character-set-server=utf-8</span></span><br><span class="line"><span class="comment"># 在[mysql]下追加default-character-set=utf-8</span></span><br><span class="line"><span class="comment"># 启动mysqld</span></span><br><span class="line">systemctl start mysqld</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      CentOS7下安装mysql。
    
    </summary>
    
      <category term="mysql" scheme="http://rovo98.github.io/categories/mysql/"/>
    
    
      <category term="mysql5.7安装" scheme="http://rovo98.github.io/tags/mysql5-7%E5%AE%89%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>Union-Find -- 动态连通性问题算法</title>
    <link href="http://rovo98.github.io/posts/b3f33dac/"/>
    <id>http://rovo98.github.io/posts/b3f33dac/</id>
    <published>2018-03-07T08:00:12.000Z</published>
    <updated>2018-10-08T05:08:41.948Z</updated>
    
    <content type="html"><![CDATA[<p><code>union-find</code>算法主要用于解决动态连通性问题。</p><a id="more"></a><p>我们设计算法时面对的第一个任务就是<strong>精确地定义问题</strong>。为了说明问题，通常会设计一份<code>API</code>来封装所需的基本操作。</p><h2 id="UF-API"><a href="#UF-API" class="headerlink" title="UF API"></a>UF API</h2><p>根据Union Find 算法需求定义接口 - </p><div class="table-container"><table><thead><tr><th style="text-align:center">Method</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td style="text-align:center">UF(int n)</td><td style="text-align:center">以整数标识(0到n-1)初始化n个触点</td></tr><tr><td style="text-align:center">int find(int p)</td><td style="text-align:center">p所在分量的标识符</td></tr><tr><td style="text-align:center">void union(int p, int q)</td><td style="text-align:center">在p和q之间增加一条连接</td></tr><tr><td style="text-align:center">boolean connected(int p, int q)</td><td style="text-align:center">如果p和q存在于同一个分量返回true</td></tr><tr><td style="text-align:center">int count()</td><td style="text-align:center">连通分支的数量</td></tr></tbody></table></div><p>此时，解决动态连通性问题设计算法的问题已经被我们转化为实现这份API。</p><ul><li>定义一种数据结构表示已知的连接</li><li>基于此数据结构实现高效的<code>union()</code>、<code>find()</code>、<code>connected()</code>和<code>count()</code>方法</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UF</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] parent;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UF</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    parent = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        count = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> find(p) == find(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span> ...</span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> ...</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure></div><h3 id="第一种实现方式-quick-find算法"><a href="#第一种实现方式-quick-find算法" class="headerlink" title="第一种实现方式: quick-find算法"></a>第一种实现方式: quick-find算法</h3><p>   这种实现方式保证当且仅当<code>parent[p] == parent[q]</code>时<code>p</code>和<code>q</code>是连通的。即在同一个连通分支的所有触点在<code>parent[]</code>中的值必须全部相同。 也意味着<code>connected(p, q)</code>只需要判断<code>parent[p] == parent[q]</code>，只有在<code>p</code>和<code>q</code>所在连通分支相同时返回<code>true</code>,否则<code>p</code>所在连通分支的所有触点对应<code>parent[]</code>中的值为一个值，而q所在连通分支的所有触点对应<code>parent[]</code>中的值为另一个值。因此我们在合并分量时需要<strong>遍历整个数组</strong>来将所有和<code>parent[p]</code>相等的元素变为<code>parent[q]</code>，或者反过来。<br>由此实现的<code>find()</code>、<code>union()</code>方法如下：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> parent[p];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> rootP = find(p);</span><br><span class="line">    <span class="keyword">int</span> rootQ = find(q);</span><br><span class="line">    <span class="keyword">if</span> (rootP == rootQ) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parent.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (parent[i] == rootQ) parent[i] = rootP;</span><br><span class="line">    &#125;</span><br><span class="line">    count--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="quick-find-算法分析"><a href="#quick-find-算法分析" class="headerlink" title="quick-find 算法分析"></a>quick-find 算法分析</h4><blockquote><p><code>find()</code> 操作速度显然是很快的，因为它只需要访问<code>parent[]</code>数组一次。但quick-find算法一般无法处理大型问题，因为对于每一对输入的触点 <code>union()</code>都需要扫描整个<code>parent[]</code>数组。可以看出此算法的时间复杂度应该为：$O(n^2).$</p><p><strong>命题F: 在quick-find 算法中，每次<code>find()</code> 调用只需要访问数组一次，而归并两个分量的<code>union()</code>操作访问数组的次数在$(N+3)$到$(2N+1)$之间。</strong></p></blockquote><h3 id="第二种实现方式：-quick-union算法"><a href="#第二种实现方式：-quick-union算法" class="headerlink" title="第二种实现方式： quick-union算法"></a>第二种实现方式： quick-union算法</h3><p>该算法的重点是在于提高 <code>union()</code>方法的速度，它和 quick-find 都是基于相同的数据结构 —— 以触点为索引的 <code>parent[]</code> 数组，在此之上，我们用它们来定义更加复杂的结构。令每个触点所对应的 <code>parent[]</code> 元素都是同一个分量中的另一触点名称（也可能是它自己) — 这种联系称为<strong>链接</strong>。</p><p>在实现<code>find()</code>方法时，从给定的触点开始，由它的链接得到另一个触点，再由这个触点的链接到达第三个触点，直到随着链接到达<strong>根触点，链接指向自己的触点</strong>。<br>而对于实现<code>union()</code>方法，只需有由p和q的链接分别去找它们的根触点，然后只需要将一个跟触点链接到另一个即可。由此实现的<code>find()</code>、<code>union()</code>方法如下：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (p != parent[p]) &#123;</span><br><span class="line">    p = parent[p];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> rootP = find(p);</span><br><span class="line">    <span class="keyword">int</span> rootQ = find(q);</span><br><span class="line">    <span class="keyword">if</span> (rootP == rootQ) <span class="keyword">return</span>;</span><br><span class="line">    parent[rootP] = parent[rootQ];</span><br><span class="line">    count--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="quick-union-算法分析"><a href="#quick-union-算法分析" class="headerlink" title="quick-union 算法分析"></a>quick-union 算法分析</h4><blockquote><p>在quick-union 中<code>parent[]</code>数组用父链接的形式表示的一片森林。quick-union 算法明显比quick-find 算法更快，因为它不需要为每一对输入遍历整个数组。</p></blockquote><p>在最好的情况下，<code>find()</code>只需要访问一次数组就能得到一个触点所在的分量的标识符；而在最坏的情况下，需要$2N - 1$次数组访问。<br><strong>我们可以把quick-union看作是quick-find算法的改进</strong>。—— 它将<code>union()</code>操作改进为线性级别。</p><blockquote><p><em>定义： 一棵树的大小是它的节点的数量。树中的一个节点的深度是它到根节点的路径的链接数。树的高度是它的所有节点的最大深度。</em></p><p><strong>命题G: quick-union 算法中的 find() 方法访问数组的次数为1 加上给定触点所对应的节点的深度的两倍。<code>union()</code> 和 <code>connected()</code> 访问数组的次数为两次 <code>find()</code>操作 （如果 union() 中给定的两个触点分别存在于不同的树中则还需要加 1).</strong></p></blockquote><p><strong>由命题G我们可以知道算法在最坏的情况下的运行时间是平方级别的。</strong><br>例如：输入的整数对为$0-1、0-2、0-3$等，$N-1$ 对之后，$N$ 个触点将全部处于相同的集合之中且由quick-union算法得到的树的高度为 $N-1$, 其中0链接到2, 2链接到3，如此下去。由命题G可知，对于整数对 $0 - i$, <code>union()</code> 操作访问数组的次数为$2i + 2$ （触点0的深度为i, 触点 i 的深度为 0）。 处理 N 对整数所需的所有 <code>find()</code> 操作访问数组的总次数为 $2(1+2+…+N)~N^2$。</p><h3 id="第三种实现方式：-加权quick-union算法"><a href="#第三种实现方式：-加权quick-union算法" class="headerlink" title="第三种实现方式： 加权quick-union算法"></a>第三种实现方式： 加权quick-union算法</h3><p>改进quick-union算法，不再随意在<code>union()</code>中将一棵树连接到另一颗树，而是<strong>记录树的大小(节点个数)或高度并总是将较小的树连接到较大的树上</strong>。</p><ul><li>记录树的大小(节点个数)加权</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UF</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] parent;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] rank;</span><br><span class="line">    <span class="keyword">private</span> count;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UF</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    parent = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        rank = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        count = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        parent[i] = i;</span><br><span class="line">            rank[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (p != parent[p]) &#123;</span><br><span class="line">        parent[p] = parent[parent[p]]; <span class="comment">// 路径压缩</span></span><br><span class="line">            p = parent[p];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rootP = find(p);</span><br><span class="line">        <span class="keyword">int</span> rootQ = find(q);</span><br><span class="line">        <span class="keyword">if</span> (rootP == rootQ) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 将较小的树连接到较大的树上</span></span><br><span class="line">        <span class="keyword">if</span> (rank[rootP] &gt; rank[rootQ]) &#123;</span><br><span class="line">        parent[rootQ] = rootP;</span><br><span class="line">            rank[rootP] += rank[rootQ];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        parent[rootP] = rootQ;</span><br><span class="line">            rank[rootQ] += rank[rootP];</span><br><span class="line">        &#125;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li>记录树的高度</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UF</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] parent;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] rank;</span><br><span class="line">    <span class="keyword">private</span> count;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UF</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    parent = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        rank = <span class="keyword">new</span> <span class="keyword">byte</span>[n];</span><br><span class="line">        count = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        parent[i] = i;</span><br><span class="line">            rank[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (p != parent[p]) &#123;</span><br><span class="line">        parent[p] = parent[parent[p]];</span><br><span class="line">            p = parent[p];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rootP = find(p);</span><br><span class="line">        <span class="keyword">int</span> rootQ = find(q);</span><br><span class="line">        <span class="keyword">if</span> (rootP == rootQ) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 将高度较低的树连接到高度较高的树上</span></span><br><span class="line">        <span class="keyword">if</span> (rank[rootP] &gt; rank[rootQ]) &#123;</span><br><span class="line">        parent[rootQ] = rootP;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (rank[rootP] &lt; rank[rootQ]) &#123;</span><br><span class="line">        parent[rootP] = rootQ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">        parent[rootQ] = rootP;</span><br><span class="line">            rank[rootP]++;</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="加权quick-union-算法分析"><a href="#加权quick-union-算法分析" class="headerlink" title="加权quick-union 算法分析"></a>加权quick-union 算法分析</h4><blockquote><p><strong>命题H: 对于 $N$ 个触点，加权 quick-union 算法构造的森林中的任意节点的深度最多为 $lgN$。</strong></p><p>推论: 对于加权 quick-union 算法和 N 个触点， 在最坏的情况下 <code>find()</code>、 <code>connected()</code> 和 <code>union()</code> 的成本的增长数量级为 $log N$。</p></blockquote><p>union-find 的具体实现: <a href="https://github.com/rovo98/ds-and-algs#uf----go-back-to-top" target="_blank" rel="noopener">查看</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;union-find&lt;/code&gt;算法主要用于解决动态连通性问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithms" scheme="http://rovo98.github.io/categories/Algorithms/"/>
    
      <category term="Union Find" scheme="http://rovo98.github.io/categories/Algorithms/Union-Find/"/>
    
    
      <category term="union-find" scheme="http://rovo98.github.io/tags/union-find/"/>
    
  </entry>
  
  <entry>
    <title>基本查找算法 - basical searching algorithms</title>
    <link href="http://rovo98.github.io/posts/d83777d2/"/>
    <id>http://rovo98.github.io/posts/d83777d2/</id>
    <published>2018-03-06T16:00:00.000Z</published>
    <updated>2018-10-08T05:08:41.818Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>基本查找算法，我们只谈<strong>静态查找</strong>的查找算法。</p><h3 id="线性查找-linear-search"><a href="#线性查找-linear-search" class="headerlink" title="线性查找 - linear search"></a>线性查找 - linear search</h3><p>特点： </p><ul><li>从头开始遍历数组，一个一个和<strong>key</strong>比较，查找成功则返回索引值。</li><li>不要求数组是<strong>有序的</strong>。</li><li>时间复杂度为： $O(n)$.</li></ul><h4 id="线性查找原始抽象方法实现如下"><a href="#线性查找原始抽象方法实现如下" class="headerlink" title="线性查找原始抽象方法实现如下:"></a>线性查找原始抽象方法实现如下:</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">linearSearch</span><span class="params">(Comparable[] a, Comparable key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a[i].compareTo(key) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="跳跃查找-jump-search"><a href="#跳跃查找-jump-search" class="headerlink" title="跳跃查找 - jump search"></a>跳跃查找 - jump search</h3><p>特点：</p><ul><li>要求查找数组<strong>有序</strong>；</li><li>主要思想是每次跳跃固定量的元素来确定目标元素所在的区间，再使用线性查找在区间上搜索目标元素。</li><li>时间复杂度为： $O(\sqrt{n})$.</li></ul><p><strong>[notice] : </strong> 假设我们要在一个有n个元素的数组中搜索某个元素，最坏情况下（<strong>当目标元素为最后个元素时），这个算法要跳跃n/m步，在线性搜索时作m-1次比较。</strong>令 $f(n) = ((n/m) + m-1$.当m = $\sqrt{n}$时，f(n) 取最小值，所以通常情况下，跳跃查找所使用的固定跳跃步数为 $\sqrt{n}$. </p><h4 id="跳跃查找的原始抽象方法实现如下："><a href="#跳跃查找的原始抽象方法实现如下：" class="headerlink" title="跳跃查找的原始抽象方法实现如下："></a>跳跃查找的原始抽象方法实现如下：</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">jumpSearch</span><span class="params">(Comparable[] a, Comparable key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = a.length;</span><br><span class="line">    <span class="keyword">int</span> block_size = Math.floor(Math.sqrt(n));</span><br><span class="line"><span class="keyword">int</span> step = block_size;</span><br><span class="line">    <span class="comment">// 查找目标元素可能出现的区间</span></span><br><span class="line">    <span class="keyword">int</span> prev = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (a[Math.min(step, n) - <span class="number">1</span>].compareTo(key) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    prev = step;</span><br><span class="line">        step += block_size;</span><br><span class="line">        <span class="keyword">if</span> (prev &gt;= n)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用线性查找在确定的区间上查找目标元素</span></span><br><span class="line">    <span class="keyword">while</span> (a[prev].compareTo(key) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    prev++;</span><br><span class="line">        <span class="keyword">if</span> (prev == Math.min(step, n))</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a[prev].compareTo(key) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="二分查找-binary-search"><a href="#二分查找-binary-search" class="headerlink" title="二分查找 - binary search"></a>二分查找 - binary search</h3><ul><li>要求数组<strong>有序</strong>。</li><li>将已经排好序的数组分为两个区间(interval), 把区间的中间元素与<strong>key</strong>比较, 若大于则搜索左区间，若小于则搜索右区间，等于则返回元素的索引。<strong>当区间长度为0时（key没出现在数组中)</strong>,返回-1。</li><li>时间复杂度为 ： $O(nlogn)$.</li></ul><h4 id="二分查找原始抽象方法实现如下"><a href="#二分查找原始抽象方法实现如下" class="headerlink" title="二分查找原始抽象方法实现如下:"></a>二分查找原始抽象方法实现如下:</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(Comparable[] a, Comparable key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> lo = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> hi = a.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[mid].compareTo(key) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[mid].compareTo(key) &gt; <span class="number">0</span>)</span><br><span class="line">        hi = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        lo = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearchRecursion</span><span class="params">(Comparable[] a, Comparable key, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (lo &lt;= hi) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[mid].compareTo(key) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[mid].compareTo(key) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> binarySearchRecursion(a, key, mid+<span class="number">1</span>, hi);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> binarySearchRecursion(a, key, lo, mid-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="三分查找-ternary-search"><a href="#三分查找-ternary-search" class="headerlink" title="三分查找 - ternary search"></a>三分查找 - ternary search</h3><p>特点：</p><ul><li>三分查找是二分查找的扩展；</li><li>时间复杂度为 ： $O(nlog_3n)$.</li></ul><p><strong>[notice]:</strong> 虽然看似三分查找的时间复杂度比二分查找的时间复杂度小，但是<strong>在最坏情况下</strong>，二分查找需要$2Log<em>2n + 1$次比较，而三分查找需要$4Log</em>{3}n + 1$次比较</p><h4 id="三分查找原始抽象方法实现如下："><a href="#三分查找原始抽象方法实现如下：" class="headerlink" title="三分查找原始抽象方法实现如下："></a>三分查找原始抽象方法实现如下：</h4><p>特点：</p><ul><li>类似二分查找，将查找数组划分为三个部分来进行查找；</li><li>时间复杂度： $Log_3n$.</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归实现.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ternarySearch</span><span class="params">(Comparable[] a, Comparable key, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (lo &lt;= hi) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid1 = lo + (hi - lo) / <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> mid2 = mid1 + (hi - lo) / <span class="number">3</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (a[mid1].compareTo(key) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> mid1;</span><br><span class="line">        <span class="keyword">if</span> (a[mid2].compareTo(key) == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> mid2;</span><br><span class="line">        <span class="comment">// 目标元素只可能出现在第一部分.</span></span><br><span class="line">        <span class="keyword">if</span> (a[mid1].compareTo(key) &gt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> ternarySearch(a, key, lo, mid1-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 目标元素只可能出现在第三部分.</span></span><br><span class="line">        <span class="keyword">if</span> (a[mid2].compareTo(key) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ternarySearch(a, key, mid2+<span class="number">1</span>, hi);</span><br><span class="line">        <span class="comment">// 目标元素只可能出现在第二部分.</span></span><br><span class="line">        <span class="keyword">return</span> ternarySearch(a, key, mid1+<span class="number">1</span>, mid2-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查找失败.</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="指数搜索-exponential-search"><a href="#指数搜索-exponential-search" class="headerlink" title="指数搜索 - exponential search"></a>指数搜索 - exponential search</h3><p>特点：</p><ul><li>找到目标元素可能出现的区间；</li><li>使用二分查找在区间上查找目标元素;</li><li>时间复杂度： $logn$;</li></ul><p><strong>[notice]</strong>:</p><ol><li>适用于目标数组元素大小趋向于无限大的情况；</li><li>当目标出现在目标数组左边时，指数搜索速度比二分查找快。</li></ol><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">exponentialSearch</span><span class="params">(Comparable[] a, Comparable key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n  = a.length;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n &amp;&amp; a[i].compareTo(key) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"> i = i * <span class="number">2</span>;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> binarySearch(a, key, i/<span class="number">2</span>, Math.min(i, n-<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="插值搜索-interpolation-search"><a href="#插值搜索-interpolation-search" class="headerlink" title="插值搜索 - interpolation search"></a>插值搜索 - interpolation search</h3><p>特点：</p><ul><li><p>原理： 假设查找数组的元素是均匀分布的，使用<strong>直线插值搜索</strong>，不像二分查找那样每次都是搜索区间中间元素。它能够快速的接近目标元素。</p></li><li><p>当元素均匀分布的情况，时间复杂度为: $O(log(log n))$, 最坏情况: $O(n)$.</p></li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java program to implement interpolatoin search.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">interpolationSearch</span><span class="params">(Comparable[] a, Comparable key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> lo = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> hi = a.length - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (lo &lt;= hi &amp;&amp; less(key, a[hi]) &amp;&amp; less(a[lo], key)) &#123;</span><br><span class="line">    <span class="keyword">int</span> pos = lo + (hi - lo) * (key - a[lo]) / (a[hi] - a[lo]);</span><br><span class="line">        <span class="keyword">if</span> (a[pos].compareTo(key) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> pos;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[pos].compareTo(key) &gt; <span class="number">0</span>)</span><br><span class="line">        hi = pos - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            lo = pos + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="NOTICE"><a href="#NOTICE" class="headerlink" title="NOTICE"></a>NOTICE</h3><p>本文中，涉及的算法详细实现和使用，请移步到github<a href="https://github.com/rovo98/ds-and-algs#searching-algorithms----go-back-to-top" target="_blank" rel="noopener">查看</a>。</p>]]></content>
    
    <summary type="html">
    
      使用java实现并简要分析抽象的基本静态查找算法。notes, learning from algs4.
    
    </summary>
    
      <category term="Algorithms" scheme="http://rovo98.github.io/categories/Algorithms/"/>
    
      <category term="searching algs" scheme="http://rovo98.github.io/categories/Algorithms/searching-algs/"/>
    
    
      <category term="basical searching algs" scheme="http://rovo98.github.io/tags/basical-searching-algs/"/>
    
  </entry>
  
  <entry>
    <title>快速排序 - quickSort</title>
    <link href="http://rovo98.github.io/posts/d9de8e4c/"/>
    <id>http://rovo98.github.io/posts/d9de8e4c/</id>
    <published>2018-03-05T16:00:00.000Z</published>
    <updated>2018-10-08T05:08:41.931Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>快速排序的主要特点是：</p><ol><li>原地排序 (in-place);</li><li>将长度为 N 的数组排序所需的时间和NlgN成正比；</li><li>排序内循环比大多数排序算法都要短小，意味着无论是在理论上还是实际中都要更快。</li></ol><p>缺点：<br>    快速排序非常的脆弱，在实现时要非常小心才能避免低劣的性能。</p><h3 id="基本算法"><a href="#基本算法" class="headerlink" title="基本算法"></a>基本算法</h3><p>快速排序是一种<strong>分治</strong>排序算法，它将一个数组分成两个子数组，将两部分独立地排序。不同于归并排序，快速排序的递归调用发生在处理子数之前。</p><p>快速排序方法抽象实现如下：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Quick</span> </span>&#123;</span><br><span class="line"><span class="comment">// quick sort java implement.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">    sort(a, <span class="number">0</span>, a.length-<span class="number">1</span>);</span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">isSorted</span><span class="params">(a)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hi &lt;= lo)<span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> j = partition(a, lo, hi);</span><br><span class="line">        sort(a, lo, j-<span class="number">1</span>);</span><br><span class="line">        sort(a, j+<span class="number">1</span>, hi);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">partition</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = lo;</span><br><span class="line">        <span class="keyword">int</span> j = hi + <span class="number">1</span>;</span><br><span class="line">        Comparable v = a[lo];</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (less(a[++i], v)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lo == hi) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (less(v, a[--j])) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == lo) <span class="keyword">break</span>; <span class="comment">// redundant since a[lo] is sentinel.</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Check if pointers cross.</span></span><br><span class="line">            <span class="keyword">if</span> (j &lt;= i)<span class="keyword">break</span>;</span><br><span class="line">            exch(a, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        exch(a, lo, j);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>上述切分方法示意图: [from algs4]</p><p><img src="quickSort_partition_1.png" alt="切分示意图"></p><p>切分轨迹图: [from algs4]</p><p><img src="quickSort_partition_2.png" alt="切分轨迹图"></p><blockquote><p><strong>命题 K</strong>： 将长度为N的无重复的数组排序，快速排序平均需要 ~ $2NlnN$ 次比较(以及$1/6$的交换)</p></blockquote><p><strong>[notice]</strong>: 尽管快速排序有很多优点，它的基本实现仍有一个潜在的缺点：</p><p>在切分不平衡时该算法可能及其低效。例如： 如果第一个次从最小的元素切分，第二次从第二小的元素切分，则这样每次只会移除一个元素。<br>[solution] : <strong>在快速排序之前将数组随机排序可以避免这种情况的发生</strong>。</p><h3 id="算法改进"><a href="#算法改进" class="headerlink" title="算法改进"></a>算法改进</h3><h4 id="1-切换到插入排序"><a href="#1-切换到插入排序" class="headerlink" title="1.切换到插入排序"></a>1.切换到插入排序</h4><p>和大多数递归排序算法一样(如归并)，改进快速排序的简单方法基于以下两点：</p><ul><li>对于小数组，快速排序比插入排序慢；</li><li>以为递归，快速排序的sort()方法在小数组中也会调用自己。</li></ul><p>改进 ： 将<strong>sort()方法</strong>中的</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (hi &lt;= lo) <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure></div><p>改为：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (hi &lt;= lo + M) &#123;</span><br><span class="line">insertion.sort(a, lo, hi);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>[<strong>notice</strong>] : 这里的切换参数 M 的最佳值是和系统相关的，但是5 ~ 15 之间的任意值在大多数情况下都能令人满意。</p><h4 id="2-三取样切分"><a href="#2-三取样切分" class="headerlink" title="2. 三取样切分"></a>2. 三取样切分</h4><p>改进快速排序性能的第二个方法是<strong>使用子数组的一小部分的中位数来切分数组</strong>。这样的切分的效果更好，但代价是需要计算中位数。</p><ul><li>人们发现将取样设为 3 并用大小居中的元素切分效果<strong>最好</strong>； 我们还可以将取样元素放在数组末尾作为哨兵(sentinel)。</li></ul><p>三取样切分抽象实现 : <a href="https://github.com/rovo98/ds-and-algs/blob/master/ds/sorting/exercises/QuickSortImprovedTwo.java" target="_blank" rel="noopener">详细查看</a></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSortImproved</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">sort(a, <span class="number">0</span>, a.length-<span class="number">1</span>);</span><br><span class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">isSorted</span><span class="params">(a)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> staic <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">dealPivot(a, lo, hi);</span><br><span class="line">    <span class="keyword">int</span> i = lo;</span><br><span class="line">    <span class="keyword">int</span> j = hi - <span class="number">1</span>;</span><br><span class="line">    Comparable v = a[hi - <span class="number">1</span>]; <span class="comment">// set the  pivot at hi -1 as a sentinel.</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (less(a[++i], v)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == hi-<span class="number">1</span>) <span class="keyword">break</span>; <span class="comment">// redundant since a[hi - 1] is sentinel.</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; lo &amp;&amp; less(v, a[--j])) &#123;  &#125;</span><br><span class="line">        </span><br><span class="line">       <span class="comment">// check if pointers cross.</span></span><br><span class="line">        <span class="keyword">if</span> (j &lt;= i) <span class="keyword">break</span>;</span><br><span class="line">        exch(a, i, j);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (i &lt; hi-<span class="number">1</span>) &#123;</span><br><span class="line">   exch(a, i, hi - <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   sort(a, lo, i - <span class="number">1</span>);</span><br><span class="line">   sort(a, i + <span class="number">1</span>, hi);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 三取样并将切分元素放在数组末尾</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dealPivot</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (less(a[mid], a[lo]))</span><br><span class="line">    exch(a, lo, mid);</span><br><span class="line">    <span class="keyword">if</span> (less(a[hi], a[lo]))</span><br><span class="line">    exch(a, lo, hi);</span><br><span class="line">    <span class="keyword">if</span> (less(a[hi], a[mid]))</span><br><span class="line">    exch(a, mid, hi);</span><br><span class="line">    <span class="comment">// put the pivot to hi - 1 as a sentinel.</span></span><br><span class="line">    exch(a, mid, hi - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="熵最优的排序"><a href="#熵最优的排序" class="headerlink" title="熵最优的排序"></a>熵最优的排序</h4><p>实际应用中经常会出现含有大量重复元素的数组，我们实现的快速排序性能尚可，但是<strong>还有巨大的改进空间</strong>。例如：一个元素全部重复的子数组就不需要继续排序了，但我们的快速排序还是会继续将它切分为更小的数组。</p><p>[solution] : <strong>一个简单想法是将数组切分为三个部分，分别为小于、等于和大于切分元素的数组元素</strong>。</p><p>DIjkstra 解法 ： 从左到右遍历数组一次，维护一个指针 lt 使得 a[lo .. lt-1]中的元素都小于v, 一个 gt 使得a[gt+1 .. hi]中的元素都大于v, 一个指针 i 使得a[lt .. i-1]中的元素都等于v, a[i .. gt]中的元素都未确定。</p><ul><li>a[i] 小于 v, 将a[lt]和a[i]交换，将lt 和 i加一；</li><li>a[i] 大于 v, 将a[gt]和a[i]交换， 将gt减一；</li><li>a[i] 等于 v, i++.</li></ul><p>熵最优排序抽象实现： <a href="https://github.com/rovo98/ds-and-algs/blob/master/ds/sorting/exercises/Quick3Ways.java" target="_blank" rel="noopener">详细查看</a></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">sort(a, <span class="number">0</span>, a.length-<span class="number">1</span>);</span><br><span class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">isSorted</span><span class="params">(a)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (hi &lt;= lo) <span class="keyword">return</span>;</span><br><span class="line">    Comparable v = a[lo];</span><br><span class="line">    <span class="keyword">int</span> lt = lo;</span><br><span class="line">    <span class="keyword">int</span> i = lo + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> gt = hi;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (i &lt;= gt) &#123;</span><br><span class="line">    <span class="keyword">if</span> (less(a[i], v)) exch(a, i++,  lt++);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (less(v, a[i]))exch(a, gt--, i);</span><br><span class="line">        <span class="keyword">else</span> i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// since a[lt .. i-1] is sorted.</span></span><br><span class="line">    <span class="comment">// sort the other subarrays recursively.</span></span><br><span class="line">    sort(a, lo, lt-<span class="number">1</span>);</span><br><span class="line">    sort(a, gt+<span class="number">1</span>, hi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>[notice] : <strong>三向切分的最坏情况是所有主键均不相同。</strong>对于标准的快速排序，随着数组规模的增大其运行时间会趋于平均时间，大幅偏离的情况是非常罕见的，因此可以肯定<strong>三向切分的快速排序运行时间和输入的信息量的N倍是成正比的。</strong> ———— 因为对于包含大量重复元素的数组，它将排序时间从线性对数级降到了线性级别。</p><h3 id="NOTICE"><a href="#NOTICE" class="headerlink" title="NOTICE"></a>NOTICE</h3><p>本文中，涉及的算法详细实现和使用，请移步到github<a href="https://github.com/rovo98/ds-and-algs#sorting-algorithms----go-back-to-top" target="_blank" rel="noopener">查看</a>。</p>]]></content>
    
    <summary type="html">
    
      快速排序 notes for algs4.
    
    </summary>
    
      <category term="Algorithms" scheme="http://rovo98.github.io/categories/Algorithms/"/>
    
      <category term="sorting algs" scheme="http://rovo98.github.io/categories/Algorithms/sorting-algs/"/>
    
    
      <category term="sorting algs" scheme="http://rovo98.github.io/tags/sorting-algs/"/>
    
  </entry>
  
  <entry>
    <title>归并排序 - mergeSort</title>
    <link href="http://rovo98.github.io/posts/1368334/"/>
    <id>http://rovo98.github.io/posts/1368334/</id>
    <published>2018-03-04T16:00:00.000Z</published>
    <updated>2018-10-08T05:08:41.878Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>归并排序属于<strong>分治算法(Divide and Conquer)</strong>。通过递归不断把待排序数组分成两个部分，将有序的两部分再重新归并一起来实现对数组的排序。</p><p><strong>[pseudo code for 2-way merge sort]</strong>:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MergeSort(arr[], aux[], lo, hi)</span><br><span class="line">If hi &gt; lo</span><br><span class="line">1. Find the middle point to divide the array into two halves;</span><br><span class="line">int mid = lo + (hi - lo) / 2;</span><br><span class="line">2. Call MergeSort for first half;</span><br><span class="line">MergeSort(arr, aux, lo, mid);</span><br><span class="line">3. Call MergeSort for second half;</span><br><span class="line">MergeSort(arr, aux, mid+1, hi);</span><br><span class="line">4. Merge the two halves sorted in step 2 and 3;</span><br><span class="line">Call merge(arr, aux, lo, mid, hi);</span><br></pre></td></tr></table></figure></div><h3 id="原地归并的抽象方法"><a href="#原地归并的抽象方法" class="headerlink" title="原地归并的抽象方法"></a>原地归并的抽象方法</h3><p>要实现上述的归并方法 — <strong>merge()</strong>很简单，创建一个数组将需要归并的<strong>原数组的两个部分</strong>中的元素放到这个数组中，然后再归并按大小顺序放回原数组。</p><blockquote><p>但是，这里我们要考虑一个问题，当我们用归并排序对一个比较大的数组进行排序时，我们需要进行很多次归并，因此在每一次归并时都创建一个新的数组来存储排序结果会带来问题。我们可以考虑只创建一个<strong>辅助数组<code>aux[]</code></strong>, 在每一个归并时，将原数组需要归并的两个部分复制到<code>aux[]</code>中，再把归并结果放回原数组。</p></blockquote><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(Comparable[] a, Comparable[] aux, <span class="keyword">int</span> lo, <span class="keyword">int</span> mid, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line"><span class="comment">// precondition: a[lo .. mid] and a[mid+1 .. hi] is sorted.</span></span><br><span class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">isSorted</span><span class="params">(a, lo, mid)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">isSorted</span><span class="params">(a, mid+<span class="number">1</span>, hi)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// copy a[lo .. hi] to aux[lo .. hi].</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = lo; k &lt;= hi; k++) &#123;</span><br><span class="line">    aux[k] = a[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = lo;</span><br><span class="line">    <span class="keyword">int</span> j = mid+<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = lo; k &lt;= hi; k++) &#123;</span><br><span class="line">    <span class="keyword">if</span>      (i &gt; mid)               a[k] = aux[j++];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; hi)                a[k] = aux[i++];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (less(aux[j], aux[i]))  a[k] = aux[j++];</span><br><span class="line">        <span class="keyword">else</span>                a[k] = aux[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// postcondition: a[lo .. hi] is sorted.</span></span><br><span class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">isSorted</span><span class="params">(a, lo, hi)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>[说明] : 该方法先将原数组两个需要归并的部分复制到aux[]中，然后<strong>从两个部分的起始位置开始取元素，一直选择两个部分中较小的元素放回原数组中，当有一部分元素取完了，则将另一部分剩余的元素全部放回原数组</strong>。</p><p>原地归并抽象方法轨迹： [from algs4]</p><p><img src="mergeSort_merge.png" alt="原地归并抽象方法轨迹"></p><h3 id="自顶向下的归并排序"><a href="#自顶向下的归并排序" class="headerlink" title="自顶向下的归并排序"></a>自顶向下的归并排序</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = a.length;</span><br><span class="line">    Comparable[] aux = <span class="keyword">new</span> Comparable[n];</span><br><span class="line">    sort(a, aux, <span class="number">0</span>, a.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, Comparable[] aux, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line"><span class="comment">// If array size is 1 then return.</span></span><br><span class="line"><span class="keyword">if</span> (hi &lt;= lo)    <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// Find the middle point to divide array into two halves.</span></span><br><span class="line">    <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// Call the mergeSort for first half.</span></span><br><span class="line">    sort(a, aux, lo, mid);</span><br><span class="line">    <span class="comment">// Call the mergeSort for second half.</span></span><br><span class="line">    sort(a, aux, mid+<span class="number">1</span>, hi);</span><br><span class="line">    <span class="comment">// Merge two halves sorted.</span></span><br><span class="line">    merge(a, aux, lo, mid, hi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>自顶向下归并结果轨迹 : [from algs4]</p><p><img src="mergeSort_ubSort_1.png" alt="自顶向下归并结果轨迹"></p><p>自顶向下归并排序调用轨迹 : [from algs4]</p><p><img src="mergeSort_ubSort_2.png" alt="自顶向下归并排序调用轨迹"></p><blockquote><p><strong>命题 F: 对于长度为 $N$ 的任意数组， 自顶向下归并排序需要 $1/2NlgN$ 至 $NlgN$ 次比较。</strong></p><p>自顶向下的所需时间表达式为 : $T(N) = 2T(N/2) + O(n)$使用解决递归式的 <code>Master method</code> 解得 $T(N) = \Theta(n log n)$</p></blockquote><p>我们可以通过下图来理解命题F, 每个节点都表示一个<code>sort()</code>方法通过<code>merge()</code>方法归并而成的子数组。<strong>这棵树正好有 $n$ 层。对于$0 ~ n-1$ 之间的任意 $k$, 自顶向下的第 $k$ 层有 $2^k$个子数组，每个数组长度为 $2^{n-k}$, 归并最多需要 $2^{n-k}$ 次比较。</strong>因此每层的比较次数为$2^k X 2^{n-k} = 2^n$, n 层总共为 $n2^n = NlgN$。</p><p>子数组树状图 : [from algs4]</p><p><img src="mergeSort_ubSort_3.png" alt="子数组树状图"></p><blockquote><p><strong>命题 G : 对于长度为 $N$ 的任意数组，自顶向下的归并排序最多需要访问数组 $6NlgN$ 次。</strong></p><p>证明： 每次归并最多需要访问数组 $6N$ 次（$2N$ 次用来复制， $2N$次用来将排好序的元素移动回去，另外最多比较$2N$次），根据<strong>命题F</strong>即可得到这个命题的结果。</p></blockquote><p><strong>[小结]</strong>: 归并排序排序算法的缺点是辅助数组所使用的额外空间和N的大小成正比。一些能够大幅度缩短归并排序的运行时间的想法：</p><ul><li>对小规模子数组进行插入排序；</li><li>测试数组是否已经有序；</li><li>不将元素复制到辅助数组中。</li></ul><h3 id="自底向上的归并排序"><a href="#自底向上的归并排序" class="headerlink" title="自底向上的归并排序"></a>自底向上的归并排序</h3><p>实现归并排序另外一种方法是<strong>先归并那些微型数组， 然后再成对归并得到的子数组，直到将整个数组归并在一起</strong>。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MergeBU</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = a.length;</span><br><span class="line">    Comparable[] aux = <span class="keyword">new</span> Comparable[n];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> sz = <span class="number">1</span>; sz &lt; n; sz += sz) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> lo = sz; lo &lt; n-sz; lo += sz+sz) &#123;</span><br><span class="line">        merge(a, aux, lo, lo+sz-<span class="number">1</span>, Math.min(lo+sz+sz-<span class="number">1</span>, n-<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#123;</span><br></pre></td></tr></table></figure></div><p>[注] : 自底向上的归并排序会多次遍历整个数组，根据子数组大小进行两两归并。子数组的大小 sz 的初始值为 1， 每次加倍。最后一个子数组的大小只有在数组大小是 sz 的偶数倍的时候才会等于 sz(否则它会比sz小)。</p><p>自底向上归并排序结果轨迹 ： [from algs4]</p><p><img src="mergeSort_buSort_1.png" alt="自底向上归并排序结果轨迹"></p><blockquote><p><strong>命题 H : 对于长度为 $N$ 的任意数组， 自底向上的归并排序需要 $1/2NlgN$ 至 $NlgN$次比较，最多访问数组 $6NlgN$ 次。</strong></p><p>证明 ： 处理一个数组的遍数正好是 $lgN$(即 $2^n &lt;= N &lt;2^n+1$ 中的 $n$)。每一遍会访问数组6N次。比较次数在 $N/2$ 和 $N$ 之间。</p></blockquote><p>【补充】： 当数组长度为 2 的幂时，自顶向下和自底向上的归并排序所用的比较次数和数组访问次数正好相同，只是顺序不同。其他时候，两种方法的比较和数组访问的次序会有所不同。</p><h3 id="NOTICE"><a href="#NOTICE" class="headerlink" title="NOTICE"></a>NOTICE</h3><p>本文中，涉及的算法详细实现和使用，请移步到github<a href="https://github.com/rovo98/ds-and-algs#sorting-algorithms----go-back-to-top" target="_blank" rel="noopener">查看</a>。</p>]]></content>
    
    <summary type="html">
    
      归并排序 notes, learning from algs4.
    
    </summary>
    
      <category term="Algorithms" scheme="http://rovo98.github.io/categories/Algorithms/"/>
    
      <category term="sorting algs" scheme="http://rovo98.github.io/categories/Algorithms/sorting-algs/"/>
    
    
      <category term="sorting algs" scheme="http://rovo98.github.io/tags/sorting-algs/"/>
    
  </entry>
  
  <entry>
    <title>基本排序算法 - basial sorting algorithms with java implementation</title>
    <link href="http://rovo98.github.io/posts/57d02cec/"/>
    <id>http://rovo98.github.io/posts/57d02cec/</id>
    <published>2018-03-04T16:00:00.000Z</published>
    <updated>2018-10-08T05:08:41.825Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我们关注的主要对象是<strong>重新排列数组元素的算法</strong>， 其中每个元素都有一个<strong>主键</strong>。排序算法的目的就是将所有元素的主键按照某种方式排列(通常按照大小或是字母顺序)。</p></blockquote><a id="more"></a><p>在java中元素通常都是对象，对主键的抽象描述则是通过一种内置的机制(<code>Comparable</code>接口)来完成的。</p><h4 id="排序算法类模板"><a href="#排序算法类模板" class="headerlink" title="排序算法类模板"></a>排序算法类模板</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(Comparable[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    Comparable temp = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*排序算法，如InsertionSort、BubbleSort、</span></span><br><span class="line"><span class="comment">        SelectionSort、ShellSort等*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">        System.out.print(a[i] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(Comparable v, Comparable w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v.compareTo(w) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSorted</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (less(a[i], a[i-<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Unit tests the &#123;<span class="doctag">@code</span> Example&#125; sorting algorithm.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@args</span> command-line arguments.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 测试代码...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>这个类展示的是数组排序实现的框架。代码中实现的排序方法适用于任意实现了<code>Comparable</code>接口的数据类型</strong>。</p><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>无论数组的初始状态是什么，我们都无法确保排序算法都能成功。所以谨慎起见，我们会在测试代码中添加一条语句<code>assert isSorted(a);</code>来确保排序后的数组都是有序的。</p><h4 id="运行时间"><a href="#运行时间" class="headerlink" title="运行时间"></a>运行时间</h4><p>评估算法的性能。首先，要计算各个排序算法在不同的随机输入下的基本操作的次数(包括比较和交换，或者是读写数组的次数)。</p><blockquote><p>排序成本模型 : 在研究排序算法时，我们需要计算比较和交换的数量。<br>  对于不交换元素的算法，我们会计算访问数组的次数。</p></blockquote><h4 id="额外的内存使用"><a href="#额外的内存使用" class="headerlink" title="额外的内存使用"></a>额外的内存使用</h4><p>排序算法的额外内存开销和运行时间是同等重要的。排序算法可以分为两类:</p><ul><li>除了函数调用所需的栈和固定数目的实例变量之外无需额外内存的<strong>原地排序算法</strong>。</li><li>需要额外内存空间来存储另一份数组副本的其他排序算法。</li></ul><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p>上面的排序模板适用于实现了Comparable接口的数据类型。例如, java中封装数字类型的<code>Integer</code>、<code>Double</code>、以及<code>String</code>和其他许多高级数据类型。<br>而对于自己创建的数据类型，我们是要实现Comparable接口就能够保证能够使用排序算法进行排序。</p><p>自定义数据类型样例:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Date</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Date</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> day;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> month;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> year;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Date</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> m, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123; day = d; month = m; year = y; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">day</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> day; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">month</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> month; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">year</span><span class="params">()</span>   </span>&#123; <span class="keyword">return</span> year;  &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Date that)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.year &gt; that.year) <span class="keyword">return</span> +<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.year &lt; that.year) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.month &gt; that.month) <span class="keyword">return</span> +<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.month &lt; that.month) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.day &gt; that.day) <span class="keyword">return</span> +<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.day &lt; that.day) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> month + <span class="string">"/"</span> + day + <span class="string">"/"</span> + year;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>首先，找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置(如果第一个元素就是最小的元素那么它就和自己交换)。 再次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到整个数组排序完成。<strong>不断地选择剩余元素中的最小者</strong>。</p><blockquote><p><strong>命题 A: 对于长度为 $N$ 的数组，选择排序需要大约 $N^2/2$ 次比较和 $N$ 次交换。</strong><br>  证明： 可以通过算法的排序轨迹来证明，用一张$N X N$的表格来表示排序的轨迹，其中每个非灰色字符都表示一次比较。表格中大约有一半的元素不是  灰色的 — 即对角线和其上部分的元素。对角巷上的每个元素都对应真一次交换。通过查看代码我们可以更精确地得到，$0$ 到 $N-1$ 的任意 $i$ 都会  进行一次交换和 $N-1-i$ 次比较，因此   总共有$N$次交换以及 $(N-1)+（N-2)+…+2+1 = N(N-1)/2 ~ N^2/2$。</p></blockquote><p>算法轨迹图示（from algs4)：</p><p><img src="bs_selectionSort_1.png" alt="插入排序算法轨迹例子"></p><p>算法实现:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Selection</span> </span>&#123;</span><br><span class="line"><span class="comment">/* 其他的方法同排序算法模板*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = a.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> min = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (less(a[j], a[min]) &#123;</span><br><span class="line">                min = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            exch(a, i, min);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>与选择排序一样，当前索引左边的所有元素都是有序的，但他们的最终位置不确定，为了给更小的元素腾出空间，它们可能会移动。当索引到达数组的右端时，数组排序就完成了。</p><p>和选择排序不同的是，插入排序<strong>所需的时间取决于输入中元素的初始顺序</strong>。例如对于一个很大且其中的元素已经有序（或接近有序）的数组进行插入排序将会比对随机数组或逆序数组进行排序要快得多。</p><blockquote><p><strong>命题 B : 对于随机排列的长度为 $N$ 且主键不重复的数组, 平均情况下插入排序需要 ~ $N^2/4$次比较以及 $~N^2/4$次交换。最坏情况下需要 ~N^2  /2  次比较和 ~ $N^2/2$次交换，最好情况下需要$N-1$次比较和$0$次交换。</strong><br>  证明： 和证明命题A一样，通过一个$N X N$的算法轨迹表可以很容易就得到交换和比较的次数。最坏的情况下对角线之下所有元素都需要移动位置，最   好情况下都不需要。对于随机排列的数组，在平均情况下每个元素都可能向后移动半个数组的长度 ，因此交换总数是对角线之下的元素总数的二分之。   比较的总次数是交换的次数加上一个额外的项，该项为 $N$ 减去被插入的元素正好是已知的最小   元   素的次数。在最坏情况下（逆序数组），这一   项相对于总数可以忽略不计；在最好的情况下（数组已经有序），这一项等于$N-1$。</p></blockquote><p>插入排序算法轨迹图示（from algs4):</p><p><img src="bs_insertionSort_1.png" alt="插入排序算法轨迹图例"></p><p>算法实现:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Insertion</span> </span>&#123;</span><br><span class="line"><span class="comment">/*其他的方法同排序算法模板*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = a.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j&gt;<span class="number">0</span>&amp;&amp;less(a[j], a[j-<span class="number">1</span>]; j--) &#123;</span><br><span class="line">            exch(a, j, j-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>附加：</strong></p><p>对于插入排序，我们要考虑的更一般情况是<strong>部分有序的数组</strong>。<br><strong>倒置</strong>指的是数组中的两个顺序颠倒的元素。比如EXAMPLE中有11对倒置：<br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">E-A  X-A  X-M  X-P  X-LX-E</span><br><span class="line">M-L M-E  P-L  P-E L-E</span><br></pre></td></tr></table></figure></div></p><p>如果数组中倒置的数量小于数组大小的某个倍数，那么我们说这个数组是<strong>部分有序</strong>的。<br>几种典型的部分有序的数组:</p><ul><li>数组中每个元素距离它的最终位置不远；</li><li>一个有序数组接一个小数组；</li><li>数组中只有几个元素位置不正确。</li></ul><p><strong>插入排序对这样的数组很有效，而选择排序则不然。当倒置的数量很少时，插入排序比大部分的其他排序算法都要快</strong>。</p><blockquote><p><strong>命题 C: 插入排序需要的交换的操作和数组的中倒置的数量相同，需要的比较次数大于等于倒置的数量，小于等于倒置的数量加上数组的大小再减一</strong>。<br>  证明： 每次交换都改变了两个顺序颠倒的元素的位置，相当于减少了一对倒置，当倒置数量为0时，排序就完成了。每次交换都对应着一次比较，且$1$   到$N  -1$之间的每个$i$都可能需要一次额外的比较(在<code>a[i]</code>没有达到数组的左端时)。</p></blockquote><p><strong>[算法改进]</strong> : 大幅提高插入排序的速度，在内循环中将较大的元素都向右移动而不是总是交换两个元素(这样访问数组的次数就能减半)。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = a.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    Comparable key = a[i];</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span> (j = i-<span class="number">1</span>; j &gt;= <span class="number">0</span>&amp;&amp;less(key, a[j]); j--) &#123;</span><br><span class="line">        a[j+<span class="number">1</span>] = a[j];</span><br><span class="line">        &#125;</span><br><span class="line">        a[j+<span class="number">1</span>] = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>希尔排序是基于插入排序的快速排序算法.<br>对于规模乱序数组插入排序很慢，因为它只会交换相邻的元素，因此元素只能一点一点地从数组的一端移动到另外一端。<br>希尔排序为了加快速度简单地改进了插入排序 —— 交换不相邻的元素以对数组的<strong>局部</strong>进行排序，并最终使用插入排序将局部有序的数组排序。</p><p><strong>希尔排序的思想</strong>:使任意间隔为h的元素都是有序的。<br>这样的数组称为<strong>h有序数组</strong>。对于任意以1为结尾的h序列（递增序列），我们使用它都能将数组排序。</p><p>算法实现： —— 使用的递增序列来自 algs4.</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shell</span> </span>&#123;</span><br><span class="line"><span class="comment">/*其他排序算法方法同模板*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> n = a.length;</span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (h &lt; n/<span class="number">3</span>) h = <span class="number">3</span> * h + <span class="number">1</span>; <span class="comment">// 1， 4， 13， 40， 121， ...</span></span><br><span class="line">        <span class="keyword">while</span> (h &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= h&amp;&amp;less(a[j], a[j-h]); j -= h) &#123;</span><br><span class="line">                exch(a, j, j-h);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            h /= <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>[递增序列的选择]</strong> : 算法的性能不仅取决于h，还取决与h之间的数学性质。目前还没有人能证明某个递增序列是”最好的”。以上算法实现使用的递增序列（使用序列 $1/2(3^k-1)$,从N/3开始递减至1.）的计算和使用都很简单且和复杂的递增序列的性能接近。</p><p>算法轨迹图例 — example (from algs4):</p><p><img src="bs_shellSort_1.png" alt="希尔排序算法轨迹图例"></p><p><strong>实际应用</strong>: 对于中等大小的数组它的运行时间是可以接受的且它的代码量小，不需要额外的内存空间。<em>所以在面临一个排序问题而没有系统排序函数可用时，可先用希尔排序，然后再考虑是否将它替换为更加复杂的排序算法</em>。</p><p><strong>[算法改进]</strong> : 由于希尔排序是基于插入排序，所以我们可以参照插入排序的改进，对希尔排序进行改进 — 把内循环中较大的元素右移而不是交换两个元素。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = a.length;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (h &lt; n/<span class="number">3</span>) h = <span class="number">3</span> * h + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (h &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h; i &lt; n; i++) &#123;</span><br><span class="line">        Comparable key = a[i];</span><br><span class="line">            <span class="keyword">int</span> j;</span><br><span class="line">            <span class="keyword">for</span> (j = i-h; j &gt;= <span class="number">0</span>&amp;&amp;less(key, a[j]); j -= h) &#123;</span><br><span class="line">            a[j+h] = a[j];</span><br><span class="line">            &#125;</span><br><span class="line">            a[j+h] = key;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="附加-——-冒泡排序"><a href="#附加-——-冒泡排序" class="headerlink" title="附加 —— 冒泡排序"></a>附加 —— 冒泡排序</h3><p>冒泡排序相对比较简单，这里直接给出它的实现:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bubble</span> </span>&#123;</span><br><span class="line"><span class="comment">/*其他排序算法方法同排序算法模板*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">int</span> n = a.length;</span><br><span class="line"> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n&amp;&amp;flag == <span class="keyword">true</span>; i++) &#123;</span><br><span class="line"> flag = <span class="keyword">false</span>;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n-i; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (less(a[j+<span class="number">1</span>], a[j]) &#123;</span><br><span class="line">        exch(a, j+<span class="number">1</span>, j);</span><br><span class="line">           flag = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></div><p><strong>算法分析</strong>: 对于冒泡排序，最坏情况下，算法需要进行N-1趟排序，总的数组元素比较的次数为$(N-1)+(N-2)+…+1$ ~ $N^2/2$， 总的交换次数为数组中<strong>倒置</strong>的数量。</p><h3 id="NOTICE"><a href="#NOTICE" class="headerlink" title="NOTICE"></a>NOTICE</h3><p>本文中，涉及的算法详细实现和使用，请移步到github<a href="https://github.com/rovo98/ds-and-algs#sorting-algorithms----go-back-to-top" target="_blank" rel="noopener">查看</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;我们关注的主要对象是&lt;strong&gt;重新排列数组元素的算法&lt;/strong&gt;， 其中每个元素都有一个&lt;strong&gt;主键&lt;/strong&gt;。排序算法的目的就是将所有元素的主键按照某种方式排列(通常按照大小或是字母顺序)。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Algorithms" scheme="http://rovo98.github.io/categories/Algorithms/"/>
    
      <category term="sorting algs" scheme="http://rovo98.github.io/categories/Algorithms/sorting-algs/"/>
    
    
      <category term="sorting algs" scheme="http://rovo98.github.io/tags/sorting-algs/"/>
    
  </entry>
  
  <entry>
    <title>Advanture 1 Leetcode - 944 - Delete Columns to Make Sorted</title>
    <link href="http://rovo98.github.io/posts/f5b699c8/"/>
    <id>http://rovo98.github.io/posts/f5b699c8/</id>
    <published>2018-02-10T02:00:00.000Z</published>
    <updated>2018-11-27T05:22:17.036Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>给出由 N 个小写字母串组成的数组 <code>A</code>，所有小写字母串的长度都相同。<br>现在，我们可以选择任何一组删除索引，对于每个字符串，我们将删除这些索引中的所有字符。<br>举个例子，如果字符串为 <code>&quot;abcdef&quot;</code>，且删除索引是 <code>{0, 2, 3}</code>，那么删除之后的最终字符串为 <code>&quot;bef&quot;</code>。<br>假设我们选择了一组删除索引 <code>D</code>，在执行删除操作之后，<code>A</code> 中剩余的每一列都是有序的。<br>形式上，第 <code>c</code> 列为 <code>[A[0][c], A[1][c], ..., A[A.length-1][c]]</code><br>返回 <code>D.length</code> 的最小可能值。<br><br></p><ul><li><a href="https://leetcode-cn.com/problems/delete-columns-to-make-sorted/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/delete-columns-to-make-sorted/</a>(中文)</li><li><a href="https://leetcode.com/problems/delete-columns-to-make-sorted/" target="_blank" rel="noopener">https://leetcode.com/problems/delete-columns-to-make-sorted/</a>(en)<br><br><br>示例 1：<br>输入：[“cba”,”daf”,”ghi”]<br>输出：1<br>示例 2：<br>输入：[“a”,”b”]<br>输出：0<br>示例 3：<br>输入：[“zyx”,”wvu”,”tsr”]<br>输出：3<br>提示：<br>1 &lt;= A.length &lt;= 100<br>1 &lt;= A[i].length &lt;= 1000</li></ul></blockquote><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>对于这种可以快速得出解题思路的题目：</p><div class="note primary"><p>由于每个字符串的长度一样，所以我们只需要依次比较字符串对应的每一列，<strong>判断是否满足非降序</strong>即可得到结果。</p></div><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDeletionSize</span><span class="params">(String[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = A[<span class="number">0</span>].length(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = A.length-<span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (A[j].charAt(i) &gt; A[j+<span class="number">1</span>].charAt(i)) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>复杂度分析(Complexity Analysis)</strong>:</p><ul><li>时间复杂度(Time complexity): $O(n)$</li><li>空间复杂度(Space complexity): $O(1)$</li></ul><div class="note waring"><p>此题目，在<code>leetcode</code>上被归类为<code>greedy</code>，但我觉的解题思路并没怎么体现贪心算法的思想。。。</p></div>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;给出由 N 个小写字母串组成的数组 &lt;code&gt;A&lt;/code&gt;，所有小写字母串的长度都相同。&lt;br&gt;现在，我们可以选择任何一组删除索引，对于每个字符串，我们将删除这些索引中的所有字符。&lt;br&gt;举个例子，如果字符串为 &lt;code&gt;&amp;quot;abcdef&amp;quot;&lt;/code&gt;，且删除索引是 &lt;code&gt;{0, 2, 3}&lt;/code&gt;，那么删除之后的最终字符串为 &lt;code&gt;&amp;quot;bef&amp;quot;&lt;/code&gt;。&lt;br&gt;假设我们选择了一组删除索引 &lt;code&gt;D&lt;/code&gt;，在执行删除操作之后，&lt;code&gt;A&lt;/code&gt; 中剩余的每一列都是有序的。&lt;br&gt;形式上，第 &lt;code&gt;c&lt;/code&gt; 列为 &lt;code&gt;[A[0][c], A[1][c], ..., A[A.length-1][c]]&lt;/code&gt;&lt;br&gt;返回 &lt;code&gt;D.length&lt;/code&gt; 的最小可能值。&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/delete-columns-to-make-sorted/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/delete-columns-to-make-sorted/&lt;/a&gt;(中文)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://leetcode.com/problems/delete-columns-to-make-sorted/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/delete-columns-to-make-sorted/&lt;/a&gt;(en)&lt;br&gt;&lt;br&gt;&lt;br&gt;示例 1：&lt;br&gt;输入：[“cba”,”daf”,”ghi”]&lt;br&gt;输出：1&lt;br&gt;示例 2：&lt;br&gt;输入：[“a”,”b”]&lt;br&gt;输出：0&lt;br&gt;示例 3：&lt;br&gt;输入：[“zyx”,”wvu”,”tsr”]&lt;br&gt;输出：3&lt;br&gt;提示：&lt;br&gt;1 &amp;lt;= A.length &amp;lt;= 100&lt;br&gt;1 &amp;lt;= A[i].length &amp;lt;= 1000&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://rovo98.github.io/categories/Leetcode/"/>
    
    
      <category term="leetcode-greedy-easy" scheme="http://rovo98.github.io/tags/leetcode-greedy-easy/"/>
    
  </entry>
  
  <entry>
    <title>Advantrue 1 - Leetcode 189 - Rotate Array</title>
    <link href="http://rovo98.github.io/posts/885fe7d0/"/>
    <id>http://rovo98.github.io/posts/885fe7d0/</id>
    <published>2018-02-02T02:00:00.000Z</published>
    <updated>2018-11-30T16:16:21.492Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。<br>链接:</p><ol><li><a href="https://leetcode-cn.com/problems/rotate-array/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/rotate-array/</a>(中文)</li><li><a href="https://leetcode.com/problems/rotate-array/" target="_blank" rel="noopener">https://leetcode.com/problems/rotate-array/</a>(en)</li></ol><p>示例 1:</p><p>输入: [1,2,3,4,5,6,7] 和 k = 3<br>输出: [5,6,7,1,2,3,4]<br>解释:<br>向右旋转 1 步: [7,1,2,3,4,5,6]<br>向右旋转 2 步: [6,7,1,2,3,4,5]<br>向右旋转 3 步: [5,6,7,1,2,3,4]<br>示例 2:</p><p>输入: [-1,-100,3,99] 和 k = 2<br>输出: [3,99,-1,-100]<br>解释:<br>向右旋转 1 步: [99,-1,-100,3]<br>向右旋转 2 步: [3,99,-1,-100]<br>说明:</p><p>尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。<br>要求使用空间复杂度为 O(1) 的原地算法。</p></blockquote><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>首先考虑考虑<code>brute-force</code>暴力解法，要使数组中的元素整体右移<code>k</code>位，最直接的方式是循环<code>k</code>次，每次循环让每个元素依次跟最后一个元素进行交换<code>swap</code>即可。</p><blockquote><p>例如: input : [1, 2, 3, 4], k = 1<br>      loop1: 4, 2, 3, 1 -&gt;<br>             4, 1, 3, 2 -&gt;<br>             4, 1, 2, 3</p></blockquote><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> last = nums[nums.length-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[j];</span><br><span class="line">                nums[j] = last;</span><br><span class="line">                last = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>复杂度分析(Compelxity Analysis):</strong></p><ul><li>时间复杂度(Time complexity): $O(kn)$</li><li>空间复杂度(Space complexity): $O(1)$</li></ul><p>Submission status:</p><blockquote><p>该解法通过所有测试用例，但是执行时间为<code>109 ms</code>, 击败<code>14.9%</code>的<code>java</code>代码提交。</p></blockquote><div class="note primary"><p>解题思路二:</p><blockquote><p>利用辅助数组，先将需要移动变换的元素放在移动后的位置，再将辅助数组元素移回原数组.</p></blockquote></div><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] aux = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            aux[(i+k) % nums.length] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; aux.length; i++) &#123;</span><br><span class="line">            nums[i] = aux[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>复杂度分析(Compelxity Analysis):</strong></p><ul><li>时间复杂度(Time complexity): $O(n)$</li><li>空间复杂度(Space complexity): $O(n)$</li></ul><p>Submission status:</p><blockquote><p>代码提交运行时间: <code>1 ms</code> 击败<code>53.8%</code>的<code>java</code>提交代码。</p></blockquote><div class="note primary"><p>解题思路三:</p><p>除了上面给出的第二种方案，还有更好的解题方法，能够做到<code>O(n)</code>运行时间，以及<code>O(1)</code>的空间复杂度.</p></div><blockquote><p>思路: 拿题目给定的例子来说，[1,2,3,4,5,6,7], k = 3.<br>首先将数组划分成两个部分: <code>0~nums.length-k-1</code>,即<code>[1,2,3,4]和</code>nums.length-k ~ nums.length-1],即<code>[5,6,7]</code>,把两个部分进行翻转，此时数组变成<code>[4,3,2,1,7,6,5]</code>.<br>最后，将整个数组进行翻转即可得到我们想要的结果: <code>[5,6,7,1,2,3,4]</code>.</p></blockquote><div class="note warning"><p>需要注意的是，需要对<code>k</code>进行处理，当<code>k &gt; nums.length</code>情况，会出现越界情况。<br>解决方法: 使<code>k</code>进行 <strong>mod</strong> <code>nums.length</code>运算(<code>k = k % nums.length</code>).</p></div><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        k %= nums.length;</span><br><span class="line">        reverse(nums, <span class="number">0</span>, nums.length-k - <span class="number">1</span>);</span><br><span class="line">        reverse(nums, nums.length-k, nums.length-<span class="number">1</span>);</span><br><span class="line">        reverse(nums, <span class="number">0</span>, nums.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">            nums[i] = nums[j];</span><br><span class="line">            nums[j] = temp;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>复杂度分析(Complexity Analysis)</strong>:</p><ul><li>时间复杂度(Time complexity): $O(n)$</li><li>空间复杂度(Space complexity): $O(1)$</li></ul><p>Submission status:</p><blockquote><p>代码提交运行时间: <code>0 ms</code>, 击败<code>100%</code>的<code>java</code>提交代码。</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在处理数组问题时，需要非常小心，时刻注意边界，避免发生数组越界问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。&lt;br&gt;链接:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/rotate-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/rotate-array/&lt;/a&gt;(中文)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://leetcode.com/problems/rotate-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/rotate-array/&lt;/a&gt;(en)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;示例 1:&lt;/p&gt;
&lt;p&gt;输入: [1,2,3,4,5,6,7] 和 k = 3&lt;br&gt;输出: [5,6,7,1,2,3,4]&lt;br&gt;解释:&lt;br&gt;向右旋转 1 步: [7,1,2,3,4,5,6]&lt;br&gt;向右旋转 2 步: [6,7,1,2,3,4,5]&lt;br&gt;向右旋转 3 步: [5,6,7,1,2,3,4]&lt;br&gt;示例 2:&lt;/p&gt;
&lt;p&gt;输入: [-1,-100,3,99] 和 k = 2&lt;br&gt;输出: [3,99,-1,-100]&lt;br&gt;解释:&lt;br&gt;向右旋转 1 步: [99,-1,-100,3]&lt;br&gt;向右旋转 2 步: [3,99,-1,-100]&lt;br&gt;说明:&lt;/p&gt;
&lt;p&gt;尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。&lt;br&gt;要求使用空间复杂度为 O(1) 的原地算法。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://rovo98.github.io/categories/Leetcode/"/>
    
    
      <category term="leetcode-array-easy" scheme="http://rovo98.github.io/tags/leetcode-array-easy/"/>
    
  </entry>
  
</feed>
