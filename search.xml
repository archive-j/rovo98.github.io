<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JDK, JRE, JVM | 深入了解]]></title>
    <url>%2Fposts%2F12448424%2F</url>
    <content type="text"><![CDATA[了解JDK, JRE, JVM之间的区别，JVM是如何工作的？什么是类加载器(class loaders), 解释器(interpreter)和及时编译器(JIT compilers) 1. Java程序的执行在开始之前，让我们快速的回顾一下一个Java程序是如何执行的 使用一个编辑器或者IDE(integrated development enviroment, 如Eclipse或Intellij Idea)编写Java源代码，假设是Simple.java文件； 程序需要编译成字节码(bytecode)。使用Java编译器(javac)将源代码文件编译成Simple.class文件； 在任意平台(e.g.Mac, Windows, Linux)上的JVM(java virtual machine)执行.class文件； JVM将字节码翻译成本机机器码(native machine code), 能够让本机执行。 2. 什么是JVM ?Java virtual machine(JVM) 是用于运行字节码的虚拟机。我们通过将Java源代码文件编译成.class字节码文件，之后由JVM执行。这也是为什么Java具有WORA(Write Once Run Anywhere)特性的原因。 在现实世界中，JVM是一种规范(specification)，它提供一种使Java字节码能够执行的运行环境(runtime environment)。不同的供应商这个规范的不同实现，例如：这个wiki页面列出的就是JVM的不同实现。 最流行的JVM实现是由Oracle Corporation拥有和提供的Hotspot。 JVM使用了许多的先进技术为Java应用程序提供最佳性能，包括先进的内存模型(memory model)，垃圾收集器(garbage collector)和自适应优化器(adaptive optimizer)。 JVM提供两种不同的版本 - 客户端(-client)和服务器(-server)。尽管它们很类似，但是服务器版本JVM经过专门调整，能够最大限度地提高运行速度峰值，它适用于在服务器上长期执行的应用程序，这些应用需要的是尽可能快的运行速度，而不是快速启动或较小的运行时内存占用。开发者可以指定-client或者-server来选择想要的JVM。 JVM之所以说是虚拟(virtual)的, 是因为它提供的机器接口(machine interface)不依赖于底层的操作系统以及机器的硬件架构。 2.1 JVM 架构JVM可以分成三个主要的子系统(subsystem): 类加载子系统(Class Loader Subsystem) 运行数据区(内存区)(Runtime Data Area or Memory Area) 执行引擎(Execution Engine) 类加载子系统类加载子系统用于加载类文件(class file)。它的主要功能为: 加载(loading)、链接(linking)、初始化(initialization)。 1.加载(loading) 为了加载类文件，JVM提供了三种类加载器: Bootstrap, extension 和 application 类加载器; 当加载一个类文件时，JVM需要找出该类的依赖； 首先，bootstrap类加载器会在$JAVA_HOME/jre/lib目录下的rt.jar包中查找； 若有类文件未找到，extension类加载器会在$JAVA_HOME/jre/lib/ext目录下的类文件； 若仍有类文件未找到，application类加载器会搜索查找CLASSPATH环境变量下的所有类文件和jar包文件； 通过这些类加载找到的类文件会被加载，找不到的类文件则会抛出ClassNotFoundException异常。 Java中类加载器的加载采用了双亲委托机制(Delegation-Hierarchy principle)。 当一个类加载接收到加载类的请求时，首先会将加载任务委托给上一级类加载器，依次递归，直到最后的Bootstrap ClassLoader，若Boostrap ClassLoader找不到时，则会将加载请求委托给下一级的类加载器，依次递归，直到最后的Application ClassLoader，在此过程中，若类被找到则直接返回，找不到则最终会抛出一个java.lang.ClassNotFoundException的运行时异常。 使用这种机制的好处非常好理解，目的就是为了避免重复加载已有的类，提高效率，还有就是强制从最高一级开始逐级搜索类文件，确保核心基础类优先加载。 JVM触发类加载器去加载外部类的情况: 显示字节码指令集(new/getstatic/putstatic/invokestatic): 对应的场景是创建对象或者调用到类文件的静态变量/静态方法/静态代码块； 反射: 通过对象反射获取类对象时； 继承: 创建子类触发父类加载； 入口: 包含main方法的类首先加被加载。 2. 链接(linking)此过程分为三个阶段: 验证阶段(Verify): 字节码验证器(Bytecode verifier)会验证生成的字节码是否正确，验证不通过则会抛出验证； 验证阶段对于虚拟机的类加载机制来说，是一个非常重要但不一定是必要的阶段。如果所运行的全部代码都已经被反复使用和验证过，在实施阶段就可以考虑使用-Xverify:none参数来关闭大部分的类验证措施，从而缩短虚拟机类加载的时间。 准备阶段(Prepare): 为类中的静态变量(static variables)分配内存空间, 但还未初始化，也就是0或者null； 解析阶段(Resolve): 将方法区(Method Area)的所有符号引用(symbolic memory references)全部替换为直接引用(Direct Reference)符号引用(Symbolic Reference): 符号引用以一组符号来描述所引用的目标，符号引用可以是任何形式的字面量，符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经在内存中。直接引用(Direct Reference): 直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用与虚拟机实现的内存布局相关，同一符号引用在不同的虚拟机上翻译出来的直接引用一般都不相同，如果有了直接引用，那引用的目标必定已经在内存中存在。 3. 初始化(Initialization)作为类加载过程的最后一个阶段，它为所有的静态变量赋初值，并执行静态代码块(static blocks)。 JVM内存区域在一个Java程序执行时，JVM为它定了许多运行时数据区(runtime data areas)。 其中一些数据区在JVM启动的时候创建，并在JVM退出的时才会销毁(Destroy)。其余的数据区是每个线程(Thread)各自都有的，在线程创建的时候创建，线程退出的时候销毁。 在上面给出的JVM架构图就可以看到, 方法区(Method Area)、堆区(Heap Area)、本地方法区(Native Method Area)是随JVM启动而创建的(一个JVM只能有一个)； 栈区(Stack Area)和程序计数寄存器(PC Registers)是每个线程都有的，随线程创建而创建，销毁而销毁。 方法区域(Method Area): 方法区存放类的结构数据，如运行常量池(runtime constant pool), 字段和方法数据，方法的代码，方法也包括类(class)、实例(instance)和接口初始化(interface initialization)的方法。方法区在逻辑上实际是堆(heap)的一部分，但是不能被垃圾收集器收集，尽管垃圾收集在堆上是强制执行的。方法区的大小可以是固定的，或者可以根据需求进行扩展或缩小，且并不要求方法区的内存是连续的。如果方法区的内存无法满足分配请求，JVM会抛出一个OutOfMemoryError。 堆区域(Heap Area): 存放程序执行创建的所有对象，堆中存放的对象会有Garbage Collection来管理回收，堆的大小可以是固定，也可以动态大小的(取决系统的配置)，并且为堆分配的内存不需要是连续的。如果自动存储管理系统(automatic storage management system)管理的堆内存空间无法满足分配需求，JVM会抛出一个OutOfMemoryError。因为多个线程(multiple threads)共享方法区域和堆区域，所以数据的存储不是线程安全(thread-safe)的。 栈区域(Stack Area): 每个线程均有一个独立的栈。对于每个方法的调用，都会在栈中创建一个条目(entry), 称为栈帧(Stack Frame); 所有的局部变量(local variables or thread-local variables)也会在栈内存中创建。栈区域是线程安全的，因为它不是共享资源。栈帧可以分为三种子实体(subentities): 局部变量数组(Local Variable Array): 与方法相关的局部变量，它们相应的值将存放在这里； 操作数栈(Operand stack): 如果需要执行任何中间操作时，操作数栈充当执行操作的运行时工作区(runtime workspace)； 帧数据(Frame data): 对应方法的所有符号(Symbols)均存放在这里。在任何异常的情况下，捕获的块信息将保留在帧数据中。 如果线程执行过程中，对栈区域的内存需求无法得到满足, JVM会抛出一个StackOverflowError异常； 若栈区域内存允许动态扩展，如果内存不足以实现扩展，或者当内存无法满足新创建线程的需求时，JVM会抛出一个OutOfMemoryError异常。 程序计数器(PC Registers): 存放当前执行语句的物理内存地址，每个线程都有一个独立的程序计数器。 本地方法栈(Native Method stacks): 存放本地方法(native method),信息，每个线程创建时，对应的本地方法栈也会创建。 当本地方法栈无法满足一个线程执行时的需求时，JVM 会抛出一个StackOverflowError异常； 本地方法栈的大小可以是固定也可以是动态的，当扩展本地方法栈时或者为一个新的线程创建一个初始化的本地方法栈时，若内存需求无法得到满足，JVM会抛出OutOfMemoryError异常。 执行引擎存放到JVM内存区(Memory Area)或运行数据区(Runtime Data Area)中的字节码将由执行引擎(Execution Engine)执行。它使用两个内建的解释器(inbuilt interpreter)和一个及时编译器(JIT compiler)来将字节码转换成机器码，并执行。 不同平台有不同的解释器 在JVM中，解释器和编译器都生成本地代码(native code),但它们生成代码的方式不同，代码优化也不同。 解释器(Interpreter):JVM解释器根据预先定义好的JVM指令到机器指令的映射，将每一条字节码指令都转换成对应的本地指令(native instruction)。并且在没有对代码进行任何优化的情况下，直接执行。解释器解释代码速度快；但是执行慢(代码未优化)，且对于重复的方法调用，每次都需要重新做解释再执行。 JIT 编译器(JIT compiler):为了提高性能，JIT 编译器会将合适的字节码序列(如上面提到的重复方法调用代码，以及其他的重复代码)编译成本地机器码，这些本地机器码可以被重复使用，以此来提高系统的性能。JIT编译器由四个部分组成: 中间代码生成器(Intermediate Code Generator): 用于生成中间代码； 代码优化器(Code Optimizer): 用于优化上面生成的中间代码； 目标代码生成器(Target Code Generator): 生成本地机器码； 配置器(Profiler): 一个特殊的部分，用于查找hotspot中的方法是否多次执行。 垃圾收集器(Garbage Collector): 收集和清除那些不可达对象(unreferenced objects or dead objects)。 [补充:] 解释执行: 将高级语言编写的代码一条一条读取，解释成等价的低级语言代码并在对应的低级虚拟机上执行，在读取解释下一条代码，直到全部代码解释执行完毕。 编译执行: 将所有的由高级语言编写的程序进行编译(转换成能够实现等价功能的低级语言程序)，并在低级虚拟机上执行。 (JIT, Just-in-time)及时编译: 结合解释执行和编译执行的特点，它编译一部分代码，执行，再继续编译执行(不是一次性编译)。 计算机体系结构中将计算机系统按功能划分层次结构: 第6级(虚拟机) -&gt; 应用语言机器第5级(虚拟机) -&gt; 高级语言机器第4级(虚拟机) -&gt; 汇编语言机器第3级(虚拟机) -&gt; 操作系统机器第2级(物理机) -&gt; 传统机器语言机器第1级(物理机) -&gt; 微程序机器 翻译(Translation): 先用转换程序把高一级机器上的程序转换为低一级机器上的等效程序，然后再在该低级机器上运行，实现程序的功能。 解释(Interpretation): 是对于高一级机器上的程序的每一条语句或指令，都转成去执行低一级机器的一段等效程序. 执行完之后，再去高一级机器取下一条语句或指令，再进行解释执行，如此反复，知道解释执行完整个程序。在6级层次中，一般下面三层是用解释实现的，而上面三层是经常使用翻译的方式。 Java Native Interface(JNI)JNI处理本地方法库文件(Native Method Libraries)，为执行引擎提供需要的本地方法库文件。 Native Method Libraries存放执行引擎需要用到的本地方法库文件的一个集合。 3. 什么是JRE ?JRE(Java Runtime Environment, Java运行环境)一个包含一些库文件(jar包)、用Java编写的用于运行程序的组件和Java虚拟机的软件包。 为了运行任何Java程序，我们至少需要在我们的机器上安装JRE。 JRE绑定以下组件: Java HotSpot 客户端虚拟机需要用到的DLL动态链接库文件; Java HotSpot 服务端虚拟机需要用的DLL动态链接库文件; Java 运行环境用到的代码库文件(Code libiraries)、属性设置(property settings)以及资源文件(resource files)，例如: rt.jar和charset.jar; Java 扩展文件，例如: localedata.jar。 以及其他的安全管理用到的文件，applets使用的jar包等。 不同系统平台、64位和32位的系统拥有不同的JRE。 4. 什么是JDK ?JDK(Java Development Kit, Java 开发工具)，它包含JRE, 同时包含用于开发Java程序的工具。 下面列出的是JDK包含的一些重要的开发工具: appletviewer: 用于运行和调试Java applet 程序，不需要Web浏览器； apt: 注解处理工具(The annotation-processing-tool)； extchecker: 检测jar包冲突的工具； javadoc: 文档生成工具，可以根据源代码编写的注释自动生成文档； jar: 打包工具，用于将相关的类库打包成一个jar包文件，也可以用于管理jar包； jarsigner: jar包签名和验证工具； javap: class 类文件反编译器(class file disassembler)； javaws: JNLP程序 Java Web 启动器； JConsole: Java 监视和管理console； jhat: Java 堆分析工具； jrunscript: Java 命令行脚本 shell； jstack: 用于打印Java线程栈踪迹的工具； keytool: 操作keystore的工具； policytool: 策略(policy)修改和管理工具； xjc: Java API 的一部分，JAXB(XML Binding API), 接受XML模式(schema)并生成Java类。 和JRE一样，JDK也是平台独立的，需要为不同的机器下载不同的JDK。 5. JDK, JRE, JVM之间的区别基于上面的讨论，我们可以简单下面一个图来展示它们的关系: JRE = JVM + libraries to run Java application.JDK = JRE + tools to develop Java application. 简单来说，Java开发人员需要在机器上安装JDK来开发Java程序；如果我们只需要能够运行Java程序，则只在机器上安装JRE即可。 参考链接: https://dzone.com/articles/jvm-architecture-explained https://stackoverflow.com/questions/11547458/what-is-the-difference-between-jvm-jdk-jre-openjdk https://www.geeksforgeeks.org/jvm-works-jvm-architecture/]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GPG入门使用]]></title>
    <url>%2Fposts%2F7ea77913%2F</url>
    <content type="text"><![CDATA[引入 gpg is the OpenPGP part of the GNU Privacy Guard (GnuPG). It is a tool to provide digital encryption and signing services using the OpenPGP standard.gpg features: complete key management and all the bells and whistles you would expect from a full OpenPGP implementation. GnuPG(GPG) 是 基于OpenPGP(由RFC4880定义,也被称为PGP)的一个完整的和免费的实现.我们可以使用GPG来对我们的数据和通信进行加密(encrypt)和签名(sign), 它具有通用的密钥管理系统，以及各种公钥目录的访问模块. 我们可以很容易地使用GPG提供的命令行工具(当前它还提供不同平台下的图形界面工具frontends,以及库文件libraries)与其他的应用进行结合.同时还对S/MIME和SSH(Security Shell)提供支持. 本文使用环境为Linux命令行，掌握命令行，Window(Gpg4win)等其他客户端也很容易掌握。 安装GPG有两种安装方式。可以下载源码, 自己编译安装: 123./configuremakemake install 更方便的方式是直接安装编译好的二进制包: 12345678# Arch 环境sudo pacman -S gnupg# Debian / Ubuntu 环境sudo apt-get install gnupg# Fedora 环境yum install gnupg 安装完成后，键入下面的命令: 1gpg --help 如果屏幕显示GPG的帮助信息，就表示安装成功。 密钥管理在使用GPG进行加密和签名之前，我们应该清楚的知道，它还是一个优秀的密钥管理工具(key Manager). 可以使用gpg --list-keys查看当前管理的所有密钥. 生成密钥对使用gpg --gen-key或gpg --full-gen-key(设置完整的参数配置来生成密钥对) 以完整的生成密钥对为例,gpg --full-gen-key (1).选择加密的算法(默认RSA):12345678910gpg (GnuPG) 2.2.11; Copyright (C) 2018 Free Software Foundation, Inc.This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law.Please select what kind of key you want: (1) RSA and RSA (default) (2) DSA and Elgamal (3) DSA (sign only) (4) RSA (sign only)Your selection? (2).选择密钥的大小(默认2048位): 密钥的位数越大，对于防范暴力破解攻击就越安全,但是对于各种用途，使用默认的大小已经足够了，因为绕过加密比试图破解代价反而更少一些。此外，随着密钥大小的增加，加密和解密将变慢，较大的密钥位数可能会影响签名的长度。 12RSA keys may be between 1024 and 4096 bits long.What keysize do you want? (2048) (3). 配置密钥的失效时间(默认0, 永不失效) 123456789Please specify how long the key should be valid. 0 = key does not expire &lt;n&gt; = key expires in n days &lt;n&gt;w = key expires in n weeks &lt;n&gt;m = key expires in n months &lt;n&gt;y = key expires in n yearsKey is valid for? (0) Key does not expire at allIs this correct? (y/N) y (4). 配置用户信息 1234567891011GnuPG needs to construct a user ID to identify your key.Real name: aliceEmail address: alice@gmail.comComment: A Test caseYou selected this USER-ID: &quot;alice (A Test case) &lt;alice@gmail.com&gt;&quot;Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? # 最后确认信息，若需要修改可进行更新，按O确认 (5). 最后输入加密密码，完成密钥对的生成 查看当前的所有密钥对: 密钥的导出和导入导入公钥/私钥: 公钥和私钥的导入都是使用一样的命令gpg --import 1234#导入公钥gpg --import rovo98.pub# 导入私钥gpg --import rovo98.pri 导入公钥之后，应进行验证。GnuPG提供了功能强大的信任模型，不需要我们亲自验证导入的每一个公钥。但是一些公钥还是需要亲自进行验证的，下面简单了解一下如何对导入的公钥进行验证。 通过验证公钥的指纹，然后签名(Sign)公钥以将其证明为有效公钥来验证密钥。可以使用--fingerprint命令行选项快速查看公钥的指纹，但为了验证公钥，必须对其进行编辑。 编辑公钥示例: 123456789gpg --edit-key blake@cyb.orgpub 1024D/9E98BC16 created: 1999-06-04 expires: never trust: -/qsub 1024g/5C8CBD41 created: 1999-06-04 expires: never (1) Blake (Executioner) &lt;blake@cyb.org&gt;Command&gt; fprpub 1024D/9E98BC16 1999-06-04 Blake (Executioner) &lt;blake@cyb.org&gt; Fingerprint: 268F 448F CCD7 AF34 183E 52D8 9BDE 1A08 9E98 BC16 公钥的指纹验证需要通过公钥的所有者进行验证。可以通过电话或任何其他方式亲自完成，只要能够和公钥的真正所有者进行联系就行。如果获得指纹与公钥所有者的指纹相同，才可以确定我们得到是正确的公钥副本 检查指纹之后，最后进行公钥的签名(Sign)完成验证。由于公钥签名是公钥加密中的一个弱点，因此在进行签名验证之前，必须确保指纹验证是正确的。 1234567891011Command&gt;&gt; sign pub 1024D/9E98BC16 created: 1999-06-04 expires: never trust: -/q Fingerprint: 268F 448F CCD7 AF34 183E 52D8 9BDE 1A08 9E98 BC16 Blake (Executioner) &lt;blake@cyb.org&gt;Are you really sure that you want to sign this keywith your key: "Alice (Judge) &lt;alice@cyb.org&gt;"Really sign? 签名之后，可以检查公钥，以列出其上面的签名，并查看我们添加的签名。公钥上的每个用户ID都可以具有一个或多个自签名以及已经通过公钥验证的签名。 1234Command&gt; checkuid Blake (Executioner) &lt;blake@cyb.org&gt;sig! 9E98BC16 1999-06-04 [self-signature]sig! BB7576AC 1999-06-04 Alice (Judge) &lt;alice@cyb.org&gt; 导出公钥(Public key) 要将公钥发送给对应的用户之前，我们需要将密钥对的公钥导出，在GPG中使用gpg --export命令导出 1gpg --output alice.gpg --export alice@gmail.com 默认导出的文件是以二进制格式保存的，非常不方便进行传输，因此GPG还提供了--armor参数来指定以ASCII码形式导出。 1gpg --armor --output alice.gpg --export alice@gmail.com 导出私钥(Private key): GPG还支持导出私钥，不过是对所有的私钥进行导出，同样可以二进制格式或ASCII格式导出. 1gpg --export-secret-keys --armor 上传公钥公钥服务器是网络上专门储存用户公钥的服务器。send-keys参数可以将公钥上传到服务器。 1gpg --send-keys [用户ID] --keyserver [服务器域名] 使用上面的命令，你的公钥就被传到了服务器，然后通过交换机制，所有的公钥服务器最终都会包含你的公钥。 由于公钥服务器没有检查机制，任何人都可以用你的名义上传公钥，所以没有办法保证服务器上的公钥的可靠性。通常，你可以在网站上公布一个公钥指纹，让其他人核对下载到的公钥是否为真。fingerprint参数生成公钥指纹。 1gpg --fingerprint [用户ID] 从公钥服务器上获取公钥: 1gpg --receive-keys 获取到的公钥需要进行验证,参考上面提到的导入公钥的验证方式。 加密和解密文件在加密和解密文件时，公钥和私钥各自具有特定的作用。 公钥可以被认为是开放式保险箱。当通过公钥加密文件时，该文件被放入保险箱，安全关闭，并且组合锁经过多次旋转和组合。相对应的私钥是可以重新打开保险箱并检索文件的组合(组合锁组合)。换句话说，之后持有私钥的人才能恢复和使用相关公钥加密文件。 因此加解密过程应该是这样的，假设你要给alice发送加密信息，使用alice的公钥对信息进行加密，则alice可以使用她的私钥对加密信息进行解密，而当她向你发送加密信息，加密信息时使用的应该是你的公钥。 加密例子: 使用alice的公钥对sourceListforKali进行加密 1gpg --output sourceListforKali.en --encrypt sourceListforKali --recipient alice@gmail.com --recipient指定使用的公钥 解密: 1gpg --output sourceListforKali.de --decrypt sourceListforKali.en 输入之前创建该密钥对的密码就可以对文件进行解密。 我们还可以在不使用公钥的情况下，对文件进行加密，使用的是对称密码(symmetric chiper).使用--symmetric参数即可 手动输入加密密码即可。 1gpg --output sourceListforKali.gpg --symmetric sourceListforKali 签名(signatures)数字签名证明文档并为其加上时间戳。如果随后以任何方式修改了文档，则签名验证将失败。数字签名可以起到与手写签名相同的作用，并具有防篡改的额外好处。 例如：当你将文件签名并发布后，则接受到该文件的用户可以验证签名来查看文件是否被修改过。 创建和验证签名创建和验证签名使用公/私钥对的方式不同于加解密操作。使用签名者的私钥创建签名，使用相应的公钥验证签名。 使用数字签名的好处是一般情况下，签名人是确定的，除非签名者的私钥被泄露了。 使用--sign参数创建数字签名，例: 123456gpg --output doc.sig --sign docYou need a passphrase to unlock the private key foruser: "Alice (Judge) &lt;alice@cyb.org&gt;"1024-bit DSA key, ID BB7576AC, created 1999-06-04Enter passphrase: 签名的文件在签名之前会被进行压缩处理，并输出一个二进制格式的签名文件。根据给定的签名文件，可以检查签名或检查签名并恢复原始文件。 检查和验证签名使用--verify参数选项,验证签名并恢复原始文件使用--decrypt选项: 123gpg --output doc --decrypt doc.siggpg: Signature made Fri Jun 4 12:02:38 1999 CDT using DSA key ID BB7576ACgpg: Good signature from "Alice (Judge) &lt;alice@cyb.org&gt;" 一般情况下，数字签名多数应用于对互联网上的帖子post以及email进行签名。这种情况下，我们一般不希望对需要签名的文件进行压缩处理，因此可以使用--clearsign选项，在不修改文件的情况下，将文件以ASCII的形式包装在签名文件中。 123456789101112131415161718gpg --clearsign docYou need a passphrase to unlock the secret key foruser: "Alice (Judge) &lt;alice@cyb.org&gt;"1024-bit DSA key, ID BB7576AC, created 1999-06-04-----BEGIN PGP SIGNED MESSAGE-----Hash: SHA1[...]-----BEGIN PGP SIGNATURE-----Version: GnuPG v0.9.7 (GNU/Linux)Comment: For info see http://www.gnupg.orgiEYEARECAAYFAjdYCQoACgkQJ9S6ULt1dqz6IwCfQ7wP6i/i8HhbcOSKF4ELyQB1oCoAoOuqpRqEzr4kOkQqHRLE/b8/Rw2k=y6kj-----END PGP SIGNATURE----- 分离的、独立的签名文件(Detached signatures): 一个签名过的文件的用途一般是很少的。 其他用户必须从签名文件中恢复原始文档，即使使用未压缩处理的签名文件(Clearsigned)，也必须编辑签名文档以恢复原始文档。 因此，GPG还提供用于对文档创建分离签名第三种签名方法，该签名是单独的文件。使用--detach-sig选项创建分离签名。 1234567gpg --output doc.sig --detach-sig docYou need a passphrase to unlock the secret key foruser: "Alice (Judge) &lt;alice@cyb.org&gt;"1024-bit DSA key, ID BB7576AC, created 1999-06-04Enter passphrase: 通过此方法创建的签名，在验证时就需要同时使用签名和对应原文件: 1234gpg --verify doc.sig docgpg: Signature made Fri Jun 4 12:38:46 1999 CDT using DSA key ID BB7576ACgpg: Good signature from "Alice (Judge) &lt;alice@cyb.org&gt;" 更多以上就是GnuPG的简单入门使用，更多的可以详细阅读GnuPG提供的用户手册和文档. 例如: 我们可以在加密文件的同时对文件进行签名(使用三种签名方法的其中一种) 参看链接: https://www.gnupg.org/gph/en/manual.html https://futureboy.us/pgp.html]]></content>
      <categories>
        <category>Linux</category>
        <category>softwares</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记录一次linux系统迁移过程]]></title>
    <url>%2Fposts%2F3babee60%2F</url>
    <content type="text"><![CDATA[就在最近，终于为自己的电脑加装了固态。在装完固态之后，首先面临的问题就是如何将原先安装在机械硬盘上的linux系统迁移到固态上。还要考虑后续配置的问题。 本文主要讲述在迁移Linux系统到新的固态硬盘上所遇到的问题以及找到的相应的解决方法。 这里先给出系统迁移以及相关配置完成之后的机械硬盘和固态硬盘的简单测速对比: 引入拆开电脑，直接加装固态,顺便清清灰尘，换一下硅脂(ps: 这不知道是我第几次拆电脑了…,表示以后再也不买GPU风扇了，这已经是第二次失败的购买经历了(除非得到与原来匹配的风扇一致的风扇，不然我是不再换了). 清尘换硅脂: 加装固态和散热板: 关于固态如何购买挑选，需要很好的了解自己电脑能够支持的固态类型和市场所提供的固态类型，并综合各种因素才能做出最好的选择。这里我推荐几篇个人觉得不错的文章: https://www.laptopmag.com/articles/laptop-ssd-guide https://www.tomshardware.com/reviews/ssd-buying-guide,5602.html https://www.velocitymicro.com/blog/nvme-vs-m-2-vs-sata-whats-the-difference/ https://blog.csdn.net/u010109732/article/details/79032845 https://www.zhihu.com/question/48972075 https://www.pc841.com/article/20180914-92342_all.html https://www.techadvisor.co.uk/test-centre/storage/best-ssd-2018-3235200/ 以上推荐文章仅作为参考。 迁移系统准备进入原先的linux系统，对已经安装上的固态硬盘进行分区。因为我之前在没有固态之前，在机械硬盘上就已经安装了三个系统(win10, manjaro, kali),因此在分区时，我是考虑只把两个linux迁移到固态上，毕竟win10现在已经基本不使用了，并将机械硬盘上的EFI分区也迁移到固态上。分区这里，可以按照自己的需求对固态硬盘进行分区。 分区工具的选择，随意，哪个顺手用哪个，例如:gparted, fdisk, parted,还有各种桌面自带的分区工具。我是使用的是fdisk:例如:1sudo fdisk /dev/nvme0n1 这里我已经分好区了的，具体的操作在fdisk中进行: 123456789101112131415161718192021222324252627Generic d delete a partition F list free unpartitioned space l list known partition types n add a new partition p print the partition table t change a partition type v verify the partition table i print information about a partition Misc m print this menu x extra functionality (experts only) Script I load disk layout from sfdisk script file O dump disk layout to sfdisk script file Save &amp; Exit w write table to disk and exit q quit without saving changes Create a new label g create a new empty GPT partition table G create a new empty SGI (IRIX) partition table o create a new empty DOS partition table s create a new empty Sun partition table 例如创建EFI分区: 12345678910Command (m for help): nPartition number (2-128, default 2): 2 # 创建一个分区作为EFI分区First sector (xxxxx-xxxxxxxxxxx, default xxxxx): Last sector, +sectors or +size&#123;K,M,G,T,P&#125; (34-2047, default xxxxxxx): +200MCreated a new partition 2 of type &apos;Linux filesystem&apos; and of size 200 Mb.Command (m for help): t # 修改EFI分区的分区类型为EFI系统分区...# 最后保存设置Command (m for help): w 请注意先查看所执行的分区操作是不是你想要的再进行最后的保存设置 其他的分区创建类似EFI的创建，swap分区需要指定为Linux swap分区，作为linux数据分区的分区在创建时默认就是linux filesystem类型了，不需要更改，之后对创建的分区进行格式化:将EFI格式化为fat32，将linux数据分区格式化ext4； 先通过sudo fdisk -l或lsblk查看已经创建分区对应的设备名,例如:sudo fdisk -l: 123456789101112131415161718192021222324252627Disk /dev/nvme0n1: 238.5 GiB, 256060514304 bytes, 500118192 sectorsUnits: sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisklabel type: gptDisk identifier: 6D071E80-FF82-420B-A2D8-7A0BC4759F06Device Start End Sectors Size Type/dev/nvme0n1p1 34 262177 262144 128M Microsoft reserved/dev/nvme0n1p2 264192 673791 409600 200M EFI System/dev/nvme0n1p3 673792 9062399 8388608 4G Linux swap/dev/nvme0n1p4 9062400 428492799 419430400 200G Linux filesystem/dev/nvme0n1p5 428492800 500117503 71624704 34.2G Linux filesystemDisk /dev/sda: 931.5 GiB, 1000204886016 bytes, 1953525168 sectorsUnits: sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 4096 bytesI/O size (minimum/optimal): 4096 bytes / 4096 bytesDisklabel type: gptDisk identifier: D5CB68A7-96DA-4C61-84E2-61C98489BFF1Device Start End Sectors Size Type/dev/sda1 64 125829183 125829120 60G Microsoft basic data/dev/sda2 125829184 880802416 754973233 360G Microsoft basic data/dev/sda3 880803904 1596575151 715771248 341.3G Microsoft basic data/dev/sda4 1596575744 1953521663 356945920 170.2G Microsoft basic data lsblk 查看分好的磁盘分区: 12345678910111213NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINTsda 8:0 0 931.5G 0 disk ├─sda1 8:1 0 60G 0 part /run/media/rovo98/System├─sda2 8:2 0 360G 0 part /run/media/rovo98/Mshinoda├─sda3 8:3 0 341.3G 0 part /run/media/rovo98/Chester bennington└─sda4 8:4 0 170.2G 0 part /run/media/rovo98/LSRsr0 11:0 1 1024M 0 rom nvme0n1 259:0 0 238.5G 0 disk ├─nvme0n1p1 259:1 0 128M 0 part ├─nvme0n1p2 259:2 0 200M 0 part /boot/efi├─nvme0n1p3 259:3 0 4G 0 part [SWAP]├─nvme0n1p4 259:4 0 200G 0 part /└─nvme0n1p5 259:5 0 34.2G 0 part /run/media/rovo98/a002d542-c8c4-4c98-85af-8a4446dbaa1b 对特定的分区进行格式化,例如: 12345# 对于linux数据分区mkfs.ext4 /dev/nvme0n1p4mkfs.ext4 /dev/nvme0n1p5# EFI分区mkfs.fat /dev/nvme0n1p2 注意: 执行每条格式化命令前，必须确认指定的分区是否是你想要格式化的分区 做好这些准备之后，就可以进行系统的迁移了 系统迁移操作对于Linux系统，我们只需要知道Linux一切皆文件就行了。因此对于系统的迁移就变得简单了，可以使用dd,打包压缩然后解压缩，有关系统备份和恢复可以参看Arch wiki给出的:https://wiki.archlinux.org/index.php/System_backup.这里我是使用的是tar结合pigz(什么是pigz?)解压缩工具进行备份和恢复: 备份(打包压缩)1sudo tar --use-compress-program=pigz -cvpf /run/media/rovo98/Chester\ bennington/LP/GHOST/manjaro_backup_2018.10.7.tgz --exclude=/proc --exclude=/sys --exclude=/mnt --exclude=/run/media --exclude=/lost+found / 恢复到目标硬盘分区上(解包解压缩):先目标分区挂载到/mnt下，如:/mnt/manjaro 1mount /dev/nvme0n1p4 /mnt/manjaro 1sudo tar --use-compress-program=pigz -xvpf /run/media/rovo98/Chester\ bennington/LP/GHOST/manjaro_backup_2018.10.7.tgz -C /mnt/manjaro 完成后需要手动创建，上面打包压缩是排除的文件夹:/proc, /sys, /mnt, /run, /lost+found. 详细备份和恢复过程可以参考查看:Arch上的备份还原 修复Grub、fstab文件以及refind引导管理首先将/proc,/run,/dev,/sys重新挂载，让目标分区上的系统也拥有这些内容: 1234mount /proc /mnt/manjaro/procmount /sys /mnt/manjaro/sysmount /run /mnt/manjaro/runmount /dev /mnt/manjaro/dev 这些目录必须重新挂载，不然，当chroot切换进入目标系统之后，将无法获取一些系统信息，如：设备, 磁盘分区信息等. 在chroot到目标系统之前，需要挂载EFI分区到/mnt/manjaro/boot/efi（refind管理文件默认位置）下： 1mount /dev/nvme0n1p2 /mnt/manjaro/boot/efi chroot到目标系统中，进行之后的操作 1chroot /mnt/manjaro 更新fstab文件获取相应分区的UUID，以更新fstab文件和/etc/default/grub文件:blkid: 或 ls -l /dev/disk/by-uuid: 更新fstab文件: 主要修改挂载项以及对应的UUID，有关fstab文件的详细内容可以参考https://wiki.archlinux.org/index.php/Fstab 修复Grub 重新生成Grub 1sudo grub-install --target=x86_64-efi --efi-directory=/boot/efi --bootloader=Manjaro --recheck 更新Grub配置文件 123sudo update-grub或sudo grub-mkconfig -o /boot/grub/grub.cfg 注意：如果此过程中出现以下提示信息: EFI variables are not supported on this system. 需要先安装efibootmgr, dosfstools以及grub包，然后重新尝试重新生成Grub并更新其配置文件. 若仍出现该信息，则先退出chroot环境，并加载efivarfs模块: 1sudo modprobe efivarfs 然后再进入chroot环境，执行: 1mount -t efivarfs efivarfs /sys/firmware/efi/efivars 再重新生成Grub并更新Grub配置文件就好了。 参考链接:https://wiki.manjaro.org/index.php/Restore_the_GRUB_Bootloader 重新配置refind对之前的refind配置文件进行备份，保留主题文件themes及refind.conf就好了，其余的文件在执行refind-install时会自动生成. 12345678910111213141516# 已经生成过了的,打印信息如下ShimSource is noneInstalling rEFInd on Linux....ESP was found at /boot/efi using vfatFound rEFInd installation in /boot/efi/EFI/refind; upgrading it.Installing driver for ext4 (ext4_x64.efi)Copied rEFInd binary filesNotice: Backed up existing icons directory as icons-backup.Existing refind.conf file found; copying sample file as refind.conf-sampleto avoid overwriting your customizations.Keeping existing NVRAM entryrEFInd is set as the default boot manager.Existing //boot/refind_linux.conf found; not overwriting. 可以使用efibootmgr管理启动项，例如:efibootmgr查看当前所有的启动项，efibootmgr -Bb xxxx来删除不要的启动项，详细使用可以man efibootmgr来查看。 其中的windows系统启动项通过PE用UEFI引导修复生成即可(需要注意的是老旧的PE识别不了nvme固态)。 以上就是迁移Linux系统的完整过程了 遇到的问题在做完上面的所有操作，并将之前机械硬盘上的EFI分区等等(除Win10系统之外)都删除之后，重新启动进入固态盘上的系统，在Grub引导过程出现UUID=***************找不到的信息，经过查看之后发现，在Grub引导时居然没有挂载我那块nvme固态。 通过了解发现Grub2.2版本并不支持nvme的固态，可以使用安装bootloader来进行引导。PS: 但我Manjaro安装的Grub是2.3版本的，理论上是支持的。 参考链接: https://bbs.archlinux.org/viewtopic.php?id=209653 通过一番查找之后，终于找到了解决方法: 添加加载模块 sudo vim /etc/mkinitcpio.conf 123456...- MODULES = ""+ MODULES="nvme"... 更新mkinitcpio 123#参数说明，详细可以通过man查看-p, --preset presetBuild initramfs image(s) according to specified preset. This may be a file in /etc/mkinitcpio.d (without the .preset extension) or a full, absolute path to a file. This option may be specified multiple times to process multiple presets. 更新Grub 123sudo update-grub或sudo grub-mkocnfig -o /boot/grub/grub.cfg 再次重启之后，便可以成功进入系统了。 参考链接:http://blog.51cto.com/shenfly231/1918426, 若要安装bootloader也可以参考该链接。 SSD优化开启Trim功能关于什么是TRIM?： SSD TRIM is an Advanced Technology Attachment (ATA) command that enables an operating system to inform a NAND flash solid-state drive (SSD) which data blocks it can erase because they are no longer in use. The use of TRIM can improve the performance of writing data to SSDs and contribute to longer SSD life. 了解可以参考: https://searchstorage.techtarget.com/definition/TRIM，以及Arch wiki上的:https://wiki.archlinux.org/index.php/Solid_state_drive#TRIM Most SSDs support the ATA_TRIM command for sustained long-term performance and wear-leveling. A techspot article shows performance benchmark examples of before and after filling an SSD with data. As of Linux kernel version 3.8 onwards, support for TRIM was continually added for the different filesystems. See the following table for an indicative overview: 在使用Trim功能之前需要查看固态硬盘是否支持，否则可能造成数据丢失: 1lsblk --discard DISC-GRAN和DISC-MAX不为0则表示支持，详细查看上面的Arch Wiki给出的文章。 关于使用的Trim方式，我使用的Continuous TRIM(详见Arch Wiki)即在/etc/fstab文件的挂载项中添加参数discard123456- UUID=D942-EEB0 /boot/efi vfat defaults,noatime 0 2- UUID=67180790-92d0-48d3-8f00-448161019f2d swap swap defaults,noatime 0 2- UUID=e2708091-5a07-47a6-bc26-5fdaa044c5f3 / ext4 defaults,noatime 0 1+ UUID=D942-EEB0 /boot/efi vfat defaults,discard,noatime 0 2+ UUID=67180790-92d0-48d3-8f00-448161019f2d swap swap defaults,discard,noatime 0 2+ UUID=e2708091-5a07-47a6-bc26-5fdaa044c5f3 / ext4 defaults,discard,noatime 0 1 IO调度器选择一般来说，IO调度算法是为低速硬盘准备的，对于固态，最好是不使用任何IO调度器，或使用对硬盘干预程度最低的调度算法。 查看当前固态的IO调度器:可以看到我当前固态没有使用任何调度器，而机械硬盘使用的是bfq-sq. 修改IO调度器(临时的): 1echo noop &gt; /sys/block/sda/queue/scheduler 要永久生效则需要添加编写开机自启动脚本详见参考链接. 更多信息以及详细的内容可以参考下面给出的参考链接.参考链接: https://wiki.archlinux.org/index.php/Improving_performance#Storage_devices https://blog.codeship.com/linux-io-scheduler-tuning/ https://www.ibm.com/developerworks/cn/linux/l-lo-io-scheduler-optimize-performance/index.html 另外更多有关Linux VM性能调优的可以参考:https://lonesysadmin.net/tag/linux-vm-performance-tuning/]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>ssd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编译自己的Vim8.1]]></title>
    <url>%2Fposts%2F97c4fd12%2F</url>
    <content type="text"><![CDATA[最近换了Manjaro linux系统，发现通过系统pacman -S vim安装的无图形版本vim不支持clipboard功能。 本想看能不能通过某种方式，来扩展现有安装好的vim,但是通过google了解到：VIM is intended to be a portable editor that “just works” on all systems. By having the default version use the clipboard functionality, it will need to link against X11 libraries, and a separate version of VIM would need to be compiled for desktop versus server (no pre-installed X11/xorg) builds. This is why the vim and vim-gtk packages are provided. VIM旨在成为一个可在所有系统上“正常工作”的便携式编辑器。通过使默认版本使用剪贴板功能，它将需要链接到X11库，并且需要针对桌面与服务器（没有预安装的X11 / xorg）构建编译单独版本的VIM。这就是提供vim和vim-gtk软件包的原因。 虽然知道gvim带有支持clipboard的vim，但是我又不想装gvim。自己的系统又有X11库和 Xorg，所以决定自己编译一个vim. 注意： 对于没有X11和Xorg的需要在编译前配置好，否则编译会出错. 一、从github上获取vim的源码直接使用git clone vim仓库： 1git clone https://github.com/vim/vim.git vim_source 二、配置、编译并安装我的编译配置： 123456789101112131415161718192021make clean./configure \ --enable-cscope \ --enable-largefile \ --enable-multibyte \ --enable-mzschemeinterp \ --enable-xim \ --enable-tclinterp=dynamic \ --enable-perlinterp=dynamic \ --enable-python3interp=dynamic\ --enable-pythoninterp=dynamic \ --enable-rubyinterp=dynamic \ --enable-luainterp=dynamic \ --enable-gui=no \ --enable-fontset \ --enable-terminal \ --with-features=huge \ --with-x \ --with-compiledby=&quot;rovo98&quot; \ --with-python-config-dir=/usr/lib/python2.7/config-$(uname-m)-linux-gnu --with-python3-config-dir=/usr/lib/python3.7/config-$(uname -m)-linux-gnu 编译并安装: 1make &amp;&amp; sudo make install 编译配置的说明: 上面的参数中启用了对tcl、perl、python、ruby、lua的支持。同时为了使用系统的剪切板还启用了对X的支持， 安装位置默认是/usr/local下， 由--perfix=PREFIX参数指定。 更多详细可以使用./configure --help查看: 删除编译产生的中间文件 : 1make clean &amp;&amp; make distclean 成果: 为vim创建一个桌面图标: vim.desktop: 1234567891011[Desktop Entry]Name=Vim[compiled by rovo98]Version=8.1Exec=vim %fComment=Vim is a highly configurable text editor for efficiently creating and changing any kind of text.Icon=/usr/share/vim/vim81/src/vim.icoType=ApplicationMimeType=text/plain;Terminal=trueEncoding=UTF-8Categories=Utility; 把vim.desktop放到/usr/share/applications/下就行了。 现在可以享受你自己编译的vim了。 参考链接: https://vi.stackexchange.com/questions/13564/why-is-vim-for-debian-compiled-without-clipboard https://stackoverflow.com/questions/11416069/compile-vim-with-clipboard-and-xterm]]></content>
      <categories>
        <category>Linux</category>
        <category>softwares</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Arch linux系列 安装 haroopad markdown 编辑器]]></title>
    <url>%2Fposts%2F63e58ebb%2F</url>
    <content type="text"><![CDATA[Haroopad 是一个优秀的 Markdown 编辑器，是一个用于创建适宜 Web 的文档的处理器。使用 Haroopad 可以创作各种格式的文档，比如博客文章、幻灯片、演示文稿、报告和电子邮件等。Haroopad 在 Windows、Mac OS X 和 Linux 上均可用。它有 Debian/Ubuntu 的软件包，也有 Windows 和 Mac 的二进制文件。该应用程序使用 node-webkit、CodeMirror，marked，以及 Twitter 的 Bootstrap 。 Haroo 在韩语中的意思是“一天”。 本文主要介绍通过压缩包**.tar.gz的方式安装 Haroopad. 一、下载 Haroopad我们可以从官网直接下载我们需要的压缩包，官网地址: Haroopad官网地址 这里我选择的是linux binary 64 位的压缩包。 二、解压并安装Haroopad根据下载的压缩包格式进行解压： 例如 **.tar.gz格式 解压并放到/opt/目录下: 12345tar zxvf haroopad-v0.13.1.x64.tar.gz -C haroopadsudo cp -r haroopad /opt/tar zxvf data.tar.gztar zxvf control.tar.gz 把解压出来的 usr中的文件放到/usr/下： 1234sudo cp -r ./usr /# 执行 postinstchmod 755 postinstsudo ./postinst 三、修复桌面图标为haroopad 换一个合适的桌面图标: 1sudo vim /usr/share/applications/Haroopad.desktop 123456789101112[Desktop Entry]Name=haroopadVersion=0.13.1Exec=haroopadComment=The Next Document processor based on Markdown#Icon=haroopadIcon=/usr/share/icons/hicolor/128x128/apps/haroopad.pngType=ApplicationTerminal=falseStartupNotify=trueEncoding=UTF-8Categories=Development;GTK;GNOME; 四、配置Haroopad相关的Haroopad设置，可以打开 偏好设置进行配置: 到此，Haroopad 安装就完成了。 参考链接: https://www.jianshu.com/p/dba9acabf0a7]]></content>
      <categories>
        <category>Linux</category>
        <category>softwares</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Manjaro linux 安装与配置]]></title>
    <url>%2Fposts%2Fa1898ce2%2F</url>
    <content type="text"><![CDATA[Manjaro是一款基于Arch Linux、对用户友好、全球排名第一的Linux发行版。（排名数据源于DistroWatch，统计日期2018.08.22，时间段3个月。）在Linux圈，Arch的确是一个异常强大的发行版。它有3个无与伦比的优势： 滚动更新可以使软件保持最新； AUR软件仓库有着世界上最齐全的Linux软件（参考《一张列表展示ArchLinux系软件有多丰富——看哭百万Debian、RedHat系同学》）； 丰富的wiki和活跃的社区让所有问题都可以快速得到满意的答案。 相比于Arch linux, 不得感叹, 人生苦短,我用 Manjaro啊! 一、Manjaro的安装镜像下载官方网站：https://manjaro.org/get-manjaro/选择自己喜欢的桌面环境就好，目前官方支持包括xfce、kde、gnome三种桌面环境。而在官方的社区版本中提供更多桌面环境的支持，比如国产的deepin桌面环境 但是官方服务器在海外，所以我们也可以选择国内开源镜像进行下载清华大学开源镜像：https://mirrors.tuna.tsinghua.edu.cn/manjaro-cd/ 由于我基本都把上述的版本和一些社区版本安装过(出于各种原因&gt;_&lt;)，我建议是从官方网站下载最新的官方版本进行安装(好像清华大学源的镜像并不是最新的)，至于桌面环境的选择，看个人，我选择的是KDE(其实，桌面环境在安装之后也是可以换的)。 制作U盘启动盘manjaro官方提供的Manjaro User Guide手册里面介绍了使用 来制作镜像的方法许多方法，例如： Linux系统下，使用 dd命令来制作：sudo dd if=manjaro-xfce-17.1-stable-x86_64.iso of=/dev/sdc bs=4M, of指定烧录U盘的挂载位置; 在windows系统下使用烧录软件Rufus来进行烧录: [注意]： 烧录完成后，在进入Live系统前，需要对BIOS进行一些设置，关闭安全启动。之后即可顺利进入这个界面(至于BIOS vs UEFI的启动进入的Live系统的方式，详见手册。由于我安装的是多个系统，所以是GPT+UEFI引导): 安装系统进入启动菜单界面后，可以对一些基本的选项进行配置，如，时区，语言，键盘布局等。 具体的安装步骤请直接参考官网的Manjaro User Guide.pdf,这里主要说说安装系统时可能遇到的问题(我基本踩过的坑…)。 对于双显卡的电脑,特别是有Nvidia卡的: 在进入live系统之前,可以将Driver选项设置为no-free(让系统自动安装合适的闭源驱动),并在boot项那里按E编辑, 在boot那一行将nouveau.modeset=1设置为nouveau.modeset=0来禁用开源nouveau驱动,然后进入Live安装系统。但是,安装完系统后重启还有可能进不去桌面,可以尝试在Grub菜单启动界面按[E]编辑,找到quiet并在后面加入(注意空格): acpi_osi=! acpi_osi=&#39;Windows 2009&#39;或者acpi_osi=! acpi_osi=Linux acpi_osi=&#39;Windows 2015&#39; pcie_port_pm=off(很多硬件厂商的BIOS驱动都对Linux不友好(我的电脑就是这样的…)，无法顺利加载ACPI模块，而导致无法驱动独立显卡,acpi_osi=’Windows 2009’的意思是告诉ACPI模块，我是‘Windows 7’，别闹情绪了，赶紧工作吧。)接着按 F10 进入系统。顺利进入系统后,将这些内核启动参数配置永久生效(修改grub的配置文件):sudo vim /etc/default/grub在GRUB_CMDLINE_LINUX中添加参数:之后更新 grub文件:sudo update-grub或sudo grub-mkconfig -o /boot/grub/grub.cfg参考链接: https://forum.manjaro.org/t/a-start-job-is-running-for-livemedia-mhwd-script/3395/15 https://wiki.archlinux.org/index.php/Kernel_parameters https://www.kernel.org/doc/Documentation/admin-guide/kernel-parameters.txt 启动时出现的ACPI ERROR问题，很多都说是内核版本的原因，有尝试过添加内核启动参数acpi=off，启动正常进入系统，但键盘无法使用，所以这个提示ACPI错误的问题，由于不影响使用，可以不管(强迫症的可以再看看) 参考链接: https://forum.manjaro.org/t/acpi-error-during-boot/35125 屏幕亮度无法调节或异常的问题： Arch Wiki已经给出很详细的解决方法:链接: https://wiki.archlinux.org/index.php/backlight例如：开机亮度设置: vim /etc/rc.local:12345678910111213#!/bin/sh -e## rc.local## This script is executed at the end of the each multiuser runlevel.# Make sure that the script will "exit 0" on successs or any other value on error# # In order to enable or disable this script just change the execution bits.# # By default this script does nothing.echo 127 &gt;&gt; /sys/class/backlight/intel_backlight/brightnessexit 0 对于安装Manjaro系统出现的问题，大多数都可以在官方的论坛Manjaro Forum以及Manjaro Wiki，还有Arch Linux的Arch Wiki以及上找到解决方法。 二、Manjaro 配置简单说一下一些安装系统之后的一些常规配置。 配置更新源并更新系统 配置中国的mirrors： 1sudo pacman-mirrors -i -c China -m rank 在 /etc/pacman.conf中添加archlinuxcn源: 123[archlinuxcn]SigLevel= TrustedOnlyServer = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch 安装archlinuxcn-keyring: 1sudo pacman -S archlinuxcn-keyring 同步并更新系统； 1sudo pacman -Syyu 安装配置中文输入法 安装中文输入法和fcitx管理工具: 123sudo pacman -S fcitx-sougoupinyin # 输入法看个人sudo pacman -S fcitx-imsudo pacman -S fcitx-configtool 解决中文输入法无法切换问题: 添加文件~/.xprofile: 123export GTK_MODULE=fcitxexport QT_IM_MODULE=fcitxexport XMODIFIERS=&quot;@im=fcitx&quot; 重启即可。 配置Intel 和 Nvidia 双显卡切换Manjaro 提供了强大的硬件检测模块mhwd，可以很方便的安装各种驱动，要实现Intel 和 Nvidia 双显卡切换，我们需要安装video-hybrid-intel-nvidia-bumblebee nvidia闭源驱动和intel驱动的混合版bumblebee。对于之前安装系统是在Live启动菜单选择Driver=no-free的可以看看这个驱动是否已经安装：系统设置中的硬件设置:或 对于未安装的，这里提供一个最为简单的方式，直接在硬件设置中，右键安装即可，这样可以省去自己去添加用户组和开机启动，以及切换状态初始化 [注意：] 下面的这些依赖必须安装，否则会出现独立显卡无法正常工作的问题(fps跟集成显卡差不多)： 1sudo pacman -S virtualgl lib32-virtualgl 对于独立显卡的使用，可以使用bbswitch来进行切换开关，然后使用optirun来运行程序: 首先查看显卡的状态: lspci | grep -i nvidia(rev ff 表示关闭状态) 打开独立显卡，并进行测试，对比集成显卡的fps： 集成显卡 FPS: 打开独立显卡sudo tee /proc/acpi/bbswitch &lt;&lt;&lt; &quot;ON&quot;,测试FPS: 独立显卡设置 nvidia-settings 需要用optirun nvidia-setting -c :8才能打开: 使用 zsh 和 oh-my-zsh 配置终端我的 zsh 终端模拟器(theme: rjkirch_mod)： 基本配置过程： 查看系统安装了多少shell cat /etc/shells 查看当前shell : echo $SHELL 使用 chsh切换默认shell. 配置 zsh，直接使用oh-my-zsh来进行配置: Oh-my-zsh.zsh 主题可以自行按个人喜好配置，当然也可以随机(每次打开终端都随机选择一个主题). 插件推荐: (插件配置太多的话，会使shell启动速度变慢，适当就好) Autojump zsh-syntax-highlighting zsh-autosuggestions 总结Manjaro的安装和基本配置就到此结束。最后，简单说一下我安装此系统的缘由。在安装manjaro之前，我使用的是win10 LTSB 2016，之前接触过的的Linux发行版是CentOS, Unbuntu以及 kali， 前两者我不怎么想要，本来想直接换成kali，但是考虑到kali一般是作为一个工具来使用，并不适合我平时开发和日常使用，就再次寻找适合的Linux发行版，最后看上了Arch Linux，但是又因为Arch上手难度较高，退而求其次，选择了Manjaro。当然啦，Win10肯定是要保留的，Kali也是要的。 于是乎，在原先的GPT+UEFI引导方式的基础之上，我重新分配了我的磁盘，将原有的Win10系统盘缩小，把它当备用系统，Manjaro作为主要系统使用，而Kali只作为工具使用，其他的磁盘分区作为数据存放的分区，各个系统共用。 说明: 对于上面给出的分区方案仅供参考，例如: 对于Linux的swap分区(用于虚拟内存的置换)来说，由于系统启动时会对swap进行初始化，因此多个系统可以使用一个swap分区即可。只要配置UUID没错就行了，毕竟多系统主机每次也只能启动一个系统。。。 上面的分区旨在演示，基于GPT (GUID Partion Table 分区表(可以分128主要分区，而MBR(Master Boot Record)分区表只能是4个主要分区, 请自行了解两者的区别) 使用UEFI(Unified Extensible Firmware Interface)如何为安装多系统做准备。 然后使用 REfind来管理和引导系统: 对于Refind有兴趣的可以直接google或baidu了解一下，选择一个现有的主题然后自己稍微进行配置一下，就可以了。参考: http://www.rodsbooks.com/refind/ Arch Wiki 上关于refind的内容) 各个系统桌面 Win10 LTSB Manjaro(DE: KDE) Kali]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>manjaro</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爬取校内腾讯企业邮箱通信录]]></title>
    <url>%2Fposts%2Fe675b5d9%2F</url>
    <content type="text"><![CDATA[简单使用python request + re 爬取校内邮箱通信录(腾讯企业邮箱)的用户信息数据。 一、分析需要爬取的数据通过手动打开浏览器，正常访问网站，判断需要爬取的数据是静态还是动态数据，制定不同的爬取方案。 1. 静态/动态 数据类型判断登陆企业校内邮箱，可以看到需要获取的内容主要呈现在该页面: F12打开控制台，查看Elements，可以很容易发现，用户数据在目录节点没有展开的情况下，html文档中并不会包含我们需要的数据，当点击展开目录节点后，才能获取到数据。因此，可以判断，我们需要爬取的数据是动态生成的，可以初步认为是通过AJAX异步请求来从服务器端获取数据的。 2. 数据定位我们已经知道了需要爬取的数据是动态生成的，这时，同样F12打开控制台，到Network栏目下，查找类型为XHR(AJAX的请求链接)的请求链接，并按数据文件大小从到小排序，再次刷新页面，点击通讯录栏目，展开到具体的用户项，依次点击XHR以确定需要的数据是通过哪个链接获取的： 可以看到，请求链接格式为:https://exmail.qq.com/cgi-bin/laddr_biz?t=memtree&amp;limit={limit}&amp;partyid={pid}&amp;action=show_party&amp;sid={sid},参数有 - Argument Description t 取值不变,memtree，具体含义就不管了 limit 链接中取值:500,单次获取用户的最大数量，我们可以自己修改，再次发起请求来验证 partyid 变化值，为所属组的id,例如：学生 -&gt; 专业 -&gt; 院系学生所属专业partyid就是的专业的id,etc. action 在此链接中不变，取值:show_party sid 用户登陆后生成的sid值，访问过程中不变 通过上面的分析，我们可以知道，要获取所有学生的信息，主要是在获取所有的专业的id后，依次作为上面链接的partyid来发起请求即可。 尝试在html Elements文档中搜索，能够搜到相应的数据，但它也是动态生成的 - 继续在Network中将过滤类型设置为doc同时按文件大小排序，查找包含oPartyList的文件 - 到此，我们所有的分析任务已经结束了，接下来只需要编写相应的爬虫程序即可。 二、爬虫程序设计这里只是编写一个简单的爬虫程序，不使用IP代理，爬虫发起请求所需的sid通过用户自己登陆后手动获取，相应的cookie也是如此。 1. 获取所有专业的id上面分析提到的，要获取用户数据，主要是要先获取到用户所在的组idpartyid。 123456789101112131415161718192021def getAllPID(): """ 获取所有的专业id,作为用户的pid. """ sid = 'xxx' # 用户登陆后的sid all_parties_url = 'https://exmail.qq.com/cgi-bin/laddr_biz?action=show_party_list&amp;sid=&#123;sid&#125;&amp;t=contact&amp;view=biz'.format(sid=sid) cookies = dict(...) # cookie参数和值 request = request.get(all_parties_url,cookies=cookies) regexp = r'&#123;id:"(\S*?)", pid:"(\S*?)", name:"(\S*?)", order:"(\S*?)"&#125;' results = re.findall(regexp,text) all_parties_ids = [] # 所有pid all_parties_info = dict() # 所有组信息 root_party = None # 根通信组 for p in results: all_parties_id.append(p[0]) party = dict(id=item[0], pid=item[1], name=item[2], order=item[3]) all_parties_info[item[0]] = party if p[1] == 0 or p[1] == '0': root_party = party 2. 获取学生信息数据依次遍历pid列表，构造不同的pid不同的链接，来获取全部的通讯录内容。 1234567891011121314151617181920212223def getAllUserInfo(): ... 获取所有通讯录用户信息 ... all_user_info = [] # 用于保存所有用户数据信息 # 获取用户数据的链接 party_user_url = 'https://exmail.qq.com/cgi-bin/laddr_biz?t=memtree&amp;limit=&#123;limit&#125;'\ '&amp;partyid=&#123;pid&#125;&amp;action=show_party&amp;sid=&#123;sid&#125;' regexp = r'&#123;uin:"(\S*?)", pid:"(\S*?)", alias:"(\S*?)", sex:"(\S*?), pos:"(\S*?)", tel:"(\S*?)",'\ ' birth:"(\S*?)(\S*?)(\S*?)(\S*?)", slave_alias:"(\S*?)(\S*?)(\S*?)", department:"(\S*?)(\S*?)", mobile:"(\S*?)"&#125;' for pid in all_parites_ids: # 依次构造不同pid的请求链接 url = party_user_url.format(limit=limit, pid=pid, sid=sid) request = requests.get(url, cookies=cookies) text = request.text results = re.findall(regexp, text) for item in results: user = dict(uin=item[0], pid=item[1], name=item[2], alias=item[3], sex=item[4], pos=item[5], tel=item[6],birth=item[7], slave_alias=item[8], department=item[9], mobile=item[10]) all_user_info.append(user) 完整的程序，请移步到Github查看. 三、爬取结果]]></content>
      <categories>
        <category>Python</category>
        <category>python爬虫</category>
      </categories>
      <tags>
        <tag>Spider demo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决Github国内访问出现的问题]]></title>
    <url>%2Fposts%2F7e3029b3%2F</url>
    <content type="text"><![CDATA[主要通过修改hosts文件解决Github在国内访问不了、访问慢和页面加载异常的问题(没钱买vpn~)。 简单了解一下github, github是目前全球最大的男性同性交友网站(~滑稽~), 使用示例如下： 开个玩笑，回归正题。 为什么访问不了以及访问速度会很慢？GitHub在中国大陆访问速度慢的问题原因有很多，但最直接和最主要的原因是GitHub的分发加速网络的域名遭到DNS污染。 由于GitHub的加速分发CDN域名assets-cdn.github.com遭到DNS污染，导致无法连接使用GitHub的加速分发服务器，才使得中国大陆访问速度很慢。 如何解决DNS污染？一般的DNS问题都可以通过修改Hosts文件来解决，GitHub的CDN域名被污染问题也不例外，同样可以通过修改Hosts文件解决。 将域名解析直接指向IP地址来绕过DNS的解析，以此解决污染问题。 获取被污染域名的实际IP地址访问ipaddress.com,使用ip lookup 工具获得相关域名的ip地址。 例如： github.com 可以看到，我查出的域名ip地址为： 192.30.253.112 和 192.30.253.113 (任取一个即可) 修改host文件，在文件中添加一行：[注] ： windows的hosts文件位置为： C:/windows/system32/drivers/etc/hosts 1192.30.253.112 github.com 刷新dns缓存打开命令行cmd,输入如下命令： 1ipconfig /flushdns 此时再刷新页面即可。此时可以正常访问github，但是访问速度还是很慢，我们接着做优化。 Github 访问提速在hosts文件中继续加入，如下代码： 12345678910111213141516171819# GitHub Start192.30.253.112 github.com192.30.253.119 gist.github.com151.101.228.133 assets-cdn.github.com151.101.228.133 raw.githubusercontent.com151.101.228.133 gist.githubusercontent.com151.101.228.133 cloud.githubusercontent.com151.101.228.133 camo.githubusercontent.com151.101.228.133 avatars0.githubusercontent.com151.101.228.133 avatars1.githubusercontent.com151.101.228.133 avatars2.githubusercontent.com151.101.228.133 avatars3.githubusercontent.com151.101.228.133 avatars4.githubusercontent.com151.101.228.133 avatars5.githubusercontent.com151.101.228.133 avatars6.githubusercontent.com151.101.228.133 avatars7.githubusercontent.com151.101.228.133 avatars8.githubusercontent.com192.30.253.116 api.github.com# GitHub End 注意 : 这里域名对应的ip是通过dns查询工具查询得到的，你应当选择的是延时相对较小且比较稳定的ip。 例如，上面的151.101.228.133是对我来说较好的ip: 推荐的dns查询检测工具： DNS查询 - 在线工具 DNS检测|DNS查询-站长工具 你可对单个域名多查询几次，以挑选稳定且速度较快的ip。 快速地访问github再次刷新dns缓存后，你已经可以快速地访问github了。 参考：https://github.com/chenxuhua/issues-blog/issues/3]]></content>
      <categories>
        <category>tips</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PPP 点对点通信验证]]></title>
    <url>%2Fposts%2F28ff89ad%2F</url>
    <content type="text"><![CDATA[使用Cisco Packet Tracer7 (思科网络模拟器)验证ppp点对点通信。 实验内容使用packet Tracer 模拟两台路由器，进行点对点通信测试。 实验步骤配置路由器由于只需要验证点对点通信，对路由器的配置，相对比较简单，路由器之间使用的是serial DCE 串口线相连。 配置Router1的serial 2/0串口为ip: 11.0.0.1 mask: 255.0.0.0,并配置时钟频率为64000 1234567Router&gt; enableRouter# configure terminalRouter(config) # hostname RARA (config) # interface serial 2/0RA (config) # no shutdownRA (config-if) # ip address 11.0.0.1 255.0.0.0RA (config-if) # clock rate 64000 配置Router2的serial 3/0 串口为ip: 11.0.0.2 mask： 255.0.0.0 123456Router&gt; enableRouter# configure terminalRouter(config) # hostname RBRB (config) # interface serial 3/0RB (config) # no shutdownRB (config-if) # ip address 11.0.0.2 255.0.0.0 查看两个路由的串口状态： RA: RB: 可以看到，路由器这里点对点通信默认使用的HDLC(High Level Data Link Control, 面向比特的同步协议)协议。 HDLC情况下验证ping：11.0.0.1 ping 11.0.0.2: 11.0.0.2 ping 11.0.0.1: ping 测试成功。 配置RA,RB使用ppp协议，再做ping测试： 先配置RA 使用 ppp协议： 123RA # configure terminalRA (config) # interface serial 2/0RA (config-if) # encapsulation ppp 可以看到RA当前使用的是ppp写协议，LCP处于Closed,此时，路由器应当无法进行点对点通信。 配置RB使用ppp协议： 123RB # configure terminalRB (config) # interface serial 3/0RB (config-if) # encapsulation ppp 这时，可以看到RB也是使用了ppp协议，且LCP也处于Open状态，路由器之间可以进行通信。 给ppp协议添加authentication鉴别 先配置RA，使其开启ppp chap (Challenge Handshake Authentication Protocol), 给RB 添加身份验证 1234RA # config terminalRA (config) # username RB password passwordRA (config) # interface serial 2/0RA (config-if) # ppp authentication chap 此时，虽然RA和RB都是使用ppp协议，但是RA给RB添加了身份认证，而RB则没有，此时LCP处于Closed状态，它们之间无法进行通信。 配置RB, 添加对RA的身份验证： 1234RB # config terminalRB (config) # username RA password passwordRB (config) # interface serial 2/0RB (config-if) # ppp authentication chap 可以看到此时，LCP已经打开，路由器之间可以进行点对点通信。 实验结果通过该实验，简单地验证了ppp协议在点对点信道中的使用。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>ppp通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用ensp进行简单的路由器互连实验]]></title>
    <url>%2Fposts%2Fcc46ce96%2F</url>
    <content type="text"><![CDATA[使用ensp做华为AR1220路由进行简单的互连实验。 实验内容 路由器设置 手动设置静态路由 实验环境 华为路由器AR1220 主机 Serial设备连接串口线和Copper以太网和千兆以太网连接线 备注：所有实验设备均由ensp模拟。 路由连接实验设计整体设计结构如下： 1.其中分为六个不同的局域网； 12345678910111213141516171819192.168.11.0 网段 -&gt; 主机: 192.168.11.11 192.168.11.12 路由器AR6一个GigabitEthernet接口作为该网段的默认网关(192.168.11.1)192.168.12.0 网段 -&gt; 主机: 192.168.12.11 192.168.12.12 路由器AR4的一个GigabitEthernet接口作为该网段的默认网关(192.168.12.1)192.168.13.0 网段 -&gt; 主机: 192.168.13.11 192.168.13.12 192.168.13.13 路由器AR7的一个GigabitEthernet接口作为该网段的默认网关(192.168.13.1) 1.1.2.0 网段 -&gt; 路由器AR6和路由器AR7之间的接口1.1.1.0 网段 -&gt; 路由器AR6和AR4之间的接口1.1.3.0 网段 -&gt; 路由器AR6和AR7之间的接口 2.设备的连接： 除了路由器之间连接使用serial串口连接线外，其他均使用Copper连接线。 实验步骤配置各个局域网的ip及其网关 例如：192.168.11.0网段下的192.168.11.11主机： 配置 192.168.11.1作为192.168.11.0网段的网关： 所有主机经过配置后，他们应该可以ping通自己网段下的所有主机，如：192.168.11.12 ping 192.168.11.11 [需要注意的是]： 由于路由器互连时使用的是serial串口，所以路由器之间配置的是serial串口的ip。 例如：配置AR6的两个serial串口的接口ip为：1.1.1.1和1.1.2.1： 123456&lt;Huawei&gt; system-view[Huawei] inter serial 2/0/1[Huawei-Servial2/0/1] ip address 1.1.1.1 255.255.255.0[Huawei-Servial2/0/1] quit[Huawei] inter serial 2/0/0[Huawei-Serial2/0/0] ip address 1.1.2.1 255.255.255.0 各个路由器的静态路由：对于路由器AR6,我们希望所有目的网络为192.168.12.0的数据包都交付给AR4,即下一跳为1.1.1.2;所有目的网络为192.168.13.0的都交给AR7,下一跳为1.1.2.2： 123&lt;Huawei&gt; system-view[Huawei] ip route-static 192.168.12.0 255.255.255.0 1.1.1.2[Huawei] ip route-static 192.168.13.0 255.255.255.0 1.1.2.2 对于路由器AR4，所有目的网络为192.168.11.0的数据包交给AR6，下一跳为：1.1.1.1，目的网络为192.168.13.0的数据包交给AR7，下一跳为：1.1.3.1： 123&lt;Huawei&gt; system-view[Huawei] ip route-static 192.168.11.0 255.255.255.0 1.1.1.1[Huawei] ip route-static 192.168.13.0 255.255.255.0 1.1.3.1 对于路由器AR7， 所有目的网络为192.168.11.0的数据包都交给AR6，下一跳为：1.1.2.1，所有目的网络为192.168.12.0的数据包都交给AR4，下一跳为：1.1.3.2： 123&lt;Huawei&gt; system-view[Huawei] ip route-static 192.168.11.0 255.255.255.0 1.1.2.1[Huawei] ip route-static 192.168.12.0 255.255.255.0 1.1.3.2 经过以上对各个路由器的静态路由的配置后，我们可以通过1display ip routing-table 来查看各个路由器的路由表： AR6路由表： AR4路由表： AR7路由表： 测试实验结果使用任意一个局域网下的主机ping不同局域网下的主机： 192.168.11.11 ping 192.168.13.12 和 192.168.12.12: 192.168.12.11 ping 192.168.11.12 和 192.168.13.13: 192.168.13.11 ping 192.168.11.11 和 192.168.12.11： 由以上测试可以看出简单的路由器连接实验成功。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>路由器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7通过yum(yellow dog update modifier) 安装mysql5.7]]></title>
    <url>%2Fposts%2F86d29d2c%2F</url>
    <content type="text"><![CDATA[配置yum源1234# 下载mysql安装源包root @~&gt; wget http://dev.mysql.com/get/mysql57-community-release-el7-8.noarch.rpm# 安装mysql源root @~&gt; yum localinstall mysql57-community-release-el7-8.noarch.rpm 检查mysql源是否安装成功: 1root @~&gt; yum repolist enabled | grep "mysql.*-community.*" 如下图则安装成功: 安装mysql1root@ ~&gt; yum install -y mysql-community-server 启动MySQL服务并设置开机自动启动1root@ ~&gt; systemctl start mysqld 查看MySQL启动状态 12root@ ~&gt; systemctl enable mysqldroot@ ~&gt; systemctl daemon-reload 修改默认密码刚安装完的mysql会自动给root用户分配一个临时密码，而且必须重新设置密码(从5.5版本开始) 先查看root用户的临时密码 1root@ ~&gt; grep "temporary password" /var/log/mysqld.log 使用临时的密码登录进mysql来设置新的密码 1mysql&gt; set PASSWORD = PASSWORD('[YOUR_NEW_PASSWORD]') 可能遇到的问题：设置的密码过于简单mysql报错: 1Your password does not satisfy the current policy requirements. 解决方法：由于刚安装的mysql的密码默认强度是最高的，若想要设置简单的密码就要修改validate_password_policy的值， validate_password_policy有以下取值： Policy Tests Performed 0 or LOW Length 1 or MEDIUM Length;numeric,lowercase/uppercase,and special characters 2 or STRONG Length;numeric,lowercase/uppercase,and special characters; dictionary file 操作： 设置安全级别 1mysql&gt; set global validate_password_policy=0; 设置密码长度为8，可以设置为其他值，最小为4位 1mysql&gt; set global validate_password_length=4; 之后就可以设置简单的密码了。 允许root远程登录12mysql&gt; GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY '[YOUR_PASSWORD]' WITH GRANT OPTION;mysql&gt; flush privileges; 修改字符集编码为UTF-8 查看当前字符编码 1mysql&gt; show variables like "char%'; 检测是否都是utf-8(filesystem除外)，如果不是就需要修改。 character_set_server一般是lantin1。 12345678# 停止mysqld服务systemctl stop mysqld# 进入my.cnf文件，一般是/etc/路径下vim /etc/my.cnf# 在[mysqld]下追加character-set-server=utf-8# 在[mysql]下追加default-character-set=utf-8# 启动mysqldsystemctl start mysqld]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql5.7安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Union-Find -- 动态连通性问题算法]]></title>
    <url>%2Fposts%2Fb3f33dac%2F</url>
    <content type="text"><![CDATA[union-find算法主要用于解决动态连通性问题。 我们设计算法时面对的第一个任务就是精确地定义问题。为了说明问题，通常会设计一份API来封装所需的基本操作。 UF API根据Union Find 算法需求定义接口 - Method Description UF(int n) 以整数标识(0到n-1)初始化n个触点 int find(int p) p所在分量的标识符 void union(int p, int q) 在p和q之间增加一条连接 boolean connected(int p, int q) 如果p和q存在于同一个分量返回true int count() 连通分支的数量 此时，解决动态连通性问题设计算法的问题已经被我们转化为实现这份API。 定义一种数据结构表示已知的连接 基于此数据结构实现高效的union()、find()、connected()和count()方法 实现1234567891011121314151617181920public class UF &#123; private int[] parent; private int count; public UF(int n) &#123; parent = new int[n]; count = n; for (int i = 0; i &lt; n; i++) &#123; parent[i] = i; &#125; &#125; public int count() &#123; return count; &#125; public boolean connected(int p, int q) &#123; return find(p) == find(q); &#125; public int find(int p) ... public void union(int p, int q) ...&#125; 第一种实现方式: quick-find算法 这种实现方式保证当且仅当parent[p] == parent[q]时p和q是连通的。即在同一个连通分支的所有触点在parent[]中的值必须全部相同。 也意味着connected(p, q)只需要判断parent[p] == parent[q]，只有在p和q所在连通分支相同时返回true,否则p所在连通分支的所有触点对应parent[]中的值为一个值，而q所在连通分支的所有触点对应parent[]中的值为另一个值。因此我们在合并分量时需要遍历整个数组来将所有和parent[p]相等的元素变为parent[q]，或者反过来。由此实现的find()、union()方法如下： 123456789101112public int find(int p) &#123; return parent[p];&#125;public void union(int p, int q) &#123; int rootP = find(p); int rootQ = find(q); if (rootP == rootQ) return; for (int i = 0; i &lt; parent.length; i++) &#123; if (parent[i] == rootQ) parent[i] = rootP; &#125; count--;&#125; quick-find 算法分析 find() 操作速度显然是很快的，因为它只需要访问parent[]数组一次。但quick-find算法一般无法处理大型问题，因为对于每一对输入的触点 union()都需要扫描整个parent[]数组。可以看出此算法的时间复杂度应该为：$O(n^2).$ 命题F: 在quick-find 算法中，每次find() 调用只需要访问数组一次，而归并两个分量的union()操作访问数组的次数在$(N+3)$到$(2N+1)$之间。 第二种实现方式： quick-union算法该算法的重点是在于提高 union()方法的速度，它和 quick-find 都是基于相同的数据结构 —— 以触点为索引的 parent[] 数组，在此之上，我们用它们来定义更加复杂的结构。令每个触点所对应的 parent[] 元素都是同一个分量中的另一触点名称（也可能是它自己) — 这种联系称为链接。 在实现find()方法时，从给定的触点开始，由它的链接得到另一个触点，再由这个触点的链接到达第三个触点，直到随着链接到达根触点，链接指向自己的触点。而对于实现union()方法，只需有由p和q的链接分别去找它们的根触点，然后只需要将一个跟触点链接到另一个即可。由此实现的find()、union()方法如下： 12345678910111213public int find(int p) &#123; while (p != parent[p]) &#123; p = parent[p]; &#125; return p;&#125;public void union(int p, int q) &#123; int rootP = find(p); int rootQ = find(q); if (rootP == rootQ) return; parent[rootP] = parent[rootQ]; count--;&#125; quick-union 算法分析 在quick-union 中parent[]数组用父链接的形式表示的一片森林。quick-union 算法明显比quick-find 算法更快，因为它不需要为每一对输入遍历整个数组。 在最好的情况下，find()只需要访问一次数组就能得到一个触点所在的分量的标识符；而在最坏的情况下，需要$2N - 1$次数组访问。我们可以把quick-union看作是quick-find算法的改进。—— 它将union()操作改进为线性级别。 定义： 一棵树的大小是它的节点的数量。树中的一个节点的深度是它到根节点的路径的链接数。树的高度是它的所有节点的最大深度。 命题G: quick-union 算法中的 find() 方法访问数组的次数为1 加上给定触点所对应的节点的深度的两倍。union() 和 connected() 访问数组的次数为两次 find()操作 （如果 union() 中给定的两个触点分别存在于不同的树中则还需要加 1). 由命题G我们可以知道算法在最坏的情况下的运行时间是平方级别的。例如：输入的整数对为$0-1、0-2、0-3$等，$N-1$ 对之后，$N$ 个触点将全部处于相同的集合之中且由quick-union算法得到的树的高度为 $N-1$, 其中0链接到2, 2链接到3，如此下去。由命题G可知，对于整数对 $0 - i$, union() 操作访问数组的次数为$2i + 2$ （触点0的深度为i, 触点 i 的深度为 0）。 处理 N 对整数所需的所有 find() 操作访问数组的总次数为 $2(1+2+…+N)~N^2$。 第三种实现方式： 加权quick-union算法改进quick-union算法，不再随意在union()中将一棵树连接到另一颗树，而是记录树的大小(节点个数)或高度并总是将较小的树连接到较大的树上。 记录树的大小(节点个数)加权 1234567891011121314151617181920212223242526272829303132333435public class UF &#123; private int[] parent; private int[] rank; private count; public UF(int n) &#123; parent = new int[n]; rank = new int[n]; count = n; for (int i = 0; i &lt; n; i++) &#123; parent[i] = i; rank[i] = 1; &#125; &#125; public int find(int p) &#123; while (p != parent[p]) &#123; parent[p] = parent[parent[p]]; // 路径压缩 p = parent[p]; &#125; return p; &#125; public void union(int p, int q) &#123; int rootP = find(p); int rootQ = find(q); if (rootP == rootQ) return; // 将较小的树连接到较大的树上 if (rank[rootP] &gt; rank[rootQ]) &#123; parent[rootQ] = rootP; rank[rootP] += rank[rootQ]; &#125; else &#123; parent[rootP] = rootQ; rank[rootQ] += rank[rootP]; &#125; count--; &#125;&#125; 记录树的高度 1234567891011121314151617181920212223242526272829303132333435363738public class UF &#123; private int[] parent; private byte[] rank; private count; public UF(int n) &#123; parent = new int[n]; rank = new byte[n]; count = n; for (int i = 0; i &lt; n; i++) &#123; parent[i] = i; rank[i] = 0; &#125; &#125; public int find(int p) &#123; while (p != parent[p]) &#123; parent[p] = parent[parent[p]]; p = parent[p]; &#125; return p; &#125; public void union(int p, int q) &#123; int rootP = find(p); int rootQ = find(q); if (rootP == rootQ) return; // 将高度较低的树连接到高度较高的树上 if (rank[rootP] &gt; rank[rootQ]) &#123; parent[rootQ] = rootP; &#125; else if (rank[rootP] &lt; rank[rootQ]) &#123; parent[rootP] = rootQ; &#125; else &#123; parent[rootQ] = rootP; rank[rootP]++; &#125; count++; &#125;&#125; 加权quick-union 算法分析 命题H: 对于 $N$ 个触点，加权 quick-union 算法构造的森林中的任意节点的深度最多为 $lgN$。 推论: 对于加权 quick-union 算法和 N 个触点， 在最坏的情况下 find()、 connected() 和 union() 的成本的增长数量级为 $log N$。 union-find 的具体实现: 查看]]></content>
      <categories>
        <category>Algorithms</category>
        <category>Union Find</category>
      </categories>
      <tags>
        <tag>union-find</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基本查找算法 - basical searching algorithms]]></title>
    <url>%2Fposts%2Fd83777d2%2F</url>
    <content type="text"><![CDATA[引入基本查找算法，我们只谈静态查找的查找算法。 线性查找 - linear search特点： 从头开始遍历数组，一个一个和key比较，查找成功则返回索引值。 不要求数组是有序的。 时间复杂度为： $O(n)$. 线性查找原始抽象方法实现如下:1234567public static int linearSearch(Comparable[] a, Comparable key) &#123; for (int i = 0; i &lt; a.length; i++) &#123; if (a[i].compareTo(key) == 0) return i; &#125; return -1;&#125; 跳跃查找 - jump search特点： 要求查找数组有序； 主要思想是每次跳跃固定量的元素来确定目标元素所在的区间，再使用线性查找在区间上搜索目标元素。 时间复杂度为： $O(\sqrt{n})$. [notice] : 假设我们要在一个有n个元素的数组中搜索某个元素，最坏情况下（当目标元素为最后个元素时），这个算法要跳跃n/m步，在线性搜索时作m-1次比较。令 $f(n) = ((n/m) + m-1$.当m = $\sqrt{n}$时，f(n) 取最小值，所以通常情况下，跳跃查找所使用的固定跳跃步数为 $\sqrt{n}$. 跳跃查找的原始抽象方法实现如下：1234567891011121314151617181920212223public static int jumpSearch(Comparable[] a, Comparable key) &#123; int n = a.length; int block_size = Math.floor(Math.sqrt(n)); int step = block_size; // 查找目标元素可能出现的区间 int prev = 0; while (a[Math.min(step, n) - 1].compareTo(key) &lt; 0) &#123; prev = step; step += block_size; if (prev &gt;= n) return -1; &#125; // 使用线性查找在确定的区间上查找目标元素 while (a[prev].compareTo(key) &lt; 0) &#123; prev++; if (prev == Math.min(step, n)) return -1; &#125; if (a[prev].compareTo(key) == 0) return prev; return -1;&#125; 二分查找 - binary search 要求数组有序。 将已经排好序的数组分为两个区间(interval), 把区间的中间元素与key比较, 若大于则搜索左区间，若小于则搜索右区间，等于则返回元素的索引。当区间长度为0时（key没出现在数组中),返回-1。 时间复杂度为 ： $O(nlogn)$. 二分查找原始抽象方法实现如下:12345678910111213141516171819202122232425262728// 非递归实现public static int binarySearch(Comparable[] a, Comparable key) &#123; int lo = 0; int hi = a.length - 1; while (lo &lt;= hi) &#123; int mid = lo + (hi - lo) / 2; if (a[mid].compareTo(key) == 0) return mid; else if (a[mid].compareTo(key) &gt; 0) hi = mid - 1; else lo = mid + 1; &#125; return -1;&#125;// 递归实现public static int binarySearchRecursion(Comparable[] a, Comparable key, int lo, int hi) &#123; if (lo &lt;= hi) &#123; int mid = lo + (hi - lo) / 2; if (a[mid].compareTo(key) == 0) return mid; else if (a[mid].compareTo(key) &lt; 0) return binarySearchRecursion(a, key, mid+1, hi); else return binarySearchRecursion(a, key, lo, mid-1); &#125; return -1;&#125; 三分查找 - ternary search特点： 三分查找是二分查找的扩展； 时间复杂度为 ： $O(nlog_3n)$. [notice]: 虽然看似三分查找的时间复杂度比二分查找的时间复杂度小，但是在最坏情况下，二分查找需要$2Log2n + 1$次比较，而三分查找需要$4Log{3}n + 1$次比较 三分查找原始抽象方法实现如下：特点： 类似二分查找，将查找数组划分为三个部分来进行查找； 时间复杂度： $Log_3n$. 12345678910111213141516171819202122// 递归实现.public static int ternarySearch(Comparable[] a, Comparable key, int lo, int hi) &#123; if (lo &lt;= hi) &#123; int mid1 = lo + (hi - lo) / 3; int mid2 = mid1 + (hi - lo) / 3; if (a[mid1].compareTo(key) == 0) return mid1; if (a[mid2].compareTo(key) == 0) return mid2; // 目标元素只可能出现在第一部分. if (a[mid1].compareTo(key) &gt; 0) return ternarySearch(a, key, lo, mid1-1); // 目标元素只可能出现在第三部分. if (a[mid2].compareTo(key) &lt; 0) return ternarySearch(a, key, mid2+1, hi); // 目标元素只可能出现在第二部分. return ternarySearch(a, key, mid1+1, mid2-1); &#125; // 查找失败. return -1;&#125; 指数搜索 - exponential search特点： 找到目标元素可能出现的区间； 使用二分查找在区间上查找目标元素; 时间复杂度： $logn$; [notice]: 适用于目标数组元素大小趋向于无限大的情况； 当目标出现在目标数组左边时，指数搜索速度比二分查找快。 12345678public static int exponentialSearch(Comparable[] a, Comparable key) &#123; int n = a.length; int i = 1; while (i &lt; n &amp;&amp; a[i].compareTo(key) &lt; 0) &#123; i = i * 2; &#125; return binarySearch(a, key, i/2, Math.min(i, n-1));&#125; 插值搜索 - interpolation search特点： 原理： 假设查找数组的元素是均匀分布的，使用直线插值搜索，不像二分查找那样每次都是搜索区间中间元素。它能够快速的接近目标元素。 当元素均匀分布的情况，时间复杂度为: $O(log(log n))$, 最坏情况: $O(n)$. 12345678910111213141516// java program to implement interpolatoin search.public static int interpolationSearch(Comparable[] a, Comparable key) &#123; int lo = 0; int hi = a.length - 1; while (lo &lt;= hi &amp;&amp; less(key, a[hi]) &amp;&amp; less(a[lo], key)) &#123; int pos = lo + (hi - lo) * (key - a[lo]) / (a[hi] - a[lo]); if (a[pos].compareTo(key) == 0) return pos; else if (a[pos].compareTo(key) &gt; 0) hi = pos - 1; else lo = pos + 1; &#125; return -1;&#125; NOTICE本文中，涉及的算法详细实现和使用，请移步到github查看。]]></content>
      <categories>
        <category>Algorithms</category>
        <category>searching algs</category>
      </categories>
      <tags>
        <tag>basical searching algs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速排序 - quickSort]]></title>
    <url>%2Fposts%2Fd9de8e4c%2F</url>
    <content type="text"><![CDATA[引入快速排序的主要特点是： 原地排序 (in-place); 将长度为 N 的数组排序所需的时间和NlgN成正比； 排序内循环比大多数排序算法都要短小，意味着无论是在理论上还是实际中都要更快。 缺点： 快速排序非常的脆弱，在实现时要非常小心才能避免低劣的性能。 基本算法快速排序是一种分治排序算法，它将一个数组分成两个子数组，将两部分独立地排序。不同于归并排序，快速排序的递归调用发生在处理子数之前。 快速排序方法抽象实现如下： 12345678910111213141516171819202122232425262728293031public class Quick &#123; // quick sort java implement. public static void quickSort(Comparable[] a) &#123; sort(a, 0, a.length-1); assert isSorted(a); &#125; private static void sort(Comparable[] a, int lo, int hi) &#123; if (hi &lt;= lo) return; int j = partition(a, lo, hi); sort(a, lo, j-1); sort(a, j+1, hi); &#125; private static void partition(Comparable[] a, int lo, int hi) &#123; int i = lo; int j = hi + 1; Comparable v = a[lo]; while (true) &#123; while (less(a[++i], v)) &#123; if (lo == hi) break; &#125; while (less(v, a[--j])) &#123; if (j == lo) break; // redundant since a[lo] is sentinel. &#125; // Check if pointers cross. if (j &lt;= i) break; exch(a, i, j); &#125; exch(a, lo, j); return j; &#125;&#125; 上述切分方法示意图: [from algs4] 切分轨迹图: [from algs4] 命题 K： 将长度为N的无重复的数组排序，快速排序平均需要 ~ $2NlnN$ 次比较(以及$1/6$的交换) [notice]: 尽管快速排序有很多优点，它的基本实现仍有一个潜在的缺点： 在切分不平衡时该算法可能及其低效。例如： 如果第一个次从最小的元素切分，第二次从第二小的元素切分，则这样每次只会移除一个元素。[solution] : 在快速排序之前将数组随机排序可以避免这种情况的发生。 算法改进1.切换到插入排序和大多数递归排序算法一样(如归并)，改进快速排序的简单方法基于以下两点： 对于小数组，快速排序比插入排序慢； 以为递归，快速排序的sort()方法在小数组中也会调用自己。 改进 ： 将sort()方法中的 1if (hi &lt;= lo) return; 改为： 1234if (hi &lt;= lo + M) &#123; insertion.sort(a, lo, hi); return;&#125; [notice] : 这里的切换参数 M 的最佳值是和系统相关的，但是5 ~ 15 之间的任意值在大多数情况下都能令人满意。 2. 三取样切分改进快速排序性能的第二个方法是使用子数组的一小部分的中位数来切分数组。这样的切分的效果更好，但代价是需要计算中位数。 人们发现将取样设为 3 并用大小居中的元素切分效果最好； 我们还可以将取样元素放在数组末尾作为哨兵(sentinel)。 三取样切分抽象实现 : 详细查看 1234567891011121314151617181920212223242526272829303132333435363738public static void quickSortImproved(Comparable[] a) &#123; sort(a, 0, a.length-1); assert isSorted(a);&#125;private staic void sort(Comparable[] a, int lo, int hi) &#123; dealPivot(a, lo, hi); int i = lo; int j = hi - 1; Comparable v = a[hi - 1]; // set the pivot at hi -1 as a sentinel. while (true) &#123; while (less(a[++i], v)) &#123; if (i == hi-1) break; // redundant since a[hi - 1] is sentinel. &#125; while (j &gt; lo &amp;&amp; less(v, a[--j])) &#123; &#125; // check if pointers cross. if (j &lt;= i) break; exch(a, i, j); &#125; if (i &lt; hi-1) &#123; exch(a, i, hi - 1); &#125; sort(a, lo, i - 1); sort(a, i + 1, hi);&#125;// 三取样并将切分元素放在数组末尾private static void dealPivot(Comparable[] a, int lo, int hi) &#123; int mid = lo + (hi - lo) / 2; if (less(a[mid], a[lo])) exch(a, lo, mid); if (less(a[hi], a[lo])) exch(a, lo, hi); if (less(a[hi], a[mid])) exch(a, mid, hi); // put the pivot to hi - 1 as a sentinel. exch(a, mid, hi - 1);&#125; 熵最优的排序实际应用中经常会出现含有大量重复元素的数组，我们实现的快速排序性能尚可，但是还有巨大的改进空间。例如：一个元素全部重复的子数组就不需要继续排序了，但我们的快速排序还是会继续将它切分为更小的数组。 [solution] : 一个简单想法是将数组切分为三个部分，分别为小于、等于和大于切分元素的数组元素。 DIjkstra 解法 ： 从左到右遍历数组一次，维护一个指针 lt 使得 a[lo .. lt-1]中的元素都小于v, 一个 gt 使得a[gt+1 .. hi]中的元素都大于v, 一个指针 i 使得a[lt .. i-1]中的元素都等于v, a[i .. gt]中的元素都未确定。 a[i] 小于 v, 将a[lt]和a[i]交换，将lt 和 i加一； a[i] 大于 v, 将a[gt]和a[i]交换， 将gt减一； a[i] 等于 v, i++. 熵最优排序抽象实现： 详细查看 123456789101112131415161718192021public static void quickSort(Comparable[] a) &#123; sort(a, 0, a.length-1); assert isSorted(a);&#125;private static void sort(Comparable[] a, int lo, int hi) &#123; if (hi &lt;= lo) return; Comparable v = a[lo]; int lt = lo; int i = lo + 1; int gt = hi; while (i &lt;= gt) &#123; if (less(a[i], v)) exch(a, i++, lt++); else if (less(v, a[i])) exch(a, gt--, i); else i++; &#125; // since a[lt .. i-1] is sorted. // sort the other subarrays recursively. sort(a, lo, lt-1); sort(a, gt+1, hi);&#125; [notice] : 三向切分的最坏情况是所有主键均不相同。对于标准的快速排序，随着数组规模的增大其运行时间会趋于平均时间，大幅偏离的情况是非常罕见的，因此可以肯定三向切分的快速排序运行时间和输入的信息量的N倍是成正比的。 ———— 因为对于包含大量重复元素的数组，它将排序时间从线性对数级降到了线性级别。 NOTICE本文中，涉及的算法详细实现和使用，请移步到github查看。]]></content>
      <categories>
        <category>Algorithms</category>
        <category>sorting algs</category>
      </categories>
      <tags>
        <tag>sorting algs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[归并排序 - mergeSort]]></title>
    <url>%2Fposts%2F1368334%2F</url>
    <content type="text"><![CDATA[引入归并排序属于分治算法(Divide and Conquer)。通过递归不断把待排序数组分成两个部分，将有序的两部分再重新归并一起来实现对数组的排序。 [pseudo code for 2-way merge sort]: 12345678910MergeSort(arr[], aux[], lo, hi)If hi &gt; lo 1. Find the middle point to divide the array into two halves; int mid = lo + (hi - lo) / 2; 2. Call MergeSort for first half; MergeSort(arr, aux, lo, mid); 3. Call MergeSort for second half; MergeSort(arr, aux, mid+1, hi); 4. Merge the two halves sorted in step 2 and 3; Call merge(arr, aux, lo, mid, hi); 原地归并的抽象方法要实现上述的归并方法 — merge()很简单，创建一个数组将需要归并的原数组的两个部分中的元素放到这个数组中，然后再归并按大小顺序放回原数组。 但是，这里我们要考虑一个问题，当我们用归并排序对一个比较大的数组进行排序时，我们需要进行很多次归并，因此在每一次归并时都创建一个新的数组来存储排序结果会带来问题。我们可以考虑只创建一个辅助数组aux[], 在每一个归并时，将原数组需要归并的两个部分复制到aux[]中，再把归并结果放回原数组。 123456789101112131415161718192021public static void merge(Comparable[] a, Comparable[] aux, int lo, int mid, int hi) &#123; // precondition: a[lo .. mid] and a[mid+1 .. hi] is sorted. assert isSorted(a, lo, mid); assert isSorted(a, mid+1, hi); // copy a[lo .. hi] to aux[lo .. hi]. for (int k = lo; k &lt;= hi; k++) &#123; aux[k] = a[k]; &#125; int i = lo; int j = mid+1; for (int k = lo; k &lt;= hi; k++) &#123; if (i &gt; mid) a[k] = aux[j++]; else if (j &gt; hi) a[k] = aux[i++]; else if (less(aux[j], aux[i])) a[k] = aux[j++]; else a[k] = aux[i++]; &#125; // postcondition: a[lo .. hi] is sorted. assert isSorted(a, lo, hi);&#125; [说明] : 该方法先将原数组两个需要归并的部分复制到aux[]中，然后从两个部分的起始位置开始取元素，一直选择两个部分中较小的元素放回原数组中，当有一部分元素取完了，则将另一部分剩余的元素全部放回原数组。 原地归并抽象方法轨迹： [from algs4] 自顶向下的归并排序1234567891011121314151617public static void mergeSort(Comparable[] a) &#123; int n = a.length; Comparable[] aux = new Comparable[n]; sort(a, aux, 0, a.length-1);&#125;private static void sort(Comparable[] a, Comparable[] aux, int lo, int hi) &#123; // If array size is 1 then return. if (hi &lt;= lo) return; // Find the middle point to divide array into two halves. int mid = lo + (hi - lo) / 2; // Call the mergeSort for first half. sort(a, aux, lo, mid); // Call the mergeSort for second half. sort(a, aux, mid+1, hi); // Merge two halves sorted. merge(a, aux, lo, mid, hi);&#125; 自顶向下归并结果轨迹 : [from algs4] 自顶向下归并排序调用轨迹 : [from algs4] 命题 F: 对于长度为 $N$ 的任意数组， 自顶向下归并排序需要 $1/2NlgN$ 至 $NlgN$ 次比较。 自顶向下的所需时间表达式为 : $T(N) = 2T(N/2) + O(n)$使用解决递归式的 Master method 解得 $T(N) = \Theta(n log n)$ 我们可以通过下图来理解命题F, 每个节点都表示一个sort()方法通过merge()方法归并而成的子数组。这棵树正好有 $n$ 层。对于$0 ~ n-1$ 之间的任意 $k$, 自顶向下的第 $k$ 层有 $2^k$个子数组，每个数组长度为 $2^{n-k}$, 归并最多需要 $2^{n-k}$ 次比较。因此每层的比较次数为$2^k X 2^{n-k} = 2^n$, n 层总共为 $n2^n = NlgN$。 子数组树状图 : [from algs4] 命题 G : 对于长度为 $N$ 的任意数组，自顶向下的归并排序最多需要访问数组 $6NlgN$ 次。 证明： 每次归并最多需要访问数组 $6N$ 次（$2N$ 次用来复制， $2N$次用来将排好序的元素移动回去，另外最多比较$2N$次），根据命题F即可得到这个命题的结果。 [小结]: 归并排序排序算法的缺点是辅助数组所使用的额外空间和N的大小成正比。一些能够大幅度缩短归并排序的运行时间的想法： 对小规模子数组进行插入排序； 测试数组是否已经有序； 不将元素复制到辅助数组中。 自底向上的归并排序实现归并排序另外一种方法是先归并那些微型数组， 然后再成对归并得到的子数组，直到将整个数组归并在一起。 12345678910public static void MergeBU(Comparable[] a) &#123; int n = a.length; Comparable[] aux = new Comparable[n]; for (int sz = 1; sz &lt; n; sz += sz) &#123; for (int lo = sz; lo &lt; n-sz; lo += sz+sz) &#123; merge(a, aux, lo, lo+sz-1, Math.min(lo+sz+sz-1, n-1)); &#125; &#125;&#123; [注] : 自底向上的归并排序会多次遍历整个数组，根据子数组大小进行两两归并。子数组的大小 sz 的初始值为 1， 每次加倍。最后一个子数组的大小只有在数组大小是 sz 的偶数倍的时候才会等于 sz(否则它会比sz小)。 自底向上归并排序结果轨迹 ： [from algs4] 命题 H : 对于长度为 $N$ 的任意数组， 自底向上的归并排序需要 $1/2NlgN$ 至 $NlgN$次比较，最多访问数组 $6NlgN$ 次。 证明 ： 处理一个数组的遍数正好是 $lgN$(即 $2^n &lt;= N &lt;2^n+1$ 中的 $n$)。每一遍会访问数组6N次。比较次数在 $N/2$ 和 $N$ 之间。 【补充】： 当数组长度为 2 的幂时，自顶向下和自底向上的归并排序所用的比较次数和数组访问次数正好相同，只是顺序不同。其他时候，两种方法的比较和数组访问的次序会有所不同。 NOTICE本文中，涉及的算法详细实现和使用，请移步到github查看。]]></content>
      <categories>
        <category>Algorithms</category>
        <category>sorting algs</category>
      </categories>
      <tags>
        <tag>sorting algs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基本排序算法 - basial sorting algorithms with java implementation]]></title>
    <url>%2Fposts%2F57d02cec%2F</url>
    <content type="text"><![CDATA[我们关注的主要对象是重新排列数组元素的算法， 其中每个元素都有一个主键。排序算法的目的就是将所有元素的主键按照某种方式排列(通常按照大小或是字母顺序)。 在java中元素通常都是对象，对主键的抽象描述则是通过一种内置的机制(Comparable接口)来完成的。 排序算法类模板1234567891011121314151617181920212223242526272829303132333435public class Example &#123; public static void exch(Comparable[] a, int i, int j) &#123; Comparable temp = a[i]; a[i] = a[j]; a[j] = temp; &#125; public static void sort(Comparable[] a) &#123; /*排序算法，如InsertionSort、BubbleSort、 SelectionSort、ShellSort等*/ &#125; private static void show(Comparable[] a) &#123; for (int i = 0; i &lt; a.length; i++) &#123; System.out.print(a[i] + " "); &#125; System.out.println(); &#125; public static boolean less(Comparable v, Comparable w) &#123; return v.compareTo(w) &lt; 0; &#125; public static boolean isSorted(Comparable[] a) &#123; for (int i = 1; i &lt; a.length; i++) &#123; if (less(a[i], a[i-1]) &#123; return false; &#125; &#125; return true; &#125; /** * Unit tests the &#123;@code Example&#125; sorting algorithm. * @args command-line arguments. */ public static void main(String[] args) &#123; // 测试代码... &#125;&#125; 这个类展示的是数组排序实现的框架。代码中实现的排序方法适用于任意实现了Comparable接口的数据类型。 验证无论数组的初始状态是什么，我们都无法确保排序算法都能成功。所以谨慎起见，我们会在测试代码中添加一条语句assert isSorted(a);来确保排序后的数组都是有序的。 运行时间评估算法的性能。首先，要计算各个排序算法在不同的随机输入下的基本操作的次数(包括比较和交换，或者是读写数组的次数)。 排序成本模型 : 在研究排序算法时，我们需要计算比较和交换的数量。 对于不交换元素的算法，我们会计算访问数组的次数。 额外的内存使用排序算法的额外内存开销和运行时间是同等重要的。排序算法可以分为两类: 除了函数调用所需的栈和固定数目的实例变量之外无需额外内存的原地排序算法。 需要额外内存空间来存储另一份数组副本的其他排序算法。 数据类型上面的排序模板适用于实现了Comparable接口的数据类型。例如, java中封装数字类型的Integer、Double、以及String和其他许多高级数据类型。而对于自己创建的数据类型，我们是要实现Comparable接口就能够保证能够使用排序算法进行排序。 自定义数据类型样例: 123456789101112131415161718192021222324public class Date implements Comparable&lt;Date&gt; &#123; private final int day; private final int month; private final int year; public Date(int d, int m, int y) &#123; day = d; month = m; year = y; &#125; public int day() &#123; return day; &#125; public int month() &#123; return month; &#125; public int year() &#123; return year; &#125; public int compareTo(Date that) &#123; if (this.year &gt; that.year) return +1; if (this.year &lt; that.year) return -1; if (this.month &gt; that.month) return +1; if (this.month &lt; that.month) return -1; if (this.day &gt; that.day) return +1 if (this.day &lt; that.day) return -1; return 0; &#125; public String toString() &#123; return month + "/" + day + "/" + year; &#125;&#125; 选择排序首先，找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置(如果第一个元素就是最小的元素那么它就和自己交换)。 再次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到整个数组排序完成。不断地选择剩余元素中的最小者。 命题 A: 对于长度为 $N$ 的数组，选择排序需要大约 $N^2/2$ 次比较和 $N$ 次交换。 证明： 可以通过算法的排序轨迹来证明，用一张$N X N$的表格来表示排序的轨迹，其中每个非灰色字符都表示一次比较。表格中大约有一半的元素不是 灰色的 — 即对角线和其上部分的元素。对角巷上的每个元素都对应真一次交换。通过查看代码我们可以更精确地得到，$0$ 到 $N-1$ 的任意 $i$ 都会 进行一次交换和 $N-1-i$ 次比较，因此 总共有$N$次交换以及 $(N-1)+（N-2)+…+2+1 = N(N-1)/2 ~ N^2/2$。 算法轨迹图示（from algs4)： 算法实现: 123456789101112131415public class Selection &#123; /* 其他的方法同排序算法模板*/ public static void sort(Comparable[] a) &#123; int n = a.length; for (int i = 0; i &lt; n; i++) &#123; int min = i; for (int j = i+1; j &lt; n; j++) &#123; if (less(a[j], a[min]) &#123; min = j; &#125; &#125; exch(a, i, min); &#125; &#125;&#125; 插入排序与选择排序一样，当前索引左边的所有元素都是有序的，但他们的最终位置不确定，为了给更小的元素腾出空间，它们可能会移动。当索引到达数组的右端时，数组排序就完成了。 和选择排序不同的是，插入排序所需的时间取决于输入中元素的初始顺序。例如对于一个很大且其中的元素已经有序（或接近有序）的数组进行插入排序将会比对随机数组或逆序数组进行排序要快得多。 命题 B : 对于随机排列的长度为 $N$ 且主键不重复的数组, 平均情况下插入排序需要 ~ $N^2/4$次比较以及 $~N^2/4$次交换。最坏情况下需要 ~N^2 /2 次比较和 ~ $N^2/2$次交换，最好情况下需要$N-1$次比较和$0$次交换。 证明： 和证明命题A一样，通过一个$N X N$的算法轨迹表可以很容易就得到交换和比较的次数。最坏的情况下对角线之下所有元素都需要移动位置，最 好情况下都不需要。对于随机排列的数组，在平均情况下每个元素都可能向后移动半个数组的长度 ，因此交换总数是对角线之下的元素总数的二分之。 比较的总次数是交换的次数加上一个额外的项，该项为 $N$ 减去被插入的元素正好是已知的最小 元 素的次数。在最坏情况下（逆序数组），这一 项相对于总数可以忽略不计；在最好的情况下（数组已经有序），这一项等于$N-1$。 插入排序算法轨迹图示（from algs4): 算法实现: 1234567891011public class Insertion &#123; /*其他的方法同排序算法模板*/ public static void sort(Comparable[] a) &#123; int n = a.length; for (int i = 1; i &lt; n; i++) &#123; for (int j = i; j&gt;0&amp;&amp;less(a[j], a[j-1]; j--) &#123; exch(a, j, j-1); &#125; &#125; &#125;&#125; 附加： 对于插入排序，我们要考虑的更一般情况是部分有序的数组。倒置指的是数组中的两个顺序颠倒的元素。比如EXAMPLE中有11对倒置：12E-A X-A X-M X-P X-L X-EM-L M-E P-L P-E L-E 如果数组中倒置的数量小于数组大小的某个倍数，那么我们说这个数组是部分有序的。几种典型的部分有序的数组: 数组中每个元素距离它的最终位置不远； 一个有序数组接一个小数组； 数组中只有几个元素位置不正确。 插入排序对这样的数组很有效，而选择排序则不然。当倒置的数量很少时，插入排序比大部分的其他排序算法都要快。 命题 C: 插入排序需要的交换的操作和数组的中倒置的数量相同，需要的比较次数大于等于倒置的数量，小于等于倒置的数量加上数组的大小再减一。 证明： 每次交换都改变了两个顺序颠倒的元素的位置，相当于减少了一对倒置，当倒置数量为0时，排序就完成了。每次交换都对应着一次比较，且$1$ 到$N -1$之间的每个$i$都可能需要一次额外的比较(在a[i]没有达到数组的左端时)。 [算法改进] : 大幅提高插入排序的速度，在内循环中将较大的元素都向右移动而不是总是交换两个元素(这样访问数组的次数就能减半)。 1234567891011public static void sort(Comparable[] a) &#123; int n = a.length; for (int i = 1; i &lt; n; i++) &#123; Comparable key = a[i]; int j; for (j = i-1; j &gt;= 0&amp;&amp;less(key, a[j]); j--) &#123; a[j+1] = a[j]; &#125; a[j+1] = key; &#125;&#125; 希尔排序希尔排序是基于插入排序的快速排序算法.对于规模乱序数组插入排序很慢，因为它只会交换相邻的元素，因此元素只能一点一点地从数组的一端移动到另外一端。希尔排序为了加快速度简单地改进了插入排序 —— 交换不相邻的元素以对数组的局部进行排序，并最终使用插入排序将局部有序的数组排序。 希尔排序的思想:使任意间隔为h的元素都是有序的。这样的数组称为h有序数组。对于任意以1为结尾的h序列（递增序列），我们使用它都能将数组排序。 算法实现： —— 使用的递增序列来自 algs4. 12345678910111213141516public class Shell &#123; /*其他排序算法方法同模板*/ public static void sort(Comparable[] a) &#123; int n = a.length; int h = 1; while (h &lt; n/3) h = 3 * h + 1; // 1， 4， 13， 40， 121， ... while (h &gt;= 1) &#123; for (int i = h; i &lt; n; i++) &#123; for (int j = i; j &gt;= h&amp;&amp;less(a[j], a[j-h]); j -= h) &#123; exch(a, j, j-h); &#125; &#125; h /= 3; &#125; &#125; &#125; [递增序列的选择] : 算法的性能不仅取决于h，还取决与h之间的数学性质。目前还没有人能证明某个递增序列是”最好的”。以上算法实现使用的递增序列（使用序列 $1/2(3^k-1)$,从N/3开始递减至1.）的计算和使用都很简单且和复杂的递增序列的性能接近。 算法轨迹图例 — example (from algs4): 实际应用: 对于中等大小的数组它的运行时间是可以接受的且它的代码量小，不需要额外的内存空间。所以在面临一个排序问题而没有系统排序函数可用时，可先用希尔排序，然后再考虑是否将它替换为更加复杂的排序算法。 [算法改进] : 由于希尔排序是基于插入排序，所以我们可以参照插入排序的改进，对希尔排序进行改进 — 把内循环中较大的元素右移而不是交换两个元素。 123456789101112131415public static void sort(Comparable[] a) &#123; int n = a.length; int h = 1; while (h &lt; n/3) h = 3 * h + 1; while (h &gt;= 1) &#123; for (int i = h; i &lt; n; i++) &#123; Comparable key = a[i]; int j; for (j = i-h; j &gt;= 0&amp;&amp;less(key, a[j]); j -= h) &#123; a[j+h] = a[j]; &#125; a[j+h] = key; &#125; &#125;&#125; 附加 —— 冒泡排序冒泡排序相对比较简单，这里直接给出它的实现: 12345678910111213141516public class Bubble &#123; /*其他排序算法方法同排序算法模板*/ public static void sort(Comparable[] a) &#123; int n = a.length; boolean flag = true; for (int i = 1; i &lt; n&amp;&amp;flag == true; i++) &#123; flag = false; for (int j = 0; j &lt; n-i; j++) &#123; if (less(a[j+1], a[j]) &#123; exch(a, j+1, j); flag = true; &#125; &#125; &#125; &#125; &#125; 算法分析: 对于冒泡排序，最坏情况下，算法需要进行N-1趟排序，总的数组元素比较的次数为$(N-1)+(N-2)+…+1$ ~ $N^2/2$， 总的交换次数为数组中倒置的数量。 NOTICE本文中，涉及的算法详细实现和使用，请移步到github查看。]]></content>
      <categories>
        <category>Algorithms</category>
        <category>sorting algs</category>
      </categories>
      <tags>
        <tag>sorting algs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Advanture 1 Leetcode - 944 - Delete Columns to Make Sorted]]></title>
    <url>%2Fposts%2Ff5b699c8%2F</url>
    <content type="text"><![CDATA[给出由 N 个小写字母串组成的数组 A，所有小写字母串的长度都相同。现在，我们可以选择任何一组删除索引，对于每个字符串，我们将删除这些索引中的所有字符。举个例子，如果字符串为 &quot;abcdef&quot;，且删除索引是 {0, 2, 3}，那么删除之后的最终字符串为 &quot;bef&quot;。假设我们选择了一组删除索引 D，在执行删除操作之后，A 中剩余的每一列都是有序的。形式上，第 c 列为 [A[0][c], A[1][c], ..., A[A.length-1][c]]返回 D.length 的最小可能值。 https://leetcode-cn.com/problems/delete-columns-to-make-sorted/(中文) https://leetcode.com/problems/delete-columns-to-make-sorted/(en)示例 1：输入：[“cba”,”daf”,”ghi”]输出：1示例 2：输入：[“a”,”b”]输出：0示例 3：输入：[“zyx”,”wvu”,”tsr”]输出：3提示：1 &lt;= A.length &lt;= 1001 &lt;= A[i].length &lt;= 1000 解题思路对于这种可以快速得出解题思路的题目： 由于每个字符串的长度一样，所以我们只需要依次比较字符串对应的每一列，判断是否满足非降序即可得到结果。 1234567891011121314class Solution &#123; public int minDeletionSize(String[] A) &#123; int count = 0; for (int i = A[0].length(); i++) &#123; for (int j = A.length-1; j++) &#123; if (A[j].charAt(i) &gt; A[j+1].charAt(i)) &#123; count++; break; &#125; &#125; &#125; return count; &#125;&#125; 复杂度分析(Complexity Analysis): 时间复杂度(Time complexity): $O(n)$ 空间复杂度(Space complexity): $O(1)$ 此题目，在leetcode上被归类为greedy，但我觉的解题思路并没怎么体现贪心算法的思想。。。]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>leetcode-greedy-easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Advantrue 1 - Leetcode 189 - Rotate Array]]></title>
    <url>%2Fposts%2F885fe7d0%2F</url>
    <content type="text"><![CDATA[给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。链接: https://leetcode-cn.com/problems/rotate-array/(中文) https://leetcode.com/problems/rotate-array/(en) 示例 1: 输入: [1,2,3,4,5,6,7] 和 k = 3输出: [5,6,7,1,2,3,4]解释:向右旋转 1 步: [7,1,2,3,4,5,6]向右旋转 2 步: [6,7,1,2,3,4,5]向右旋转 3 步: [5,6,7,1,2,3,4]示例 2: 输入: [-1,-100,3,99] 和 k = 2输出: [3,99,-1,-100]解释:向右旋转 1 步: [99,-1,-100,3]向右旋转 2 步: [3,99,-1,-100]说明: 尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。要求使用空间复杂度为 O(1) 的原地算法。 解题思路首先考虑考虑brute-force暴力解法，要使数组中的元素整体右移k位，最直接的方式是循环k次，每次循环让每个元素依次跟最后一个元素进行交换swap即可。 例如: input : [1, 2, 3, 4], k = 1 loop1: 4, 2, 3, 1 -&gt; 4, 1, 3, 2 -&gt; 4, 1, 2, 3 1234567891011121314class Solution &#123; public void rotate(int[] nums, int k) &#123; if (nums == null || nums.length &lt;= 1) return; for (int i = 0; i &lt; k; i++) &#123; int last = nums[nums.length-1]; for (int j = 0; j &lt; nums.length; j++) &#123; int temp = nums[j]; nums[j] = last; last = temp; &#125; &#125; &#125;&#125; 复杂度分析(Compelxity Analysis): 时间复杂度(Time complexity): $O(kn)$ 空间复杂度(Space complexity): $O(1)$ Submission status: 该解法通过所有测试用例，但是执行时间为109 ms, 击败14.9%的java代码提交。 解题思路二: 利用辅助数组，先将需要移动变换的元素放在移动后的位置，再将辅助数组元素移回原数组. 1234567891011121314class Solution &#123; public void rotate(int[] nums, int k) &#123; if (nums == null || nums.length &lt; 2) return; int[] aux = new int[nums.length]; for (int i = 0; i &lt; nums.length; i++) &#123; aux[(i+k) % nums.length] = nums[i]; &#125; for (int i = 0; i &lt; aux.length; i++) &#123; nums[i] = aux[i]; &#125; &#125;&#125; 复杂度分析(Compelxity Analysis): 时间复杂度(Time complexity): $O(n)$ 空间复杂度(Space complexity): $O(n)$ Submission status: 代码提交运行时间: 1 ms 击败53.8%的java提交代码。 解题思路三: 除了上面给出的第二种方案，还有更好的解题方法，能够做到O(n)运行时间，以及O(1)的空间复杂度. 思路: 拿题目给定的例子来说，[1,2,3,4,5,6,7], k = 3.首先将数组划分成两个部分: 0~nums.length-k-1,即[1,2,3,4]和nums.length-k ~ nums.length-1],即[5,6,7],把两个部分进行翻转，此时数组变成[4,3,2,1,7,6,5].最后，将整个数组进行翻转即可得到我们想要的结果: [5,6,7,1,2,3,4]. 需要注意的是，需要对k进行处理，当k &gt; nums.length情况，会出现越界情况。解决方法: 使k进行 mod nums.length运算(k = k % nums.length). 12345678910111213141516171819class Solution &#123; public void rotate(int[] nums, int k) &#123; if (nums == null || nums.length &lt; 2) return; k %= nums.length; reverse(nums, 0, nums.length-k - 1); reverse(nums, nums.length-k, nums.length-1); reverse(nums, 0, nums.length-1); &#125; private void reverse(int[] nums, int i, int j) &#123; while (i &lt; j) &#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; i++; j--; &#125; &#125;&#125; 复杂度分析(Complexity Analysis): 时间复杂度(Time complexity): $O(n)$ 空间复杂度(Space complexity): $O(1)$ Submission status: 代码提交运行时间: 0 ms, 击败100%的java提交代码。 总结在处理数组问题时，需要非常小心，时刻注意边界，避免发生数组越界问题。]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>leetcode-array-easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Advantrue 1 - Leetcode 11 - Container With Most Water]]></title>
    <url>%2Fposts%2Fdac7fdaa%2F</url>
    <content type="text"><![CDATA[给定 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 https://leetcode-cn.com/problems/container-with-most-water/(中文) https://leetcode.com/problems/container-with-most-water/(en)说明：你不能倾斜容器，且 n 的值至少为 2。示例:输入: [1,8,6,2,5,4,8,3,7]输出: 49 解题思路对于这样的题目，很明显可以快速的使用brute-force方式得到解法: 12345678910111213class Solution &#123; public int maxArea(int[] height) &#123; int maxArea = Integer.MIN_VALUE; for (int i = 0; i &lt; height; i++) &#123; for (int j = i+1; j &lt; height; j++) &#123; int temp = (j-i) * (height[i]&gt;height[j]?height[j]:height[i]); if (temp &gt; maxArea) maxArea = temp; &#125; &#125; return maxArea; &#125;&#125; 复杂度分析(Complexity Analysis): 时间复杂度(Time complexity): $O(n^2)$ 空间复杂度(Space complexity): $O(1)$ 显然使用brute-force解法设计的算法是正确的，但是时间复杂度是$O(n^2)$级别，因此我们需要考虑优化。代码提交状况:运行时间(Runtime): 269 msbeats rate: 20.1% 其实仔细看的话，要使围成的矩形面积最大，无非就是让长和宽尽量的大，因此我们可以使用Two-pointers双指针的思想:使用两个指针i,j分别指向0和height.length-1，让一开始的x坐标距离最大化，然后判断它们所对应的高度谁低，依据较低的高度值计算面积，再将对应索引指针增1(对于低索引指针)或减1(高索引指针)。 12345678910111213141516171819class Solution &#123; public int maxArea(int[] height) &#123; int maxArea = Integer.MIN_VAlUE; int i = 0; int j = height.length-1; while (i &lt; j) &#123; // int x = j - i; // maxArea = Math.max(maxArea,Math.min(heigth[i], height[j])*x); // if (height[i] &lt; height[j]) &#123; // i++; // &#125; else &#123; // j--; // &#125; // 对代码进行缩减 maxArea = Math.max(maxArea, height[j]&lt;height[i]?(j-i)*height[j--]:(j-i))*height[i++]); &#125; return maxArea; &#125;&#125; 复杂度分析(Complexity Analysis): 时间复杂度(Time complexity): $O(n)$ 空间复杂度(Space complexity): $O(1)$ 使用双指针，只需要一次遍历就能得到结果。可以见得双指针是非常有效的工具，也是数组类问题中常见的解题思路: 例如，对于已经排好序的两数之和(Two sum - sorted)问题,就可以使用双指针进行解决。 代码提交状况:运行时间(Runtime): 6 msbeat rate: 65.95%]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>leetcode-array-medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Advanture 1 - Leetcode 561 - Array Partition I]]></title>
    <url>%2Fposts%2F270f73f9%2F</url>
    <content type="text"><![CDATA[给定长度为 2n 的数组, 你的任务是将这些数分成 n 对, 例如 (a1, b1), (a2, b2), …, (an, bn) ，使得从1 到 n 的 min(ai, bi) 总和最大。链接: https://leetcode-cn.com/problems/array-partition-i/(中文) https://leetcode.com/problems/array-partition-i/(en) 示例 1: 1234输入: [1,4,3,2]输出: 4解释: n 等于 2, 最大总和为 4 = min(1, 2) + min(3, 4). 提示: n 是正整数,范围在 [1, 10000]. 数组中的元素范围在 [-10000, 10000]. 解题思路个人解题思路，观察给定的例子，很容易发现，对于一个给定的$2n$大小的数组，只要在组成数对时每次都从数组选择最小的连两个数来组成$n$个数对。所获得的$1到n的min(a_i,b_i)$总和最大。 证明: 可以使用数学归纳法进行证明。 因此，首先考虑将数组进行排序，然后将所有奇数位置的元素加和起来就是结果. 1234567891011121314151617181920212223class Solution &#123; public int arrayPairSum(int[] nums) &#123; if (nums.length % 2 != 0) throw new IllegalArgumentException(); // sort the array first if it is unsorted. if (!isSorted(nums)) Arrays.sort(nums); int sum = 0; for (int i = 0; i &lt; nums.length; i+=2) &#123; sum += nums[i]; &#125; return sum; &#125; // simple tool for sorting a integer array. private static boolean isSorted(int[] arr) &#123; for (int i = 0; i &lt; arr.length-1; i++) &#123; if (arr[i]&gt;arr[i+1]) return false; &#125; return true; &#125;&#125; 复杂度分析(Compelxity Analysis): 时间复杂度(Time complexity): $O(nlogn)$，主要取决所使用的排序算法 空间复杂度(Space complexity): $O(1)$ Submission status: 以上解法，通过所有测试用例，运行时间$32 ms$击败$28.65$%的提交(英文版leetcode) 可以清楚的了解到该问题还有更好的解法。由于我的解题思路基于比较的排序算法，因此时间复杂度$O(nlogn)$已是最优,需要考虑另外的解题思路。 如果不排序的情况下，得到结果。？？？ —&gt; emmm…. 没想到。。。 额…, 解题思路不变，还是基于排序，但是应用空间换时间的思想，因此容易想到利用桶排序对给定数组进行排序(毕竟数组元素范围已经给定$-10000 ~ 10000$) 123456789101112131415161718192021222324252627282930313233class Solution &#123; public int arrayPairSum(int[] nums) &#123; if (nums.length % 2 != 0) throw new IllegalArgumentException(); int[] bucket = new int[20001]; int maxElemt = Integer.MIN_VALUE; int minElemt = Integer.MAX_VALUE; for (int i = 0; i &lt; nums.length; i++) &#123; bucket[nums[i]+10000]++; if (nums[i] &gt; maxElemt) maxElemt = nums[i]; if (nums[i] &lt; minElemt) minElemt = nums[i]; &#125; int result = 0; minElemt += 10000; // offset is 10000 maxElemt += 10000; boolean isOdd = true; for (int i = minElemt; i &lt;= maxElemt; i++) &#123; if (bucket[i] &gt; 0) &#123; for (int j = 0; j &lt; bucket[i]; j++) &#123; if (isOdd) result += (i - 10000); isOdd = !isOdd; &#125; &#125; &#125; return result; &#125;&#125; 代码简单解释，由于给定数组元素的范围为$-10000$ ~ $10000$, 因此桶排序所需要的总的容量为$20000$, 对给定数组出现的元素进行偏移(偏移量为$10000$)bucket[nums[i]+10000]++，使用两个整型变量minElemt和maxElemt确定元素出现的范围, 使用flag变量isOdd判断当前处理元素是处于奇数位置还是偶数位置。 复杂度分析(Complexity Analysis): 时间复杂度(Time complexity): $O(n)$, 就算是数组所有元素都相同的情况，也是只要遍历$n$次 空间复杂度(Space complexity): $O(n)$ 对于该题目来说，$n为20000$ Submission status: 代码提交状况: 运行时间$7 ms$,超过$100$%的java代码提交。 总结第一种解法是通用解法，可以适用于不同的给定数组元素范围，而第二种解法只适用于此题，当元素范围比较大时，所花费的空间代价高。]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>leetcode-array-easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Advanture 1 - leetcode 1 - Two Sum]]></title>
    <url>%2Fposts%2F917327d3%2F</url>
    <content type="text"><![CDATA[leetcode解题思路总结: 给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。 你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。链接: https://leetcode-cn.com/problems/two-sum/(中文) https://leetcode.com/problems/two-sum/(en) 示例: 1234给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 解题思路对于这样的题目，最容易想到的是brute-force暴力解法, 直接两重循环进行迭代. 123456789101112class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; for (int i = 0; i &lt; nums.length; i++) &#123; for (int j = i+1; j &lt; nums.length; j++) &#123; if (nums[j] == target-nums[i]) return new int[] &#123;i, j&#125;; &#125; &#125; // Returns null if solution not found. return null; &#125;&#125; 复杂度分析(Complexity Analysising): 时间复杂度(Time complexity): $O(n^2)$ 空间复杂度(Space complexity): $O(1)$ 暴力解法虽然可行，但是时间复杂度为$O(n^2)$, 考虑进行优化，首先想到是可以以空间换时间: 如果能够把给定数组的数，用某种数据结构将每个数的数值以及对应的索引(index)保存起来，则只需要用一次遍历查找target - nums[i]是否存在于该数据结构中，且非nums[i]即可。 1234567891011121314151617class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; map.put(nums[i], i); &#125; for (int i = 0; i &lt; nums.length; i++) &#123; int remain = target - map.get(nums[i]); if (map.containsKey(remain) &amp;&amp; map.get(remain) != i) return new int[] &#123;i, map.get(remain)&#125;; &#125; // returns null if solution not found. reutrn null; &#125;&#125; 复杂度分析(Complexity Analysising): 时间复杂度(Time complexity): $O(n)$ 空间复杂度(Space complexity): $O(n)$ 年轻的我，本以为上面的这种解法已经是最优的了，但是看完讨论区之后，才焕然大悟，它还可以进行优化:仔细看的话，上面的HashMap算法访问了nums数组两遍，而接下来，从leetcode上学习到的优化方法就是将nums数组的访问从两遍降到一遍. 123456789101112class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; int remain = target - nums[i]; if (map.containsKey(remain)) return new int[] &#123;map.get(remain), i&#125;; map.put(nums[i], i); &#125; return null; &#125;&#125; 由于map中保存的肯定是索引i之前的数，因此不需要判断map.get(remain) != i. 复杂度分析(Complexity Analysising): 时间复杂度(Time complexity): O(n) 空间复杂度(Space complexity): O(n) 总结对于能够快速使用brute-force暴力解法解决的问题，考虑优化时，首先考虑能够减少循环的嵌套，其次是考虑减少数组的访问次数、元素比较次数、元素交换次数等。]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>leetcode-array-easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[\[Notice\]]]></title>
    <url>%2Fposts%2F4fa140f4%2F</url>
    <content type="text"><![CDATA[( ◜◡‾) 为了有更好的显示效果，建议使用桌面端打开! (‾◡◝ )]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java Reflection]]></title>
    <url>%2Fposts%2Fd897152e%2F</url>
    <content type="text"><![CDATA[简单了解Java反射的基本内容。 Java反射Class类的使用 A class named Class 1)在面向对象的世界里，万事万物皆对象。 类是对象，类是java.lang.Class类的实例对象 2)任何一个类都是Class的实例对象，这个实例对象有三种表示方式： 123456789101112131415161718192021package com.rovo98.reflect;public class ClassDemo1 &#123; public static void main(String args[]) &#123; //Foo的实例对象如何表示 Foo foo1 = new Foo() ;// foo1就表示出来了. //Foo这个类本身 也是一个实例对象，Class类的实例对象 // 第一种表示方式 --&gt; 任何一个类都有一个隐含的静态成员变量class Class c1 = Foo.class; //第二种表示方式 --&gt; 已经知道该类的对象通过getClass()方法 Class c2 = foo1.getClass() ; /* c1,c2 表示了Foo类的类类型(class type)*/ // 不管c1 or c2 都代表了Foo类的类类型，一个类只可能是Class类的一个实例对象 // 第三种表达方式 Class c3 = null ; c3 = Class.forName("com.rovo98.Foo"); // 我们完全可以通过类的类类型创建该类的对象实例 Foo foo = (Foo)c1.newInstance() ;//需要有无参构造方法 &#125;&#125;class Foo&#123;&#125; Java动态加载类 Class.forName(“类的名称”) 不仅表示了类的类类型，还代表了动态加载类 编译时刻加载类是静态加载类、运行时刻加载类是动态加载类 使用：当有多个功能模块(具体由类实现)时，使用动态加载 12345678910111213141516171819202122232425//动态加载实例interface OfficeAble // 指定接口标准&#123; public void start() ;&#125;class Word implements OfficeAble &#123; public static void start() &#123; System.out.println("Start the Word"); &#125;&#125;class Office&#123; public static void main(String args[]) &#123; try&#123; //实现动态加载，运行时加载类 Class c = Class.forName(args[0]) ; OfficeAble oa = c.newInstance() ; oa.start() ; &#125; catch (Exception e) &#123; e.printStackTrace() ; &#125; &#125;&#125; 通过反射获取方法信息 getMethods() 获取所有public 方法，包括父类继承而来的 getDeclaredMethods() 获取所有自定义的方法，不包含访问权限 1234567891011121314package com.rovo98.reflect;public class ClassDemo2 &#123; public static void main(String args[])&#123; Class c1 = int.class; // int 的类类型 Class c2 = String.class; //String的类类型 Class c3 = double.class ; Class c4 = Double.class ; Class c5 = void.class ; System.out.println(c1.getName()) ; System.out.println(c3.getSimpleName()) ;//打印不包含包名的类信息 &#125;&#125; 案例： 123456789101112131415161718192021222324252627282930313233package com.rovo98.feflect;public class ClassUtil &#123; /** *打印类的信息，包括类的成员变量，成员方法 *@param obj 该对象所属类的信息 */ public static void printClassMessage(Object obj) &#123; //要获取类的信息 首先要获取类的类类型 Class c = obj.getClass() ;//传递的是哪个子类的对象 c就是该子类的类类型 // 获取类名称 System.out.println("类的名称："+c.getName()) ; /* *Method类 ，方法对象 *一个成员方法就是一个Method对象 *getMethods()方法获取的是所有public的函数，包括父类继承而来的 *getDeclaredMethods()获取的是所有该类自己声明的方法，不包含访问权限 */ Method[] ms = c.getMethods() ;//c.getDeclaredMethods() for (int i=0; i&lt;ms.length; i++) &#123; // 得到方法的返回值类型的类类型 Class returnType = ms[i].getReturnType() ; System.out.print(returnType.getName()+" ") ; //得到方法的名称 System.out.print(ms[i].getName()+"("); //获取参数类型 --&gt; 得到的是参数列表的类型的类类型 for (Class class1 : paramTypes) &#123; System.out.print(class1.getName()+","); &#125; System.out.println(")"); &#125; &#125;&#125; 成员变量和构造方法信息的获取 getField()方法获取的是所有的public的成员变量的信息 getDeclaredField()获取的是该类自己声明的成员变量的信息 getConstructors获取所有的public的构造方法 getDeclaredConstructors得到所有的构造方法 12345678910111213141516171819202122232425262728293031323334353637383940414243public static void printClassFieldMessage(Object obj) &#123; /**成员变量也是对象*java.lang.reflect.Field*Field类封装了关于成员变量的操作*getField()方法获取的是所有的public的成员变量的信息*getDeclaredField()获取的是该类自己声明的成员变量的信息*///Field[] fs = c.getDeclaredFields();Filed[] fs = c.getDeclaredFields();for (Field field:fs) &#123; //得到成员变量的类型的类类型 Class fieldType = field.getType(); String typeName = fieldType.getName(); //得到成员变量的名称 String fieldName = field.getName(); System.out.println(typeName+" "+fieldName) ; &#125;&#125;/***打印对象的构造函数的信息*@param obj*/public static void printConMessage(Object obj) &#123; Class c = obj.getClass(); /* *构造方法也是对象 *java.lang.Constructor中封装了构造方法的信息 *getConstructors获取所有的public的构造方法 *getDeclaredConstructors得到所有的构造方法 */ //Constructor[] cs = c.getConstructors(); Construtor() cs = c.getDeclaredConstructors(); for (Constructor constructor : cs) &#123; //打印构造方法信息 System.out.print(constructor.getName()+"("); Class[] paramTypes = constructor.getParameterTypes(); for (Class class1 : paramTypes) &#123; System.out.print(class1.getName+" "); &#125; System.out.println(")"); &#125;&#125; java方法反射的基本操作方法的反射 1)如何获取某个方法方法的名称和方法的参数列表才能唯一决定某个方法 2)方法反射的操作method.invoke(对象,参数列表) 123456789101112131415161718192021222324252627282930313233343536package com.rovo98.reflect;public class MethodDemo1 &#123; public static main(String args[]) &#123; //要获取print(int, int)方法 //1.要先获取类的类类类型 //2.获取类的信息 A a1 = new A() ; Class c = a1.getClass() ; // 3.获取方法 名称和参数列表决定 //getMethod获取的是public的方法 //getDeclaredMethod自己的声明的方法 //c.getMethod(name,parameterTypes); //Method m = c.getMethod("print",new Class[]&#123;int.class,int.class&#125;); try &#123; // 获取print(int,int)方法 Method m = c.getMethod("print",int.class,int.class); //方法的反射操作 //使用m对象来进行方法调用 和a1对象调用一样 //方法如果没有返回值返回null,有则返回具体返回值 //本来是a1.print(10,20); Object o = m.invoke(a1,new Object[]&#123;10,20&#125;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;class A &#123; public vodi print(int a, int b) &#123; System.out.println(a + b) ; &#125; public void print(String a, String b) &#123; System.out.println(a.toUpperCase()+","+b.tolowerCase()) ; &#125;&#125; 通过反射了解集合泛型的本质12345678910111213141516171819202122232425262728293031package com.rovo98.reflect;public class MethodDemo4&#123; public static void main(String args[]) &#123; ArrayList list = new ArrayList() ; ArrayList&lt;String&gt; list1 = new ArrayList&lt;String&gt;(); list1.add("hello"); //list1.add(20); 错误的 Class c1 = list.getClass() ; Class c2 = list1.getClass() ; System.out.println(c1 == c2) ; //反射的操作都是编译之后的操作 /* *c1 == c2 结果返回true说明编译之后集合的泛型是去泛型化的 *java中集合的泛型，是防止错误输入的，只在编译阶段有效 *验证：可以通过方法的反射操作，绕过编译 */ try &#123; Method m = c1.getMethod("add",Object.class) ; // 绕过编译操作，绕过了泛型 Object o = c1.invoke(list1,20) ; System.out.println(list1.size()) ; // list1.size --&gt; 2 // list1 -- &gt; ["hello",20] &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>basic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式基本使用]]></title>
    <url>%2Fposts%2Ff85f3c07%2F</url>
    <content type="text"><![CDATA[regular expression regex RE 简介 正则表达式是用来简洁表达一组字符串的表达式。 正则表达式——一行胜千言 通用的字符串表达框架 简洁表达一组字符串的表达式 针对字符串表达“简洁”和“特征”思想的工具 判断某一字符串的特征归属 正则表达式在文本处理中十分常用 表达文本类型的特征(病毒、入侵等) 同时查找或替换一组字符串 匹配字符串的全部或部分 正则表达式主要应用在字符串的匹配中 正则表达式的使用 编译：将符合正则表达式语法的字符串转换成正则表达式特征。—— re.compile(regex) 正则表达式的语法正则表达式常用的操作符 操作符 说明 实例 . 表示任何单个字符 [ ] 字符集，对单个字符给出取值范围 [abc]表示a、b、c, [a-z]表示a到z单个字符 [^ ] 非字符集，对单个字符给出排除范围 [^abc]表示非a或b或c的单个字符 * 前一个字符0次或无限次扩展 abc*表示ab、abc、abcc、abcc等 + 前一个字符1次或无限次扩展 abc+表示abc、abcc、abccc等 ? 前一个字符0次或1次扩展 abc?表示ab、abc &#124; 左右表达式任意一个 abc &#124; def表示abc、def {m} 扩展前一个字符m次 ab{2}c表示abbc {m,n} 扩展前一个字符m至n次 ab{1,2}c表示abc、abbc ^ 匹配字符串开头 ^abc表示abc且在一个字符串的开头 $ 匹配字符串结尾 abc$表示abc且在一个字符串的结尾 ( ) 分组标记，内部只能使用 &#124; 操作符 (abc)表示abc ，(abc&#124;def)表示abc、def \d 数字，等价于[0-9] \w 单词字符，等价于[A-Za-z0-9] 经典正则表达式实例 ^[A-Za-z]+$ 由26个字母组成的字符串 ^[A-za-z0-9]+$ 由26个字母及数字组成的字符串 ^-?\d+$ 整数形式的字符串 ^[0-9]\*\[1-9][0-9]*$ 正整数形式的字符串 [1-9]\d{5} 中国境内的邮政编码，6 位 [\u4e00-\u9fa5] 匹配中文字符 \d{3}-\d{8} &#124; \d{4}-\d{7} 国内电话 IP地址: 不精确的写法： \d+.\d+.\d+.\d+ —— 以四个点进行分隔作为特点 \d{1,3}.\d{1,3}.\d{1,3}.\d{1,3} 精确写法：0-99 : [0-9]?\d 100-199 : 1\d{2}200-249 : 2[0-4]\d 250-255 : 25[0-5](([0-9]?\d|1\d{2}|2[0-4]\d|25[0-5]).){3}([0-9]?\d|1\d{2}|2[0-4]\d|25[0-5]) Re库的基本使用Re库介绍Re库是Python的标准库，主要用于字符串匹配。 1import re 正则表达式的表示类型 raw string 类型(原生字符串类型) —— 不包含转义字符re 库采用raw string 类型表示正则表达式，表示为：r’text’ string类型， 更繁琐 —— 需要双重转义 Re库的主要功能函数 函数 说明 re.search() 在一个字符串中搜索匹配正则表达式的第一个位置，返回match对象 re.match() 在一个字符串开始位置起匹配正则表达式，返回match对象 re.findall() 搜索字符串，以列表类型返回全部能匹配的子串 re.spilt() 将一个字符串按照正则表达式匹配结果进行分割，返回列表类型 re.fiinditer() 搜索字符串，返回一个匹配结果的迭代类型，每个迭代元素是match re.sub() 在一个字符串中替换所有匹配正则表达式的子串，返回替换后的字符串 re.search(pattern, string,flags=0) 在一个字符串中搜索匹配正则表达式的第一个位置，返回match对象 pattern: 正则表达式的字符串或者原生字符串 表示 string : 待匹配字符串 flags : 正则表达式使用时的控制标记 常用标记 说明 re.I re.IGNORECASE 忽略正则表达式的大小写，[A-Z]能够匹配小写字符 re.M RE.MULTILINE 正则表达式中的^操作符能够将给定字符串的每行当作匹配开始 re.S RE.DOTALL 正则表达式中的.操作符能够匹配所有字符，默认匹配除换行符外的所有字符 re.match(partern, string, flags=0) 从一个字符串的开始位置起匹配正则表达式，返回match对象 re.findall(pattern, string , flags=0) 搜索字符串，以列表类型返回全部能匹配的子串。 pattern ： 正则表达式的字符串或原生字符串表示 string ： 待匹配字符串 flags: 正则表达式使用时的控制标记 re.split(pattern, string, maxsplit=0, flags=0) 将一个字符串按照正则表达式匹配结果进行分割，返回列表类型。 maxsplit: 最大分割数 re.finditer(patern, string, flags=0) 搜索字符串，返回一个匹配结果的迭代类型，每一个迭代元素是match对象。 re.sub(pattern, repl, string, count=0, flags=0) 在一个字符串中替换所有匹配正则表达式的子串，返回替换后的字符串。 repl: 替换匹配字符串的字符串 count： 替换的最大次数 Re库的另一种等价用法1234567rst = re.search(r'[1-9]\d&#123;5&#125;', 'BIT100081')#函数式用法： 一次性操作#面向对象用法：编译后的多次操作pat = re.compile(r'[1-9]\d&#123;5&#125;')rst = pat.search('BIT100081') regex = re.compile(pattern, flags=0) 将正则表达式的字符串形式编译成正则表达式对象 Re库的match对象Match对象的属性 属性 说明 .string 待匹配文本 .re 匹配时使用的pattern对象()正则表达式 .pos 正则表达式搜索文本的开始位置 .endpos 正则表达式搜索文本的结束位置 Match对象的方法 方法 说明 .group(0) 获得匹配后的字符串 .start() 匹配字符串在原始字符串的开始位置 .end() 匹配字符串在原始字符串的结束位置 .span() 返回(.start(),.end()) — 元组类型 Re库的贪婪匹配和最小匹配 Re库默认采用贪婪匹配 最小匹配操作符 操作符 说明 *? 前一个字符0次或无限次扩展，最小匹配 +? 前一个字符1次或无限次扩展，最小匹配 ?? 前一个字符0次或1次扩展，最小匹配 {m,n}? 扩展前一个字符m至n次(含n)，最小匹配 高效的正则表达式技巧总结误匹配 指正则表达式所匹配的内容范围超过了所需要范围，有些文本命名不符合要求，但是被所写的正则表达式“击中”了。例如：如果使用\d{11}去匹配11位手机号，\d{11}不单单能匹配正确的手机号，它还会匹配98824839344这样明显不是手机号的字符串。我们把这样的匹配称为误匹配。 漏匹配 指正则表达式所匹配的内容所规定的范围太狭窄，有些文本确实是所需要的，但是所写的正则表达式没有将这种情况囊括在内。例如：使用\d{18}来匹配身份证号码，就会漏掉结尾是字母X的情况。 写出一条正则表达式，既可能出现误匹配(条件写得太宽松，范围大于目标文本)，也可能出现漏匹配(只描述了目标文本中多种情况的部分)，还可能既有误匹配又有漏匹配。例如：使用\w+\.com来匹配.com结尾的域名，既会误匹配abc\_.com(合法域名不包含\_,\w包含了这种情况),又会漏掉ab-c.com这样的域名(合法域名可以包含中划线，\w不包含中划线). 应对方法掌握语法细节 正则表达式在各种语言中，其语法大致相同，细节各有千秋。明确所使用语言的正则的语法的细节，是写出正确、高效正则表达式的基础。例如，perl中与\w等效的匹配范围是[a-zA-Z0-9\_];perl正则表达式不支持肯定逆序视中使用可变的重复(variable repetition inside lookbehind,例如( ?&lt;=.* )abc), 但是.Net语法是支持这一特性的；又如，JavaScript连逆序环视(lookbehind,如(?&lt;=ab)c)都不支持，而Perl和Python是支持的。&lt;&lt;精通正则表达式&gt;&gt;第三章&lt;&lt;正则表达式的特性和流派概览&gt;&gt;明确地列出了个大派系的正则表达式的异同。 先粗后精，先减后加 使用正则表达式语法对于目标文本进行描述和界定，可以像画素描一样，先大致勾勒出框架，在逐步在局部实现细节。仍举刚才的手机例子：先界定\d{11},总不会错；再细化为1[358]\d{9},就向前迈了一大步。先消除 漏匹配(刚开始先尽可能多的匹配，做加法)，然后再一点点去除误匹配(做减法)。]]></content>
      <categories>
        <category>Python</category>
        <category>python爬虫</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>regex基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解Requests库的异常和HTTP协议]]></title>
    <url>%2Fposts%2F4ae864e2%2F</url>
    <content type="text"><![CDATA[简单理解Requests库中的异常和HTTP协议。 异常 说明 requests.ConnectionError 网络连接错误异常，如DNS查询失败、拒绝连接等 requests.HTTPError HTTP错误异常 requests.URLRequired URl缺失异常 requests.TooManyRedirects 超过最大重定向次数，产生重定向异常 requests.ConnectTimeout 连接远程服务器超时异常 requests.Timeout 请求URL超时，产生超时异常 Response的异常： 异常 说明 r.raise_for_status() 如果不是200， 产生异常requests.HTTPError 爬取网页的通用代码框架 123456789101112import requestsdef getHTMLText(url) : try: r = requests.get(url, timeout=30) r.raise_for_status() #如果状态不是200， 引发requests.HTTPError异常 r.encoding = r.apparent_encoding #将encoding 设置为'utf-8'，一般用于没有charset的header return r.text except: return '产生异常'if __name__ == '__main__': url = "http://www.baidu.com" print(getHTMLText(url)) HTTP协议HTTP, Hypertext Transfer Protocol, 超文本传输协议 HTTP是一个基于“请求与响应”模式的、无状态的应用层协议。 HTTP协议采用URL作为定位网络资源的标识。 URL格式： http://host[ :port ][ path ] HTTP URL的理解： URL 是通过HTTP协议存取资源的Internet路径，一个URL对应一个数据资源。 HTTP协议对资源的操作 方法 说明 GET 请求获取URL位置的资源 HEAD 请求获取URL位置资源的响应消息报告，即获取该资源的头部信息 POST 请求URL位置的资源后附加新的数据 PUT 请求向URL位置存储一个资源，覆盖原URL位置的资源 PATCH 请求局部更新URL位置的资源，即改变该处资源的部分内容 DELETE 请求删除URL位置存储的资源 理解PATCH和PUT的区别： 假设URL位置有一组数据UserInfo， 包括UserID、UserName等20个字段 需求：用户修改了UserName，其他不变。 采用PATCH，仅向URL提交UserName的更新请求。 采用PUT，必须将所有20个字段一并提交URL，未提交字段被删除。PATCH的好处：节省网络带宽]]></content>
      <categories>
        <category>Python</category>
        <category>python爬虫</category>
      </categories>
      <tags>
        <tag>Requests库</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Requests库的7个主要方法]]></title>
    <url>%2Fposts%2Fc671c604%2F</url>
    <content type="text"><![CDATA[Requests库的7个主要方法 方法 说明 requests.request() 构造一个请求，支撑以下各方法的基础方法 requests.get() 获取HTML网页的主要方法，对应于HTTP的GET requests.head() 获取HTML网页头信息的方法，对应于HTTP的HEAD requests.post() 向HTML网页提交POST请求的方法，对应于HTTP的POST requests.put() 向HTML网页提交PUT请求的方法，对应于HTTP的PUT requests.patch() 向HTML网页提交局部修改请求，对应于HTTP的PATCH requests.delete() 向HTML页面提交删除请求，对应HTTP的DELETE requests库的主要方法(基础方法)requests.request(method, url, **kwargs) method:请求方式，对应get/put/post等7种 r = requests.request(&#39;GET&#39;,url, **kwargs) r = requsts.request(&#39;HEAD&#39;,url, **kwargs) r = requests.request(&#39;POST&#39;,url, **kwargs) r = requests.request(&#39;PATCH&#39;,url, **kwargs) r = requests.request(&#39;delete&#39;, url, **kwargs) r = requests.request(&#39;OPTIONS&#39;,url, **kwargs) url:拟获取页面的URL链接 **kwargs: 控制访问的参数，共13个 1)params:字典或字节序列，作为参数增加到URL中 2)data: 字典、字节序列或者文件对象，作为Request的内容 3)json : JSON格式数据，作为Request内容 4)headers : 字典，HTTP定制头 5)cookies : 字典或CookieJar，Request中的cookie 6)auth : 元组，支持HTTP认证功能 7)files : 字典类型，传输文件 8)timeout : 设定的超时时间，秒为单位 9)proxies : 字典类型，设定访问代理服务器，可以增加登录认证 10)allow_redirects : True/False, 默认为True,重定向开关 11)stream : True/False, 默认为True ,获取内容立即下载开关 12)verify : True/False , 默认为True ， 认证SSL证书开关 13) cert : 本地SSL证书路径requests.get()方法： 12r = requests.get(url) #构造一个向服务器请求资源的Request对象#返回一个包含服务器资源的Response对象 完整方法：requests.get(url, params=None, **kwargs) url: 拟获取页面的url链接 params: url中的额外参数， 字典或字节流格式， 可选 **kwargs : 12个控制访问的参数，与request()的一样 实际上是这样的： 12345678910def get(url, params=None, **kwargs): #Sends a GET request. #:param url: URL for the new :class :'Request' object. #:param params: (optional) Dictionary ro bytes to be sent in the query #:return: :class :'Request &lt;Response&gt;' object #:rtype: requests.Response kwargs.setdefault('allow redirect', True) return request('get', url, params=params, **kwargs) 例子： 1234567891011import requestsr = requests.get("http://www.baidu.com")print(r)type(r)r.headers"""输出：200&lt;class 'requests.models.Response'&gt;&#123;'Transfer-Encoding': 'chunked', 'Pragma': 'no-cache', 'Connection': 'Keep-Alive', 'Last-Modified': 'Mon, 23 Jan 2017 13:27:52 GMT', 'Cache-Control': 'private, no-cache, no-store, proxy-revalidate, no-transform', 'Server': 'bfe/1.0.8.18', 'Set-Cookie': 'BDORZ=27315; max-age=86400; domain=.baidu.com; path=/', 'Content-Encoding': 'gzip', 'Date': 'Sat, 15 Jul 2017 13:27:01 GMT', 'Content-Type': 'text/html'&#125;""" Response对象的属性 属性 说明 r.status_code HTTP请求的返回状态，200表示连接成功，404表示失败 r.text HTTP响应内容的字符串形式，即，url对应的页面内容 r.encoding 从HTTP header中猜测的响应内容编码方式 r.apparent_encoding 从内容中分析出的响应内容编码方式(备用编码凡是) r.content HTTP响应内容的二进制形式 [注]：r.encoding: 如果header中不存在charset， 则认为编码为ISO-8859-1 Requests库的head()方法12345678r = requests.head('http://httpbin.org/get')r.headersr.text"""输出：&#123;'Access-Control-Allow-Credentials': 'true', 'X-Processed-Time': '0.000805139541626', 'Via': '1.1 vegur', 'Access-Control-Allow-Origin': '*', 'X-Powered-By': 'Flask', 'Content-Length': '267', 'Server': 'meinheld/0.6.1', 'Content-Type': 'application/json', 'Date': 'Sat, 15 Jul 2017 14:23:41 GMT', 'Connection': 'keep-alive'&#125;'' -- r.text""" Requests库的post()方法123456789101112131415161718192021222324252627payload = &#123;'key1':'value1', 'key2':'value2'&#125;r = requests.post('http://httpbin.org/post', data = payload)r = requests.post('http://httpbin.org/post', data = 'ABC')#向URL POST一个字典自动编码为form(表单)print(r.text)"""输出:&#123; "args": &#123;&#125;, "data": "ABC", --- &gt; 向URLPOST一个字符串，自动编码为data "files": &#123;&#125;, "form": &#123; "key1": "value1", "key2": "value2" &#125;, "headers": &#123; "Accept": "*/*", "Accept-Encoding": "gzip, deflate", "Connection": "close", "Content-Length": "23", "Content-Type": "application/x-www-form-urlencoded", "Host": "httpbin.org", "User-Agent": "python-requests/2.18.1" &#125;, "json": null, "origin": "120.85.181.141", "url": "http://httpbin.org/post"""" Requests库的put()方法1234payload = &#123;'key1':'value1', 'key2':'value2'&#125;r = requests.put('http://httpbin.org/put', data = payload)print(r.text)#此方法与post方法类似，只不过是替换了URL位置上资源的内容]]></content>
      <categories>
        <category>Python</category>
        <category>python爬虫</category>
      </categories>
      <tags>
        <tag>Requests库</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
</search>
