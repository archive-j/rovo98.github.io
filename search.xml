<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Sharing]]></title>
    <url>%2Fposts%2F613cd5f4%2F</url>
    <content type="text"><![CDATA[Temporary file. 临时文件: 2018.11.02 deadline: 2018.11.03 引入本文旨在告诉你们我所知道的一点点东西，分享的内容也只是让你们知道和了解一些东西。 说到分享学习心得，我想关于学习的话，我们每个人对于学习都应该会有自己的看法，每个人的学习方式可能也都不太一样。但是应该比较认同，大学中的学习绝对是不同于高中中的学习的，我的个人认为是, 在高中，学习目的就是为了考试，能做出题目就行了。(LOL: 我相信很多人在高中毕业几年后，基本就把高中所学的东西都遗忘了，毕竟所学知识在日常生活中很少使用到（是指自己你不知道怎么应用，毕竟当初学的时候，大多数都是把它们当做工具来解题使用的）) 因此，我想说的是我们不能按照原来的套路来了，大学中的学习已经和高中不一样了，插语：不知道你们高中的老师有没有跟你们说过，高中高三努力把高考考了，到了大学就轻松了。（什么60分万岁，多一分浪费之类的话）。 首先，我们需要先对比一下高中和大学学习区别(我所认为的)： 在大学里，相比于高中，没有了很多的条条框框，让我们变得更加自由，但这不意味着可以放纵自己； 高中学习，我们优先掌握的学习内容只是高考考纲内容，而在大学中，要想有所收获，决不能将目光只放在老师课堂上教授的内容上，要更加拓宽自己的知识面； 在大学中，成绩不代表一切，但说明一些问题； 在高中，有问题时，有老师/同学帮忙解决(对于大部分人来说)，但是在大学必须学会自己尝试解决问题，扮演之前老师/同学角色的一般是书，以及网上能够查阅的各种资料。（并不是说不能询问老师/同学，只是侧重于自己解决） 。。。。 关于学习方法(暂定)主要分享一下我所了解到的关于学习的一些个人觉得比较好的内容。 一万个小时定律大众所熟知的“一万小时定律”是由美国畅销书作家马尔科姆‧格拉德威尔(Malcolm Gladwell)在《异类》一书中指出，其实，这个定律不是格拉德威尔发明的，但他确实在《异类》中普及了“一万小时定律”。 首先需要说明的是，这个10000不是确数，不是说你得不多不少正好10000小时。大约可以理解成平均需要10000小时。比如说有研究显示，要达到国际象棋大师级水平，刻意训练的时间从3000小时到25000小时不等，差不多平均6700小时。 正如很多知友所言，这个说法来自K. Anders Ericsson的论文《The Role of Deliberate Practice in the Acquisition of Expert Performance》，所以要了解这个说法到底怎么回事儿，应该看看原始论文。这篇论文的题目就明确指出Deliberate Practice，也就是刻意的训练。其实，在19世纪的时候，就有说法，认为你只要是花足够时间，就能在你花时间的那个领域做得很棒，但是忽略了花时间练习的内容。到了19世纪末，就有人发现，其实如果仅仅是简单的重复，你很可能只是达到一个平台的水平，而不是达到最棒。所以，Ericsson提到了刻意训练这个概念。为了能把刻意训练说清楚，Ericsson把刻意训练和另外两种活动做了对比，玩儿（play）和工作（work）。 — 引用自 https://www.zhihu.com/question/21655527 了解到所谓“一万个小时定律”并不是简单的重复，为了更好的理解刻意练习,我们先了解下面的内容: 心理学研究说，人类对于外部世界的认识可分为三个区域：舒适区（comfort zone），学习区（stretch zone），和恐慌区（stress zone）。 舒适区：舒适区的定义及理论,在舒适区我们得心应手，每天处于熟悉的环境中，做在行的的事情，和熟悉的人交际，甚至你就是这个领域的专家，对这个区域中的人和事感觉很舒适。但是学到的东西很少，进步缓慢，而且一旦跳出这个领域，面对不熟悉的环境及变化，你可能会觉得有压力，无所适从。 学习区：是我们很少接触甚至未曾涉足的领域，充满新颖的事物，在这里可以充分的锻炼自我，挑战自我。比如，生活中，换一条上班的路线；学习中，接触另一个专业的书籍；工作中，切换到另外一个岗位。 恐慌区：在这个区域中会感到忧虑，恐惧，不堪重负。比如在公共场合演讲，或者从事一些危险的极限运动。 如果我们长期待在自己所熟知的领域——舒适区，那么我们的能力很难有所增长。只需要在舒适区结合或者关联较紧密的学习区不断开垦，将学习区逐渐转化为新的舒适区，那么我们的恐慌区就会越来越小，我们的专业度也会越来越强。无效或低效努力除了掩饰自己安慰自己，结果只会是浪费了宝贵的时间彻底摧毁了我们进步的空间。 这里只是针对学习而言的，对于其他方面，并不适合这么做，例如：在生活上，我一般是待在自己的舒适区中的；毕竟“不作死就不会死”嘛！ 更多关于舒适区、学习区和恐慌区的内容可以参考: THE 3 ZONES EVERYONE SHOULD KNOW ABOUT http://www.amsterdamuas.com/binaries/content/assets/subsites/safe/lecturers/background-for-teachers/the-comfort-stretch-panic-model.pdf https://zhuanlan.zhihu.com/p/27860325 Comfort, Stretch and Don’t Panic! 前面提到，首次提出“刻意练习”这个概念的是佛罗里达大学心理学家 K. Anders Ericsson。这套练习方法的核心假设是，专家级水平是逐渐地练出来的，而有效进步的关键在于找到一系列的小任务让受训者按顺序完成。这些小任务必须是受训者正好不会做，但是又正好可以学习掌握的。完成这种练习要求受训者思想高度集中，这就与那些例行公事或者带娱乐色彩的练习完全不同。“刻意练习”的理论目前已经被广泛接受，我们可以总结一下它的特点。 只在“学习区”练习； 大量重复训练； 持续获得有效的反馈； 精神高度集中。 引用自学而时嘻之的博主同人于野的文章&quot;怎样练习一万小时&quot;, 详细内容可以前往查看. 更多关于刻意练习的内容请参考: The Beginner’s Guide to Deliberate Practice Get Better at Anything: 6 Steps of Deliberate Practice 书籍: 刻意练习 pdf下载: 刻意练习(随便搜索找的) 费曼学习法费曼学习法是一种高效的学习技巧。大概的内容如下: 原文来自 Quora: 如何才能学得快一些 (How can you learn faster) Step 1. Choose the concept you want to understand.Take a blank piece of paper and write that concept at the top of the page. Step 2. Pretend you’re teaching the idea to someone else.Write out an explanation of the topic, as if you were trying to teach it to a new student. When you explain the idea this way you get a better idea of what you understand and where you might have some gaps. Step 3. If you get stuck, go back to the book.Whenever you get stuck, go back to the source material and re-learn that part of the material until you get it enough that you can explain it on paper. Step 4. Simplify your language.The goal is to use your words, not the words of the source material. If your explanation is wordy or confusing, that’s an indication that you might not understand the idea as well as you thought – try to simplify the language or create an analogy to better understand it 第一步 - 选择一个你想要理解的概念选择一个你想要理解的概念, 然后拿出一张白纸, 把这个概念写在白纸的最上边. 第二步 - 设想一种场景，你正要向别人传授这个概念在白纸上写下你对这个概念的解释, 就好像你正在教导一位新接触这个概念的学生一样. 当你这样做的时候, 你会更清楚地意识到关于这个概念你理解了多少, 以及是否还存在理解不清的地方. 第三步 - 如果你感觉卡壳了, 就回顾一下学习资料无论何时你感觉卡壳了, 都要回到原始的学习资料并重新学习让你感到卡壳的那部分, 直到你领会得足够顺畅, 顺畅到可以在纸上解释这个部分为止. 第四步 - 为了让你的讲解通俗易懂，简化语言表达最终的目的, 是用你自己的语言, 而不是学习资料中的语言来解释概念. 如果你的解释很冗长或者令人迷惑, 那就说明你对概念的理解可能并没有你自己想象得那么顺畅 — 你要努力简化语言表达, 或者与已有的知识建立一种类比关系, 以便更好地理解它。 更多有关费曼学习技巧的参考: How to Use the Feynman Technique to Learn Faster (With Examples) THE FEYNMAN TECHNIQUE MODEL The Feynman Technique: The Best Way to Learn Anything Quora上关于费曼学习法的一个谈论: How effective is the Feynman technique for learning? 知乎上关于费曼学习法的内容: 号称终极快速学习法的费曼技巧，究竟是什么样的学习方法？ 更多说到效率问题，突然想到不得不说一下 80/20 rule (80/20法则) 参考wikipedia上简单介绍: The principle was suggested by management thinker Joseph M. Juran. It was named after the Italian economist Vilfredo Pareto, who observed that 80% of income in Italy was received by 20% of the Italian population. The assumption is that most of the results in any situation are determined by a small number of causes. 80%的产出取决于20%的投入 80/20的应用更多的可以参考: 想要提高效率，就得不公平 - 来自同人于野(该博主写的文章都挺不错的，可以看一下) 例如有篇探讨记忆的文章 - “超强记忆力是个邪道功夫“ - 引用 物理学家费曼念研究生的时候，曾经出于玩票的心理跟生物系的人一起上过一门《细胞生理学》。这门课要求他读一篇涉及到猫的肌肉构造的论文，并且要在课堂上介绍这篇论文。费曼完全不知道论文中提到的各个肌肉位于猫身上的什么部位，自己事先找资料学习了一番。等到费曼作报告的时候，他先在黑板上画了一只猫， 然后在图上标记各部分肌肉的名称。生物系同学纷纷告诉费曼，这些名称他们早就知道了。年轻气盛的费曼，立即当着全班同学说了一句话：“你们都知道？难怪你们念了四年的生物，我却还是一下便追上你们的程度了。”费曼在自传里说，这帮学生物的把大好时间都浪费在死记名词上，而这些东西只要15分钟就能查到。 What is 80/20 rule and why it will change your life Apply the 80/20 rule to everything 以上只是简单的了解和知道的有这样的方法和技巧(理论)的存在，能不能为自己所用，要看自己的理解和应用了。 关于阅读和资料查找前面说过，很多时候，书籍，和网上的资料一般扮演着老师/同学的角色。下面简单介绍一下如何跟它们打交道。 关于阅读关于阅读方面的，强烈推荐以下这本书:如何阅读一本书 书中将阅读分为四个阶段:1、基础阅读，2、检视阅读，3、分析阅读，4、主题阅读，最终目标是达到主题阅读 看了之后，才知道，自己读了这么多年书，原来连阅读都没学会(自己原来很多书都白看了，只停留在基础阅读阶段) 知乎上的一篇文章，可以快速的了解这本书主要讲述的内容: 如何评价《如何阅读一本书》（How to Read a Book）？ 资料查找一定要学会科学上网, 如何科学上网? 《科学上网翻墙教程》，科学上网资料(参考资料，更多的可以自行搜索) 另外github别人整理的资源: 翻墙工具收集，翻墙免费软件、免费ss账号、vps便宜网站 免费ss账号 免费shadowsocks账号 免费v2ray账号 (长期更新) 更加高效地进行搜索: Google搜索技巧: Google搜索技巧 使用Google搜索引擎的10个搜索技巧 资源分享分享一些学习网站，以及一些有用的工具。 再次强调，所谓的分享，这篇所谓的学习分享只是个人认为可以了解的一些东西而已，更多的内容需要靠你们自己发掘。 网站分享综合性的学习网站: https://www.geeksforgeeks.org https://www.tutorialspoint.com 基于git版本控制的代码托管平台: github: https://github.com gitlab: https://about.gitlab.com coding: https://coding.net - 国内 gitee: https://gitee.com - 码云 - 国内 http://hao.jobbole.com 工具git： 关于git的使用，这里推荐廖雪峰老师的教程: Git教程- 廖雪峰的官方网站 markdown: 快速做笔记、写博客，整合学习思路等，可以配合思维导图(如:Xmind等)使用。 more更多的东西，你们可以自己去找，就当做是留给你们的新手任务了。]]></content>
      <categories>
        <category>misc</category>
      </categories>
      <tags>
        <tag>resources sharing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记录一次linux系统迁移过程]]></title>
    <url>%2Fposts%2F3babee60%2F</url>
    <content type="text"><![CDATA[就在最近，终于为自己的电脑加装了固态。在装完固态之后，首先面临的问题就是如何将原先安装在机械硬盘上的linux系统迁移到固态上。还要考虑后续配置的问题。 本文主要讲述在迁移Linux系统到新的固态硬盘上所遇到的问题以及找到的相应的解决方法。 这里先给出系统迁移以及相关配置完成之后的机械硬盘和固态硬盘的简单测速对比: 引入拆开电脑，直接加装固态,顺便清清灰尘，换一下硅脂(ps: 这不知道是我第几次拆电脑了…,表示以后再也不买GPU风扇了，这已经是第二次失败的购买经历了(除非得到与原来匹配的风扇一致的风扇，不然我是不再换了). 清尘换硅脂: 加装固态和散热板: 关于固态如何购买挑选，需要很好的了解自己电脑能够支持的固态类型和市场所提供的固态类型，并综合各种因素才能做出最好的选择。这里我推荐几篇个人觉得不错的文章: https://www.laptopmag.com/articles/laptop-ssd-guide https://www.tomshardware.com/reviews/ssd-buying-guide,5602.html https://www.velocitymicro.com/blog/nvme-vs-m-2-vs-sata-whats-the-difference/ https://blog.csdn.net/u010109732/article/details/79032845 https://www.zhihu.com/question/48972075 https://www.pc841.com/article/20180914-92342_all.html https://www.techadvisor.co.uk/test-centre/storage/best-ssd-2018-3235200/ 以上推荐文章仅作为参考。 迁移系统准备进入原先的linux系统，对已经安装上的固态硬盘进行分区。因为我之前在没有固态之前，在机械硬盘上就已经安装了三个系统(win10, manjaro, kali),因此在分区时，我是考虑只把两个linux迁移到固态上，毕竟win10现在已经基本不使用了，并将机械硬盘上的EFI分区也迁移到固态上。分区这里，可以按照自己的需求对固态硬盘进行分区。 分区工具的选择，随意，哪个顺手用哪个，例如:gparted, fdisk, parted,还有各种桌面自带的分区工具。我是使用的是fdisk:例如:1sudo fdisk /dev/nvme0n1 这里我已经分好区了的，具体的操作在fdisk中进行: fdisk操作帮助目录123456789101112131415161718192021222324252627Generic d delete a partition F list free unpartitioned space l list known partition types n add a new partition p print the partition table t change a partition type v verify the partition table i print information about a partition Misc m print this menu x extra functionality (experts only) Script I load disk layout from sfdisk script file O dump disk layout to sfdisk script file Save &amp; Exit w write table to disk and exit q quit without saving changes Create a new label g create a new empty GPT partition table G create a new empty SGI (IRIX) partition table o create a new empty DOS partition table s create a new empty Sun partition table 例如创建EFI分区: 12345678910Command (m for help): nPartition number (2-128, default 2): 2 # 创建一个分区作为EFI分区First sector (xxxxx-xxxxxxxxxxx, default xxxxx): Last sector, +sectors or +size&#123;K,M,G,T,P&#125; (34-2047, default xxxxxxx): +200MCreated a new partition 2 of type &apos;Linux filesystem&apos; and of size 200 Mb.Command (m for help): t # 修改EFI分区的分区类型为EFI系统分区...# 最后保存设置Command (m for help): w 请注意先查看所执行的分区操作是不是你想要的再进行最后的保存设置 其他的分区创建类似EFI的创建，swap分区需要指定为Linux swap分区，作为linux数据分区的分区在创建时默认就是linux filesystem类型了，不需要更改，之后对创建的分区进行格式化:将EFI格式化为fat32，将linux数据分区格式化ext4； 先通过sudo fdisk -l或lsblk查看已经创建分区对应的设备名,例如:sudo fdisk -l: 123456789101112131415161718192021222324252627Disk /dev/nvme0n1: 238.5 GiB, 256060514304 bytes, 500118192 sectorsUnits: sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisklabel type: gptDisk identifier: 6D071E80-FF82-420B-A2D8-7A0BC4759F06Device Start End Sectors Size Type/dev/nvme0n1p1 34 262177 262144 128M Microsoft reserved/dev/nvme0n1p2 264192 673791 409600 200M EFI System/dev/nvme0n1p3 673792 9062399 8388608 4G Linux swap/dev/nvme0n1p4 9062400 428492799 419430400 200G Linux filesystem/dev/nvme0n1p5 428492800 500117503 71624704 34.2G Linux filesystemDisk /dev/sda: 931.5 GiB, 1000204886016 bytes, 1953525168 sectorsUnits: sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 4096 bytesI/O size (minimum/optimal): 4096 bytes / 4096 bytesDisklabel type: gptDisk identifier: D5CB68A7-96DA-4C61-84E2-61C98489BFF1Device Start End Sectors Size Type/dev/sda1 64 125829183 125829120 60G Microsoft basic data/dev/sda2 125829184 880802416 754973233 360G Microsoft basic data/dev/sda3 880803904 1596575151 715771248 341.3G Microsoft basic data/dev/sda4 1596575744 1953521663 356945920 170.2G Microsoft basic data lsblk 查看分好的磁盘分区: 12345678910111213NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINTsda 8:0 0 931.5G 0 disk ├─sda1 8:1 0 60G 0 part /run/media/rovo98/System├─sda2 8:2 0 360G 0 part /run/media/rovo98/Mshinoda├─sda3 8:3 0 341.3G 0 part /run/media/rovo98/Chester bennington└─sda4 8:4 0 170.2G 0 part /run/media/rovo98/LSRsr0 11:0 1 1024M 0 rom nvme0n1 259:0 0 238.5G 0 disk ├─nvme0n1p1 259:1 0 128M 0 part ├─nvme0n1p2 259:2 0 200M 0 part /boot/efi├─nvme0n1p3 259:3 0 4G 0 part [SWAP]├─nvme0n1p4 259:4 0 200G 0 part /└─nvme0n1p5 259:5 0 34.2G 0 part /run/media/rovo98/a002d542-c8c4-4c98-85af-8a4446dbaa1b 对特定的分区进行格式化,例如: 12345# 对于linux数据分区mkfs.ext4 /dev/nvme0n1p4mkfs.ext4 /dev/nvme0n1p5# EFI分区mkfs.fat /dev/nvme0n1p2 注意: 执行每条格式化命令前，必须确认指定的分区是否是你想要格式化的分区 做好这些准备之后，就可以进行系统的迁移了 系统迁移操作对于Linux系统，我们只需要知道Linux一切皆文件就行了。因此对于系统的迁移就变得简单了，可以使用dd,打包压缩然后解压缩，有关系统备份和恢复可以参看Arch wiki给出的:https://wiki.archlinux.org/index.php/System_backup.这里我是使用的是tar结合pigz(什么是pigz?)解压缩工具进行备份和恢复: 备份(打包压缩)1sudo tar --use-compress-program=pigz -cvpf /run/media/rovo98/Chester\ bennington/LP/GHOST/manjaro_backup_2018.10.7.tgz --exclude=/proc --exclude=/sys --exclude=/mnt --exclude=/run/media --exclude=/lost+found / 恢复到目标硬盘分区上(解包解压缩):先目标分区挂载到/mnt下，如:/mnt/manjaro 1mount /dev/nvme0n1p4 /mnt/manjaro 1sudo tar --use-compress-program=pigz -xvpf /run/media/rovo98/Chester\ bennington/LP/GHOST/manjaro_backup_2018.10.7.tgz -C /mnt/manjaro 完成后需要手动创建，上面打包压缩是排除的文件夹:/proc, /sys, /mnt, /run, /lost+found. 详细备份和恢复过程可以参考查看:Arch上的备份还原 修复Grub、fstab文件以及refind引导管理首先将/proc,/run,/dev,/sys重新挂载，让目标分区上的系统也拥有这些内容: 1234mount /proc /mnt/manjaro/procmount /sys /mnt/manjaro/sysmount /run /mnt/manjaro/runmount /dev /mnt/manjaro/dev 这些目录必须重新挂载，不然，当chroot切换进入目标系统之后，将无法获取一些系统信息，如：设备, 磁盘分区信息等. 在chroot到目标系统之前，需要挂载EFI分区到/mnt/manjaro/boot/efi（refind管理文件默认位置）下： 1mount /dev/nvme0n1p2 /mnt/manjaro/boot/efi chroot到目标系统中，进行之后的操作 1chroot /mnt/manjaro 更新fstab文件获取相应分区的UUID，以更新fstab文件和/etc/default/grub文件:blkid: 或 ls -l /dev/disk/by-uuid: 更新fstab文件: 主要修改挂载项以及对应的UUID，有关fstab文件的详细内容可以参考https://wiki.archlinux.org/index.php/Fstab 修复Grub 重新生成Grub 1sudo grub-install --target=x86_64-efi --efi-directory=/boot/efi --bootloader=Manjaro --recheck 更新Grub配置文件 123sudo update-grub或sudo grub-mkconfig -o /boot/grub/grub.cfg 注意：如果此过程中出现以下提示信息: EFI variables are not supported on this system. 需要先安装efibootmgr, dosfstools以及grub包，然后重新尝试重新生成Grub并更新其配置文件. 若仍出现该信息，则先退出chroot环境，并加载efivarfs模块: 1sudo modprobe efivarfs 然后再进入chroot环境，执行: 1mount -t efivarfs efivarfs /sys/firmware/efi/efivars 再重新生成Grub并更新Grub配置文件就好了。 参考链接:https://wiki.manjaro.org/index.php/Restore_the_GRUB_Bootloader 重新配置refind对之前的refind配置文件进行备份，保留主题文件themes及refind.conf就好了，其余的文件在执行refind-install时会自动生成. sudo refind-install12345678910111213141516# 已经生成过了的,打印信息如下ShimSource is noneInstalling rEFInd on Linux....ESP was found at /boot/efi using vfatFound rEFInd installation in /boot/efi/EFI/refind; upgrading it.Installing driver for ext4 (ext4_x64.efi)Copied rEFInd binary filesNotice: Backed up existing icons directory as icons-backup.Existing refind.conf file found; copying sample file as refind.conf-sampleto avoid overwriting your customizations.Keeping existing NVRAM entryrEFInd is set as the default boot manager.Existing //boot/refind_linux.conf found; not overwriting. 可以使用efibootmgr管理启动项，例如:efibootmgr查看当前所有的启动项，efibootmgr -Bb xxxx来删除不要的启动项，详细使用可以man efibootmgr来查看。 其中的windows系统启动项通过PE用UEFI引导修复生成即可(需要注意的是老旧的PE识别不了nvme固态)。 以上就是迁移Linux系统的完整过程了 遇到的问题在做完上面的所有操作，并将之前机械硬盘上的EFI分区等等(除Win10系统之外)都删除之后，重新启动进入固态盘上的系统，在Grub引导过程出现UUID=***************找不到的信息，经过查看之后发现，在Grub引导时居然没有挂载我那块nvme固态。 通过了解发现Grub2.2版本并不支持nvme的固态，可以使用安装bootloader来进行引导。PS: 但我Manjaro安装的Grub是2.3版本的，理论上是支持的。 参考链接: https://bbs.archlinux.org/viewtopic.php?id=209653 通过一番查找之后，终于找到了解决方法: 添加加载模块 sudo vim /etc/mkinitcpio.conf 文件:/etc/mkinitcpio.conf 123456...- MODULES = ""+ MODULES="nvme"... 更新mkinitcpio 执行命令: sudo mkinitcpio -p linux414123#参数说明，详细可以通过man查看-p, --preset presetBuild initramfs image(s) according to specified preset. This may be a file in /etc/mkinitcpio.d (without the .preset extension) or a full, absolute path to a file. This option may be specified multiple times to process multiple presets. 更新Grub 123sudo update-grub或sudo grub-mkocnfig -o /boot/grub/grub.cfg 再次重启之后，便可以成功进入系统了。 参考链接:http://blog.51cto.com/shenfly231/1918426, 若要安装bootloader也可以参考该链接。 SSD优化开启Trim功能关于什么是TRIM?： SSD TRIM is an Advanced Technology Attachment (ATA) command that enables an operating system to inform a NAND flash solid-state drive (SSD) which data blocks it can erase because they are no longer in use. The use of TRIM can improve the performance of writing data to SSDs and contribute to longer SSD life. 了解可以参考: https://searchstorage.techtarget.com/definition/TRIM，以及Arch wiki上的:https://wiki.archlinux.org/index.php/Solid_state_drive#TRIM Most SSDs support the ATA_TRIM command for sustained long-term performance and wear-leveling. A techspot article shows performance benchmark examples of before and after filling an SSD with data. As of Linux kernel version 3.8 onwards, support for TRIM was continually added for the different filesystems. See the following table for an indicative overview: 在使用Trim功能之前需要查看固态硬盘是否支持，否则可能造成数据丢失: 1lsblk --discard DISC-GRAN和DISC-MAX不为0则表示支持，详细查看上面的Arch Wiki给出的文章。 关于使用的Trim方式，我使用的Continuous TRIM(详见Arch Wiki)即在fstab文件的挂载项中添加参数discard文件:/etc/fstab123456- UUID=D942-EEB0 /boot/efi vfat defaults,noatime 0 2- UUID=67180790-92d0-48d3-8f00-448161019f2d swap swap defaults,noatime 0 2- UUID=e2708091-5a07-47a6-bc26-5fdaa044c5f3 / ext4 defaults,noatime 0 1+ UUID=D942-EEB0 /boot/efi vfat defaults,discard,noatime 0 2+ UUID=67180790-92d0-48d3-8f00-448161019f2d swap swap defaults,discard,noatime 0 2+ UUID=e2708091-5a07-47a6-bc26-5fdaa044c5f3 / ext4 defaults,discard,noatime 0 1 IO调度器选择一般来说，IO调度算法是为低速硬盘准备的，对于固态，最好是不使用任何IO调度器，或使用对硬盘干预程度最低的调度算法。 查看当前固态的IO调度器:可以看到我当前固态没有使用任何调度器，而机械硬盘使用的是bfq-sq. 修改IO调度器(临时的): 1echo noop &gt; /sys/block/sda/queue/scheduler 要永久生效则需要添加编写开机自启动脚本详见参考链接. 更多信息以及详细的内容可以参考下面给出的参考链接.参考链接: https://wiki.archlinux.org/index.php/Improving_performance#Storage_devices https://blog.codeship.com/linux-io-scheduler-tuning/ https://www.ibm.com/developerworks/cn/linux/l-lo-io-scheduler-optimize-performance/index.html 另外更多有关Linux VM性能调优的可以参考:https://lonesysadmin.net/tag/linux-vm-performance-tuning/]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>ssd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编译自己的Vim8.1]]></title>
    <url>%2Fposts%2F97c4fd12%2F</url>
    <content type="text"><![CDATA[最近换了Manjaro linux系统，发现通过系统pacman -S vim安装的无图形版本vim不支持clipboard功能。 本想看能不能通过某种方式，来扩展现有安装好的vim,但是通过google了解到：VIM is intended to be a portable editor that “just works” on all systems. By having the default version use the clipboard functionality, it will need to link against X11 libraries, and a separate version of VIM would need to be compiled for desktop versus server (no pre-installed X11/xorg) builds. This is why the vim and vim-gtk packages are provided. VIM旨在成为一个可在所有系统上“正常工作”的便携式编辑器。通过使默认版本使用剪贴板功能，它将需要链接到X11库，并且需要针对桌面与服务器（没有预安装的X11 / xorg）构建编译单独版本的VIM。这就是提供vim和vim-gtk软件包的原因。 虽然知道gvim带有支持clipboard的vim，但是我又不想装gvim。自己的系统又有X11库和 Xorg，所以决定自己编译一个vim. 注意： 对于没有X11和Xorg的需要在编译前配置好，否则编译会出错. 一、从github上获取vim的源码直接使用git clone vim仓库： 1git clone https://github.com/vim/vim.git vim_source 二、配置、编译并安装我的编译配置： 123456789101112131415161718192021make clean./configure \ --enable-cscope \ --enable-largefile \ --enable-multibyte \ --enable-mzschemeinterp \ --enable-xim \ --enable-tclinterp=dynamic \ --enable-perlinterp=dynamic \ --enable-python3interp=dynamic\ --enable-pythoninterp=dynamic \ --enable-rubyinterp=dynamic \ --enable-luainterp=dynamic \ --enable-gui=no \ --enable-fontset \ --enable-terminal \ --with-features=huge \ --with-x \ --with-compiledby=&quot;rovo98&quot; \ --with-python-config-dir=/usr/lib/python2.7/config-$(uname-m)-linux-gnu --with-python3-config-dir=/usr/lib/python3.7/config-$(uname -m)-linux-gnu 编译并安装: 1make &amp;&amp; sudo make install 编译配置的说明: 上面的参数中启用了对tcl、perl、python、ruby、lua的支持。同时为了使用系统的剪切板还启用了对X的支持， 安装位置默认是/usr/local下， 由--perfix=PREFIX参数指定。 更多详细可以使用./configure --help查看: 删除编译产生的中间文件 : 1make clean &amp;&amp; make distclean 成果: 为vim创建一个桌面图标: vim.desktop: 1234567891011[Desktop Entry]Name=Vim[compiled by rovo98]Version=8.1Exec=vim %fComment=Vim is a highly configurable text editor for efficiently creating and changing any kind of text.Icon=/usr/share/vim/vim81/src/vim.icoType=ApplicationMimeType=text/plain;Terminal=trueEncoding=UTF-8Categories=Utility; 把vim.desktop放到/usr/share/applications/下就行了。 现在可以享受你自己编译的vim了。 参考链接: https://vi.stackexchange.com/questions/13564/why-is-vim-for-debian-compiled-without-clipboard https://stackoverflow.com/questions/11416069/compile-vim-with-clipboard-and-xterm]]></content>
      <categories>
        <category>Linux</category>
        <category>softwares</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Arch linux系列 安装 haroopad markdown 编辑器]]></title>
    <url>%2Fposts%2F63e58ebb%2F</url>
    <content type="text"><![CDATA[Haroopad 是一个优秀的 Markdown 编辑器，是一个用于创建适宜 Web 的文档的处理器。使用 Haroopad 可以创作各种格式的文档，比如博客文章、幻灯片、演示文稿、报告和电子邮件等。Haroopad 在 Windows、Mac OS X 和 Linux 上均可用。它有 Debian/Ubuntu 的软件包，也有 Windows 和 Mac 的二进制文件。该应用程序使用 node-webkit、CodeMirror，marked，以及 Twitter 的 Bootstrap 。 Haroo 在韩语中的意思是“一天”。 本文主要介绍通过压缩包**.tar.gz的方式安装 Haroopad. 一、下载 Haroopad我们可以从官网直接下载我们需要的压缩包，官网地址: Haroopad官网地址 这里我选择的是linux binary 64 位的压缩包。 二、解压并安装Haroopad根据下载的压缩包格式进行解压： 例如 **.tar.gz格式 解压并放到/opt/目录下: 12345tar zxvf haroopad-v0.13.1.x64.tar.gz -C haroopadsudo cp -r haroopad /opt/tar zxvf data.tar.gztar zxvf control.tar.gz 把解压出来的 usr中的文件放到/usr/下： 1234sudo cp -r ./usr /# 执行 postinstchmod 755 postinstsudo ./postinst 三、修复桌面图标为haroopad 换一个合适的桌面图标: 1sudo vim /usr/share/applications/Haroopad.desktop 123456789101112[Desktop Entry]Name=haroopadVersion=0.13.1Exec=haroopadComment=The Next Document processor based on Markdown#Icon=haroopadIcon=/usr/share/icons/hicolor/128x128/apps/haroopad.pngType=ApplicationTerminal=falseStartupNotify=trueEncoding=UTF-8Categories=Development;GTK;GNOME; 四、配置Haroopad相关的Haroopad设置，可以打开 偏好设置进行配置: 到此，Haroopad 安装就完成了。 参考链接: https://www.jianshu.com/p/dba9acabf0a7]]></content>
      <categories>
        <category>Linux</category>
        <category>softwares</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Manjaro linux 安装与配置]]></title>
    <url>%2Fposts%2Fa1898ce2%2F</url>
    <content type="text"><![CDATA[Manjaro是一款基于Arch Linux、对用户友好、全球排名第一的Linux发行版。（排名数据源于DistroWatch，统计日期2018.08.22，时间段3个月。）在Linux圈，Arch的确是一个异常强大的发行版。它有3个无与伦比的优势： 滚动更新可以使软件保持最新； AUR软件仓库有着世界上最齐全的Linux软件（参考《一张列表展示ArchLinux系软件有多丰富——看哭百万Debian、RedHat系同学》）； 丰富的wiki和活跃的社区让所有问题都可以快速得到满意的答案。 相比于Arch linux, 不得感叹, 人生苦短,我用 Manjaro啊! 一、Manjaro的安装镜像下载官方网站：https://manjaro.org/get-manjaro/选择自己喜欢的桌面环境就好，目前官方支持包括xfce、kde、gnome三种桌面环境。而在官方的社区版本中提供更多桌面环境的支持，比如国产的deepin桌面环境 但是官方服务器在海外，所以我们也可以选择国内开源镜像进行下载清华大学开源镜像：https://mirrors.tuna.tsinghua.edu.cn/manjaro-cd/ 由于我基本都把上述的版本和一些社区版本安装过(出于各种原因&gt;_&lt;)，我建议是从官方网站下载最新的官方版本进行安装(好像清华大学源的镜像并不是最新的)，至于桌面环境的选择，看个人，我选择的是KDE(其实，桌面环境在安装之后也是可以换的)。 制作U盘启动盘manjaro官方提供的Manjaro User Guide手册里面介绍了使用 来制作镜像的方法许多方法，例如： Linux系统下，使用 dd命令来制作：sudo dd if=manjaro-xfce-17.1-stable-x86_64.iso of=/dev/sdc bs=4M, of指定烧录U盘的挂载位置; 在windows系统下使用烧录软件Rufus来进行烧录: [注意]： 烧录完成后，在进入Live系统前，需要对BIOS进行一些设置，关闭安全启动。之后即可顺利进入这个界面(至于BIOS vs UEFI的启动进入的Live系统的方式，详见手册。由于我安装的是多个系统，所以是GPT+UEFI引导): 安装系统进入启动菜单界面后，可以对一些基本的选项进行配置，如，时区，语言，键盘布局等。 具体的安装步骤请直接参考官网的Manjaro User Guide.pdf,这里主要说说安装系统时可能遇到的问题(我基本踩过的坑…)。 对于双显卡的电脑,特别是有Nvidia卡的: 在进入live系统之前,可以将Driver选项设置为no-free(让系统自动安装合适的闭源驱动),并在boot项那里按E编辑, 在boot那一行将nouveau.modeset=1设置为nouveau.modeset=0来禁用开源nouveau驱动,然后进入Live安装系统。但是,安装完系统后重启还有可能进不去桌面,可以尝试在Grub菜单启动界面按[E]编辑,找到quite并在后面加入(注意空格): acpi_osi=! acpi_osi=&#39;Windows 2009&#39;或者acpi_osi=! acpi_osi=Linux acpi_osi=&#39;Windows 2015&#39; pcie_port_pm=off(很多硬件厂商的BIOS驱动都对Linux不友好(我的电脑就是这样的…)，无法顺利加载ACPI模块，而导致无法驱动独立显卡,acpi_osi=’Windows 2009’的意思是告诉ACPI模块，我是‘Windows 7’，别闹情绪了，赶紧工作吧。)接着按 F10 进入系统。顺利进入系统后,将这些内核启动参数配置永久生效(修改grub的配置文件):sudo vim /etc/default/grub在GRUB_CMDLINE_LINUX中添加参数:之后更新 grub文件:sudo update-grub或sudo grub-mkconfig -o /boot/grub/grub.cfg参考链接: https://forum.manjaro.org/t/a-start-job-is-running-for-livemedia-mhwd-script/3395/15 https://wiki.archlinux.org/index.php/Kernel_parameters https://www.kernel.org/doc/Documentation/admin-guide/kernel-parameters.txt 启动时出现的ACPI ERROR问题，很多都说是内核版本的原因，有尝试过添加内核启动参数acpi=off，启动正常进入系统，但键盘无法使用，所以这个提示ACPI错误的问题，由于不影响使用，所以可以不管(强迫症的可以再看看) 参考链接: https://forum.manjaro.org/t/acpi-error-during-boot/35125 屏幕亮度无法调节或异常的问题： Arch Wiki已经给出很详细的解决方法:链接: https://wiki.archlinux.org/index.php/backlight例如：开机亮度设置: vim /etc/rc.local:12345678910111213#!/bin/sh -e## rc.local## This script is executed at the end of the each multiuser runlevel.# Make sure that the script will &quot;exit 0&quot; on successs or any other value on error# # In order to enable or disable this script just change the execution bits.# # By default this script does nothing.echo 127 &gt;&gt; /sys/class/backlight/intel_backlight/brightnessexit 0 对于安装Manjaro系统出现的问题，大多数都可以在官方的论坛Manjaro Forum以及Manjaro Wiki，还有Arch Linux的Arch Wiki以及上找到解决方法。 二、Manjaro 配置简单说一下一些安装系统之后的一些常规配置。 配置更新源并更新系统 配置中国的mirrors： 1sudo pacman-mirrors -i -c China -m rank 在 /etc/pacman.conf中添加archlinuxcn源: 123[archlinuxcn]SigLevel= TrustedOnlyServer = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch 安装archlinuxcn-keyring: 1sudo pacman -S archlinuxcn-keyring 同步并更新系统； 1sudo pacman -Syyu 安装配置中文输入法 安装中文输入法和fcitx管理工具: 123sudo pacman -S fcitx-sougoupinyin # 输入法看个人sudo pacman -S fcitx-imsudo pacman -S fcitx-configtool 解决中文输入法无法切换问题: 添加文件~/.xprofile: 123export GTK_MODULE=fcitxexport QT_IM_MODULE=fcitxexport XMODIFIERS=&quot;@im=fcitx&quot; 重启即可。 配置Intel 和 Nvidia 双显卡切换Manjaro 提供了强大的硬件检测模块mhwd，可以很方便的安装各种驱动，要实现Intel 和 Nvidia 双显卡切换，我们需要安装video-hybrid-intel-nvidia-bumblebee nvidia闭源驱动和intel驱动的混合版bumblebee。对于之前安装系统是在Live启动菜单选择Driver=no-free的可以看看这个驱动是否已经安装：系统设置中的硬件设置:或 对于未安装的，这里提供一个最为简单的方式，直接在硬件设置中，右键安装即可，这样可以省去自己去添加用户组和开机启动，以及切换状态初始化 [注意：] 下面的这些依赖必须安装，否则会出现独立显卡无法正常工作的问题(fps跟集成显卡差不多)： 1sudo pacman -S virtualgl lib32-virtualgl 对于独立显卡的使用，可以使用bbswitch来进行切换开关，然后使用optirun来运行程序: 首先查看显卡的状态: lspci | grep -i nvidia(rev ff 表示关闭状态) 打开独立显卡，并进行测试，对比集成显卡的fps： 集成显卡 FPS: 打开独立显卡sudo tee /proc/acpi/bbswitch &lt;&lt;&lt; &quot;ON&quot;,测试FPS: 独立显卡设置 nvidia-settings 需要用optirun nvidia-setting -c :8才能打开: 使用 zsh 和 oh-my-zsh 配置终端我的 zsh 终端模拟器(theme: rjkirch_mod)： 基本配置过程： 查看系统安装了多少shell cat /etc/shells 查看当前shell : echo $SHELL 使用 chsh切换默认shell. 配置 zsh，直接使用oh-my-zsh来进行配置: Oh-my-zsh.zsh 主题可以自行按个人喜好配置，当然也可以随机(每次打开终端都随机选择一个主题). 插件推荐: (插件配置太多的话，会使shell启动速度变慢，适当就好) Autojump zsh-syntax-highlighting zsh-autosuggestions 总结Manjaro的安装和基本配置就到此结束。最后，简单说一下我安装此系统的缘由。在安装manjaro之前，我使用的是win10 LTSB 2016，之前接触过的的Linux发行版是CentOS, Unbuntu以及 kali， 前两者我不怎么想要，本来想直接换成kali，但是考虑到kali一般是作为一个工具来使用，并不适合我平时开发和日常使用，就再次寻找适合的Linux发行版，最后看上了Arch Linux，但是又因为Arch上手难度较高，退而求其次，选择了Manjaro。当然啦，Win10肯定是要保留的，Kali也是要的。 于是乎，在原先的GPT+UEFI引导方式的基础之上，我重新分配了我的磁盘，将原有的Win10系统盘缩小，把它当备用系统，Manjaro作为主要系统使用，而Kali只作为工具使用，其他的磁盘分区作为数据存放的分区，各个系统共用。 然后使用 REfind来管理和引导系统: 对于Refind有兴趣的可以直接google或baidu了解一下，选择一个现有的主题然后自己稍微进行配置一下，就可以了。参考: http://www.rodsbooks.com/refind/ Arch Wiki 上关于refind的内容) 各个系统桌面 Win10 LTSB Manjaro 17.1.12 (DE: KDE) Kali 2018.1(upgraded)]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>manjaro</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爬取校内腾讯企业邮箱通信录]]></title>
    <url>%2Fposts%2Fe675b5d9%2F</url>
    <content type="text"><![CDATA[简单使用python request + re 爬取校内邮箱通信录(腾讯企业邮箱)的用户信息数据。 一、分析需要爬取的数据通过手动打开浏览器，正常访问网站，判断需要爬取的数据是静态还是动态数据，制定不同的爬取方案。 1. 静态/动态 数据类型判断登陆企业校内邮箱，可以看到需要获取的内容主要呈现在该页面: F12打开控制台，查看Elements，可以很容易发现，用户数据在目录节点没有展开的情况下，html文档中并不会包含我们需要的数据，当点击展开目录节点后，才能获取到数据。因此，可以判断，我们需要爬取的数据是动态生成的，可以初步认为是通过AJAX异步请求来从服务器端获取数据的。 2. 数据定位我们已经知道了需要爬取的数据是动态生成的，这时，同样F12打开控制台，到Network栏目下，查找类型为XHR(AJAX的请求链接)的请求链接，并按数据文件大小从到小排序，再次刷新页面，点击通讯录栏目，展开到具体的用户项，依次点击XHR以确定需要的数据是通过哪个链接获取的： 可以看到，请求链接格式为:https://exmail.qq.com/cgi-bin/laddr_biz?t=memtree&amp;limit={limit}&amp;partyid={pid}&amp;action=show_party&amp;sid={sid},参数有 - Argument Description t 取值不变,memtree，具体含义就不管了 limit 链接中取值:500,单次获取用户的最大数量，我们可以自己修改，再次发起请求来验证 partyid 变化值，为所属组的id,例如：学生 -&gt; 专业 -&gt; 院系学生所属专业partyid就是的专业的id,etc. action 在此链接中不变，取值:show_party sid 用户登陆后生成的sid值，访问过程中不变 通过上面的分析，我们可以知道，要获取所有学生的信息，主要是在获取所有的专业的id后，依次作为上面链接的partyid来发起请求即可。 尝试在html Elements文档中搜索，能够搜到相应的数据，但它也是动态生成的 - 继续在Network中将过滤类型设置为doc同时按文件大小排序，查找包含oPartyList的文件 - 到此，我们所有的分析任务已经结束了，接下来只需要编写相应的爬虫程序即可。 二、爬虫程序设计这里只是编写一个简单的爬虫程序，不使用IP代理，爬虫发起请求所需的sid通过用户自己登陆后手动获取，相应的cookie也是如此。 1. 获取所有专业的id上面分析提到的，要获取用户数据，主要是要先获取到用户所在的组idpartyid。 123456789101112131415161718192021def getAllPID(): """ 获取所有的专业id,作为用户的pid. """ sid = 'xxx' # 用户登陆后的sid all_parties_url = 'https://exmail.qq.com/cgi-bin/laddr_biz?action=show_party_list&amp;sid=&#123;sid&#125;&amp;t=contact&amp;view=biz'.format(sid=sid) cookies = dict(...) # cookie参数和值 request = request.get(all_parties_url,cookies=cookies) regexp = r'&#123;id:"(\S*?)", pid:"(\S*?)", name:"(\S*?)", order:"(\S*?)"&#125;' results = re.findall(regexp,text) all_parties_ids = [] # 所有pid all_parties_info = dict() # 所有组信息 root_party = None # 根通信组 for p in results: all_parties_id.append(p[0]) party = dict(id=item[0], pid=item[1], name=item[2], order=item[3]) all_parties_info[item[0]] = party if p[1] == 0 or p[1] == '0': root_party = party 2. 获取学生信息数据依次遍历pid列表，构造不同的pid不同的链接，来获取全部的通讯录内容。 1234567891011121314151617181920212223def getAllUserInfo(): ... 获取所有通讯录用户信息 ... all_user_info = [] # 用于保存所有用户数据信息 # 获取用户数据的链接 party_user_url = 'https://exmail.qq.com/cgi-bin/laddr_biz?t=memtree&amp;limit=&#123;limit&#125;'\ '&amp;partyid=&#123;pid&#125;&amp;action=show_party&amp;sid=&#123;sid&#125;' regexp = r'&#123;uin:"(\S*?)", pid:"(\S*?)", alias:"(\S*?)", sex:"(\S*?), pos:"(\S*?)", tel:"(\S*?)",'\ ' birth:"(\S*?)(\S*?)(\S*?)(\S*?)", slave_alias:"(\S*?)(\S*?)(\S*?)", department:"(\S*?)(\S*?)", mobile:"(\S*?)"&#125;' for pid in all_parites_ids: # 依次构造不同pid的请求链接 url = party_user_url.format(limit=limit, pid=pid, sid=sid) request = requests.get(url, cookies=cookies) text = request.text results = re.findall(regexp, text) for item in results: user = dict(uin=item[0], pid=item[1], name=item[2], alias=item[3], sex=item[4], pos=item[5], tel=item[6],birth=item[7], slave_alias=item[8], department=item[9], mobile=item[10]) all_user_info.append(user) 完整的程序，请移步到Github查看. 三、爬取结果]]></content>
      <categories>
        <category>Python</category>
        <category>python爬虫</category>
      </categories>
      <tags>
        <tag>Spider demo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决Github国内访问出现的问题]]></title>
    <url>%2Fposts%2F7e3029b3%2F</url>
    <content type="text"><![CDATA[主要通过修改hosts文件解决Github在国内访问不了、访问慢和页面加载异常的问题(没钱买vpn~)。 简单了解一下github, github是目前全球最大的男性同性交友网站(~滑稽~), 使用示例如下： 开个玩笑，回归正题。 为什么访问不了以及访问速度会很慢？GitHub在中国大陆访问速度慢的问题原因有很多，但最直接和最主要的原因是GitHub的分发加速网络的域名遭到DNS污染。 由于GitHub的加速分发CDN域名assets-cdn.github.com遭到DNS污染，导致无法连接使用GitHub的加速分发服务器，才使得中国大陆访问速度很慢。 如何解决DNS污染？一般的DNS问题都可以通过修改Hosts文件来解决，GitHub的CDN域名被污染问题也不例外，同样可以通过修改Hosts文件解决。 将域名解析直接指向IP地址来绕过DNS的解析，以此解决污染问题。 获取被污染域名的实际IP地址访问ipaddress.com,使用ip lookup 工具获得相关域名的ip地址。 例如： github.com 可以看到，我查出的域名ip地址为： 192.30.253.112 和 192.30.253.113 (任取一个即可) 修改host文件，在文件中添加一行：[注] ： windows的hosts文件位置为： C:/windows/system32/drivers/etc/hosts 1192.30.253.112 github.com 刷新dns缓存打开命令行cmd,输入如下命令： 1ipconfig /flushdns 此时再刷新页面即可。此时可以正常访问github，但是访问速度还是很慢，我们接着做优化。 Github 访问提速在hosts文件中继续加入，如下代码： 12345678910111213141516171819# GitHub Start192.30.253.112 github.com192.30.253.119 gist.github.com151.101.228.133 assets-cdn.github.com151.101.228.133 raw.githubusercontent.com151.101.228.133 gist.githubusercontent.com151.101.228.133 cloud.githubusercontent.com151.101.228.133 camo.githubusercontent.com151.101.228.133 avatars0.githubusercontent.com151.101.228.133 avatars1.githubusercontent.com151.101.228.133 avatars2.githubusercontent.com151.101.228.133 avatars3.githubusercontent.com151.101.228.133 avatars4.githubusercontent.com151.101.228.133 avatars5.githubusercontent.com151.101.228.133 avatars6.githubusercontent.com151.101.228.133 avatars7.githubusercontent.com151.101.228.133 avatars8.githubusercontent.com192.30.253.116 api.github.com# GitHub End 注意 : 这里域名对应的ip是通过dns查询工具查询得到的，你应当选择的是延时相对较小且比较稳定的ip。 例如，上面的151.101.228.133是对我来说较好的ip: 推荐的dns查询检测工具： DNS查询 - 在线工具 DNS检测|DNS查询-站长工具 你可对单个域名多查询几次，以挑选稳定且速度较快的ip。 快速地访问github再次刷新dns缓存后，你已经可以快速地访问github了。 参考：https://github.com/chenxuhua/issues-blog/issues/3]]></content>
      <categories>
        <category>tips</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PPP 点对点通信验证]]></title>
    <url>%2Fposts%2F28ff89ad%2F</url>
    <content type="text"><![CDATA[使用Cisco Packet Tracer7 (思科网络模拟器)验证ppp点对点通信。 实验内容使用packet Tracer 模拟两台路由器，进行点对点通信测试。 实验步骤配置路由器由于只需要验证点对点通信，对路由器的配置，相对比较简单，路由器之间使用的是serial DCE 串口线相连。 配置Router1的serial 2/0串口为ip: 11.0.0.1 mask: 255.0.0.0,并配置时钟频率为64000 1234567Router&gt; enableRouter# configure terminalRouter(config) # hostname RARA (config) # interface serial 2/0RA (config) # no shutdownRA (config-if) # ip address 11.0.0.1 255.0.0.0RA (config-if) # clock rate 64000 配置Router2的serial 3/0 串口为ip: 11.0.0.2 mask： 255.0.0.0 123456Router&gt; enableRouter# configure terminalRouter(config) # hostname RBRB (config) # interface serial 3/0RB (config) # no shutdownRB (config-if) # ip address 11.0.0.2 255.0.0.0 查看两个路由的串口状态： RA: RB: 可以看到，路由器这里点对点通信默认使用的HDLC(High Level Data Link Control, 面向比特的同步协议)协议。 HDLC情况下验证ping：11.0.0.1 ping 11.0.0.2: 11.0.0.2 ping 11.0.0.1: ping 测试成功。 配置RA,RB使用ppp协议，再做ping测试： 先配置RA 使用 ppp协议： 123RA # configure terminalRA (config) # interface serial 2/0RA (config-if) # encapsulation ppp 可以看到RA当前使用的是ppp写协议，LCP处于Closed,此时，路由器应当无法进行点对点通信。 配置RB使用ppp协议： 123RB # configure terminalRB (config) # interface serial 3/0RB (config-if) # encapsulation ppp 这时，可以看到RB也是使用了ppp协议，且LCP也处于Open状态，路由器之间可以进行通信。 给ppp协议添加authentication鉴别 先配置RA，使其开启ppp chap (Challenge Handshake Authentication Protocol), 给RB 添加身份验证 1234RA # config terminalRA (config) # username RB password passwordRA (config) # interface serial 2/0RA (config-if) # ppp authentication chap 此时，虽然RA和RB都是使用ppp协议，但是RA给RB添加了身份认证，而RB则没有，此时LCP处于Closed状态，它们之间无法进行通信。 配置RB, 添加对RA的身份验证： 1234RB # config terminalRB (config) # username RA password passwordRB (config) # interface serial 2/0RB (config-if) # ppp authentication chap 可以看到此时，LCP已经打开，路由器之间可以进行点对点通信。 实验结果通过该实验，简单地验证了ppp协议在点对点信道中的使用。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>ppp通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用ensp进行简单的路由器互连实验]]></title>
    <url>%2Fposts%2Fcc46ce96%2F</url>
    <content type="text"><![CDATA[使用ensp做华为AR1220路由进行简单的互连实验。 实验内容 路由器设置 手动设置静态路由 实验环境 华为路由器AR1220 主机 Serial设备连接串口线和Copper以太网和千兆以太网连接线 备注：所有实验设备均由ensp模拟。 路由连接实验设计整体设计结构如下： 1.其中分为六个不同的局域网； 12345678910111213141516171819192.168.11.0 网段 -&gt; 主机: 192.168.11.11 192.168.11.12 路由器AR6一个GigabitEthernet接口作为该网段的默认网关(192.168.11.1)192.168.12.0 网段 -&gt; 主机: 192.168.12.11 192.168.12.12 路由器AR4的一个GigabitEthernet接口作为该网段的默认网关(192.168.12.1)192.168.13.0 网段 -&gt; 主机: 192.168.13.11 192.168.13.12 192.168.13.13 路由器AR7的一个GigabitEthernet接口作为该网段的默认网关(192.168.13.1) 1.1.2.0 网段 -&gt; 路由器AR6和路由器AR7之间的接口1.1.1.0 网段 -&gt; 路由器AR6和AR4之间的接口1.1.3.0 网段 -&gt; 路由器AR6和AR7之间的接口 2.设备的连接： 除了路由器之间连接使用serial串口连接线外，其他均使用Copper连接线。 实验步骤配置各个局域网的ip及其网关 例如：192.168.11.0网段下的192.168.11.11主机： 配置 192.168.11.1作为192.168.11.0网段的网关： 所有主机经过配置后，他们应该可以ping通自己网段下的所有主机，如：192.168.11.12 ping 192.168.11.11 [需要注意的是]： 由于路由器互连时使用的是serial串口，所以路由器之间配置的是serial串口的ip。 例如：配置AR6的两个serial串口的接口ip为：1.1.1.1和1.1.2.1： 123456&lt;Huawei&gt; system-view[Huawei] inter serial 2/0/1[Huawei-Servial2/0/1] ip address 1.1.1.1 255.255.255.0[Huawei-Servial2/0/1] quit[Huawei] inter serial 2/0/0[Huawei-Serial2/0/0] ip address 1.1.2.1 255.255.255.0 各个路由器的静态路由：对于路由器AR6,我们希望所有目的网络为192.168.12.0的数据包都交付给AR4,即下一跳为1.1.1.2;所有目的网络为192.168.13.0的都交给AR7,下一跳为1.1.2.2： 123&lt;Huawei&gt; system-view[Huawei] ip route-static 192.168.12.0 255.255.255.0 1.1.1.2[Huawei] ip route-static 192.168.13.0 255.255.255.0 1.1.2.2 对于路由器AR4，所有目的网络为192.168.11.0的数据包交给AR6，下一跳为：1.1.1.1，目的网络为192.168.13.0的数据包交给AR7，下一跳为：1.1.3.1： 123&lt;Huawei&gt; system-view[Huawei] ip route-static 192.168.11.0 255.255.255.0 1.1.1.1[Huawei] ip route-static 192.168.13.0 255.255.255.0 1.1.3.1 对于路由器AR7， 所有目的网络为192.168.11.0的数据包都交给AR6，下一跳为：1.1.2.1，所有目的网络为192.168.12.0的数据包都交给AR4，下一跳为：1.1.3.2： 123&lt;Huawei&gt; system-view[Huawei] ip route-static 192.168.11.0 255.255.255.0 1.1.2.1[Huawei] ip route-static 192.168.12.0 255.255.255.0 1.1.3.2 经过以上对各个路由器的静态路由的配置后，我们可以通过1display ip routing-table 来查看各个路由器的路由表： AR6路由表： AR4路由表： AR7路由表： 测试实验结果使用任意一个局域网下的主机ping不同局域网下的主机： 192.168.11.11 ping 192.168.13.12 和 192.168.12.12: 192.168.12.11 ping 192.168.11.12 和 192.168.13.13: 192.168.13.11 ping 192.168.11.11 和 192.168.12.11： 由以上测试可以看出简单的路由器连接实验成功。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>路由器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Computer Network | 计算机网络]]></title>
    <url>%2Fposts%2F7fc520f1%2F</url>
    <content type="text"><![CDATA[计算机科学核心内容学习，译自GeeksforGeeks. 计算机网络作为计算机科学核心课程之一，是认识计算机网络、了解网络应用程序开发技术、探索计算机网络深层机理、了解计算机网络安全威胁及其防护技术等内容的必须学习的课程。 基础 | Basics 计算机网络基础 互联网和网络 计算机网络的目标 计算机网络的链路配置 计算机网路的传输模式 传输媒体的类型 单播，广播，多播 网络拓扑 区域网类型-LAN，MAN，WAN 接入网 TCP/IP模型 OSI参考模型分层 数据链路层 | Data Link Layer 局域网(LAN)技术 网络互联 数据链路层中的帧 MAC地址介绍 MAC过滤 多点接入协议 以太网帧格式 以太网信道 字节填充和位填充之间的区别 用Java实现字节填充 电路交换 分组交换和时延 电路交换 VS 分组交换 虚电路网络和数据报网络之间的区别 报文交换 无噪声和噪声信道上的最大数据速率(信道容量) 无线网络中的冲突避免(Colision Avoidance) 载波监听多点接入(CSMA) CSMA/CD中的碰撞检测(Colision Detection) CSMA/CD的效率 CSMA/CD退避算法 控制访问协议 虚拟局域网(VLAN) 网络层 | Network Layer传输层 | Transport Layer应用层 | Application Layer网络安全与密码学 | Network Security and Cryptography压缩技术 | Compression Techniques网络实验 | Network Experiments设备 | Devices杂项 | Misc]]></content>
      <categories>
        <category>GeeksforGeeks</category>
        <category>Computer Network</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络中的传输模式 | Transmission in Computer Network]]></title>
    <url>%2Fposts%2F2ccb698e%2F</url>
    <content type="text"><![CDATA[了解计算机网络中的传输模式 — 译自GeeksforGeeks. 传输模式(transmission mode)意味着在两个设备之间传输数据。它也被称为通信模式(communication mode)。总线和网络旨在允许互连的各个设备之间进行通信。传输模式有下面三种类型 - 单工传输模式 (Simplex Mode) 半双工传输模式 (Half-Duplex Mode) 全双工传输模式 (Full-Duplex Mode) 单工传输模式 (Simplex Mode) 在单工模式下，通信是单向的，就像在单行道上一样。链路上的两个设备中只有一个可以传输，另一个只能接受。单工模式可以使用通道的整个容量在一个方向上发送数据。 示例： 键盘和传统显示器。键盘只能引入输入，显示器只能输出。 半双工传输模式 (Half-Duplex Mode) 在半双工模式下，每个站点都可以发送和接受数据，但是不能同时发送和接受数据。当一个设备发送时，另一个设备只能接受，反之亦然。半双工模式用于不需要同时在两个方向上进行通信的情况。可以为每个方向利用整个信道的容量。 示例：对讲机，其中每一次只能一方发送消息，一方接受消息。并且可以在两个方向上发送消息。 全双工传输模式 (Full-Duplex Mode) 在全双工模式下，两个站点可以同时发送和接受数据。一个方向上的信号与另一个方向上的信号共享信道链路容量，这种共享可以通过下面两种方式实现 - 链路包含两个物理上独立的传输路径(物理划分信道容量资源)，一个用于发送，一个用于接受； 在两个方向上传播的信号之间分配容量(信道复用, Multiplexing) 当始终需要双向通信时，使用全双工模式。但是，信道的容量必须在两个方向之间分配。 示例：电话网络，通过电话线两个人之间的通信，可以同时进行通话和接受。 返回到计算机网络主目录]]></content>
      <categories>
        <category>GeeksforGeeks</category>
        <category>Computer Network</category>
        <category>Basics</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络中的链路配置 | Line configuration in computer network]]></title>
    <url>%2Fposts%2F0%2F</url>
    <content type="text"><![CDATA[了解计算机网络中的链路配置，译自GeeksforGeeks. 网络是通过链路连接的两个或更多设备。链路是将数据从一个设备传输到另一个设备的通信路径。设备可以是计算机，打印机或任何其他能够发送和接受数据的设备。出于可视化的目的，将任何链路想象为两点之间绘制的线。 为了进行通信，必须以某种方式将两个设备同时连接到同一链路上。有两种可能的连接类型 - 点对点连接(Point to Point Connection) 多点连接(Multipoint Connection) 点对点连接 (Point to Point Connection) 点对点连接提供两个设备之间的专用链接; 链路的整个容量都用于这两个设备之间的传输; 大多数点对点连接使用实际长度的电线或电缆连接两端，但也可以使用其他选项，如微波或卫星链路; 点对点网路拓扑被认为是最简单和最传统的网络之一; 点对点连接的建立和理解也是最简单的. 例如： 远程控制和电视之间使用点对点连接来更改频道。 多点连接 (Multipoint Connection) Multipoint也可以是Multidrop,使用该连接的两个设备共享一个单一的链路; 两个以上的设备共享信道的容量，通过共享容量，多点链路配置有两种类型 - 空间共享(Spatial Sharing):如果多个设备可以同时共享链路，则称为空间共享线路配置; 时间共享(Temporal/Time Sharing):如果用户必须轮流使用该链路，则称其为时间共享链路配置. 返回到计算机网络主目录]]></content>
      <categories>
        <category>GeeksforGeeks</category>
        <category>Computer Network</category>
        <category>Basics</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络目标 | Network goals]]></title>
    <url>%2Fposts%2F8a6daeb5%2F</url>
    <content type="text"><![CDATA[计算机网络是指用于信息交换的自主(独立)计算机的互连。连接介质可以是铜线，光纤，微波或卫星。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; —— 了解计算机网络的目标。译自GeeksforGeeks. 网络元素 (Networing Elements)计算机网络包括以下网络元素 - 至少两个主机; 传输介质有线或无线; 管理通信的协议或规则; 网络软件，例如网络操作系统. 网络标准 (Network Criteria)计算机网络必须满足的标准是 : 1. 性能 (Performance)性能根据传输时间和响应时间来衡量 - 传输时间是消息(数据)从一个设备到另一个设备的时间; 响应时间是请求和响应之间经过的时间. 性能取决以下的因素 - 用户的数量 传输媒体的类型 连接网络的传输能力 软件的效率 2. 可靠性 (Reliability)它的衡量标准是 - 失败的频率 从失败中恢复的能力 灾难期间的健壮性 3. 安全性 (Security)安全性主要是保护数据避免未授权的请求访问。 计算机网络的目标下面列出的是计算机网络的重要目标 - 资源共享(Resource Sharing) - 许多组织在运营中拥有大量的计算机，而它们是分开的。例如：一组办公室工作人员可以共享通用的打印机，传真，调制解调器，扫描仪等。 高可靠性(High Reliability) - 如果有备用供应源，则可以在两台或多台计算机上复制所有文件。如果硬件故障，其中一个不可用，则可以使用其他副本。 进程间通信(Inter-process Communication) - 位于地理上分开的网络用户可以通过网络在交互式会话中进行交谈。为了实现这一点，网络必须提供几乎无差错的通信。 灵活访问(Flexible access) - 可以从网络中的任何计算机访问文件。一个项目可以从一台计算机开始，在另一台计算机上完成。 计算机网络的其他目标是实现处理功能的分配，网络资源的集中管理和分配，不同设备和软件的兼容性，良好的网络性能，省钱，可扩展性，访问远程信息，人与人之间通信等。 原地址:https://www.geeksforgeeks.org/computer-network-network-goals 返回到计算机网络主目录]]></content>
      <categories>
        <category>GeeksforGeeks</category>
        <category>Computer Network</category>
        <category>Basics</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[互联网与网络 | The Internet and the Web]]></title>
    <url>%2Fposts%2F28f758bc%2F</url>
    <content type="text"><![CDATA[了解互联网与网络的概念以及它们之间的区别，译自GeeksforGeeks。 互联网 (The Internet)互联网，简而言之，它是使用标准化的通信协议的较小网络互连而成的全球网络。Internet标准描述了称为Internet协议栈的框架。该模型将方法分为分层的协议系统。 分层如下 - 应用层(Application layer, 最高层) - 关注数据(URL,类型等等)，其中包含HTTP, HTTPS等; 传输层(Transport layer) - 负责网络上的端到端的通信; 网络层(Network layer) - 提供数据路由. 互联网提供各种信息和通信设施，包含论坛，数据库，电子邮件，超文本等。它由本地和全球范围内的私人，公共，学术，商业和政府网络组成，通过广泛的电子，无线和光纤网络技术相互联系。 万维网 (The World Wide Web)网络是互联网的一个子集。它是一个支持特殊格式文档的Internet服务器系统。文档采用称为HTML(支持链接，多媒体等)的标记语言格式化。这些文档使用超文本链接相互来链接，可通过Internet访问。 要将超文本链接到Internet，我们需要 - 文本标记语言，例如， HTML; 传输协议，例如， HTTP; 统一资源定位器(Uniform Resource Locator, URL),资源的地址. 可以使用Web浏览器访问Web. 互联网与网络之间的区别 Internet Web 互联网是库和网络的集合。互联网还包含数据库，电子邮件，论坛等。 Web是互联网的一个子集。网络是互联网的很大一部分，但并不是全部。 互联网是一个网络，一种传输内容和网络的方式。 Web理想情况下是通过Internet介质访问信息的一种方式。Web是可以托管HTML格式文档的Internet服务器集合。全球各地相互连接的信息页面的集合。每个页面可以是文本和多媒体的组合。 URIURI, 即Uniform Resource Identifier, 统一资源定位符，它像是一个地址，为Web上的资源提供一个唯一的全局标识符。统一资源定位器(URL)是最常用的URI形式。 URL包含两个主要的部分 - 传输使用的协议，例如，HTTP; 域名. 谁管理互联网?互联网不受管理，没有单一的权威机构。互联网协会的最终权威取决于互联网协会或ISOC(Internet Society)。 ISOC是一个自愿成员组织，其目的是通过互联网技术促进全球信息交流。 ISOC任命为IAB(Internet Architecture Board,互联网架构委员会)。他们会定期会面以审查标准并分配资源，如地址; IETF(Internet Engineering Task Force,互联网工程任务组)。另一个志愿者组织定期开会讨论运营和技术问题. 原地址:https://www.geeksforgeeks.org/the-internet-and-the-web 返回到计算机网络主目录]]></content>
      <categories>
        <category>GeeksforGeeks</category>
        <category>Computer Network</category>
        <category>Basics</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络基础 | Basics of Computer Network]]></title>
    <url>%2Fposts%2Fc88d46b1%2F</url>
    <content type="text"><![CDATA[主要了解计算机网络中一些基本的概念，译自GeeksforGeeks. 基本概念开放系统 (Open system)连接到网络并准备好进行通信的系统。 封闭系统 (Closed system)未连接到网络且无法与之通信的系统。 计算机网络 (Computer Network)计算机网络是多个设备进行互连，这些设备通常称为多路径连接的主机，用于发送/接受数据。 还有许多设备和介质是用于协助不同两个不同设备之间的通信的，这些设备就是网络设备(Network devices)。例如：路由器，交换机，集线器，网桥。 使用哪些设备互连的布局模式称为网络拓扑。如:总线型(Bus), 星型(Star), 网状型(Mesh), 环形型(Ring), 以及链状型(Daisy chain)等。 OSIOSI，即Open Systems Interconnection,开放系统互连。它是一个参考模型，指定了通信协议的标准以及每层的功能。 协议 (Protocol)协议是一组规则或算法，它们定义了两个实体如何通过网络进行通信的方式，并且在OSI模型的每一层都存在不同的协议。例如：TCP, IP, UDP, ARP, DHCP, FTP等等。 网络的唯一标识主机名 (Host name)网络中的每一个设备都有与一个唯一设备名称相关联，称为主机名(Hostname)。 我们可以在命令行cmd界面中键入hostname，然后回车来查看主机名 - IP 地址 (Internet Protocol address)IP 地址也称为逻辑地址，是在整个网络中开放系统的网络地址。 为了识别万维网中的每个设备，Internet Assigned Numbers Authority(互联网号码分配局，IANA)将IPV4(版本4)地址分配为Internet上每个设备的唯一标识符。 IP地址的长度为: 32位(因此一共有$2^32$个ip地址可用)。在命令提示符cmd下键入ipconfig并按回车，可以查看设备的ip地址。 MAC 地址 (Media Access Control address)MAC地址也称为物理地址，是每个主机的唯一标识符，并于NIC(Network Interface Card，网络接口卡)相关联。 网卡的生产产商在制造网卡时将MAC地址分配给NIC。MAC地址的长度为： 48位。在命令行提示符cmd中键入ipconfig /all并回车，可以查看MAC地址。 端口 (Port)端口可以称为是逻辑信道，通过该信道可以将数据发送/接受到应用程序。任何主机都可能运行多个应用程序，并且每个应用程序都使用运行它们的端口号进行标识。 端口号是一个16 bit整数，因此一共有$2^16$(65535)个端口号可用,它们可以被分成以下几类 - 端口类型 范围 知名端口(Well known Ports) $0 - 1023$ 注册端口(Registered Ports) $1024 - 49151$ 临时端口(Ephemeral Ports) $49152 - 65535$ 在命令行中键入netstat -a可以查看目前主机正在使用的所有端口号 - SocketIP地址和端口号组成的唯一组合就是Socket。 一些额外概念DNS 服务器DNS,即Domain Name system,域名系统。DNS是将Web地址h或URL(例如： www.google.com)转换为相应的IP地址的服务器。这样我们就不必记住每个网站的所有IP地址。 命令nslookup可以查看所需域名的IP地址。同时也提供了所使用的DNS服务器的信息 - ARPARP，即Address Resolution Protocol(地址解析协议)。它用于将IP地址转换为与其对应的物理地址(即MAC地址)。数据链路层使用ARP来识别接受计算机的MAC地址。 RARPRARP,即Reverse Address Resolution Protocol(逆地址解析协议)。顾名思义，它是逆向将给定的物理地址转换为设备的IP地址。但是自从DHCP出项以来，RARP已经过时了。 原地址: https://www.geeksforgeeks.org/basics-computer-networking 返回到计算机网络主目录]]></content>
      <categories>
        <category>GeeksforGeeks</category>
        <category>Computer Network</category>
        <category>Basics</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7通过yum(yellow dog update modifier) 安装mysql5.7]]></title>
    <url>%2Fposts%2F86d29d2c%2F</url>
    <content type="text"><![CDATA[配置yum源1234# 下载mysql安装源包root @~&gt; wget http://dev.mysql.com/get/mysql57-community-release-el7-8.noarch.rpm# 安装mysql源root @~&gt; yum localinstall mysql57-community-release-el7-8.noarch.rpm 检查mysql源是否安装成功: 1root @~&gt; yum repolist enabled | grep "mysql.*-community.*" 如下图则安装成功: 安装mysql1root@ ~&gt; yum install -y mysql-community-server 启动MySQL服务并设置开机自动启动1root@ ~&gt; systemctl start mysqld 查看MySQL启动状态 12root@ ~&gt; systemctl enable mysqldroot@ ~&gt; systemctl daemon-reload 修改默认密码刚安装完的mysql会自动给root用户分配一个临时密码，而且必须重新设置密码(从5.5版本开始) 先查看root用户的临时密码 1root@ ~&gt; grep "temporary password" /var/log/mysqld.log 使用临时的密码登录进mysql来设置新的密码 1mysql&gt; set PASSWORD = PASSWORD('[YOUR_NEW_PASSWORD]') 可能遇到的问题：设置的密码过于简单mysql报错: 1Your password does not satisfy the current policy requirements. 解决方法：由于刚安装的mysql的密码默认强度是最高的，若想要设置简单的密码就要修改validate_password_policy的值， validate_password_policy有以下取值： Policy Tests Performed 0 or LOW Length 1 or MEDIUM Length;numeric,lowercase/uppercase,and special characters 2 or STRONG Length;numeric,lowercase/uppercase,and special characters; dictionary file 操作： 设置安全级别 1mysql&gt; set global validate_password_policy=0; 设置密码长度为8，可以设置为其他值，最小为4位 1mysql&gt; set global validate_password_length=4; 之后就可以设置简单的密码了。 允许root远程登录12mysql&gt; GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY '[YOUR_PASSWORD]' WITH GRANT OPTION;mysql&gt; flush privileges; 修改字符集编码为UTF-8 查看当前字符编码 1mysql&gt; show variables like "char%'; 检测是否都是utf-8(filesystem除外)，如果不是就需要修改。 character_set_server一般是lantin1。 12345678# 停止mysqld服务systemctl stop mysqld# 进入my.cnf文件，一般是/etc/路径下vim /etc/my.cnf# 在[mysqld]下追加character-set-server=utf-8# 在[mysql]下追加default-character-set=utf-8# 启动mysqldsystemctl start mysqld]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql5.7安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hibernate基础学习]]></title>
    <url>%2Fposts%2Fb19895ed%2F</url>
    <content type="text"><![CDATA[Hibernate是一个对象关系映射ORM的JAVA解决方案。是在2001年由 Gavin King创建的开源持久化框架。适用于任何使用Java应用程序的功能强大的高性能对象关系持久化和查询服务。 概述Hibernate将Java类映射到数据表并将Java数据类型映射到SQL数据类型，使开发人员从95%的常见数据持久化相关编程任务中解脱出来。 Hibernate位于传统的Java对象和数据库服务器之间，以适应基于适当$O/R$机制和模式的持久化对象的保存工作。 一、Hibernate 优势 Hibernate使用XML文件来将Java类映射到数据表，不需要写任何代码。 提供简单的APIs直接将java对象保存到数据库中，或从数据库中检索出来。 数据库或数据表发生改变时，只需要修改XML文件。 不采用不熟悉的SQL类型，而提供一中方法来解决熟悉的Java对象。 Hibernate不需要应用服务器来操作。 可以操纵数据库对象的复杂关联。 使用智能检索策略来最小化数据库的访问。 提供简单的数据查询。 二、支持的数据库Hibernate支持所有主流的关系型数据库(RDBMS)。下面简单地列出Hibernate支持的数据库: HSQL Database Engine DB2/NT MySQL PostgreSQL FrontBase Oracle Microsoft SQL Server Database Sybase SQL Server Infomix Dynamic Server 三、支持的技术Hibernate支持很多其他的技术，包括 XDoclet Spring J2EE Eclipse plug-ins Maven 架构Hibernate拥有一个分层的架构，可以使用户在不了解底层APIs的情况下使用它。Hibernate使用数据库和配置数据来向应用提供持久化服务。 下面是从宏观角度看Hibernate的视图： 从细节视角看Hibernate以及它的核心类： Hibernate使用很多现有的Java API, 例如： JDBC, Java Transaction API(JTA)以及 Java Naming and Directory Interface(JNDI)。JDBC提供了关系数据库通用功能的基本抽象级别，使Hibernate支持几乎所有具有JDBC驱动程序的数据库。JNDI和JTA使J2EE可以集成Hibernate。 下面是针对上面架构图中出现的核心类给出的简单解释。 一、Configuration ObjectConfiguration(配置对象)是在Hibernate应用中第一个被创建的对象，且在Hibernate应用初始化时，只创建一次。它通常代表着Hibernate所需的配置信息或属性。 Configuartion包含一下两个关键的组件: Database Connection(数据库连接) - 通过hibernate支持的一个或多个配置文件来处理的，例如： hibernate.properties和hibernate.cfg.xml。 Class Mapping Setup(类映射设置) - 该组件负责创建Java类和数据表之间的连接。 二、SessionFactory ObjectSessionFactory对象是通过使用Configuration对象创建生成的，该对象可以使用提供的配置文件为应用程序配置Hibernate，并能够实例化Session对象。SessionFactory是一个线程安全对象，并被应用程序的所有线程使用。 Sessionfactory是一个重量级对象，通常在应用程序启动时创建并保留以备后续使用。每个数据库使用单独的配置文件都需要一个SessionFactory对象。因此，如果使用多个数据库，我们可能需要创建多个SessionFactory对象。 三、Session ObjectSession对象主要用来从数据库中获取物理连接。Session是轻量级对象，当每次需要与数据库交互时都可以实例化该对象。持久化对象(persistent Objects)就是通过它来实现保存和检索的。 Session对象一般不会保留很长一段时间，因为它并不是线程安全对象，只能在需要使用的时候创建和销毁。 四、Transaction ObjectTransaction对象代表了数据库的一个工作单元，大多数RDBMS都支持事务功能。Hibernate中的事务由underlying transaction manager(基础事务管理器)以及transaction(事务，来自JDBC或者JTA)。 这是一个可选对象，Hibernate应用程序可以选择不使用此接口，而是使用自己的应用程序的代码来管理事务。 五、Query ObjectQuery对象使用SQL或者Hibernate查询语言（HQL)字符串来从数据库中检索数据以及创建对象。一个Query实例一般是用来绑定查询参数，限制返回结果行数，并执行查询操作的。 七、Criteria ObjectCriteria对象用于创建和执行面向对象的条件查询来检索对象。 Hibernate 配置Hibernate需要事先知道在哪里可以找到定义Java类和数据表的关系的映射信息。Hibernate还需哟啊一组与数据库和其他相关参数相关的配置设置。所有这些信息通常由标准Java属性文件(hibernate.properties)或XML文件(hibernate.cfg.xml)提供。 这里我们只需要考虑hibernate.cfg.xml配置文件的配置。大多数的属性一般都采用默认值，并且不需要在属性文件(hibernate.properties)中制定它们，除非真的需要。配置文件只能保存在应用程序的类路径的根目录中。 一、Hibernate 属性下面列出的使一些重要的属性，当我们在配置数据库时可能会用到： Properties Description hibernate.dialect 数据库方言，该属性能够是Hibernate为选择的数据库生成合适的SQL hibernate.connection.driver_class JDBC 驱动类 hibernate.connection.url 数据库实例的JDBC URL hibernate.connection.username 数据库用户名 hibernate.connection.password 数据库密码 hibernate.connection.pool_size 限制Hibernate数据库连接池中等待的连接数 hibernate.connection.autocommit 允许JDBC连接自动提交 如果使用应用程序服务器和JNDI,则必须配置以下属性： Properties Description hibernate.connection.datasource 在应用服务器上下文中定义JNDI名称 hibernate.jndi.class JNDI的InitialContext类 hibernate.jndi.&lt; JNDIpropertyname &gt; 向JNDI InitialContext传递的属性 hibernate.jndi.url JNDI URL hibernate.connection.username 数据库用户名 hibernate.connection.password 数据库密码 二、在Hibernate中配置 MySQL 数据库MySQL是目前最受欢的开源数据库系统之一。下面通过配置hibernate.cfg.xml文件来配置MySQL数据库，在此之前，确保在MySQL中创建一个testdb数据库，以及test用户。 [notice] : XML配置文件必须符合Hibernate 2 配置 DTD标准。 hibernate.cfg.xml: 123456789101112131415161718192021222324252627282930313233&lt;?xml version = "1.0" encoding = "utf-8"?&gt;&lt;!DOCTYPE hibernate-configuration SYSTEM "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd"&gt;&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;property name = "hibernate.dialect"&gt; org.hibernate.dialect.MySQL5Dialect &lt;/property&gt; &lt;property name = "hibernate.connection.driver_class"&gt; com.mysql.jdbc.Driver &lt;/property&gt; &lt;!-- Assume test is the database name --&gt; &lt;property name = "hibernate.connection.url"&gt; jdbc:mysql://localhost/test &lt;/property&gt; &lt;property name = "hibernate.connection.username"&gt; root &lt;/property&gt; &lt;property name = "hibernate.connection.password"&gt; root &lt;/property&gt; &lt;!-- List of XML mapping files --&gt; &lt;mapping resource = "Employee.hbm.xml"/&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; 上面配置文件中&lt;mapping&gt;标签与hibernate mapping(映射文件)相关。 以下是一些重要的数据库方言属性类型： Database Dialect Property DB 2 org.hibernate.dialect.DB2Dialect HSQLDB org.hibernate.dialect.HSQLDialect HypersonicSQL org.hibernate.dialect.HSQLDialect Informix org.hibernate.dialect.InformixDialect Ingres org.hibernate.dialect.IngresDialect Interbase org.hibernate.dialect.InterbaseDialect Microsoft SQL Server 2000 org.hibernate.dialect.SQLServerDialect Microsoft SQL Server 2005 org.hibernate.dialect.SQLServer2005Dialect Microsoft SQL Server 2008 org.hibernate.dialect.SQLServer2008Dialect MySQL org.hibernate.dialect.MySQLDialect Oracle(any version org.hibernate.dialect.OracleDialect Oracle 11g org.hibernate.dialect.Oracle10gDialect Oracle 10g org.hibernate.dialect.Oracle10gDialect Oracle 9i org.hibernate.dialect.Oracle9iDialect PostgreSQL org.hibernate.dialect.PostgreSQLDialect Progress org.hibernate.dialect.ProgressDialect SAP DB org.hibernate.dialect.SAPDBDialect Sybase org.hibernate.dialect.SybaseDialect Sybase anywhere org.hibernate.dialect.SybaseAnywhereDialect Sessions前面我们已经提到Session使用来获取数据库物理连接的，为轻量级对象，只有需要和数据库发生交互时才进行对象实例化。持久化对象的保存和检索就是通过它来完成的。 Session不能维持太长时间，毕竟它们不是线程安全对象， 只能在需要的时候创建和销毁。Session的主要功能是为映射实体类提供创建、读取和删除操作。 在给定的时间点中，实例可能有下面的这些状态： transient(暂时的) - 一个持久类的新实例，与Session没有关联，并且在数据库中没有表示以及没有标识符值，被Hibernate认为是暂时的。 persistent(持久的) - 我们可以通过将暂时的实例(transient)与Session关联来将它进行持久化。 detached(独立的) - 一旦关闭Hibernate Session对象，持久化对象将转化为独立的对象(detached instance)。 当Session对象中的持久类(persistent classes)是可序列化时，Session也是可序列化的。下面是典型的事务处理代码： 1234567891011121314Session session = factory.openSession();Transaction tx = null;try &#123; tx = session.beginTransaction(); // do some work ... tx.commit();&#125; catch (Exception e) &#123; if (tx != null) tx.rollback(); e.printStackTrace();&#125; finally &#123; session.close();&#125; [notice] : 如果Session抛出异常，事务必须回滚(rollback)并且Session需要丢弃。 一、Session 接口方法Session接口提供了很多方法，下面列出的是其中一些中重要的方法。更多的信息可以查看Hibernate文档中与Session以及SessionFactory相关的完整方法信息。 Session Method Description Transaction beginTransaction() 开启一个工作单元并返回已经关联的事务对象。 void cancelQuery() 取消执行当前查询操作 void clear() 完全清除回话(session) Connection close() 结束回话并释放JDBC连接资源 Criteria createCriteria(Class persistentClass) 为指定的实体类或者实体类的超类创建一个条件查询(Criteria)对象 Criteria createCriteria(String entityName) 根据实体类的名称创建Criteria对象 Serializable getIdentifier(Object Object) 返回与此回话关联的给定实体的标识符值 Query createFilter(Object collection, String queryString) 根据给定的集合(collection)以及过滤字符串创建一个新的Query实例 SQLQuery createSQLQuery(String queryString) 根据给定的SQL查询语句创建一个SQLQuery对象 void delete(Object object) 从数据存储(datastore)中移除持久实例 void delete(String entityName, Object object) 从数据存储中移除持久实例 Session get(String entityName, Serializable id) 根据给定的标识符(identifier)以及实体名返回持久化实例；如果没有该实例，则返回null SessionFactory getSessionFactory() 获取创建该Session实例的SessionFactory对象 void refresh(Object object) 从底层数据库重新读取给定实例的状态 Transaction getTransaction() 获取与该Session关联的Transaction实例 boolean isConnected() 返回当前Session的连接状态 boolean isDirty() 判断Session中是否存在未同步到数据库的脏数据(已经修改过的数据) boolean isOpen() 判断Session是否打开 Serializable save(Object object) 持久化给定的暂时实例，分配一个生成的标识符 void saveOrUpdate(Object object) 对给定的实例执行save(Object)或者update(Object)操作 void update(Object object) 根据给定的独立实例的标识符更新持久化实例 void update(String entityName, Object object) 根据给定的独立实例的标识符更新持久化实例 Hibernate 持久化类Hibernate的整体理念是从Java类属性中取值并将它们保存到数据表中。Hibernate使用给定的映射文件来获取Java类中的属性值，并将它们映射到数据表和相关字段。 在Hibernate中，我们把那些对象或实例将被保存到数据表中的Java类成为持久化类，持久类。一般这些遵循这样的一些简单的规则，即符合Plain Ordinary Java Object(POJO)编程模型。 下面给出的就是持久化类需要遵循的规则，但这并不是硬性要求： 所有的持久化类都需要有一个默认的构造方法； 所有类都需要包含一个ID属性，以便在Hibernate和数据库中轻松识别对象，该属性一般映射到数据表中的主键； 所有需要持久化的属性都应该声明为private并定义getXXX和setXXX方法； Hibernate的一个中心特性是代理，因此依赖的持久化类不能是final类或者实现声明所有公共方法的接口； 所有类不继承或实现EJB框架所需的特定类和接口。 POJO是用来强调给定的对象是一个原始的Java对象，而不是一个特殊的类，也不是一个Enterprise JavaBean。 一、简单POJO例子基于上面提到的规则，定义了下面的一个简单POJO类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Employee &#123; private int id; private String firstName; private String lastName; private int salary; public Employee() &#123;&#125; public Employee(String fname, String lname, int salary) &#123; this.firstName = fname; this.lastName = lname; this.salary = salary; &#125; public int getId() &#123; return id; &#125; public void setId( int id ) &#123; this.id = id; &#125; public String getFirstName() &#123; return firstName; &#125; public void setFirstName( String first_name ) &#123; this.firstName = first_name; &#125; public String getLastName() &#123; return lastName; &#125; public void setLastName( String last_name ) &#123; this.lastName = last_name; &#125; public int getSalary() &#123; return salary; &#125; public void setSalary( int salary ) &#123; this.salary = salary; &#125;&#125; Hibernate 映射文件对象关系映射通常都是定义在一个XML文档中。该映射文件告诉Hibernate如果将定义的Java类映射到数据库中的数据表。 尽管很多Hibernate用户都选择使用人工方式来写XML文档。但是现在有很多现有的工具可以用来生成映射文档，其中包含供Hibernate高级用户使用的XDoclet, Middlegen以及AndroMDA。 对于之前给出的简单的POJO类，假设它需要保存到下面的RDBMS数据表中，以及从中检索数据: 1234567create table EMPLOYEE ( id int not null auto_increment, first_name varchar(20) default null, last_name varchar(20) default null, salaary int default null, primary key (id)); 定义映射文件: 12345678910111213141516171819202122&lt;?xml version = "1.0" encoding = "utf-8"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD//EN""http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt; &lt;hibernate-mapping&gt; &lt;class name = "Employee" table = "EMPLOYEE"&gt; &lt;meta attribute = "class-description"&gt; This class contains the employee detail. &lt;/meta&gt; &lt;id name = "id" type = "int" column = "id"&gt; &lt;generator class="native"/&gt; &lt;/id&gt; &lt;property name = "firstName" column = "first_name" type = "string"/&gt; &lt;property name = "lastName" column = "last_name" type = "string"/&gt; &lt;property name = "salary" column = "salary" type = "int"/&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 一般映射文件的文件名格式为: &lt;classname&gt;.hbm.xml。例如上面的映射文件我们可以命名为: Employee.hbm.xml。 下面是针对映射文件中涉及到的标签元素给出的具体解释: 映射文件使用&lt;hibernate-mapping&gt;标签作为根标签元素，它包含所有的&lt;class&gt;标签元素； &lt;class&gt;标签是用来定义java类到数据表的映射关系的。Java类名和数据表名称分别由标签的name和table属性指定； &lt;meta&gt;标签用于创建类的描述信息，是可选标签； &lt;id&gt;标签映射Java类的唯一id属性到数据表的主键。该标签的name属性指定类的属性名，column则指定数据表的字段名。type属性为hibernate映射类型，将Java数据类型转化为SQL数据类型。 &lt;generator&gt;标签元素是&lt;id&gt;标签的子元素，用来自动生成主键值。其中class属性设置为native，以使Hibernate根据底层数据库的功能选择identity,sequence或hilo算法来生成主键； &lt;property&gt;标签则用来将java类中的属性映射到数据表中的字段。name属性指定java类的属性名，相应的，column指定数据表对应的字段名称。type为hibernate映射类型。 除了上面提到的这些标签元素和属性外，其实还有其他的标签元素和属性。这里只不过是简单地给出了常用的标签元素及其属性的解释。 Hibernate 映射类型当我们配置Hibernate映射文件时，我们需要将Java数据类型映射转化为RDBMS数据类型。在映射文件中生命的类型(types)既不是java数据类型，也不是SQL 数据据数据类型。我们一般称其为Hibernate mapping types(hibernate映射类型),它们能够将java数据类型转化为SQL数据类型，反之亦然。 下面给出了所有基本的，日期和时间，大对象以及其他各种内置映射类型。 一、原始类型(Primitive Types) Mapping type Java type ANSI SQL Type integer int or java.lang.Integer INTEGER long long or java.lang.Long BIGINT short short or java.lang.Short SMALLINT float float or java.lang.Float FLOAT double double or java.lang.Double DOUBLE big_decimal java.math.BigDecimal NUMERIC character java.lang.String CHAR(1) string java.lang.String VARCHAR byte byte or java.lang.Byte TINYINT boolean boolean or java.lang.Boolean BIT yes/no boolean or java.lang.Boolean CHAR(1)(‘Y’ or ‘N’) true/false boolean or java.lang.Boolean CHAR(1)(‘Y’ or ‘N’) 二、日期和时间类型 Mapping Type Java Type ANSI SQL Type date java..util.Date or java.sql.Date DATE time java.util.Date or java.sql.Date TIME timestamp java.util.Date or java.sql.Timestamp TIMESTAMP calendar java.util.Calendar TIMESTAMP calendar_date java.util.Calendar DATE 三、二进制和大对象类型 Mapping Type Java Type ANSI SQL Type binary byte[] VARBINARY(or BLOB) text java.lang.String CLOB serializable 任何实现java.io.Serializable接口的类 VARBIANRY(or BLOB clob java.sql.Clob CLOB blob java.sql.Blob BLOB 四、JDK相关类型 Mapping Type Java Type ANSI SQL Type class java.lang.Class VARCHAR locale java.util.Locale VARCHAR timezone java.util.TimeZone VARCHAR currency java.util.Currency VARCHAR Hibernate 使用实例接下来我们将通过一个简单的例子来了解Hiberate是如何为独立应用程序提供持久化服务的。下面使用Hibernate技术分几个不同的步骤来创建一个Java应用程序。 一、创建POJO类创建应用程序的第一步就是创建Java POJO类，这取决与应用程序中需要保留到数据库的类。这里我们创建一个拥有getter和setter方法的Employee类，并让它成为JavaBean兼容类。 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Employee &#123; private int id; private String firstName; private String lastName; private int salary; public Employee() &#123;&#125; public Employee(String fname, String lname, int salary) &#123; this.firstName = fname; this.lastName = lname; this.salary = salary; &#125; public int getId() &#123; return id; &#125; public void setId( int id ) &#123; this.id = id; &#125; public String getFirstName() &#123; return firstName; &#125; public void setFirstName( String first_name ) &#123; this.firstName = first_name; &#125; public String getLastName() &#123; return lastName; &#125; public void setLastName( String last_name ) &#123; this.lastName = last_name; &#125; public int getSalary() &#123; return salary; &#125; public void setSalary( int salary ) &#123; this.salary = salary; &#125;&#125; 二、创建数据表第二步，就是要在数据库中创建数据表。一张数据表对应一个持久化类。定义EMPLOYEE表来对应Employee持久化类。 1234567create table EMPLOYEE ( id INT NOT NULL auto_increment, first_name VARCHAR(20) default NULL, last_name VARCHAR(20) default NULL, salary INT default NULL, PRIMARY KEY (id)); 三、创建映射文件创建一个映射文件来告诉Hibernate如何将持久化类映射到数据表。 Employee.hbm.xml: 12345678910111213141516171819202122&lt;?xml version = "1.0" encoding = "utf-8"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD//EN""http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt; &lt;hibernate-mapping&gt; &lt;class name = "Employee" table = "EMPLOYEE"&gt; &lt;meta attribute = "class-description"&gt; This class contains the employee detail. &lt;/meta&gt; &lt;id name = "id" type = "int" column = "id"&gt; &lt;generator class="native"/&gt; &lt;/id&gt; &lt;property name = "firstName" column = "first_name" type = "string"/&gt; &lt;property name = "lastName" column = "last_name" type = "string"/&gt; &lt;property name = "salary" column = "salary" type = "int"/&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 四、创建应用程序类最后，我们创建一个应用程序类来做简单的测试。例如：保存一些Employee数据，执行CRUD操作等。 ManageEmployee.java: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121import java.util.List; import java.util.Date;import java.util.Iterator; import org.hibernate.HibernateException; import org.hibernate.Session; import org.hibernate.Transaction;import org.hibernate.SessionFactory;import org.hibernate.cfg.Configuration;public class ManageEmployee &#123; private static SessionFactory factory; public static void main(String[] args) &#123; try &#123; factory = new Configuration().configure().buildSessionFactory(); &#125; catch (Throwable ex) &#123; System.err.println("Failed to create sessionFactory object." + ex); throw new ExceptionInInitializerError(ex); &#125; ManageEmployee ME = new ManageEmployee(); /* Add few employee records in database */ Integer empID1 = ME.addEmployee("Zara", "Ali", 1000); Integer empID2 = ME.addEmployee("Daisy", "Das", 5000); Integer empID3 = ME.addEmployee("John", "Paul", 10000); /* List down all the employees */ ME.listEmployees(); /* Update employee's records */ ME.updateEmployee(empID1, 5000); /* Delete an employee from the database */ ME.deleteEmployee(empID2); /* List down new list of the employees */ ME.listEmployees(); &#125; /* Method to CREATE an employee in the database */ public Integer addEmployee(String fname, String lname, int salary)&#123; Session session = factory.openSession(); Transaction tx = null; Integer employeeID = null; try &#123; tx = session.beginTransaction(); Employee employee = new Employee(fname, lname, salary); employeeID = (Integer) session.save(employee); tx.commit(); &#125; catch (HibernateException e) &#123; if (tx!=null) tx.rollback(); e.printStackTrace(); &#125; finally &#123; session.close(); &#125; return employeeID; &#125; /* Method to READ all the employees */ public void listEmployees( )&#123; Session session = factory.openSession(); Transaction tx = null; try &#123; tx = session.beginTransaction(); List employees = session.createQuery("FROM Employee").list(); for (Iterator iterator = employees.iterator(); iterator.hasNext();)&#123; Employee employee = (Employee) iterator.next(); System.out.print("First Name: " + employee.getFirstName()); System.out.print(" Last Name: " + employee.getLastName()); System.out.println(" Salary: " + employee.getSalary()); &#125; tx.commit(); &#125; catch (HibernateException e) &#123; if (tx!=null) tx.rollback(); e.printStackTrace(); &#125; finally &#123; session.close(); &#125; &#125; /* Method to UPDATE salary for an employee */ public void updateEmployee(Integer EmployeeID, int salary )&#123; Session session = factory.openSession(); Transaction tx = null; try &#123; tx = session.beginTransaction(); Employee employee = (Employee)session.get(Employee.class, EmployeeID); employee.setSalary( salary ); session.update(employee); tx.commit(); &#125; catch (HibernateException e) &#123; if (tx!=null) tx.rollback(); e.printStackTrace(); &#125; finally &#123; session.close(); &#125; &#125; /* Method to DELETE an employee from the records */ public void deleteEmployee(Integer EmployeeID)&#123; Session session = factory.openSession(); Transaction tx = null; try &#123; tx = session.beginTransaction(); Employee employee = (Employee)session.get(Employee.class, EmployeeID); session.delete(employee); tx.commit(); &#125; catch (HibernateException e) &#123; if (tx!=null) tx.rollback(); e.printStackTrace(); &#125; finally &#123; session.close(); &#125; &#125;&#125; 五、编译执行通过编译执行，我们可以得到下面的测试结果： 12345678$java ManageEmployee.......VARIOUS LOG MESSAGES WILL DISPLAY HERE........First Name: Zara Last Name: Ali Salary: 1000First Name: Daisy Last Name: Das Salary: 5000First Name: John Last Name: Paul Salary: 10000First Name: Zara Last Name: Ali Salary: 5000First Name: John Last Name: Paul Salary: 10000 EMPLOYEE表中的数据： 12345678910mysql&gt; select * from EMPLOYEE;+----+------------+-----------+--------+| id | first_name | last_name | salary |+----+------------+-----------+--------+| 29 | Zara | Ali | 5000 || 31 | John | Paul | 10000 |+----+------------+-----------+--------+2 rows in set (0.00 secmysql&gt; Hibernate O/R 映射之前，我们已经熟悉了Hibernate的基本O/R映射的使用，但是还有很多映射我们还需要进一步的了解。如： 集合的映射 实体类之间的关联映射 组件映射 一、集合映射如果持久化类中包含某个属性为集合类型，我们也需要将集合类型值映射到数据表中。Hibernate能够持久化的集合实例有java.util.Map、java.util.Set、java.util.SortedMap、java.util.SortedSet、java.util.List以及持久化实例中的数组(array)。 Collection Type Mapping Description java.util.Set 使用&lt;set&gt;标签元素进行映射并使用java.util.HashSet进行初始化 java.util.SortedSet 使用&lt;set&gt;标签进行映射并用java.util.TreeSet初始化，属性sort可以设置为comparator或者natural ordering java.util.List 使用&lt;list&gt;标签进行映射，并用java.util.ArrayList初始化 java.util.Collection 使用&lt;bag&gt;或&lt;ibag&gt;标签进行映射配置并使用java.util.ArrayList初始化 java.util.Map 使用&lt;map标签进行映射并使用java.util.HashMap初始化 java.util.SortedMap 使用&lt;map标签进行映射并用java.util.TreeMap初始化。属性sort可以设置为comparator或natural ordering 对于数组类型的映射，针对Java原始值类型使用&lt;primitive-array&gt;标签，其他的数组类型则使用&lt;array&gt;。但是一般很少使用到。 [notice]:如果需要映射用户自定义的集合接口，切该集合接口不是Hiberate直接支持的，就需要告诉Hibernate定义集合的语义，通常是很难实现的，一般不推荐使用。 Set-MappingSortedSet-MappingList-MappingCollection-MappingMap-MappingSortedMap-Mapping二、关联映射实体类和数据表之间的映射是ORM的灵魂。以下是可以表示对象之间关系的四种方式。关联映射可以是单向的，也可以是双向的。 Mapping Type Description Many-to-One 多对一关系的映射 One-to-One 一对一关系的映射 One-to-Many 一对多关系的映射 Many-to-Many 多对多关系的映射 Many-to-OneOne-to-OneOne-to-ManyMany-to-Many三、组件映射在应用程序中，有很大的可能性一个实体类会持有另一个实体的引用最为成员变量。如果别引用的类没有自己的申明周期并且完全依赖与拥有的实体类的生命周期，那么所引用的类称为组件类。 组件的映射可以以类似集合映射的方式进行，但有点不同与常规的集合映射： Mapping Type Description Component Mappings 对持有另一个类作为成员变量的实体类进行映射]]></content>
      <categories>
        <category>Java框架学习</category>
        <category>Hibernate</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>Java框架基础</tag>
        <tag>hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java持久化框架基础学习笔记 - ORM]]></title>
    <url>%2Fposts%2F4e7f2cb9%2F</url>
    <content type="text"><![CDATA[对象关系映射(Oject Relational Mapping, ORM)是一种程序技术，用户实现面向对象编程语言中不同类型系统的数据之间的转换。 为了更好的了解ORM，我们先要了解一下JDBC。 什么是JDBC?JDBC，即Java Database Connectivity(Java数据库连接)。它为Java程序提供了访问关系型数据库(relational database)的Java API集合。这些API使得Java程序可以执行SQL语句并与任何符合SQL的数据库库进行交互。 JDBC提供了一种灵活的结构来编写能够和数据库进行交互的应用，且在不做任何修改的情况下，能够运行于不同的平台。 JDBC的优点和缺点 优点 缺点 清晰简单的SQL处理 在大型的项目中使用时变得异常复杂 处理大数据时有良好表现 大量编程开销，没有封装 非常适合小应用程序 难以实现MVC模式 语法简单易学 查询是DBMS特有的 为什么使用对象关系映射(ORM)?当我们使用面向对象系统时，对象模型和关系数据库存在不匹配的现象，RDMSs(关系型数据库) 以表格的形式表示数据，而面向对象编程语言，如java,C# 将数据表示为对象的属性，以及对象之间的关系。 例如下面的一个简单的实体类： 12345678910111213141516171819202122232425262728public class Employee &#123; private int id; private String firstName; private String lastName; private int salary; public Employee() &#123;&#125; public Employee(String fname, String lname, int sal) &#123; this.firstName = fname; this.lastName = lname; this.salary = sal; &#125; public int getId() &#123; return id; &#125; public String getFirstName() &#123; return firstName; &#125; public String getLastName() &#123; return lastName; &#125; public int getSalary() &#123; return salary; &#125;&#125; 上面的对象在关系型数据库中可以这样存储和检索的： 1234567create table EMPLOYEE ( id int not null auto_increment, first_name varchar(20) default null, last_name varchar(20) default null, salary int default null, contraint PK_id primary key (id)); 遇到的问题 可能我们开发了几个页面后，要修改数据库的设计，我们应该怎样处理？ 将对象存储到关系型数据库和从数据库中读取存在以下五个不匹配(mismatch)的问题： 不匹配(Mismatch) 描述(Description) Granularity(粒度) 有时你可能会有一个对象模型，它的类比数据库中的相应的表的数量还要多。 Inheritence(继承) RDBMS不定义任何类似继承的东西，但这确是面向对象编程语言中的的自然范式。 Identity(标识) RDBMS正好定义了一个“相等”的概念：主键。但是Java定义对象标识(a == b) 和对象相等(a.equals(b))。 Associations(关联) 面向对象编程语言使用对象引用来表示关联，而RDBMS将关联表示为外键。 Navigation(检索) 在Java和RDBMS中访问对象的方式根本不同。 对象关系映射（ORM）是处理上述所有不匹配问题的解决方案。 什么是ORM?ORM 是一项在关系型数据库和面向对象编程语言之间转换数据的编程技术。 相比于简单的JDBC，ORM有以下优点： No. Advantages 1 让业务逻辑代码访问数据对象，而不是数据表 2 隐藏了业务逻辑的SQL查询的详细信息 3 无需处理数据库实现问题 4 基于业务概念而非数据库结构的实体 5 基于JDBC“底层” 6 事务管理和自动密钥生成 7 应用程序快速开发 一个 ORM 解决方案由以下四个实体组成： No. Solutions 1 对持久化类的对象执行基本CRUD操作的API 2 用于指定引用类和类的属性的查询的语言或API 3 用于指定映射元数据的可配置工具 4 一种与事务对象进行交互以执行脏检查，懒惰关联提取以及其他优化功能的技术。 Java ORM 框架有许多持久化框架ORM解决方案使用java实现的，如： Enterprise JavaBeans Entity Beans Java Data Ojects Castor TopLink Spring DAO Hibernate Mybatis 等等。]]></content>
      <categories>
        <category>Java框架学习</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>Java框架基础</tag>
        <tag>ORM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Struts 2基础学习 - Interceptors]]></title>
    <url>%2Fposts%2F5e817364%2F</url>
    <content type="text"><![CDATA[Interceptors(拦截器)在概念上同servlet过滤器以及JDK动态代理类一样。拦截器可以透切(crosscutting)action以及框架来实现一些特定的功能。例如： 在action调用执行前，预先执行某些代码； 在action调用和执行后，再次执行你指定的代码； 用来捕捉异常，以便可以执行替代处理(alternate processing)。 事实上，Struts 2框架的许多特性都是使用拦截器实现的。例如： exception handling, file uploading, lifecycle callbacks等等。因为Struts 2在拦截器上强调了它的大部分功能，因此不太可能为单个action分配7或8个拦截器。 Struts 2框架拦截器Struts 2框架提供了许多预先配置并且可以开箱即用的拦截器。下面是一些比较重要的拦截器： Interceptor Description alias 允许参数(parameters)跨请求拥有不同的别名 checkbox 通过为未选中的复选框(check box)添加参数值false来协助管理复选框 conversionError 将字符串转换为参数类型的错误信息放入Action的字段错误中 createSession 自动创建一个HTTP session如果它没有存在 debugging 为开发人员提供几个不同的调式界面 execAndWait 当action在后台执行时，给用户提供一个等待页面 exception 将action引发的异常映射到result,并通过重定向自动处理异常 fileUpload 便于文件上传 i18n 在用户回话期间跟踪所选的语言环境 logger 通过输出被执行的action的名字来提供简单的日志信息 params 允许在action中设置request的参数 prepare 这是一个用来的做预处理工作的典型代表，例如：建立数据库连接 profile 允许为action记录简单的分析信息 scope 在session或application域中存储和检索action的状态 ServletConfig 提供可以访问各种基于servlet信息的action timer 为action需要执行多少时间提供一个简单的分析信息 token 检查有效标记的action以防止重复的表单提交 validation 为action的提供验证支持 如何使用拦截器？我们可以直接在struts.xml配置文件中配置Struts 2已经提供的拦截器，例如使用timer拦截器来打印执行action所需要的时间，同时还可以使用params拦截器来将request参数传递给action。 1234567891011121314151617&lt;?xml version = "1.0" Encoding = "UTF-8"?&gt;&lt;!DOCTYPE struts PUBLIC "-//Apache Software Foundation//DTD Struts Configuration 2.0//EN" "http://struts.apache.org/dtds/struts-2.0.dtd"&gt;&lt;struts&gt; &lt;constant name = "struts.devMode" value = "true" /&gt; &lt;package name = "helloworld" extends = "struts-default"&gt; &lt;action name = "hello" class = "com.rovo98.struts2.HelloWorldAction" method = "execute"&gt; &lt;interceptor-ref name = "params"/&gt; &lt;interceptor-ref name = "timer" /&gt; &lt;result name = "success"&gt;/HelloWorld.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 创建自定义拦截器在我们的应用程序中使用拦截器来透切(crosscutting)应用使用一种优雅的方式。创建自定义的拦截器很容易，只需要实现Interceptor接口就行了。 12345public interface Interceptor extends Serializable &#123; void destroy(); void init(); String intercept(ActionInvocation invocation) throws Exception;&#125; 其中init()方法用来初始化拦截器，destroy()方法被用来销毁拦截器。不像action，拦截器request中被重复使用，所以它需要考虑线程安全问题，特别是intercept()方法。 ActionInvocation对象提供的运行环境的访问。它允许访问action本身和调用action的方法并确定action是否已经被调用。 如果你不需要实现初始化和销毁拦截器的代码，可以直接继承AbstractInterceptor类，它不需要实现init()和destroy()方法。 12345678910111213141516171819202122package com.rovo98.struts2;import java.util.*;import com.opensymphony.xwork2.ActionInvocation;import com.opensymphony.xwork2.interceptor.AbstractInterceptor;public class MyInterceptor extends AbstractInterceptor &#123; public String intercept(ActionInvocation invocation) throws Exception &#123; /* let us do some pre-processing */ String output = "Pre-Processing"; System.out.println(output); /* let us call action or next interceptor */ String result = invocation.invoke(); /* let us do some post-processing */ output = "Post-Processing"; System.out.println(output); return result; &#125;&#125; 实际的action将通过拦截器调用invocation.invoke()方法来执行。因此我们action执行前或执行后加入我们的处理代码。 框架本身通过对ActionInvocation对象的invoke()方法的第一次调用来启动该过程。每次调用invoke()，ActionInvocation都会查询其状态并执行下一个拦截器。当所有的配置的拦截器都执行完了之后，action才会被执行。 下面是其工作流程图： 拦截器栈不难想象，当我们为单个action配置多个拦截器时，它们很快会变得很难管理。所以Struts 2引入了拦截器栈的概念来管理。下面是一个在sturtsdefault.xml配置文件中的一个拦截器栈： 12345678&lt;interceptor-stack name = "basicStack"&gt; &lt;interceptor-ref name = "exception"/&gt; &lt;interceptor-ref name = "servlet-config"/&gt; &lt;interceptor-ref name = "prepare"/&gt; &lt;interceptor-ref name = "checkbox"/&gt; &lt;interceptor-ref name = "params"/&gt; &lt;interceptor-ref name = "conversionError"/&gt;&lt;/interceptor-stack&gt; 上面的拦截器栈拥有唯一标识basicStack,当我们使用这个拦截器栈时，实际上和之前配置单个拦截器使用的是同样的语法： 1234&lt;action name= "hello" class= "com.rovo98.struts2.MyActoin" &gt; &lt;interceptor-ref name = "basicStack" /&gt; &lt;result&gt;/view.jsp&lt;/result&gt;&lt;/action&gt; 通过上面的配置，为helloaction 配置了六个拦截器，且这六个拦截器在action被执行前将被按顺序执行。]]></content>
      <categories>
        <category>Java框架学习</category>
        <category>Struts 2</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>Java框架基础</tag>
        <tag>Struts 2基础学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Struts 2基础学习 - Actions]]></title>
    <url>%2Fposts%2F338c78b5%2F</url>
    <content type="text"><![CDATA[action是Struts 2 框架的核心，它们适用于任何MVC框架。每个URL都映射到一个具体的action，action提供了业务逻辑处理来响应用户发起的请求。 但是，action拥有另外两个重要的职能。第一， action在数据(data)从request中传递到视图(view,无论是jsp还是其他的result)的过程扮演着一个重要的角色。第二，action帮助Struts 2 来确定哪个result对应的视图(view)将被返回去响应用户的请求。 创建Action创建和使用action类的唯一要求就是必须要有一个无参方法(noargument method)返回String或Result对象，并且必须是POJO(Plain Ordinary Java Object).如果该方法没有给出，默认的，execute()方法将会被执行。 另外，我们可以通过继承实现了六个接口(其中包含Action interface)的ActionSupport类来创建我们的action类。 Action接口的定义如下： 12345678public interface Action &#123; public static final String SUCCESS = "success"; public static final String NONE = "none"; public static final String ERROR = "error"; public static final String INPUT = "input"; public static final String LOGIN = "login"; public String execute() throws Exception;&#125; 下面是一个简单的普通的 action： 1234567891011121314151617package com.rovo98.struts2;public class HelloWorldAction &#123; private String name; public String execute() throws Exception &#123; return "success"; &#125; public String getNane() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 我们说过action可以控制视图，为了验证这一点，我们对上面的action的execute()方法做简单的修改，以及继承ActionSupport类： 12345678910111213141516171819202122package com.rovo98.struts2;import com.opensymphony.xwork2.ActionSupport;public class HelloWorldAction extends ActionSupport &#123; private String name; public String execute() throws Exception &#123; if ("SECRET".equals(name)) &#123; return SUCCESS; &#125; else &#123; return ERROR; &#125; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 使用Action在struts.xml 配置文件中配置action在上面的action中，我们执行execute()方法的业务逻辑是从request对象中获取的name的值如果是&quot;SECRET&quot;的话，返回SUCCESS,否则返回ERROR。struts.xml配置文件如下： 123456789101112131415&lt;?xml version = "1.0" Encoding = "UTF-8"?&gt;&lt;!DOCTYPE struts PUBLIC "-//Apache Software Foundation//DTD Struts Configuration 2.0//EN" "http://struts.apache.org/dtds/struts-2.0.dtd"&gt;&lt;struts&gt; &lt;constant name = "struts.devMode" value = "true" /&gt; &lt;package name = "helloworld" extends = "struts-default"&gt; &lt;action name = "hello" class = "com.rovo98.struts2.HelloWorldAction" method = "execute"&gt; &lt;result name = "success"&gt;/HelloWorld.jsp&lt;/result&gt; &lt;result name = "error"&gt;/AccessDenied.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 从上面的配置文件看，当用户请求helloaction映射的URL时，HelloworldAction的execute()方法将会被执行，返回SUCCESS时，将以HelloWorld.jsp去响应用户的请求，否则以AccessDenied.jsp来响应用户的请求。]]></content>
      <categories>
        <category>Java框架学习</category>
        <category>Struts 2</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>Java框架基础</tag>
        <tag>Struts 2基础学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Struts 2基础学习 - 配置文件]]></title>
    <url>%2Fposts%2F3fe084cc%2F</url>
    <content type="text"><![CDATA[主要了解Struts 2应用的基本配置。看看使用Struts 2的一些重要的配置文件，如：web.xml, struts.xml,struts-config.xml和struts.properties，可以对Struts 2应用做哪些配置。 其实，我们只要使用web.xml和struts.xml问价就可以使用Struts 2应用。但是我们还是有必要了解一下其他配置文件。 web.xml 配置文件 web.xml 配置文件是 J2EE 配置文件，它决定了Servlet容器如何处理HTTP请求中的元素。严格上来说，它并不是 Struts 2 的配置文件，但是我们需要通过配置它来使 Struts 2工作。毕竟Struts 2 是基于一个Filter做Controller实现的) 这个文件为任何一个Web应用提供一个入口点(entry point),而 Struts 2 应用的入口点是定义在 web.xml 文件中的一个过滤器(filter)。因此我们会在 web.xml 中顶一个 FilterDispatcher 类的入口。 一个简单的web.xml文件配置例子： 1234567891011121314151617181920212223242526&lt;?xml version = "1.0" Encoding = "UTF-8"?&gt;&lt;web-app xmlns:xsi = "http://www.w3.org/2001/XMLSchema-instance" xmlns = "http://java.sun.com/xml/ns/javaee" xmlns:web = "http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" xsi:schemaLocation = "http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd" id = "WebApp_ID" version = "3.0"&gt; &lt;display-name&gt;Struts 2&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt; org.apache.struts2.dispatcher.FilterDispatcher &lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; 【notice】: 这里将Struts 2 Filter映射到 /* ，而不是/*.action, 这意味着所有的url都会被Struts 2的过滤器解析。 struts.xml 配置文件struts.xml 文件包含actions开发时需要修改的配置信息。这个文件可以覆盖应用的默认配置，例如：struts.devMode = false，该文件可以放置在WEB-INF/classes目录下。 一个hellowordWorld例子的struts.xml配置文件： 1234567891011121314151617181920&lt;?xml version = "1.0" Encoding = "UTF-8"?&gt;&lt;!DOCTYPE struts PUBLIC "-//Apache Software Foundation//DTD Struts Configuration 2.0//EN" "http://struts.apache.org/dtds/struts-2.0.dtd"&gt;&lt;struts&gt; &lt;constant name = "struts.devMode" value = "true" /&gt; &lt;package name = "helloworld" extends = "struts-default"&gt; &lt;action name = "hello" class = "com.rovo98.struts2.HelloWorldAction" method = "execute"&gt; &lt;result name = "success"&gt;/HelloWorld.jsp&lt;/result&gt; &lt;/action&gt; &lt;!-- more actions can be listed here --&gt; &lt;/package&gt; &lt;!-- more packages can be listed here --&gt;&lt;/struts&gt; 一点需要注意的是 DOCTYPE，所有struts 配置文件都需要有正确的doctype信息，例如上面所展示的。标签是配置文件中的根标签元素，我们可以在里面定义不同的包(package)，使用标签可以使用配置信息模块化，当我们需要把一个大型的项目拆分成不同的模块的时候，它将非常有用。 package 标签拥有以下的属性： Attribute Description name(required) 包的唯一标识符 extends 说明包继承于哪个包，默认的，我们使用struts-default作为基包(base package) abstract 如果属性值为true,终端用户将无法使用该包 namespace action类的唯一名称空间 constant标签拥有name和value属性，可以重写覆盖定义在default.properites文件中的属性配置，例如我们上面提到的struts.devMode,通过设置struts.devMode属性，我们在日志文件中查看debug信息。 我们通过定义一个action标签来映射我们需要访问的链接URL并定义一个实现execute()方法的类，任何时刻，当我们访问对应的链接时，该类的execute()方法都会被执行。 result决定了执行action之后，返回浏览器的内容。action返回的String应该是和某个result的name属性值是一致的。result拥有两个可选的属性name和type，name属性的值默认为”success”,type默认为”dispatcher”。 struts.xml配置文件在开发中可能会变得非常大，我们可以使用package将它们模块化，当然Struts还提供了另一种方式，我们可以把配置文件分割成多个xml文件，然后通过下面这种方式来将它们导入： 123456789&lt;?xml version = "1.0" Encoding = "UTF-8"?&gt;&lt;!DOCTYPE struts PUBLIC "-//Apache Software Foundation//DTD Struts Configuration 2.0//EN" "http://struts.apache.org/dtds/struts-2.0.dtd"&gt;&lt;struts&gt; &lt;include file="my-struts1.xml"/&gt; &lt;include file="my-struts2.xml"/&gt;&lt;/struts&gt; 【notice】: 这里有一个配置文件我们过多的提及，是struts-default.xml，该文件包含了Struts 的所有标准配置设置，在我们的开发项目中，我们可能并不会触碰到它。感兴趣的话，可以查看struts2-core-x.x.x.jar包中的default.properties文件。 struts-config.xml 配置文件struts-config.xml配置文件是Web客户端中View和Model组件之间的链接，但在我们99%的开发项目中，我们并不会接触到它。 配置文件主要包含以下这些主要的元素: Interceptor Description struts-config 配置文件的根节点 form-bean 可以将ActionForm的子类映射到一个名称(name),并在整个struts-config.xml文件的其余部分中，甚至在JSP页面上，都可使用这个name作为ActionForm的别名 global forwards 可以将一个页面映射到一个名称(name),并使用该名称来引用实际页面。这可以避免使用网页上的硬编码(hardcoding)网址 action-mapping 用来声明表单处理程序，也被成为action映射 controller 配置Struts的内部结构，很少在实际情况中使用 plug-in 告诉Struts如何查看你的属性文件(properties files)，其中包含提示和错误信息 struts-config.xml配置文件简单实例： 1234567891011121314151617181920212223242526272829303132&lt;?xml version = "1.0" Encoding = "ISO-8859-1" ?&gt;&lt;!DOCTYPE struts-config PUBLIC "-//Apache Software Foundation//DTD Struts Configuration 1.0//EN" "http://jakarta.apache.org/struts/dtds/struts-config_1_0.dtd"&gt;&lt;struts-config&gt; &lt;!-- ========== Form Bean Definitions ============ --&gt; &lt;form-beans&gt; &lt;form-bean name = "login" type = "test.struts.LoginForm" /&gt; &lt;/form-beans&gt; &lt;!-- ========== Global Forward Definitions ========= --&gt; &lt;global-forwards&gt; &lt;/global-forwards&gt; &lt;!-- ========== Action Mapping Definitions ======== --&gt; &lt;action-mappings&gt; &lt;action path = "/login" type = "test.struts.LoginAction" &gt; &lt;forward name = "valid" path = "/jsp/MainMenu.jsp" /&gt; &lt;forward name = "invalid" path = "/jsp/LoginView.jsp" /&gt; &lt;/action&gt; &lt;/action-mappings&gt; &lt;!-- ========== Controller Definitions ======== --&gt; &lt;controller contentType = "text/html;charset = UTF-8" debug = "3" maxFileSize = "1.618M" locale = "true" nocache = "true"/&gt;&lt;/struts-config&gt; struts.properties 配置文件该配置文件提供了一种可以改变框架默认行为的机制。实际上，所有包含在struts.properties配置文集中的属性都可以在web.xml中使用init-param标签来配置。也可以在struts.xml配置文件中使用constant标签来进行配置。但是，如果你想将不同的配置信息分开，那么你可以使用struts.properties，它可以放置在WEB-INF/classes**目录下。 在该文件中配置的属性值将会覆盖struts2-core.x.y.z.jar包中default.properties文件中配置的默认属性值。 下面是我们开发中可能会使用到的属性值： 1234567891011### When set to true, Struts will act much more friendly for developersstruts.devMode = true### Enables reloading of internationalization filesstruts.i18n.reload = true### Enables reloading of XML configuration filesstruts.configuration.xml.reload = true### Sets the port that the server is run onstruts.url.http.port = 8080]]></content>
      <categories>
        <category>Java框架学习</category>
        <category>Struts 2</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>Java框架基础</tag>
        <tag>Struts 2基础学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Struts 2基础学习 - 架构]]></title>
    <url>%2Fposts%2F4fe73428%2F</url>
    <content type="text"><![CDATA[从高层面来看， Struts 2 是一个纯粹的 MVC (或MVC2)框架，Struts 2使用以下的五个核心部分来实现 Model-View-Controller(MVC) 模式： Actions Interceptors Value Stack / OGNL Results / Result types View technologies 概述相比于传统的 MVC 框架， Struts 2 略有不同， 这是因为Struts 2中的 action更多的是扮演model的角色， 而不是 controller,虽然这其中有一些重叠的地方。 上面的图描述了Struts 2架构中的Model, View和Controller。controller由Struts 2的dispatch servlet filter(Servlet分发过滤器) 和 interceptors(拦截器)，actions实现Model, 视图view由result types 和 results 实现。值栈(Value Stack)和 OGNL 提供通用线程，链接和启用其他组件之间的集成。 除了上述的组件外， 还有大量的关于配置的消息(information)， 对Web 应用程序的配置， 对actions的配置，以及interceptors,results等等的配置。 Request 生命周期基于上面的图，我们可以了解到在Struts 2工作流中的用户请求的生命周期是这样的： 用户向服务器发送一个资源(例如: 页面)请求； Struts 2 的 Dispatcher Filter 拦截请求，并选择合适Action； 执行已配置的interceptors(拦截器)的功能， 例如： 表单验证，文件上传等； 基于请求操作，调用并执行已选择的action； 同样，如果需要，配置的拦截器可用于进行任意的后期处理； 最后，将由view准备的结果(result)返回给用户。]]></content>
      <categories>
        <category>Java框架学习</category>
        <category>Struts 2</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>Java框架基础</tag>
        <tag>Struts 2基础学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Union-Find -- 动态连通性问题算法]]></title>
    <url>%2Fposts%2Fb3f33dac%2F</url>
    <content type="text"><![CDATA[union-find算法主要用于解决动态连通性问题。 我们设计算法时面对的第一个任务就是精确地定义问题。为了说明问题，通常会设计一份API来封装所需的基本操作。 UF API根据Union Find 算法需求定义接口 - Method Description UF(int n) 以整数标识(0到n-1)初始化n个触点 int find(int p) p所在分量的标识符 void union(int p, int q) 在p和q之间增加一条连接 boolean connected(int p, int q) 如果p和q存在于同一个分量返回true int count() 连通分支的数量 此时，解决动态连通性问题设计算法的问题已经被我们转化为实现这份API。 定义一种数据结构表示已知的连接 基于此数据结构实现高效的union()、find()、connected()和count()方法 实现1234567891011121314151617181920public class UF &#123; private int[] parent; private int count; public UF(int n) &#123; parent = new int[n]; count = n; for (int i = 0; i &lt; n; i++) &#123; parent[i] = i; &#125; &#125; public int count() &#123; return count; &#125; public boolean connected(int p, int q) &#123; return find(p) == find(q); &#125; public int find(int p) ... public void union(int p, int q) ...&#125; 第一种实现方式: quick-find算法 这种实现方式保证当且仅当parent[p] == parent[q]时p和q是连通的。即在同一个连通分支的所有触点在parent[]中的值必须全部相同。 也意味着connected(p, q)只需要判断parent[p] == parent[q]，只有在p和q所在连通分支相同时返回true,否则p所在连通分支的所有触点对应parent[]中的值为一个值，而q所在连通分支的所有触点对应parent[]中的值为另一个值。因此我们在合并分量时需要遍历整个数组来将所有和parent[p]相等的元素变为parent[q]，或者反过来。由此实现的find()、union()方法如下： 123456789101112public int find(int p) &#123; return parent[p];&#125;public void union(int p, int q) &#123; int rootP = find(p); int rootQ = find(q); if (rootP == rootQ) return; for (int i = 0; i &lt; parent.length; i++) &#123; if (parent[i] == rootQ) parent[i] = rootP; &#125; count--;&#125; quick-find 算法分析 find() 操作速度显然是很快的，因为它只需要访问parent[]数组一次。但quick-find算法一般无法处理大型问题，因为对于每一对输入的触点 union()都需要扫描整个parent[]数组。可以看出此算法的时间复杂度应该为：$O(n^2).$ 命题F: 在quick-find 算法中，每次find() 调用只需要访问数组一次，而归并两个分量的union()操作访问数组的次数在$(N+3)$到$(2N+1)$之间。 第二种实现方式： quick-union算法该算法的重点是在于提高 union()方法的速度，它和 quick-find 都是基于相同的数据结构 —— 以触点为索引的 parent[] 数组，在此之上，我们用它们来定义更加复杂的结构。令每个触点所对应的 parent[] 元素都是同一个分量中的另一触点名称（也可能是它自己) — 这种联系称为链接。 在实现find()方法时，从给定的触点开始，由它的链接得到另一个触点，再由这个触点的链接到达第三个触点，直到随着链接到达根触点，链接指向自己的触点。而对于实现union()方法，只需有由p和q的链接分别去找它们的根触点，然后只需要将一个跟触点链接到另一个即可。由此实现的find()、union()方法如下： 12345678910111213public int find(int p) &#123; while (p != parent[p]) &#123; p = parent[p]; &#125; return p;&#125;public void union(int p, int q) &#123; int rootP = find(p); int rootQ = find(q); if (rootP == rootQ) return; parent[rootP] = parent[rootQ]; count--;&#125; quick-union 算法分析 在quick-union 中parent[]数组用父链接的形式表示的一片森林。quick-union 算法明显比quick-find 算法更快，因为它不需要为每一对输入遍历整个数组。 在最好的情况下，find()只需要访问一次数组就能得到一个触点所在的分量的标识符；而在最坏的情况下，需要$2N - 1$次数组访问。我们可以把quick-union看作是quick-find算法的改进。—— 它将union()操作改进为线性级别。 定义： 一棵树的大小是它的节点的数量。树中的一个节点的深度是它到根节点的路径的链接数。树的高度是它的所有节点的最大深度。 命题G: quick-union 算法中的 find() 方法访问数组的次数为1 加上给定触点所对应的节点的深度的两倍。union() 和 connected() 访问数组的次数为两次 find()操作 （如果 union() 中给定的两个触点分别存在于不同的树中则还需要加 1). 由命题G我们可以知道算法在最坏的情况下的运行时间是平方级别的。例如：输入的整数对为$0-1、0-2、0-3$等，$N-1$ 对之后，$N$ 个触点将全部处于相同的集合之中且由quick-union算法得到的树的高度为 $N-1$, 其中0链接到2, 2链接到3，如此下去。由命题G可知，对于整数对 $0 - i$, union() 操作访问数组的次数为$2i + 2$ （触点0的深度为i, 触点 i 的深度为 0）。 处理 N 对整数所需的所有 find() 操作访问数组的总次数为 $2(1+2+…+N)~N^2$。 第三种实现方式： 加权quick-union算法改进quick-union算法，不再随意在union()中将一棵树连接到另一颗树，而是记录树的大小(节点个数)或高度并总是将较小的树连接到较大的树上。 记录树的大小(节点个数)加权 1234567891011121314151617181920212223242526272829303132333435public class UF &#123; private int[] parent; private int[] rank; private count; public UF(int n) &#123; parent = new int[n]; rank = new int[n]; count = n; for (int i = 0; i &lt; n; i++) &#123; parent[i] = i; rank[i] = 1; &#125; &#125; public int find(int p) &#123; while (p != parent[p]) &#123; parent[p] = parent[parent[p]]; // 路径压缩 p = parent[p]; &#125; return p; &#125; public void union(int p, int q) &#123; int rootP = find(p); int rootQ = find(q); if (rootP == rootQ) return; // 将较小的树连接到较大的树上 if (rank[rootP] &gt; rank[rootQ]) &#123; parent[rootQ] = rootP; rank[rootP] += rank[rootQ]; &#125; else &#123; parent[rootP] = rootQ; rank[rootQ] += rank[rootP]; &#125; count--; &#125;&#125; 记录树的高度 1234567891011121314151617181920212223242526272829303132333435363738public class UF &#123; private int[] parent; private byte[] rank; private count; public UF(int n) &#123; parent = new int[n]; rank = new byte[n]; count = n; for (int i = 0; i &lt; n; i++) &#123; parent[i] = i; rank[i] = 0; &#125; &#125; public int find(int p) &#123; while (p != parent[p]) &#123; parent[p] = parent[parent[p]]; p = parent[p]; &#125; return p; &#125; public void union(int p, int q) &#123; int rootP = find(p); int rootQ = find(q); if (rootP == rootQ) return; // 将高度较低的树连接到高度较高的树上 if (rank[rootP] &gt; rank[rootQ]) &#123; parent[rootQ] = rootP; &#125; else if (rank[rootP] &lt; rank[rootQ]) &#123; parent[rootP] = rootQ; &#125; else &#123; parent[rootQ] = rootP; rank[rootP]++; &#125; count++; &#125;&#125; 加权quick-union 算法分析 命题H: 对于 $N$ 个触点，加权 quick-union 算法构造的森林中的任意节点的深度最多为 $lgN$。 推论: 对于加权 quick-union 算法和 N 个触点， 在最坏的情况下 find()、 connected() 和 union() 的成本的增长数量级为 $log N$。 union-find 的具体实现: 查看]]></content>
      <categories>
        <category>Algorithms</category>
        <category>Union Find</category>
      </categories>
      <tags>
        <tag>union-find</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基本查找算法 - basical searching algorithms]]></title>
    <url>%2Fposts%2Fd83777d2%2F</url>
    <content type="text"><![CDATA[引入基本查找算法，我们只谈静态查找的查找算法。 线性查找 - linear search特点： 从头开始遍历数组，一个一个和key比较，查找成功则返回索引值。 不要求数组是有序的。 时间复杂度为： $O(n)$. 线性查找原始抽象方法实现如下:1234567public static int linearSearch(Comparable[] a, Comparable key) &#123; for (int i = 0; i &lt; a.length; i++) &#123; if (a[i].compareTo(key) == 0) return i; &#125; return -1;&#125; 跳跃查找 - jump search特点： 要求查找数组有序； 主要思想是每次跳跃固定量的元素来确定目标元素所在的区间，再使用线性查找在区间上搜索目标元素。 时间复杂度为： $O(\sqrt{n})$. [notice] : 假设我们要在一个有n个元素的数组中搜索某个元素，最坏情况下（当目标元素为最后个元素时），这个算法要跳跃n/m步，在线性搜索时作m-1次比较。令 $f(n) = ((n/m) + m-1$.当m = $\sqrt{n}$时，f(n) 取最小值，所以通常情况下，跳跃查找所使用的固定跳跃步数为 $\sqrt{n}$. 跳跃查找的原始抽象方法实现如下：1234567891011121314151617181920212223public static int jumpSearch(Comparable[] a, Comparable key) &#123; int n = a.length; int block_size = Math.floor(Math.sqrt(n)); int step = block_size; // 查找目标元素可能出现的区间 int prev = 0; while (a[Math.min(step, n) - 1].compareTo(key) &lt; 0) &#123; prev = step; step += block_size; if (prev &gt;= n) return -1; &#125; // 使用线性查找在确定的区间上查找目标元素 while (a[prev].compareTo(key) &lt; 0) &#123; prev++; if (prev == Math.min(step, n)) return -1; &#125; if (a[prev].compareTo(key) == 0) return prev; return -1;&#125; 二分查找 - binary search 要求数组有序。 将已经排好序的数组分为两个区间(interval), 把区间的中间元素与key比较, 若大于则搜索左区间，若小于则搜索右区间，等于则返回元素的索引。当区间长度为0时（key没出现在数组中),返回-1。 时间复杂度为 ： $O(nlogn)$. 二分查找原始抽象方法实现如下:12345678910111213141516171819202122232425262728// 非递归实现public static int binarySearch(Comparable[] a, Comparable key) &#123; int lo = 0; int hi = a.length - 1; while (lo &lt;= hi) &#123; int mid = lo + (hi - lo) / 2; if (a[mid].compareTo(key) == 0) return mid; else if (a[mid].compareTo(key) &gt; 0) hi = mid - 1; else lo = mid + 1; &#125; return -1;&#125;// 递归实现public static int binarySearchRecursion(Comparable[] a, Comparable key, int lo, int hi) &#123; if (lo &lt;= hi) &#123; int mid = lo + (hi - lo) / 2; if (a[mid].compareTo(key) == 0) return mid; else if (a[mid].compareTo(key) &lt; 0) return binarySearchRecursion(a, key, mid+1, hi); else return binarySearchRecursion(a, key, lo, mid-1); &#125; return -1;&#125; 三分查找 - ternary search特点： 三分查找是二分查找的扩展； 时间复杂度为 ： $O(nlog_3n)$. [notice]: 虽然看似三分查找的时间复杂度比二分查找的时间复杂度小，但是在最坏情况下，二分查找需要$2Log2n + 1$次比较，而三分查找需要$4Log{3}n + 1$次比较 三分查找原始抽象方法实现如下：特点： 类似二分查找，将查找数组划分为三个部分来进行查找； 时间复杂度： $Log_3n$. 12345678910111213141516171819202122// 递归实现.public static int ternarySearch(Comparable[] a, Comparable key, int lo, int hi) &#123; if (lo &lt;= hi) &#123; int mid1 = lo + (hi - lo) / 3; int mid2 = mid1 + (hi - lo) / 3; if (a[mid1].compareTo(key) == 0) return mid1; if (a[mid2].compareTo(key) == 0) return mid2; // 目标元素只可能出现在第一部分. if (a[mid1].compareTo(key) &gt; 0) return ternarySearch(a, key, lo, mid1-1); // 目标元素只可能出现在第三部分. if (a[mid2].compareTo(key) &lt; 0) return ternarySearch(a, key, mid2+1, hi); // 目标元素只可能出现在第二部分. return ternarySearch(a, key, mid1+1, mid2-1); &#125; // 查找失败. return -1;&#125; 指数搜索 - exponential search特点： 找到目标元素可能出现的区间； 使用二分查找在区间上查找目标元素; 时间复杂度： $logn$; [notice]: 适用于目标数组元素大小趋向于无限大的情况； 当目标出现在目标数组左边时，指数搜索速度比二分查找快。 12345678public static int exponentialSearch(Comparable[] a, Comparable key) &#123; int n = a.length; int i = 1; while (i &lt; n &amp;&amp; a[i].compareTo(key) &lt; 0) &#123; i = i * 2; &#125; return binarySearch(a, key, i/2, Math.min(i, n-1));&#125; 插值搜索 - interpolation search特点： 原理： 假设查找数组的元素是均匀分布的，使用直线插值搜索，不像二分查找那样每次都是搜索区间中间元素。它能够快速的接近目标元素。 当元素均匀分布的情况，时间复杂度为: $O(log(log n))$, 最坏情况: $O(n)$. 12345678910111213141516// java program to implement interpolatoin search.public static int interpolationSearch(Comparable[] a, Comparable key) &#123; int lo = 0; int hi = a.length - 1; while (lo &lt;= hi &amp;&amp; less(key, a[hi]) &amp;&amp; less(a[lo], key)) &#123; int pos = lo + (hi - lo) * (key - a[lo]) / (a[hi] - a[lo]); if (a[pos].compareTo(key) == 0) return pos; else if (a[pos].compareTo(key) &gt; 0) hi = pos - 1; else lo = pos + 1; &#125; return -1;&#125; NOTICE本文中，涉及的算法详细实现和使用，请移步到github查看。]]></content>
      <categories>
        <category>Algorithms</category>
        <category>searching algs</category>
      </categories>
      <tags>
        <tag>basical searching algs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速排序 - quickSort]]></title>
    <url>%2Fposts%2Fd9de8e4c%2F</url>
    <content type="text"><![CDATA[引入快速排序的主要特点是： 原地排序 (in-place); 将长度为 N 的数组排序所需的时间和NlgN成正比； 排序内循环比大多数排序算法都要短小，意味着无论是在理论上还是实际中都要更快。 缺点： 快速排序非常的脆弱，在实现时要非常小心才能避免低劣的性能。 基本算法快速排序是一种分治排序算法，它将一个数组分成两个子数组，将两部分独立地排序。不同于归并排序，快速排序的递归调用发生在处理子数之前。 快速排序方法抽象实现如下： 12345678910111213141516171819202122232425262728293031public class Quick &#123; // quick sort java implement. public static void quickSort(Comparable[] a) &#123; sort(a, 0, a.length-1); assert isSorted(a); &#125; private static void sort(Comparable[] a, int lo, int hi) &#123; if (hi &lt;= lo) return; int j = partition(a, lo, hi); sort(a, lo, j-1); sort(a, j+1, hi); &#125; private static void partition(Comparable[] a, int lo, int hi) &#123; int i = lo; int j = hi + 1; Comparable v = a[lo]; while (true) &#123; while (less(a[++i], v)) &#123; if (lo == hi) break; &#125; while (less(v, a[--j])) &#123; if (j == lo) break; // redundant since a[lo] is sentinel. &#125; // Check if pointers cross. if (j &lt;= i) break; exch(a, i, j); &#125; exch(a, lo, j); return j; &#125;&#125; 上述切分方法示意图: [from algs4] 切分轨迹图: [from algs4] 命题 K： 将长度为N的无重复的数组排序，快速排序平均需要 ~ $2NlnN$ 次比较(以及$1/6$的交换) [notice]: 尽管快速排序有很多优点，它的基本实现仍有一个潜在的缺点： 在切分不平衡时该算法可能及其低效。例如： 如果第一个次从最小的元素切分，第二次从第二小的元素切分，则这样每次只会移除一个元素。[solution] : 在快速排序之前将数组随机排序可以避免这种情况的发生。 算法改进1.切换到插入排序和大多数递归排序算法一样(如归并)，改进快速排序的简单方法基于以下两点： 对于小数组，快速排序比插入排序慢； 以为递归，快速排序的sort()方法在小数组中也会调用自己。 改进 ： 将sort()方法中的 1if (hi &lt;= lo) return; 改为： 1234if (hi &lt;= lo + M) &#123; insertion.sort(a, lo, hi); return;&#125; [notice] : 这里的切换参数 M 的最佳值是和系统相关的，但是5 ~ 15 之间的任意值在大多数情况下都能令人满意。 2. 三取样切分改进快速排序性能的第二个方法是使用子数组的一小部分的中位数来切分数组。这样的切分的效果更好，但代价是需要计算中位数。 人们发现将取样设为 3 并用大小居中的元素切分效果最好； 我们还可以将取样元素放在数组末尾作为哨兵(sentinel)。 三取样切分抽象实现 : 详细查看 1234567891011121314151617181920212223242526272829303132333435363738public static void quickSortImproved(Comparable[] a) &#123; sort(a, 0, a.length-1); assert isSorted(a);&#125;private staic void sort(Comparable[] a, int lo, int hi) &#123; dealPivot(a, lo, hi); int i = lo; int j = hi - 1; Comparable v = a[hi - 1]; // set the pivot at hi -1 as a sentinel. while (true) &#123; while (less(a[++i], v)) &#123; if (i == hi-1) break; // redundant since a[hi - 1] is sentinel. &#125; while (j &gt; lo &amp;&amp; less(v, a[--j])) &#123; &#125; // check if pointers cross. if (j &lt;= i) break; exch(a, i, j); &#125; if (i &lt; hi-1) &#123; exch(a, i, hi - 1); &#125; sort(a, lo, i - 1); sort(a, i + 1, hi);&#125;// 三取样并将切分元素放在数组末尾private static void dealPivot(Comparable[] a, int lo, int hi) &#123; int mid = lo + (hi - lo) / 2; if (less(a[mid], a[lo])) exch(a, lo, mid); if (less(a[hi], a[lo])) exch(a, lo, hi); if (less(a[hi], a[mid])) exch(a, mid, hi); // put the pivot to hi - 1 as a sentinel. exch(a, mid, hi - 1);&#125; 熵最优的排序实际应用中经常会出现含有大量重复元素的数组，我们实现的快速排序性能尚可，但是还有巨大的改进空间。例如：一个元素全部重复的子数组就不需要继续排序了，但我们的快速排序还是会继续将它切分为更小的数组。 [solution] : 一个简单想法是将数组切分为三个部分，分别为小于、等于和大于切分元素的数组元素。 DIjkstra 解法 ： 从左到右遍历数组一次，维护一个指针 lt 使得 a[lo .. lt-1]中的元素都小于v, 一个 gt 使得a[gt+1 .. hi]中的元素都大于v, 一个指针 i 使得a[lt .. i-1]中的元素都等于v, a[i .. gt]中的元素都未确定。 a[i] 小于 v, 将a[lt]和a[i]交换，将lt 和 i加一； a[i] 大于 v, 将a[gt]和a[i]交换， 将gt减一； a[i] 等于 v, i++. 熵最优排序抽象实现： 详细查看 123456789101112131415161718192021public static void quickSort(Comparable[] a) &#123; sort(a, 0, a.length-1); assert isSorted(a);&#125;private static void sort(Comparable[] a, int lo, int hi) &#123; if (hi &lt;= lo) return; Comparable v = a[lo]; int lt = lo; int i = lo + 1; int gt = hi; while (i &lt;= gt) &#123; if (less(a[i], v)) exch(a, i++, lt++); else if (less(v, a[i])) exch(a, gt--, i); else i++; &#125; // since a[lt .. i-1] is sorted. // sort the other subarrays recursively. sort(a, lo, lt-1); sort(a, gt+1, hi);&#125; [notice] : 三向切分的最坏情况是所有主键均不相同。对于标准的快速排序，随着数组规模的增大其运行时间会趋于平均时间，大幅偏离的情况是非常罕见的，因此可以肯定三向切分的快速排序运行时间和输入的信息量的N倍是成正比的。 ———— 因为对于包含大量重复元素的数组，它将排序时间从线性对数级降到了线性级别。 NOTICE本文中，涉及的算法详细实现和使用，请移步到github查看。]]></content>
      <categories>
        <category>Algorithms</category>
        <category>sorting algs</category>
      </categories>
      <tags>
        <tag>sorting algs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[归并排序 - mergeSort]]></title>
    <url>%2Fposts%2F1368334%2F</url>
    <content type="text"><![CDATA[引入归并排序属于分治算法(Divide and Conquer)。通过递归不断把待排序数组分成两个部分，将有序的两部分再重新归并一起来实现对数组的排序。 [pseudo code for 2-way merge sort]: 12345678910MergeSort(arr[], aux[], lo, hi)If hi &gt; lo 1. Find the middle point to divide the array into two halves; int mid = lo + (hi - lo) / 2; 2. Call MergeSort for first half; MergeSort(arr, aux, lo, mid); 3. Call MergeSort for second half; MergeSort(arr, aux, mid+1, hi); 4. Merge the two halves sorted in step 2 and 3; Call merge(arr, aux, lo, mid, hi); 原地归并的抽象方法要实现上述的归并方法 — merge()很简单，创建一个数组将需要归并的原数组的两个部分中的元素放到这个数组中，然后再归并按大小顺序放回原数组。 但是，这里我们要考虑一个问题，当我们用归并排序对一个比较大的数组进行排序时，我们需要进行很多次归并，因此在每一次归并时都创建一个新的数组来存储排序结果会带来问题。我们可以考虑只创建一个辅助数组aux[], 在每一个归并时，将原数组需要归并的两个部分复制到aux[]中，再把归并结果放回原数组。 123456789101112131415161718192021public static void merge(Comparable[] a, Comparable[] aux, int lo, int mid, int hi) &#123; // precondition: a[lo .. mid] and a[mid+1 .. hi] is sorted. assert isSorted(a, lo, mid); assert isSorted(a, mid+1, hi); // copy a[lo .. hi] to aux[lo .. hi]. for (int k = lo; k &lt;= hi; k++) &#123; aux[k] = a[k]; &#125; int i = lo; int j = mid+1; for (int k = lo; k &lt;= hi; k++) &#123; if (i &gt; mid) a[k] = aux[j++]; else if (j &gt; hi) a[k] = aux[i++]; else if (less(aux[j], aux[i])) a[k] = aux[j++]; else a[k] = aux[i++]; &#125; // postcondition: a[lo .. hi] is sorted. assert isSorted(a, lo, hi);&#125; [说明] : 该方法先将原数组两个需要归并的部分复制到aux[]中，然后从两个部分的起始位置开始取元素，一直选择两个部分中较小的元素放回原数组中，当有一部分元素取完了，则将另一部分剩余的元素全部放回原数组。 原地归并抽象方法轨迹： [from algs4] 自顶向下的归并排序1234567891011121314151617public static void mergeSort(Comparable[] a) &#123; int n = a.length; Comparable[] aux = new Comparable[n]; sort(a, aux, 0, a.length-1);&#125;private static void sort(Comparable[] a, Comparable[] aux, int lo, int hi) &#123; // If array size is 1 then return. if (hi &lt;= lo) return; // Find the middle point to divide array into two halves. int mid = lo + (hi - lo) / 2; // Call the mergeSort for first half. sort(a, aux, lo, mid); // Call the mergeSort for second half. sort(a, aux, mid+1, hi); // Merge two halves sorted. merge(a, aux, lo, mid, hi);&#125; 自顶向下归并结果轨迹 : [from algs4] 自顶向下归并排序调用轨迹 : [from algs4] 命题 F: 对于长度为 $N$ 的任意数组， 自顶向下归并排序需要 $1/2NlgN$ 至 $NlgN$ 次比较。 自顶向下的所需时间表达式为 : $T(N) = 2T(N/2) + O(n)$使用解决递归式的 Master method 解得 $T(N) = \Theta(n log n)$ 我们可以通过下图来理解命题F, 每个节点都表示一个sort()方法通过merge()方法归并而成的子数组。这棵树正好有 $n$ 层。对于$0 ~ n-1$ 之间的任意 $k$, 自顶向下的第 $k$ 层有 $2^k$个子数组，每个数组长度为 $2^{n-k}$, 归并最多需要 $2^{n-k}$ 次比较。因此每层的比较次数为$2^k X 2^{n-k} = 2^n$, n 层总共为 $n2^n = NlgN$。 子数组树状图 : [from algs4] 命题 G : 对于长度为 $N$ 的任意数组，自顶向下的归并排序最多需要访问数组 $6NlgN$ 次。 证明： 每次归并最多需要访问数组 $6N$ 次（$2N$ 次用来复制， $2N$次用来将排好序的元素移动回去，另外最多比较$2N$次），根据命题F即可得到这个命题的结果。 [小结]: 归并排序排序算法的缺点是辅助数组所使用的额外空间和N的大小成正比。一些能够大幅度缩短归并排序的运行时间的想法： 对小规模子数组进行插入排序； 测试数组是否已经有序； 不将元素复制到辅助数组中。 自底向上的归并排序实现归并排序另外一种方法是先归并那些微型数组， 然后再成对归并得到的子数组，直到将整个数组归并在一起。 12345678910public static void MergeBU(Comparable[] a) &#123; int n = a.length; Comparable[] aux = new Comparable[n]; for (int sz = 1; sz &lt; n; sz += sz) &#123; for (int lo = sz; lo &lt; n-sz; lo += sz+sz) &#123; merge(a, aux, lo, lo+sz-1, Math.min(lo+sz+sz-1, n-1)); &#125; &#125;&#123; [注] : 自底向上的归并排序会多次遍历整个数组，根据子数组大小进行两两归并。子数组的大小 sz 的初始值为 1， 每次加倍。最后一个子数组的大小只有在数组大小是 sz 的偶数倍的时候才会等于 sz(否则它会比sz小)。 自底向上归并排序结果轨迹 ： [from algs4] 命题 H : 对于长度为 $N$ 的任意数组， 自底向上的归并排序需要 $1/2NlgN$ 至 $NlgN$次比较，最多访问数组 $6NlgN$ 次。 证明 ： 处理一个数组的遍数正好是 $lgN$(即 $2^n &lt;= N &lt;2^n+1$ 中的 $n$)。每一遍会访问数组6N次。比较次数在 $N/2$ 和 $N$ 之间。 【补充】： 当数组长度为 2 的幂时，自顶向下和自底向上的归并排序所用的比较次数和数组访问次数正好相同，只是顺序不同。其他时候，两种方法的比较和数组访问的次序会有所不同。 NOTICE本文中，涉及的算法详细实现和使用，请移步到github查看。]]></content>
      <categories>
        <category>Algorithms</category>
        <category>sorting algs</category>
      </categories>
      <tags>
        <tag>sorting algs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基本排序算法 - basial sorting algorithms with java implementation]]></title>
    <url>%2Fposts%2F57d02cec%2F</url>
    <content type="text"><![CDATA[我们关注的主要对象是重新排列数组元素的算法， 其中每个元素都有一个主键。排序算法的目的就是将所有元素的主键按照某种方式排列(通常按照大小或是字母顺序)。 在java中元素通常都是对象，对主键的抽象描述则是通过一种内置的机制(Comparable接口)来完成的。 排序算法类模板1234567891011121314151617181920212223242526272829303132333435public class Example &#123; public static void exch(Comparable[] a, int i, int j) &#123; Comparable temp = a[i]; a[i] = a[j]; a[j] = temp; &#125; public static void sort(Comparable[] a) &#123; /*排序算法，如InsertionSort、BubbleSort、 SelectionSort、ShellSort等*/ &#125; private static void show(Comparable[] a) &#123; for (int i = 0; i &lt; a.length; i++) &#123; System.out.print(a[i] + " "); &#125; System.out.println(); &#125; public static boolean less(Comparable v, Comparable w) &#123; return v.compareTo(w) &lt; 0; &#125; public static boolean isSorted(Comparable[] a) &#123; for (int i = 1; i &lt; a.length; i++) &#123; if (less(a[i], a[i-1]) &#123; return false; &#125; &#125; return true; &#125; /** * Unit tests the &#123;@code Example&#125; sorting algorithm. * @args command-line arguments. */ public static void main(String[] args) &#123; // 测试代码... &#125;&#125; 这个类展示的是数组排序实现的框架。代码中实现的排序方法适用于任意实现了Comparable接口的数据类型。 验证无论数组的初始状态是什么，我们都无法确保排序算法都能成功。所以谨慎起见，我们会在测试代码中添加一条语句assert isSorted(a);来确保排序后的数组都是有序的。 运行时间评估算法的性能。首先，要计算各个排序算法在不同的随机输入下的基本操作的次数(包括比较和交换，或者是读写数组的次数)。 排序成本模型 : 在研究排序算法时，我们需要计算比较和交换的数量。 对于不交换元素的算法，我们会计算访问数组的次数。 额外的内存使用排序算法的额外内存开销和运行时间是同等重要的。排序算法可以分为两类: 除了函数调用所需的栈和固定数目的实例变量之外无需额外内存的原地排序算法。 需要额外内存空间来存储另一份数组副本的其他排序算法。 数据类型上面的排序模板适用于实现了Comparable接口的数据类型。例如, java中封装数字类型的Integer、Double、以及String和其他许多高级数据类型。而对于自己创建的数据类型，我们是要实现Comparable接口就能够保证能够使用排序算法进行排序。 自定义数据类型样例: 123456789101112131415161718192021222324public class Date implements Comparable&lt;Date&gt; &#123; private final int day; private final int month; private final int year; public Date(int d, int m, int y) &#123; day = d; month = m; year = y; &#125; public int day() &#123; return day; &#125; public int month() &#123; return month; &#125; public int year() &#123; return year; &#125; public int compareTo(Date that) &#123; if (this.year &gt; that.year) return +1; if (this.year &lt; that.year) return -1; if (this.month &gt; that.month) return +1; if (this.month &lt; that.month) return -1; if (this.day &gt; that.day) return +1 if (this.day &lt; that.day) return -1; return 0; &#125; public String toString() &#123; return month + "/" + day + "/" + year; &#125;&#125; 选择排序首先，找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置(如果第一个元素就是最小的元素那么它就和自己交换)。 再次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到整个数组排序完成。不断地选择剩余元素中的最小者。 命题 A: 对于长度为 $N$ 的数组，选择排序需要大约 $N^2/2$ 次比较和 $N$ 次交换。 证明： 可以通过算法的排序轨迹来证明，用一张$N X N$的表格来表示排序的轨迹，其中每个非灰色字符都表示一次比较。表格中大约有一半的元素不是 灰色的 — 即对角线和其上部分的元素。对角巷上的每个元素都对应真一次交换。通过查看代码我们可以更精确地得到，$0$ 到 $N-1$ 的任意 $i$ 都会 进行一次交换和 $N-1-i$ 次比较，因此 总共有$N$次交换以及 $(N-1)+（N-2)+…+2+1 = N(N-1)/2 ~ N^2/2$。 算法轨迹图示（from algs4)： 算法实现: 123456789101112131415public class Selection &#123; /* 其他的方法同排序算法模板*/ public static void sort(Comparable[] a) &#123; int n = a.length; for (int i = 0; i &lt; n; i++) &#123; int min = i; for (int j = i+1; j &lt; n; j++) &#123; if (less(a[j], a[min]) &#123; min = j; &#125; &#125; exch(a, i, min); &#125; &#125;&#125; 插入排序与选择排序一样，当前索引左边的所有元素都是有序的，但他们的最终位置不确定，为了给更小的元素腾出空间，它们可能会移动。当索引到达数组的右端时，数组排序就完成了。 和选择排序不同的是，插入排序所需的时间取决于输入中元素的初始顺序。例如对于一个很大且其中的元素已经有序（或接近有序）的数组进行插入排序将会比对随机数组或逆序数组进行排序要快得多。 命题 B : 对于随机排列的长度为 $N$ 且主键不重复的数组, 平均情况下插入排序需要 ~ $N^2/4$次比较以及 $~N^2/4$次交换。最坏情况下需要 ~N^2 /2 次比较和 ~ $N^2/2$次交换，最好情况下需要$N-1$次比较和$0$次交换。 证明： 和证明命题A一样，通过一个$N X N$的算法轨迹表可以很容易就得到交换和比较的次数。最坏的情况下对角线之下所有元素都需要移动位置，最 好情况下都不需要。对于随机排列的数组，在平均情况下每个元素都可能向后移动半个数组的长度 ，因此交换总数是对角线之下的元素总数的二分之。 比较的总次数是交换的次数加上一个额外的项，该项为 $N$ 减去被插入的元素正好是已知的最小 元 素的次数。在最坏情况下（逆序数组），这一 项相对于总数可以忽略不计；在最好的情况下（数组已经有序），这一项等于$N-1$。 插入排序算法轨迹图示（from algs4): 算法实现: 1234567891011public class Insertion &#123; /*其他的方法同排序算法模板*/ public static void sort(Comparable[] a) &#123; int n = a.length; for (int i = 1; i &lt; n; i++) &#123; for (int j = i; j&gt;0&amp;&amp;less(a[j], a[j-1]; j--) &#123; exch(a, j, j-1); &#125; &#125; &#125;&#125; 附加： 对于插入排序，我们要考虑的更一般情况是部分有序的数组。倒置指的是数组中的两个顺序颠倒的元素。比如EXAMPLE中有11对倒置：12E-A X-A X-M X-P X-L X-EM-L M-E P-L P-E L-E 如果数组中倒置的数量小于数组大小的某个倍数，那么我们说这个数组是部分有序的。几种典型的部分有序的数组: 数组中每个元素距离它的最终位置不远； 一个有序数组接一个小数组； 数组中只有几个元素位置不正确。 插入排序对这样的数组很有效，而选择排序则不然。当倒置的数量很少时，插入排序比大部分的其他排序算法都要快。 命题 C: 插入排序需要的交换的操作和数组的中倒置的数量相同，需要的比较次数大于等于倒置的数量，小于等于倒置的数量加上数组的大小再减一。 证明： 每次交换都改变了两个顺序颠倒的元素的位置，相当于减少了一对倒置，当倒置数量为0时，排序就完成了。每次交换都对应着一次比较，且$1$ 到$N -1$之间的每个$i$都可能需要一次额外的比较(在a[i]没有达到数组的左端时)。 [算法改进] : 大幅提高插入排序的速度，在内循环中将较大的元素都向右移动而不是总是交换两个元素(这样访问数组的次数就能减半)。 1234567891011public static void sort(Comparable[] a) &#123; int n = a.length; for (int i = 1; i &lt; n; i++) &#123; Comparable key = a[i]; int j; for (j = i-1; j &gt;= 0&amp;&amp;less(key, a[j]); j--) &#123; a[j+1] = a[j]; &#125; a[j+1] = key; &#125;&#125; 希尔排序希尔排序是基于插入排序的快速排序算法.对于规模乱序数组插入排序很慢，因为它只会交换相邻的元素，因此元素只能一点一点地从数组的一端移动到另外一端。希尔排序为了加快速度简单地改进了插入排序 —— 交换不相邻的元素以对数组的局部进行排序，并最终使用插入排序将局部有序的数组排序。 希尔排序的思想:使任意间隔为h的元素都是有序的。这样的数组称为h有序数组。对于任意以1为结尾的h序列（递增序列），我们使用它都能将数组排序。 算法实现： —— 使用的递增序列来自 algs4. 12345678910111213141516public class Shell &#123; /*其他排序算法方法同模板*/ public static void sort(Comparable[] a) &#123; int n = a.length; int h = 1; while (h &lt; n/3) h = 3 * h + 1; // 1， 4， 13， 40， 121， ... while (h &gt;= 1) &#123; for (int i = h; i &lt; n; i++) &#123; for (int j = i; j &gt;= h&amp;&amp;less(a[j], a[j-h]); j -= h) &#123; exch(a, j, j-h); &#125; &#125; h /= 3; &#125; &#125; &#125; [递增序列的选择] : 算法的性能不仅取决于h，还取决与h之间的数学性质。目前还没有人能证明某个递增序列是”最好的”。以上算法实现使用的递增序列（使用序列 $1/2(3^k-1)$,从N/3开始递减至1.）的计算和使用都很简单且和复杂的递增序列的性能接近。 算法轨迹图例 — example (from algs4): 实际应用: 对于中等大小的数组它的运行时间是可以接受的且它的代码量小，不需要额外的内存空间。所以在面临一个排序问题而没有系统排序函数可用时，可先用希尔排序，然后再考虑是否将它替换为更加复杂的排序算法。 [算法改进] : 由于希尔排序是基于插入排序，所以我们可以参照插入排序的改进，对希尔排序进行改进 — 把内循环中较大的元素右移而不是交换两个元素。 123456789101112131415public static void sort(Comparable[] a) &#123; int n = a.length; int h = 1; while (h &lt; n/3) h = 3 * h + 1; while (h &gt;= 1) &#123; for (int i = h; i &lt; n; i++) &#123; Comparable key = a[i]; int j; for (j = i-h; j &gt;= 0&amp;&amp;less(key, a[j]); j -= h) &#123; a[j+h] = a[j]; &#125; a[j+h] = key; &#125; &#125;&#125; 附加 —— 冒泡排序冒泡排序相对比较简单，这里直接给出它的实现: 12345678910111213141516public class Bubble &#123; /*其他排序算法方法同排序算法模板*/ public static void sort(Comparable[] a) &#123; int n = a.length; boolean flag = true; for (int i = 1; i &lt; n&amp;&amp;flag == true; i++) &#123; flag = false; for (int j = 0; j &lt; n-i; j++) &#123; if (less(a[j+1], a[j]) &#123; exch(a, j+1, j); flag = true; &#125; &#125; &#125; &#125; &#125; 算法分析: 对于冒泡排序，最坏情况下，算法需要进行N-1趟排序，总的数组元素比较的次数为$(N-1)+(N-2)+…+1$ ~ $N^2/2$， 总的交换次数为数组中倒置的数量。 NOTICE本文中，涉及的算法详细实现和使用，请移步到github查看。]]></content>
      <categories>
        <category>Algorithms</category>
        <category>sorting algs</category>
      </categories>
      <tags>
        <tag>sorting algs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[概率论与数理统计 Chapter Two - 随机变量及其分布]]></title>
    <url>%2Fposts%2F19e3879c%2F</url>
    <content type="text"><![CDATA[随机变量是概率论与数理统计研究的基本对象，它是定义在样本空间上的实函数.我们关心的是它取哪些值以及以怎样的概率取这些值，而分布函数完整地描述了随机变量取值的统计规律，且具有良好的分析性质，因此第二章 随机变量及其分布的主题是: 求随机变量的分布函数. 下面我们围绕如下三个问题讨论: 什么是随机变量? 何谓分布函数? 如何求分布? 一、什么是随机变量？将随机试验的样本空间$\small\mathbf{\Omega}$中的每个样本点$\small\mathbf{\omega}$, 按照某种对应法则$\small\mathbf{X}$, 对应数轴上唯一确定的一个实数$\small\mathbf{X(\omega)}$, 则称$\small\mathbf{X = X(\omega) (\omega \in \Omega)}$为随机变量. 二、何谓分布函数？1.分布函数的定义设$\small\mathbf{X}$为随机变量，对任意的$\small\mathbf{x \in (-\infty,+\infty)}$, 称$\small\mathbf{F(x) = P{X \leq x}}$为随机变量$\small\mathbf{X}$的分布函数. 2.分布函数的性质 $0 \leq F(x) \leq 1$; $F(x)$为单调不减函数; $F(x)$右连续; $F(-\infty) = 0, F(+\infty) = 1$. 3. 分布律&amp;概率密度 离散型 连续型 $X$ $x_1,x_2,...,x_n,...$ $p$ $p_1,p_2,...,p_n,...$ 概率密度$f(x)$ $F(x) = \sum_{x_k \leq x}p(x_k)$ $F(x) = \lmoustache_{-\infty}^xf(t)dt$ $0 \leq pi \leq 1\\sum{i=1}^{+\infty}p_i = 1$ $f(x) \geq 0\\lmoustache_{-\infty}^{+\infty}f(x)dx = 1\P{a \lt X \leq b} = \lmoustache_a^bf(x)dx\F^{‘}(x) = f(x)$ 4. 八大分布离散型 离散型 分布律 说明 0-1分布 $P{X = k}=p^k(1-p)^{1-k}\\qquad(k = 0,1)$ $X$ $0\quad1$ $P$ $q\quad p$ 二项分布 $P{X=k}=C_n^kp^k(1-p)^{n-k}\\qquad(k=0,1,…,n)$ n重贝努利试验$X\sim B(n,p)$ 泊松分布 $P{X=k}=\frac{\lambda^k}{k!}e^{-\lambda}\\quad(k=0,1,2,…)$ 单位时间人流数$X\sim P(\lambda)/\pi(\lambda)$ 几何分布 $P{X=k}=p(1-p)^{k-1}\\qquad(k=1,2,…)$ 等待型分布$X\sim G(p)$ 超几何分布 $P{X=k}=C^kMC^{n-k}{N-M}/C_N^n\\quad(k=0,1,2,…,min{n,M})$ 从$\small{N}$件产品中任取n件, 抽到k件次品的概率 连续型(1)均匀分布：设随机变量$\small\mathbf{X}$的概率密度为$\displaystyle \mathbf{f(x)} = \left{\begin{array}{cc}\displaystyle\mathbf{\frac{1}{b-a},\qquad x\in (a,b)}\\displaystyle\mathbf{0,\qquad\qquad 其它}\end{array}\right.$ 则称$\small\mathbf{X}$在$\small\mathbf{(a,b)}$内服从均匀分布，记为$\small\mathbf{X\sim U(a,b)}$,其分布函数为$\displaystyle\mathbf{F(x)=\left{\begin{array}{cc}\mathbf{0,\qquad x \lt a}\\mathbf{\frac{x-a}{b-a},\quad a\leq x\lt b}\\mathbf{1,\qquad x\geq b}\end{array}\right.}$ (2)指数分布: 设随机变量$\small\mathbf{X}$的概率密度为$\displaystyle\mathbf{f(x)=\left{\begin{array}{cc}\mathbf{\lambda e^{-\lambda x},\qquad x \gt 0}\\mathbf{0,\qquad\qquad 其它}\end{array}\right.}\quad\mathbf{(\lambda \gt 0)}$ 则称$\small\mathbf{X}$服从参数为$\small\mathbf{\lambda}$的指数分布，记为$\small\mathbf{X\sim E(\lambda)}$, 其分布函数为$\displaystyle\mathbf{F(x)}=\left{\begin{array}{cc}\mathbf{1-e^{-\lambda x},\qquad x \geq 0}\\mathbf{0,\qquad\qquad\quad 其它}\end{array}\right.$ [注]:指数分布具有无记忆性，即$\qquad P{X\gt a+b|x\gt a} = P{X\gt b}$ (3)正态分布: 设随机变量$\small\mathbf{X}$的概率密度为$\large\mathbf{\quad f(x)=\frac{1}{\sqrt{2\pi \sigma}}e^{\frac{(x-\mu)^2}{2\sigma^2}}\quad(\sigma\gt 0,x\in (-\infty,+\infty)}$ 则称$\small\mathbf{X}$服从正态分布，记为$\small\mathbf{X\sim N(\mu,\sigma^2)}$.特别地，当$\small\mathbf{\mu=0,\sigma=1}$时，称$\small\mathbf{X}$服从标准正太分布，其概率密度为$\displaystyle\mathbf{\quad\varphi(x)=\frac{1}{\sqrt{2\pi}}e^{-\frac{x^2}{2}}\qquad x\in(-\infty,+\infty)}$ [注记]： $\mathbf{\Phi(0)=1/2}$; $\mathbf{\Phi(-a)=1-\Phi(a)}$; $\mathbf{P{X\leq \mu}=P{X\gt \mu}=1/2}$; 若$\mathbf{X\sim N(\mu,\sigma^2)}$,则$\displaystyle\mathbf{F(x)=\Phi\lgroup\frac{x-\mu}{\sigma}\rgroup},$ $\displaystyle\mathbf{P{a\lt X\leq b}=F(b)-F(a)\\qquad\qquad\qquad=\Phi\lgroup\frac{b-\mu}{\sigma}\rgroup}-\Phi\lgroup\frac{a-\mu}{\sigma}\rgroup$ 若$\mathbf{X\sim N(\mu,\sigma^2)}$, 则$\displaystyle\mathbf{\frac{x-\mu}{\sigma}\sim N(0,1)}.$ 三、如何求分布？]]></content>
      <categories>
        <category>数学学习</category>
        <category>概率论与数理统计</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>概率论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[概率论与数理统计 Chapter One - 随机事件与概率]]></title>
    <url>%2Fposts%2F76a9cf42%2F</url>
    <content type="text"><![CDATA[《概率论与数理统计》是利用微积分为工具，研究随机现象的统计规律性！而第一章 随机事件和概率是整个概率论和数理统计的工具和基础，必须踏实地学好！这一章的中心主题是: 求事件的概率。 下面将围绕如下三个问题讨论: 什么是事件? 何谓概率？ 如何求概率？ 什么是事件？1.随机试验称满足如下三个条件的试验为随机试验，简称试验: 相同条件下可重复； 所有基本结果确定； 试验前结果未知. 2.样本空间随机试验$\mathbf{E}$的所有可能的基本结果构成的集合称为$\mathbf{E}$的样本空间，记作$\mathbf{\Omega}$. 每一个基本结果称为样本点，记作$\mathbf{\omega}$. 3.随机事件样本空间$\mathbf{\Omega}$的子集称为随机事件. $\mathbf{\Omega}$ : 必然事件 $\mathbf{\emptyset}$ : 不可能事件 4.事件的运算 运算 符号 和(并) $A + B$或$A \cup B$ 积(交) $AB$或$A \cap B$ 差 $A - B$ 逆(补) $\bar{A}$ 5. 事件的关系 关系 符号 包含 $A \supset B$ 相等 $A = B$ 互斥(不相容) $AB = \emptyset$ 对立 $AB = \emptyset且A + B = \Omega$ 6.事件运算的性质德摩根律 ： $\mathbf{\overline{A + B} = \bar{A}\bar{B}, \overline{AB} = \bar{A} + \bar{B}}.$ 何谓概率？1.概率的公理化定义设$\mathbf{E}$为随机试验，$\mathbf{\Omega}$为样本空间，称随机事件函数$\small \mathbf{P(x)}$为概率，若$\small \mathbf{P(x)}$满足: 非负性 : $\small \mathbf{P(A) \ge 0}$,对于任意的事件$\small \mathbf{A}$; 规范性 : $\small \mathbf{P(\Omega) = 1}$; 可列可加性 : 设$\small \mathbf{A_1,A_2,…,A_n,…}$为两两互斥事件，$\small \mathbf{P(A_1 + A_2 + … + A_n + …) = P(A_1) + P(A_2) + … + P(A_n)} $ 2.概率的性质 $P(\emptyset) = 0$; $设A_1,A_2,A_3,…,A_n为两两互斥事件，P(A_1 + A_2 + A_3 + … + A_n)\= P(A_1) + P(A_2) + P(A_3) + … + P(A_n);$ $0 \le P(A) \le 1, 对于任意事件A$; $P(\bar{A}) = 1 - P(A)$; $若A \subset B, 则 P(A) \le P(B)$. 3.条件概率&amp;事件的独立性1.条件概率设$P(A) \gt 0$, 则在事件$A$发生的条件下，事件$B$发生的概率定义为:$\qquad \qquad \qquad \qquad \displaystyle P(B|A) \triangleq \frac{P(AB)}{P(A)}$ 条件概率$\displaystyle P(x|A)$也是概率，因此具有概率的所有性质，比如： $\qquad P(B+C|A) = P(B|A) + P(C|A) - P(BC|A)$$\qquad \displaystyle P(\bar{B}|A) = 1 - P(B|A)$$\qquad \displaystyle P(B-C|A) = P(B|A) - P(BC|A)$ 2.事件的独立性若$\small \mathbf{P(AB) = P(A) P(B)}$, 则称事件$\small \mathbf{A, B}$相互独立.若$\left{ \begin{array}{rcl} \small \mathbf{P(AB) = P(A)P(B)}\\small \mathbf{P(BC) = P(B)P(C)}\\small \mathbf{P(AC) = P(A)P(C)}\\small \mathbf{P(ABC) = P(A)P(B)P(C)}\end{array}\right.$,则称事件$\small \mathbf{A,B,C}$相互独立. [注] 三个事件两两独立，则三个事件不一定相互独立; 若$\small \mathbf{A,B}$相互独立，则$\small \mathbf{\bar{A},B; A,\bar{B}; \bar{A},\bar{B}}$都相互独立; 若$\small \mathbf{ P(A)= 0}$或$\small \mathbf{P(A) = 1}$, 则事件$\small \mathbf{A}$与任意事件独立; 事件独立的等价条件 设$\small \mathbf{P(A) = 0}$,则$\small \mathbf{A,B}$独立的充要条件为:$\small \mathbf{P(B|A) = P(B)}$. 设$\small \mathbf{0 \lt P(A) \lt 1}$, 则$\small \mathbf{A, B}$独立的充要条件为:$\small \mathbf{P(B|A) = P(B|\bar{A})}$. 互斥、对立&amp;独立事件的比较 事件定义概率性质 互斥$\small \mathbf{AB = \emptyset}$ $\small \mathbf{P(A+B) = P(A) + P(B)}$ 对立 $\small \mathbf{AB = \emptyset}$且$\small \mathbf{A+B = \Omega}$ $\small \mathbf{P(B) = 1 - P(A)}$ 独立 $\small \mathbf{P(AB) = P(A)P(B)}$ 如何求概率？1.古典概型样本空间$\small \mathbf{\Omega}$有限且每个基本结果等可能发生.则随机事件$\small \mathbf{A}$的概率为:$\displaystyle \quad \mathbf{P(A) = \frac{k}{n}}$ 其中，$\small \mathbf{n}$为样本空间$\small \mathbf{\Omega}$的样本点总数，k为随机事件$\small \mathbf{A}$中样本点的总数. 2.几何概型样本空间$\small \mathbf{\Omega}$无限且每个基本结果等可能发生.则随机事件$\small \mathbf{A}$的概率为:$\displaystyle \quad \mathbf{P(A) = \frac{A的几何度量}{\Omega的几何度量}}$ 3.贝努利概型若随机试验$\mathbf{E}$满足: 每次试验只有两种可能结果({$\small \mathbf{A, \bar{A}}$)； 概率不发生变化($\small \mathbf{P(A) = p}$); 各次试验相互独立. 试验$\mathbf{E}$重复n次，则称这样的试验为n重贝努利试验，事件$\small \mathbf{A}$发生k次的概率为:$\quad \displaystyle \mathbf{P_n(k) = C^k_np^k(1-p)^{n-k}}$ 4.五大公式1.加法公式$\displaystyle \mathbf{P(A+B) = P(A) + P(B) - P(AB)\P(A+B+C) = P(A) + P(B)+P(C)\ \qquad\qquad\qquad\qquad-P(AC)-P(BC)-P(AB)+P(ABC)}$. 2.减法公式$\displaystyle \mathbf{P(A-B) = P(A) - P(AB) = P(A\bar{B})}$ 3.乘法公式$\displaystyle \mathbf{P(AB) = P(A)P(B|A) = P(B)P(A|B)\P(ABC) = P(A)P(B|A)P(C|AB)}$ 4.全概率公式设$\small \mathbf{A_1,A_2,…,A_n}$为两两互斥，且$\small \mathbf{A_1+A_2+…+A_n = \Omega}$(称$\small \mathbf{A_1,A_2,…,A_n}$为完备事件组)，则$\displaystyle\mathbf{P(B) = P(A_1)P(B|A_1)+P(A_2)P(B|A_2)\\qquad\qquad+…+P(A_n)P(B|A_n)}$ 5.贝叶斯公式设$\small \mathbf{A1,A_2,…,A_n}$为完备事件组，则$\displaystyle \mathbf{P(A_k|B) = \frac{P(A_k)P(B|A_k)}{\sum{i=1}^nP(A_i)P(B|A_i)}}$ [注]:$\mathbf{P(AB)} = \left{ \begin{array}{cc} \small \mathbf{P(A)P(B|A)\qquad\qquad\qquad\quad P(A) \gt 0}\\small \mathbf{P(B)P(A|B)\qquad\qquad\qquad\quad P(B) \gt 0}\\small \mathbf{P(A)P(B)\qquad\qquad\qquad\qquad A,B}\normalsize\mathbf{独立}\\small \mathbf{0\qquad\qquad\qquad\qquad\qquad\qquad}\normalsize\mathbf{互斥}\\small \mathbf{P(B)\qquad\qquad\qquad\qquad\qquad A \subset B}\\small \mathbf{P(A)+P(B)-P(A+B)\qquad}\normalsize\mathbf{加法公式}\end{array}\right.$]]></content>
      <categories>
        <category>数学学习</category>
        <category>概率论与数理统计</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>概率论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSP 基础学习]]></title>
    <url>%2Fposts%2F67d7cfb7%2F</url>
    <content type="text"><![CDATA[Java 服务器页面(jsp) 是用来开发动态页面的一项技术。 概述JSP 允许开发人员使用指定的 JSP 标签来向html页面中插入java源代码，标签通常是以 &lt;% 开头并以 %&gt; 结束。 为什么使用 JSP？使用Java服务器页面(jsp)与使用实现 Common Gateway Interface(CGI)的程序目的是大致相同的。但对比CGI，jsp有以下优点： 性能较好。因为JSP允许直接在html页面中嵌入动态元素，而不需要独立持有CGI文件； JSP在服务器处理前都会进行预编译，不像 CGI/Perl, 每次页面被请求时，服务器都需要加在一个解释器(interperter) 以及目标脚本(target script); JSP是基于 Java Servlets API 构建的，因此，和Servlets一样，JSP也可以使用这些强大的Enterprise Java API, ：JDBC, JNDI, EJB, JAXP, 等等**； JSP 页面可以和处理业务逻辑的servlets结合使用，该模型由java servlet 模板引擎提供支持。 最后，JSP是JavaEE(企业级应用程序的完整平台)的一个组成部分。这意味着JSP可以在最简单的应用程序中扮演最复杂和最苛刻的角色。 使用JSP的优势下面通过对比不同的技术来体现使用JSP的优点： vs. Active Server Pages (ASP)对比ASP, JSP有两大优点：第一是页面的动态部分是用java写的，而不是Visual Basic或其他MS特定的语言编写，所以它更强有力且易于使用；第二是它可以移植到其他的操作系统和非Microsoft的Web 服务器上，这使它更加健壮。 vs. Pure Servets（纯Servlets)使用JSP可以更容易编写和修改常规的html代码，而不是使用大量的 println语句来生成HTML。 vs. Server-Side Includes (SSI)SSI 实际上只适用于处理简单内容的程序，而不适用于使用表单数据，进行数据库连接等的程序。 vs. JavascriptJavaScript 可以在客户端生成HTML，但很难和Web 服务器实现复杂任务的交互，例如：数据库访问以及图像处理等。 vs. 静态HTML常规的HTML不能包含动态的内容，无法动态地改变页面展示的数据。 架构Web服务器需要JSP引擎（容器）才能处理JSP页面。JSP容器负责拦截JSP页面的请求。JSP容器和Web服务器一起可以为JSP提供运行环境和其他服务。使服务器可以识别JSP中的特殊元素。 下面展示的是JSP容器和JSP文件在Web应用程序中的位置： JSP处理过程下面的步骤是Web服务器处理JSP生成Web页面的过程： 和普通的页面一样，客户端的浏览器会向Web服务器发起一个HTTP请求。 Web服务器识别出该HTTP请求是JSP请求，然后将请求转发给JSP引擎处理。即请求链接是以.jsp结尾的URL。 JSP引擎从硬盘中加载JSP页面并将它转换为Servlet文件。该转换过程非常简单，将所有的模板内容都转换为println()语句，所有的JSP元素都转换为Java代码。这些Java代码实现了页面中的动态行为。 JSP引擎将Servlet文件编译成可执行class文件，并将原始请求转发给servlet引擎。 Servlet引擎加载Servletclass文件并执行。执行期间，生成HTML文件并放在HTTP response中，随后通过servlet引擎移交给Web服务器。 Web服务器将包含静态HTML内容的HTTP响应转发到客户端浏览器。 最后，客户端浏览器HTTP响应中由服务器动态生成的静态HTML内容。 以上的步骤的流程图示： 通常，JSP引擎会检查JSP文件对应的Servlet文件是否已经存在，若是，如果JSP文件的修改日期旧于对应的Servlet文件，JSP引擎则认为JSP没有改变且已经的生成的Servlet文件仍然匹配JSP文件的内容。这中处理使得JSP的处理和运行速度比其他的脚本语言(如：PHP）更高效、更快。 其实，JSP页面是编写servlet的另外一种方式，不需要Java编程。除了上述的JSP处理过程中的翻译转换过程，JSP和一般的servlet处理方式一样。 生命周期理解JSP低级功能的关键就是简单了解JSP的生命周期。JSP的生命周期就是jsp从创建到销毁的过程。该过程与servlet的生命周期类似，不过多了一个将JSP编译转换为servlet文件的步骤。 JSP遵循的过程 编译 (Compilation) 初始化 (Initialization) 执行 (Execution) 销毁 (Cleanup) JSP生命周期的四个主要阶段： JSP编译阶段当浏览器请求JSP页面时，JSP引擎首先检查是否需要编译该JSP页面。如果页面还为编译过，或者JSP文件被修改，JSP引擎就编译该页面。 编译阶段包含下面三个步骤： 解析JSP页面 将JSP转换为servlet 编译servlet为class文件 JSP初始化阶段当JSP容器加载JSP时，它会在处理任何请求之前调用jspInit()方法。如果需要执行特定的JSP初始化，直接覆盖jspInit()方法就行： 123public void jspInit() &#123; // Initialization code...&#125; 通常，和servlet的init()方法一样，该初始化方法只执行一次，一般是初始化数据库连接，打开文件和创建查找表格(look-up table)。 JSP执行阶段这一阶段表示在销毁JSP之前与请求的所有交互。每当浏览器请求JSP并且页面已加载以及初始化时，JSP引擎就会调用JSP的_jspService()方法。 _jspService()方法拥有两个参数HttpServletRequest和HttpServletResponse: 123public void _jspService(HttpServletRequest request, HttpServletResponse response) &#123; // Service handling code...&#125; _jspService()方法在request的基础上调用。主要负责生成请求的响应，同时也可以生成所有的七种HTTP请求方式对应的响应，GET, POST, DELETE 等。 JSP销毁阶段JSP生命周期的销毁阶段表示从容器中移除JSP。JSP中的jspDestroy()方法等价于servlet中的destroy()方法。通过覆盖jspDestroy()方法可以实现特定的销毁需求，例如：释放数据库连接， 关闭文件等。 123public void jspDestroy() &#123; // cleanup code goes here.&#125; 语法简单了解JSP开发中涉及到的语法(JSP元素的使用)。 小脚本(Scriptlet)元素小脚本可以包含任意多行Java语句，变量， 方法申明，以及表达式。 使用Scriptlet的语法： 1&lt;% code fragment %&gt; XML方式语法的等价表达方式: 123&lt;jsp:scriptlet&gt; code fragment&lt;/jsp:scriptlet&gt; 其他编写的任何文本，HTML标签或JSP元素都必须为与Scriptlet之外。下面是JSP使用Scriptlet的简单示例: 12345678910&lt;html&gt; &lt;head&gt;&lt;title&gt;Hello World&lt;/title&gt;&lt;/head&gt; &lt;body&gt; Hello World!&lt;br /&gt; &lt;% out.println("Your IP address is " + request.getRemoteAddr()); %&gt; &lt;/body&gt;&lt;/html&gt; 申明(Declarations)元素一个申明(declaration)可以的申明一个或多个变量，方法，以便在后续的Java代码中使用。在我们是使用Scriptlet编写Java代码之前，应该申明变量或方法。 JSP申明语法： 1&lt;%! declaration; [declaration; ] + ... %&gt; XML等价于语法： 123&lt;jsp:declaration&gt; declarations define here.&lt;/jsp:declaration&gt; 简单例子： 123&lt;%! int i = 0; %&gt;&lt;%! int a, b, c; %&gt;&lt;%! Circle a = new Circle(2.0); %&gt; JSP表达式元素一个JSP表达式元素可以包含一个脚本语言表达式，该表达式可以通过计算，转换为String，并插入表达式出现在JSP文件中的位置。 因为表达式中的值最终是转换为String，所以我们可以在JSP文件中使用一行文本编写表达式，无论是否使用HTML标签都可以。表达式可以包含Java语言规范有效的任何表达式，但不能使用分号来结束表达式。 使用JSP表达式的语法: 1&lt;%= expression %&gt; XML语法等价表达方式: 123&lt;jsp:expression&gt; expression&lt;/jsp:expression&gt; 使用JSP表达式例子: 123456&lt;html&gt;&lt;head&gt;&lt;title&gt;A Comment Test&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Today's date: &lt;%= (new java.util.Date()).toLocaleString()%&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 上面例子的运行结果可能是: 1Today&apos;s date: 11-Sep-2017 21:24:11 JSP注释元素JSP容器会忽略使用JSP注释标记的文本和语句。 使用语法: 1&lt;%-- This is JSP comment --%&gt; 简单使用例子： 1234567&lt;html&gt;&lt;head&gt;&lt;title&gt;A Comment Test! &lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;A Test of Comments&lt;/h2&gt;&lt;%-- This comment will not be visible in the page source --%&gt;&lt;/body&gt;&lt;/html&gt; 我们可以在各种情况下使用少量的特殊结构来插入注释和字符，否则这些注释或字符将被特殊处理. Syntax Purpose &lt;%-- comment --%&gt; JSP注释，文本内容被JSP引擎忽略 &lt;!-- comment --&gt; HTML注释，文本内容被浏览器忽略 &lt;\% 表示静态的字符&lt;% %\&gt; 表示静态的字符%&gt; \&#39; 在属性中使用单引号 \&quot; 在属性中使用双引号 JSP指令(Directives)元素JSP指令元素会影响Servletclass文件的整体结构。使用方式: 1&lt;%@ directive attribute="value" %&gt; JSP中的三种指令元素： Directive Description &lt;%@ page ... %&gt; 定义页面相关属性，例如使用脚本语言，错误页面和缓冲请求等 &lt;%@ include ... %&gt; 在翻译转换阶段导入文件 &lt;%@taglib ... %&gt; 申明包含页面中使用的自定义标签的标签库 page 指令元素page指令用于向容器提供指令。这些指令适用于当前的JSP页面。我们可以在JSP页面中的任何位置编写page指令，但是按照惯例，该指令一般写在JSP的顶部。 使用page指令的基本语法: 1&lt;%@ page attribute = "value" %&gt; XML语法等价表达方式: 1&lt;jsp:directive.page attribute = "value" /&gt; page 指令属性下面的表格列出的是跟page指令相关的属性: Attribute Purpose buffer 指定输出流的缓冲模式 autoFlush 控制servlet输出缓冲区的行为 contentType 定义字符编码模式 errorPage 定义报告Java未检查的运行时异常的另一个JSP的URL isErrorPage 指示此JSP页面是否由另一个JSP页面的errorPage属性指定 extends 指定生成的servlet需要继承的超类 import 指定JSP中是使用的包或类的列表，如Javaimport语句那样 info 定义一个能被servlet的getServletInfo()方法访问的字符串 isThreadSafe 定义生成的servlet的线程模式 language 定义JSP页面中使用的编程语言，默认java session 指定JSP页面是否使用HTTPsession isELIgnored 指定JSP页面内的EL表达式是否忽略 isScriptingEnabled 确定是否允许使用脚本元素 include 指令元素include指令用于告诉容器在翻译阶段将其他的外部文件与当前JSP文件合并。我们可能在JSP页面中任何位置使用该指令元素。 普通的语法: 1&lt;%@ include file = "relative url" &gt; XML语法等价表达方式： 1&lt;jsp:directive.include file = "relative url" /&gt; include指令中的文件名实际上是一个相对URL。如果文件名没有指定关联路径的话，JSP编译器会认为文件与当前JSP页面在同一目录下。 taglib 指令元素JSPAPI允许我们定义像HTML或XML标签那样的自定义标签，标签库就是实现用户行为的自定义标签的集合。 常规使用语法: 1&lt;%@ taglib uri = "uri" prefix = "prefixOfTag" &gt; 这里的uri属性值解析为容器能够理解的位置，prefix属性告诉容器哪些标记是自定义的。 同样它也是可以使用XML语法的形式的： 1&lt;jsp:directive.taglib uri = "uri" prefix = "prefixOfTag" /&gt; JSP动作(Actions)元素JSP动作元素使用XML语法结构，可以控制servlet引擎的行为。通过它，我们可以动态插入一个文件，服用JavaBeans，跳转到另一个页面，或者为Java插件生成HTML。 使用JSP动作元素只用一种语法，符合XML标准: 1&lt;jsp:action_name attribute="value" /&gt; 动作元素其实预定义的基础函数，下面的表格展示了我们可以使用的JSP动作元素: Syntax Purpose jsp:include 在页面被请求时，动态导入一个文件 jsp:useBean 查找或实例化一个JavaBean jsp:setproperty 为一个JavaBean设置属性 jsp:getProperty 将JavaBean的属性插入到输出中 jsp:forward 将用户转发到一个新的页面 jsp:plugin 用于生成特定的浏览器代码，为Java插件生成OBJECT或EMBED标记 jsp:element 动态定义一个XML元素 jsp:attribute 定义动态定义的XML元素的属性 jsp:body 定义动态定义的XML元素的主体(body) jsp:text 用于在JSP页面和文档中写模板文本 共同属性(Common Attributes)对于所有的动作元素, 它们都有两个共同的属性, 即id和scope属性。 Id 属性id属性用于唯一标识动作元素，并允许在JSP页面中因引用该动作元素。如果动作元素创建某个对象的实例，则可以使用id值通过隐式对象PageContext来引用它。 Scope 属性scope属性申明了动作元素的生命周期。id属性和scope属性是直接相关的，因为scope属性确定了与id相关联的对象的生命周期。scope属性有四种取值: page request session application &lt;jsp:include&gt;动作元素该动作元素允许我们将文件插入到正在生成的页面中。使用语法如下： 1&lt;jsp:include page = "relative URL" flush = "true" /&gt; [notice]:不像include指令元素，只在JSP页面的翻译阶段插入文件，该动作元素是在每次页面被请求时都将文件进行插入。 下面的表格列出的是与include动作元素相关的属性: Attribute Description page 需要被包含的页面的相对路径 flush 确定包含的资源是否在其被包含之前刷新其缓冲区 例子： 定义两个JSP页面，date.jsp和main.jsp， 并将date.jsp插入main.jsp中. date.jsp: 1&lt;p&gt;Today&apos;s date: &lt;%= (new java.util.Date()).toLocaleString()%&gt; main.jsp: 1234567891011&lt;html&gt; &lt;head&gt; &lt;title&gt;The include Action Example&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;center&gt; &lt;h2&gt;The include action Example&lt;/h2&gt; &lt;jsp:include page = "data.jsp" flush = "true" /&gt; &lt;/center&gt; &lt;/body&gt;&lt;/html&gt; &lt;jsp:useBean&gt;动作元素useBean动作元素非常常用，它首先使用id和scope变量搜索现有对象，如果找不到对象，则会尝试创建指定的对象。 使用语法: 1&lt;jsp:useBean id = "name" class = "package.class" /&gt; 一旦bean类被加载后，就可以通过jsp:setProperty和jsp:getProperty动作元素来修改和检索bean的属性。 下面的表格列出了与jsp;useBean相关的属性: Attribute Description class 指定bean的完整包名称 type 指定引用该对象的变量类型 beanName 给出java.beans.Beans类中instantiate()方法指定的bean的名称 &lt;jsp:setProperty&gt;动作元素jsp:setProperty动作元素用于设置bean的属性。在使用该动作元素之前，bean类必须预先定义。下面是使用jsp:setProperty动作元素的两种方式。 1.我们可以在jsp:useBean之后，且在其元素外使用jsp:setProperty动作元素。如： 123&lt;jsp:useBean id = "myName" ... /&gt;...&lt;jsp:setProperty name = "myName" property = "someProperty" ... /&gt; 在上面的例子的情况下，无论是否实例化新bean或找到现有bean，都会执行jsp:setProperty动作元素。 第二种方式是jsp:setProperty可以出现在jsp:useBean元素的主体中。 1234&lt;jsp:useBean id = "myName" &gt; ... &lt;jsp:setProperty name = "myName" property = "someProperty" ... /&gt;&lt;/jsp:useBean&gt; 这种情况下，jsp:setProperty元素只有在创建新的bean时，才会被执行。 下面是与jsp:setProperty元素相关的属性: Attribute Description name 指定设置属性的bean，bean必须预先定义 property 申明想要设置的属性。取值*的话，则表示名称与bean属性匹配的所有请求参数将传递给相应的setter方法 value 要分配给指定属性的值。参数值为null，或者参数不存在，将忽略jsp:setProperty操作 param param属性是请求参数的名称，该属性将接受其值。不能同时使用value和param属性 jsp:getProperty动作元素jsp:getProperty动作元素用于检索给定属性的值，并将它转换为String字符串，最后插入到输出中。 该动作元素只有两个属性，且它们都是必须的。使用语法如下: 123&lt;jsp:useBean id = "myName" ... /&gt;...&lt;jsp:getProperty name = "myName" property = "someProperty" ... /&gt; 下面的表格给出了与getProperty元素的相关属性: Attribute Description name 要检索属性的bean的名称。bean必须预先定义 property 要检索的属性名称 jsp:setProperty和jsp:getProperty使用例子： 定义一个简单的TestBean.java: 1234567891011package test.beans;public class TestBean &#123; private String message = "No message specified"; public String getMessage() &#123; return message; &#125; public vodi setMessage(String message) &#123; this.message = message; &#125;&#125; 在main.jsp页面中做测试： 12345678910111213141516&lt;html&gt; &lt;head&gt; &lt;title&gt;Using JavaBeans in JSP&lt;/title&gt; &lt;body&gt; &lt;center&gt; &lt;h2&gt;using JavaBeans in JSP&lt;/h2&gt; &lt;jsp:useBean id = "test" class = "test.beans.TestBean" /&gt; &lt;jsp:setProperty name = "test" property = "message" value = "Hello JSP" /&gt; &lt;p&gt;Got message....&lt;/p&gt; &lt;jsp:getProperty name = "test" property = "message" /&gt; &lt;/center&gt; &lt;/body&gt; &lt;/head&gt;&lt;/html&gt; jsp:forward动作元素jsp:forward动作元素会终止当前页面的操作，并将请求转发到另一个资源，例如：静态页面，另一个JSP页面或Java Servlet。 使用jsp:forward动作元素的语法： 1&lt;jsp:forward page = "Relative URL" /&gt; 下面的表格给出了与该动作元素相关的必须属性: Attribute Description page 另一个资源的相对URL，例如：静态页面，另一个JSP页面，或者一个Java Servlet 使用例子: 定义date.jsp和main.jsp，并使用在main.jsp页面中跳转到date.jsp页面: date.jsp: 1&lt;p&gt;Today's date: &lt;%= (new java.util.Date()).toLocaleString()%&gt;&lt;/p&gt; main.jsp: 123456789101112&lt;html&gt; &lt;head&gt; &lt;title&gt;The include Action Example&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;center&gt; &lt;h2&gt;The include action Example&lt;/h2&gt; &lt;jsp:forward page = "date.jsp" /&gt; &lt;/center&gt; &lt;/body&gt;&lt;/html&gt; 运行结果可能是: 1Today&apos;s date: 12-July-2017 14:54:22 jsp:plugin动作元素jsp:plugin动作元素用于在JSP页面中插入Java组件。它确定浏览器的类型，并根据需要插入的&lt;object&gt;或&lt;embed&gt;标签。 如果所需的插件不存在，则下载插件然后执行Java组件。Java组件可以是Applet或JavaBean。 该动作元素有几个属性，对应用于格式化java组件的常用HTML标签元素。&lt;param&gt;元素也可用于将参数发送到Applet或Bean中。 以下是使用jsp:plugin元素的语法： 12345678&lt;jsp:plugin type = "applet" codebase = "dirname" code = "MyApplet.class" width = "60" height = "80" &gt; &lt;jsp:param name = "fontcolor" value = "red" /&gt; &lt;jsp:param name = "background" value = "black" /&gt; &lt;jsp:fallback&gt; Unable to initialize Java Plugin &lt;/jsp:fallback&gt;&lt;/jsp:plugin&gt; 上面的&lt;jsp:fallback&gt;元素可用于指定在组件发生故障时要发送给用户的错误字符串。 &lt;jsp:element&gt;, &lt;jsp:attribute&gt;和&lt;jsp:body&gt;动作元素主要用于动态定义XML元素。这意味着XML元素可以在请求时动态生成，而不是在编译时静态生成。 下面是动态定义XML元素的一个简单例子: 12345678910111213141516171819&lt;%@page language = "java" contentType = "text/html"%&gt;&lt;html xmlns = "http://www.w3c.org/1999/xhtml" xmlns:jsp = "http://java.sun.com/JSP/Page"&gt; &lt;head&gt;&lt;title&gt;Generate XML Element&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;jsp:element name = "xmlElement"&gt; &lt;jsp:attribute name = "xmlElementAttr"&gt; Value for the attribute &lt;/jsp:attribute&gt; &lt;jsp:body&gt; Body for XML element &lt;/jsp:body&gt; &lt;/jsp:element&gt; &lt;/body&gt;&lt;/html&gt; 在运行时就会生成下面的HTML代码； 123456789&lt;html xmlns = "http://www.w3c.org/1999/xhtml" xmlns:jsp = "http://java.sun.com/JSP/Page"&gt; &lt;head&gt;&lt;title&gt;Generate XML Element&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;xmlElement xmlElementAttr = "Value for the attribute"&gt; Body for XML element &lt;/xmlElement&gt; &lt;/body&gt;&lt;/html&gt; jsp:text动作元素&lt;jsp:text&gt;动作元素主要用于在JSP页面中编写模板文本。使用语法如下: 1&lt;jsp:text&gt;Tempate data &lt;/jsp:text&gt; 模板的主体不能包含其他元素，只能包含EL表达式。在XML文件中，不能使用${whatever &gt; 0}, 因为&gt;在这里是不允许的，需要书写成${whatever gt 0}，另一种方法是将值嵌入CDATA部分。 1&lt;jsp:text&gt;&lt;![CDATA[&lt;br&gt;]]&gt;&lt;/jsp:text&gt; 如果需要包含DOCTYPE申明(例如XHTML)，可以使用&lt;jsp:text&gt;元素，如下所示: 1234567891011&lt;jsp:text&gt;&lt;![CDATA[&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd"&gt;]]&gt;&lt;/jsp:text&gt; &lt;head&gt;&lt;title&gt;jsp:text action&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;books&gt;&lt;book&gt;&lt;jsp:text&gt; Welcome to JSP Programming &lt;/jsp:text&gt;&lt;/book&gt;&lt;/books&gt; &lt;/body&gt;&lt;/html&gt; JSP隐式(Implicit)对象JSP支持九个自动定义的变量，它们被称为隐式对象。 Object Description request 与请求关联的HttpServletRequest对象 response 与客户端响应关联的HttpServletResponse对象 out PrintWriter对象，用于输出文本到客户端 session 与请求关联的HttpSession对象 application 与应用程序上下文(application context)关联的ServletContext对象 config 与页面关联的ServletConfig对象 pageContext 封装了特定的服务器功能，如性能更高的JspWriters page 与Java中的this一样，主要用于调用已转换为servlet类中定义的方法 Exception Exception对象允许指定的JSP访问异常数据 request对象request对象是javax.servlet.http.HttpServletRequest对象的一个实例。每次客户端发起请求时，JSP引擎都会创建一个新的request对象来表示请求。request提供获取HTTP头部信息（如：表单数据、cookies、HTTP方法等）的方法。 response对象response对象是javax.servlet.http.HttpServletResponse对象的实例。和request一样，服务器也会创建response来代表客户端响应。 response对象还定义了处理创建新HTTP头部的接口。通过这个对象，JSP开发人员可以添加新的cookie或者时间戳，HTTP状态码等。 out对象out隐式对象是javax.servlet.jsp.JspWriter对象的一个实例。用于向response发送内容。 初始的JspWriter兑现过的实例化取决于页面是否缓冲。通过使用page指令元素的buffered=&#39;false&#39;属性，可以轻松关闭缓冲。 JspWriter对象包含很多和java.io.PrintWriter类相同的方法。但是，JspWriter拥有额外的方法用于处理缓冲(buffering)。不同与PrintWriter对象，JspWriter还会抛出IOExceptions。 下面的表格列出了使用out对象写入char, int, double, object, String等的重要方法。 Method Description out.print(dataType dt) 打印数据类型值 out.println(dataType dt) 打印数据类型值，并换行 out.flush() 刷新流，清楚缓冲区 session对象session对象是javax.servlet.http.HttpSession对象的一个实例，其行为和Java Servlets下的Session对象行为完全相同。session对象主要用于跟踪客户端请求之间的客户端回话。 application对象application对象是生成servlet的ServletContext对象的直接包装器(direct wrapper),实际上是javax.servlet.ServletContext对象的实例。 该对象是JSP页面整个生命周期的表示。初始化JSP页面时会创建对象，并且在jspDestroy()方法执行删除JSP页面时，该对象也会被删除。 通过向application添加属性，可以使Web应用程序中所有JSP页面都可以访问该属性。 config对象config对象是javax.servlet.ServletConfig对象的实例，是生成servlet的ServletConfig对象的直接包装器。使用该对象可以使JSP开发人员访问Servlets或JSP引擎的初始化参数（如：文件路径等）。 下面是config对象中我们唯一会使用到的方法，用法也很简单: 1config.getServletName(); 该方法返回servlet的名字，这些名字一般定义在WEB-INF\web.xml中的&lt;servlet-name&gt;的元素内。 pageContext对象pageContext对象是javax.servlet.jsp.PageContext对象的一个实例。pageContext对象用于表示整个JSP页面。 该对象旨在获取有关页面的相关信息，同时避免大多数的实现细节。pageContext会保存每个请求对应的request和response对象的引用。application, config, session以及out对象都是通过访问该对象的属性派生的。 pageContext对象还包含有关发布到JSP页面的指令的信息，包括缓冲信息，errorPageURL和page Scope。 PageContext类中定义了许多属性，其中包含PAGE_SCOPE, REQUEST_SCOPE, SESSION_SCOPE和APPLICATION_SCOPE,这些刚好对应页面的页面范围(scope)。它还拥有40多种方法，大约一一半是从javax.servlet.jsp.JspContext类继承来的。其中一个重要的方法是 :removeAttribute，该方法接受一个或两个参数。例如：pageContext.removeAttribute(&quot;attrName&quot;);从所有范围中删除该属性，下面的代码是从指定范围中移除属性: 1pageContext.removeAttribute("attrName", PAGE_SCOPE); page对象page对象是对页面的实际引用。它可以被认为是代表整体JSP页面的对象。page对象实际上是this对象的直接同义词。 exception对象exception对象是一个包装器(wrapper),包含从上一个页面抛出的异常。它通常用于生成针对特定错误的response对象。 控制流语句 (Control-Flow Statements)我们可以在JSP编程中使用Java的所有API，例如：流程控制语句等。 决策语句 (Decision-Making Statements)if ... else块像普通的Scriptlet一样开始，但Scriptlet在每一行都关闭，Scriptlet标签之间包含有HTML文本。 12345678910111213&lt;%! int day = 3; %&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;IF ... ELSE Example&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;% if (day == 1 || day == 7) &#123; %&gt; &lt;p&gt;Today is weekend&lt;/p&gt; &lt;% &#125; else &#123; %&gt; &lt;p&gt;Today is not weekend&lt;/p&gt; &lt;% &#125; %&gt;&lt;/body&gt;&lt;/html&gt; 上面的程序代码输出结果为： 1Today is not weekend 下面看一下如何使用switch ... case块并使用out.println()： 12345678910111213141516171819202122232425262728293031&lt;%! int day = 3; %&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;SWITCH .. CASE Example&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;% switch(day) &#123; case 0: out.println("It\'s Sunday."); break; case 1: out.println("it\'s Mondya."); break; case 2: out.println("It\'s Tuesday."); break; case 3: out.println("it\'s WEdnesday."); break; case 4: out.println("It\' Thursday."); break; case 5: out.println("It\'s Friday."); break; default: out.println("it\'s Saturday."); &#125; %&gt;&lt;/body&gt;&lt;/html&gt; 运行结果为： 1It&apos;s Wednesday. 循环语句同样在JSP中使用循环语句块也是可以的，例如：for, while,以及do ... while。 简单的使用for循环语句的例子： 12345678910111213&lt;%! int fontSize; %&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;FOR LOOP Example&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;% for (fontSize = 1; fontSize &lt; - 3; fontSize++) &#123; %&gt; &lt;font color = "green" size = &lt;%= fontSize %&gt;"&gt; JSP Test &lt;/font&gt;&lt;br /&gt; &lt;% &#125; %&gt;&lt;/body&gt;&lt;/html&gt; JSP数据类型 (Literals)JSP表达式定义了下面的数据类型: Boolean — true 或者 false Integer — 与Java中一样 Floating point — 与Java中一样 String — 以单引号或双引号包围起来的字符串 Null — null 客户端请求(Client Request)当浏览器请求网页时，它会向Web服务器发送大量的信息。一般无法直接读取这些信息，因为它们是作为HTTP请求的头部的一部分来发送的。 下面的表格列出了来自浏览器的重要头部信息。它们经常用于Web编程: Header Description Accept 此header指定浏览器或其他客户端可以处理的MIME类型。image/png或image/jpeg是两种常见的取值 Accept-Charset 此header指定浏览器可用于显示信息的字符集, 例如: ISO-8859-1 Accept-Encoding 此header指定浏览器能够处理的编码类型, gizp和compress是两种常见的取值 Accept-Language 此header指定客户端的首选语言，servlet可以使用多种语言来生成结果。例如：en, en-us, ru等 Authorization 在访问受密码保护的网页时，浏览器使用此header来标识自己 Connection 此header指定客户端是否可以处理持久HTTP连接。使用持久连接可以使客户端或其他浏览器在单个请求内检索多个文件。取值keep-Alive表示使用持久连接 Content-Length 此header只适用于POST请求，并以字节为单位给出POST数据的大小 Cookie 此header将cookie返回给先前已将其发送到浏览器的服务器 Host 此header指定原始URL中给出的主机和端口 If-Modified-Since 此header申明客户端仅在指定日期之后更改页面时才需要该页面。如果没有可用的更新结果，服务器会发送代码304，意味着header 为Not Modified If-Unmodified-Since 此header与If-Modified-Since相反，它指定仅当文档早于指定日期时操作才会成功 Referer 此header指定引用网页的URL。例如，如果在网页1中并单机指向网页2的链接，则当浏览器请求网页2时，网页1的URL将包含在Referer header中 User-Agent 该header用于标识发出请求的浏览器或者其他客户端，可用于将不同内容返回到不同类型的浏览器 HttpServletRequest对象之前已经了解到，request对象是HttpServletRequest对象的实例。每次客户端发起请求时，JSP引擎都会创建一个request对象来表示该请求。 request对象提供了获取HTTP header信息的方法。header信息包括表单数据, cookie, HTTP方法等等。 下面的表格列出了JSP程序用于读取HTTP header信息的重要方法。这些方法适用于HttpServletRequest对象。 Method Description Cookie[] getCookies() 返回一个包含客户端使用该请求发送的所有Cookie对象 Enumeration getAttributeNames() 返回包含此请求中所有可用属性名称的Enumeration对象 Enumeration getHeaderNames() 返回包含此请求中包含的所有header名称的Enumeration对象 Enumeration getParameterNames() 返回String对象的Enumeration对象，其中包含此请求中包含的参数的名称 HttpSession getSession() 返回与当前请求相关联的HttpSession对象，如果该请求没有对应的session对象，则创建一个 HttpSession getSession(boolean create) 返回与此请求关联的当前的HttpSession对象，如果没有当前session且create为true，则返回一个新HttpSession对象 Locale getLocale() 根据Accept-Language header返回客户端将接受内容的的首选语言环境 Object getAttribute(String name) 以Object形式返回指定属性的值，如果不存在给定名称的属性，则返回null ServletInputStream getInputStream() 使用ServletInputeStream以二进制数据的形式检索请求的主体 String getAuthType() 返回用于保护servlet的身份验证方案的名称，例如&quot;BASIC&quot;或&quot;SSL&quot;,如果JSP未受保护，则返回null String getCharacterEncoding() 返回该请求正文中使用的字符编码的名称 String getContentType() 返回请求正文的MIME类型，如果类型未知，则返回null String getContextPath() 返回请求URI的一部分，代表请求的上下文 String getHeader(String name) 以String的形式返回指定header的值 String getMethod() 返回用于发出该请求的HTTP方法的名称，例如:GET, POST, PUT String getParameter(String name) 以String形式返回请求中的参数的值，如果参数不存在，则返回null String getPathInfo() 返回与客户端发出此请求时发送的URL关联的任何额外的路径信息 String getProtocol() 返回请求使用的协议的名称和版本 String getQueryString() 返回路径后面请求URL中包含的查询字符串 String getRemoteAddr() 返回发送请求的客户端的Internet协议(IP)地址 String getRemoteHost() 返回发送请求的客户端的完全限定名称 String getRemoteUser() 如果用户已通过身份验证，则返回发出此请求的用户的登录名； 如果用户尚未通过身份验证，则返回null String getRequestURI() 从协议名称到HTTP请求第一行中的查询字符串返回此请求的URL部分 String getRequestedSessionId() 返回客户端指定的回话(session)ID String getServletPath() 返回该请求中调用的JSP的URL的一部分 String[] getParameterValues(String name) 返回包含给定请求参数所具有的所有值的String对象数组，如果参数不存在，则返回null boolean isSecure() 返回一个boolean值，表示该请求是否使用安全隧道, 如HTTPS int getContentLength() 返回请求正文的长度(以字节为单位)，并使输入流能够访问，如果长度未知，则返回-1 int getIntHeader(String name) 以int形式返回指定header的值 int getServerPort() 返回接受该请求的端口号 HTTP Header请求示例下面的例子，使用HttpServletRequest的getHeaderNames()方法来读取HTTP的头部信息。该方法返回一个Enumeration对象，其中包含与当前HTTP请求关联的header的信息。 一旦我们有了Enumeration对象，我们就可以使用标准方式循环打印其中的信息。这里使用hasMoreElement()来判断什么时候停止循环，并用nextElement()返回获取每个参数对应的值。 123456789101112131415161718192021222324252627282930&lt;%@ page import = "java.io.*,java.util.*" %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;HTTP Header Request Example&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;center&gt; &lt;h2&gt;HTTP Header Request Example&lt;/h2&gt; &lt;table width = "100%" border = "1" align = "center"&gt; &lt;tr bgcolor = "#949494"&gt; &lt;th&gt;Header Name&lt;/th&gt; &lt;th&gt;Header Value(s)&lt;/th&gt; &lt;/tr&gt; &lt;% Enumeration headerNames = request.getHeaderNames(); while(headerNames.hasMoreElements()) &#123; String paramName = (String)headerNames.nextElement(); out.print("&lt;tr&gt;&lt;td&gt;" + paramName + "&lt;/td&gt;\n"); String paramValue = request.getHeader(paramName); out.println("&lt;td&gt; " + paramValue + "&lt;/td&gt;&lt;/tr&gt;\n"); &#125; %&gt; &lt;/table&gt; &lt;/center&gt; &lt;/body&gt;&lt;/html&gt; 运行结果： 服务器响应(Server Response)下面我们主要是在JSP中讨论服务器响应。当Web服务器响应HTTP请求时，响应通常由状态行，一些响应头，空行和文档组成。典型的响应如下面所示: 1234567891011121314HTTP/1.1 200 OKContent-Type: text/htmlHeader2: ......HeaderN: ... (Blank Line)&lt;!doctype ...&gt;&lt;html&gt; &lt;head&gt;...&lt;/head&gt; &lt;body&gt; ... &lt;/body&gt;&lt;/html&gt; 状态行包含了HTTP的版本(HTTP/1.1)以及状态码(200), 此外还有非常短的信息来对应状态码(OK). 以下是从Web服务器返回到浏览器的最有用的HTTP/1.1响应header的摘要。这些header经常用于Web编程: Header Description Allow 该header指定了服务器支持的请求方法(GET, POST等) Cache-Control 此header指定可以安全地缓存响应文档的环境。它的取值可以为public,private,和no-cache.public意味着文档是可以缓存的，private意味着文档是针对单个用户的，并且只能存储在私有(非共享)缓存中，而no-cache意味着文档不能被缓存 Connection 该header指定浏览器是否使用持久化HTTP链接。close意味着不使用，而keep-alive则使用持久化链接 Content-Disposition 该header允许您请求浏览器要求用户将响应保存到给定的文件中 Content-Encoding 此header指定页面在传输过程中的的编码方式 Content-Language 该header标明文档是以何种语言编写的.例如: en, en-us, ru等等 Content-Length 该header表明了响应包含的字节数。它只有在浏览器使用持久化链接时才会被用到 Content-Type 此header提供响应文档的MIME(Multipurpose Internet Mail Extentsion, 多用途Internet邮件扩展)类型 Expires 此header指定响应内容被视为过期的时间，即不被缓存 Last-Modified 该header标明文档上次更改的时间。然后，客户端可以缓存文档，并在以后的请求中通过If-Modified-Since header来提供日期 Location 此header包含在状态码为300s的所以响应中。这回通知浏览器文档的地址。浏览器会自动重新连接到此位置并检索新文档 Refresh 该header指定浏览器应该多久请求更新页面。可以指定刷新页面的时间(以秒为单位) Retry-After 该header可以和503（服务不可用）响应结合使用，以告知客户端它可以多快重复进行请求 Set-Cookie 此header指定页面是否关联一个cookie HttpServletResponse对象response对象是javax.servlet.http.HttpServletResponse的一个实例。和创建request对象一样，服务器同样会创建一个response对象来对应对客户端的响应. 响应对象还定义了处理创建新HTTP header的接口。通过这个对象，JSP开发人员可以添加新的cookie和日期戳，HTTP状态码等。 我们可以使用以下的方法在servlet程序中设置HTTP响应头。这些方法可用于HttpServletResponse对象。次该对象表示服务器响应。 Method Description String encodeRedirectURL(String url) 对指定的URL进行编码以在sendRedirect方法中使用，如果不需要编码，则返回的URL不变 String encodeURL(String url) 通过在其中包含Session ID来对指定的URL进行编码，如果不需要编码，则返回URL不变 boolean containsHeader(String name) 返回一个boolean值，表明是否设置指定的响应头 boolean isCommitted() 返回一个boolean，标明响应是否已提交 void addCookie(Cookie cookie) 向响应中添加指定的cookie void addDateHeader(String name, long date) 添加一个具有给定名称和日期值的响应header void addIntHeader(String name, int value) 添加一个具有给定名称和Integer值的响应header vodi flushBuffer() 强制将缓冲区中的任何内容写入到客户端 void reset() 清楚缓冲中的所有数据以及状态码和header void resetBuffer() 清楚响应中底层缓冲区中的内容，而不清楚header和状态码 void sendError(int sc, String msg) 使用指定的状态码向客户端发送一个错误响应 void sendRedirect(String location) 使用指定的重定向位置URL向客户端发送临时重定向响应 void setBufferSize(int size) 设置响应正文的首选缓冲区的大小 void setCharacterEncoding(String charset) 设置发送到客户端的响应的字符编码(MIME字符集)，例如： UTF-8 void setContentLength(int len) 在HTTP servlet中设置响应中内容主体的长度，此方法还设置HTTPContent-Length header void setContentType(String type) 如果尚未提交响应，则设置发送到客户端响应的内容类型 void setDateHeader(String name, long date) 设置具有给定名称和日期值的响应header void setHeader(String name, String value) 设置具有给定名称和值的响应header void setIntHeader(String name, int value) 设置具有给定名称和int值的响应header void setLocale(Locale loc) 如果尚未提交响应，则设置响应的区域设置 void setStatus(int sc) 设置该响应的状态码 HTTP Header响应示例下面的示例将使用setIntHeader()方法设置Refresh header来模拟数字时钟。 123456789101112131415161718192021222324252627282930&lt;%@ page import = "java.io.*, java.util.*" %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Auto Refresh Header Example&lt;/title&gt; &lt;body&gt; &lt;center&gt; &lt;h2&gt;Auto Refresh Header Example&lt;/h2&gt; &lt;% // Set refresh, autoload time as 5 seconds response.setIntHeader("Refresh", 5); // Get current time Calendar clendar = new Gregoriancalendar(); String am_pm; int hour = calendar.get(Calendar.HOUR); int minute = alendar.get(Calendar.MINUTE); int second = calendar.get(Calendar.SECOND); if (calendar.get(Calendar.AM_PM == 0) am_pm = "AM"; else am_pm = "PM"; String CT = hour + ":" + minute + ":" + second + " " + am_pm; out.println("Current Time is: " + CT + "\n"); %&gt; &lt;/center&gt; &lt;/body&gt; &lt;/head&gt;&lt;/html&gt; 运行结果:(每隔5秒刷新页面) Http 状态码(Status Codes)下面我们将在JSP范围内讨论HTTP状态码。HTTP请求的格式和HTTP响应消息类似，具有如下结构: 初始状态行 + CRLF(回车符+换行符，即新行) 零个或多个header行 + CRLF 一个空行，即一个CRLF 可选的消息体，如文件，查询数据或查询输出 例如，一个服务器响应header可能是下面这样子的： 123456789101112131415HTTP/1.1 200 OKContent-Type: text/htmlHeader2: ......HeaderN: ... (Blank Line)&lt;!doctype ...&gt;&lt;html&gt; &lt;head&gt;...&lt;/head&gt; &lt;body&gt; ... &lt;/body&gt;&lt;/html&gt; 状态行包含了HTTP的版本（HTTP/1.1）, 状态码(200)，以及一条非常短的消息对应着状态码. 下面的表格列出了Web服务器可能返回的状态码及其对应的消息: Code Message Description 100 Continue 服务器只收到请求的一部分，但只要它没有别拒绝，客户端就应该继续请求 101 Switching Protocols 服务器切换协议 200 OK 表示请求没有问题 201 Created 请求已完成，并且已创建新资源 202 Accepted 请求被接受并在处理中，但处理还未完成 203 Non-authoritative Information 204 No Content 205 Reset Content 206 Partial Content 300 Multiple Choices 一个链接列表，用户可以选择一个链接并转到该位置。最多五个地址 301 Moved Permanently 请求的页面被永久地移动到一个新的url 302 Found 请求的页面被临时地移动到一个新的url 303 See Other 请求的页面可以在不同的url中找到 304 Not Modified 305 Use Proxy 306 Unused 此状态码用于以前的HTTP版本。它已经不再使用，但被保留了下来 307 Temporary Redirect 请求的也main暂时移动到新的url 400 Bad Request 服务器无法解析请求 401 Unauthorized 请求的页面需要一个用户名和密码 402 Payment Required 此状态码已能使用 403 Forbidden 请求的页面禁止访问 404 Not Found 请求页面找不到 405 Method Not Allowed 请求方法不允许 406 Not Acceptable 服务器只能生成客户端不能接收的响应 407 Proxy Authentication Required 在提供此请求之前，必须使用代理服务器进行身份验证 408 Request Timeout 请求花费的时间比服务器准备等待的时间长 409 Conflict 由于冲突，请求无法完成 410 Gone 请求页面不再可达 411 Length Required Content-Length header没有定义，服务器不接收该请求 412 PreCondition Failed 请求中给出的前提条件有服务器评估为false 413 Request Entity TooLarge 服务器不接受请求，因为请求实体太大 414 Request-url Too Long 服务器不接受该请求，因为请求的url过长。这通过出现在将post改为get请求的情况下 415 Unsupported Media Type 服务器不接受请求，由于媒体类型不支持 417 Expectation Failed 500 Internal Server Error 请求未完成。服务器遇到意外情况 501 Not Implemented 请求未完成。服务器对请求的需求体提供支持 502 Bad Gateway 请求未完成。服务器从上游服务器收到无效响应 503 Service Unavailable 请求未完成。服务器暂时超载或关闭 504 Gateway Timeout 网关已超时 505 HTTP Version Not Supported 服务器不支持该HTTP协议版本 设置HTTP状态码的方法我们可以使用HttpServletResponse对象下面的这些方法在servlet程序中设置HTTP状态码。 Method Description public void setStatus(int statusCode) 该方法可以设置任意状态代码。int(状态代码)作为参数.如果响波包含特殊状态代码和文档，务必使用PrintWriter实际返回任何内容之前调用setStatus方法 public void sendRedirect(String url) 该方法生成一个302响应以及提供新文档的URL的Location header public void sendError(int code, String message) 此方法发送状态代码(通常为404)以及在HTML文档中自动格式化并发送到客户端的短消息 HTTP状态码示例下面的例子使用setError()方法向客户端发送403状态代码以及短消息Forbidden. 123456789101112&lt;html&gt; &lt;head&gt; &lt;title&gt;Setting HTTP Status Code&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;% // Set error code and reason. response.sendError(403, "Forbidden" ); %&gt; &lt;/body&gt;&lt;/html&gt; 页面运行结果: 表单处理(Form Handling)这里我们主要讨论在JSP中的表单处理。当我们需要将某些信息从浏览器传递到Web服务器并最终传递到后端程序时，肯定会遇到很多情况。浏览器使用两种方法将此信息传递给Web服务器。即POST和GET方法。 表单处理的方法GET 方法GET方法发送附加到页面请求的以编码的用户信息。页面和编码信息由?分隔。格式如下: 1http://www.test.com/hello?key1=value1&amp;key2=value2 GET方法是将信息从浏览器传递到Web服务器的默认方法，它会生成一个长字符串，显示在浏览器的地址栏中。 GET方法生成的字符长有大小限制，请求的字符串中只能包含1024个字符。 此信息使用QUERY_STRING header传递，并且可以通过QUERY_STRING环境变量访问，该变量可以使用request对象的getQueryString()和getParameter()方法进行处理。 POST 方法将信息传递给后端程序的一般更可靠的方法是POST方法。该方法以与GET方法完全相同的方式打包信息，但不是将其作为以?组成的文本字符串发送，而是作为单独的消息发送。传递消息以标准输入的形式提供给后端程序，服务器可以解析并用于处理。 JSP使用getParameter()方法处理此类请求以读取简单参数，并使用getInputStream()方法读取来自客户端的二进制数据流。 使用JSP读取表单数据JSP可以根据具体情况使用一下的方法自动处理表单数据并进行解析 - getParameter() - 可以调用request.getParameter()方法来读取一个表单数据的对应值; getParameterValues() - 如果参数出现多次并返回多个值(例如复选框)可以调用此方法; getParameterNames() - 如果需要获取当前请求中的所有参数的完整列表，可以调用此方法; getIntputStream() - 调用此方法可以同客户端读取二进制数据. GET 使用示例(使用URL的方式)下面的URL会向getMethodTest.jsp页面传递两个值，通过GET的方式 - 1http://localhost:8080/getMethodTest.jsp?username=rovo98&amp;msg=hello 下面的getMethodTest.jsp页面使用getParameter()方法来处理传递过来的数据 - 12345678910111213141516&lt;html&gt; &lt;head&gt; &lt;title&gt;Using GET Method to Read Form Data&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Using GET Method to Read Form Data&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;&lt;p&gt;&lt;b&gt;Username:&lt;/b&gt; &lt;%= request.getParameter("username")%&gt; &lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;p&gt;&lt;b&gt;Message:&lt;/b&gt; &lt;%= request.getParameter("msg")%&gt; &lt;/p&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; 在浏览器的地址栏中输入上面的URL，即可获得结果: GET 方法示例(使用表单提交方式)下面的例子是通过HTML的表单向上面的getMethodTest.jsp传递同样的两个参数 - main.jsp:123456789&lt;html&gt;&lt;body&gt; &lt;form action="getMethodTest.jsp" method="GET" &gt; Username: &lt;input type="text" name="username" /&gt;&lt;br /&gt; Message: &lt;input type="text" name="msg" /&gt; &lt;input type="submit" value="Submit" /&gt; &lt;/form&gt;&lt;body&gt;&lt;/html&gt; 运行成功的话，应该可以得到和上面同样的结果。 POST 方法示例修改一下上面的main.jsp页面以使用POST请求方法，实际上，修改后和之前的JSP没有多大区别，只是传递参数方法发生改变而已，在没有传递二进制数据的情况下。 getAndPostMethod.jsp:1234567891011121314151617&lt;html&gt; &lt;head&gt; &lt;title&gt;Using GET and POST Method to Read Form Data&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Using POST Method to Read Form Data&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;&lt;p&gt;&lt;b&gt;Username: &lt;/b&gt; &lt;%= request.getParameter("username") %&gt; &lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;p&gt;&lt;b&gt;Message: &lt;/b&gt; &lt;%= request.getParameter("msg")%&gt; &lt;/p&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; 修改后的main.jsp文件 - 123456789&lt;html&gt; &lt;body&gt; &lt;form action="getAndPostMethod.jsp" method = "POST"&gt; Username: &lt;input type = "text" name = "username" /&gt;&lt;br /&gt; Message: &lt;input type = "text" name = "msg" /&gt; &lt;input type="submit" value = "Submit" /&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 运行结果与之前的GET请求方法得到的结果类似。 向JSP程序传递复选框数据当需要选择多个选项时，我们通常会在页面中使用复选框(checkbox)。以下是一个示例HTML代码checkBox.html，其中有包含两个复选框的表单 - 12345678910&lt;html&gt; &lt;body&gt; &lt;form action="checkbox.jsp" method="POST" target="_blank"&gt; &lt;input type="checkbox" name="maths" checked="checked" /&gt;Maths &lt;input type="checkbox" name="physics" /&gt;Physics &lt;input type="checkbox" name = "chemistry" checked="checked" /&gt; Chemistry &lt;input type="submit" value="Select Subject" /&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 页面显示如下 - 用于接受数据的JSP页面 checkbox.jsp - 12345678910111213141516171819&lt;html&gt; &lt;head&gt; &lt;title&gt;Reading Checkbox Data &lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Reading Checkbox Data&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;&lt;p&gt;&lt;b&gt;Maths Flag:&lt;/b&gt; &lt;$= request.getParameter("maths")%&gt; &lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;p&gt;&lt;b&gt;Physics Flag:&lt;/b&gt; &lt;$= request.getParameter("physics")%&gt; &lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;p&gt;&lt;b&gt;Chemistry Flag:&lt;/b&gt; &lt;$= request.getParameter("chemistry")%&gt; &lt;/p&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; 运行结果如下 - 读取所有表单参数下面是一个通用的示例，使用HttpServletRequest的getParameterNames()方法来读取所有可用的表单参数。此方法返回一个Enumeration对象，其中包含未指定顺序的参数名称。 在获得Enumeration对象后，我们可以通过循环的方式依次打印参数内容。 allParameters.jsp - 123456789101112131415161718192021222324252627&lt;%@ page import = "java.io.*,java.util.*" %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Reading All Parameters&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;center&gt; &lt;h2&gt;Reading All Parameters&lt;/h2&gt; &lt;table width = "100%" border = "1" align = "center"&gt; &lt;tr bgcolor = "$949494"&gt; &lt;th&gt;Param Name&lt;/th&gt; &lt;th&gt;Param Value(s)&lt;/th&gt; &lt;/tr&gt; &lt;% Enumeration paramNames = request.getParameterNames(); while (paramNames.hasMoreElements()) &#123; String paramName = (String)paramNames.nextElement(); out,print("&lt;tr&gt;&lt;td&gt;" + paramName + "&lt;/td&gt;\n"); String paramValue = request.getParameter(paramName); out.println("&lt;td&gt;" + paramValue + "&lt;/td&gt;&lt;/tr&gt;\n"); &#125; %&gt; &lt;/table&gt; &lt;/center&gt; &lt;/body&gt;&lt;/html&gt; 请求页面使用之前的复选框页面 - checkBox.html 123456789101112&lt;html&gt; &lt;body&gt; &lt;form action = "main.jsp" method = "POST" target = "_blank"&gt; &lt;input type = "checkbox" name = "maths" checked = "checked" /&gt; Maths &lt;input type = "checkbox" name = "physics" /&gt; Physics &lt;input type = "checkbox" name = "chemistry" checked = "checked" /&gt; Chem &lt;input type = "submit" value = "Select Subject" /&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 运行测试结果如下 - 过滤器(Filters)Servlet和JSP过滤器都是可用于Servlet和JSP编程横的Java类，主要有以下目的 - 在客户端访问后端资源之前拦截客户端请求; 在服务器发送响应回客户端之前，操纵响应. 各种类型的过滤器 - 验证过滤器 (Authentication Filters) 数据压缩过滤器 (Data compression Filters) 加密过滤器 (Encryption Filters) 触发资源访问事件的过滤器 (Filters that trigger resource access events) 图像转换过滤器 (Image Conversion Filters) 日志和审计过滤器 (Logging and Auditing Filters) MIME-TYPE链过滤器 (MIME-TYPE Chain Filters) 标记过滤器 (Tokenizing Filters) 转换XML内容的XSL/T过滤器 过滤器在部署描述符文件web.xml中，然后映射到应用程序部署描述符中的servlet或JSP名称或URL模式。部署描述符文件web.xml可以在Tomcat的安装目录的conf目录下找到。 当JSP容器启动Web应用程序时，它会创建我们在部署描述符文件中声明的每个过滤器的实例。过滤器按照在部署描述符中声明的顺序执行。 Servlet 过滤器方法一个过滤器其实就是一个实现javax.servlet.Filter接口的简单Java类。接口中定义了下面的三个方法 - Method Description public void doFilter(ServletRequest, ServletResponse,FilterChain) 每次由于客户端请求末端的资源而请求/响应对通过链时，容器都会调用此方法 public void init(FilterConfig filterConfig) Web容器调用执行该方法，表示过滤器正在投入使用 public void destroy() 由Web容器调用执行，表示过滤器已停止服务 JSP 过滤器示例下面的示例在每次访问任何JSP文件时打印客户端的IP地址和当前日期时间。我们可以按照类似的流程编写更复杂的过滤器来适应我们的需求 - 1234567891011121314151617181920212223242526272829303132// Import required java librariesimport java.io.*;import javax.servlet.*;import javax.servlet.http.*;import java.util.*; // Implements Filter classpublic class LogFilter implements Filter &#123; public void init(FilterConfig config) throws ServletException &#123; // Get init parameter String testParam = config.getInitParameter("test-param"); //Print the init parameter System.out.println("Test Param: " + testParam); &#125; public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws java.io.IOException, ServletException &#123; // Get the IP address of client machine. String ipAddress = request.getRemoteAddr(); // Log the IP address and current timestamp. System.out.println("IP "+ ipAddress + ", Time "+ new Date().toString()); // Pass request back down the filter chain chain.doFilter(request,response); &#125; public void destroy( ) &#123; /* Called before the Filter instance is removed from service by the web container*/ &#125;&#125; 在web.xml中配置过滤器定义过滤器，然后映射到URL或JSP文件名，在web.xml中映射到URL模式，其方式和定义Servlet的方式类似。例如 - web.xml:1234567891011121314&lt;filter&gt; &lt;filter-name&gt;LogFilter&lt;/filter-name&gt; &lt;filter-class&gt;LogFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;test-param&lt;/param-name&gt; &lt;param-value&gt;Initialization Paramter&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;LogFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 上面配置过滤器将适用于所有的Servlet和JSP，因为配置中的映射URL指定了/*。如果要在少数servlet或JSP上应用过滤器，则可以指定特定的servlet或JSP路径。 使用多个过滤器在Web应用中，我们可能会定义具有特定用途的多个不同过滤器。例如：下面的web.xml中定义了两个过滤器AuthenFilter和LogFilter - web.xml:12345678910111213141516171819202122232425262728&lt;filter&gt; &lt;filter-name&gt;LogFilter&lt;/filter-name&gt; &lt;filter-class&gt;LogFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;test-param&lt;/param-name&gt; &lt;param-value&gt;Initialization Paramter&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt; &lt;filter&gt; &lt;filter-name&gt;AuthenFilter&lt;/filter-name&gt; &lt;filter-class&gt;AuthenFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;test-param&lt;/param-name&gt; &lt;param-value&gt;Initialization Paramter&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;LogFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;AuthenFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 过滤器执行顺序web.xml中filter-mapping元素的顺序决定了Web容器将过滤器应用于Servlet或JSP的顺序。要改变过滤器执行的顺序，只需要改变filter-mapping元素的顺序即可。 例如： 下面的例子中，AuthenFilter会被执行，再者是LogFilter，与上面之前定义的顺序不同 - 123456789&lt;filter-mapping&gt; &lt;filter-name&gt;AuthenFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;LogFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; Cookies 处理(Cookies Handing)Cookies是存储在客户端计算机上的文本文件，用于各种信息的跟踪目的。JSP使用底层servlet技术透明地支持HTTP cookie。 识别和返回用户涉及以下三个步骤 - 服务器将一组cookie发送到浏览器。例如，姓名，年龄后身份证号码等; 浏览器将此信息存储在本地计算机上以备将来使用; 当下次浏览器向Web服务器发送任何请求时，它将这些cookie信息发送到服务器，并且服务器使用该信息来识别用户或者也可以用于其他目的. 我们主要学习如何设置或重置cookie如何访问它们以及如何使用JSP程序将它们删除。 Cookie 的剖析Cookie通常设置在HTTP的标头(header)中(尽管JavaScript也可以直接在浏览器上设置cookie)。设置cookie的JSP可能会发送看起来像这样的header - 1234567HTTP/1.1 200 OKDate: Fri, 04 Feb 2000 21:03:38 GMTServer: Apache/1.3.9 (UNIX) PHP/4.0b3Set-Cookie: name = xyz; expires = Friday, 04-Feb-07 22:03:38 GMT; path = /; domain = tutorialspoint.comConnection: closeContent-Type: text/html 我们可以看到，Set-Cookie标头(header)包含名称值对，GMT日期，路径和域。名称值对将进行URL编码。expires字段是浏览器在给定时间和日期之后”忘记”cookie的指令，即cookie的过期时间。 如果浏览器设置了存储cookie，则会将这些信息保留到过期时间。如果用户将浏览器指向与cookie的路径或域匹配的任何页面，则会将cookie重新发送到服务器。浏览器的标头(header)可能看起来是这样的 - 12345678910GET / HTTP/1.0Connection: Keep-AliveUser-Agent: Mozilla/4.6 (X11; I; Linux 2.2.6-15apmac ppc)Host: zink.demon.co.uk:1126Accept: image/gif, */*Accept-Encoding: gzipAccept-Language: enAccept-Charset: iso-8859-1,*,utf-8Cookie: name = xyz 然后，JSP程序将通过request.getCookies()方法来访问cookie，该方法将返回一个Cookie对象的数组。 Servlet Cookies 方法下表列出了在JSP，Servlet中操作Cookie时可以使用的有用方法 - Method Description public void setDomain(String pattern) 此方法设置cookie适用的域；例如 : rovo98.com public String getDomain() 此方法获取cookie适用的域；例如: rovo98.com public void setMaxAge(int expiry) 此方法设置cookie到期之前应经过多长时间(以秒为单位)。如果未设置此值，则cookie将仅持续与当前回话(session) public int getMaxAge() 此方法返回cookie的持续时间，以秒为单位。默认情况下，-1表示cookie将持续存在直到浏览器关闭 public String getName() 此方法返回cookie的名称。创建后无法更改名称 public void setValue(String newValue) 此方法设置与cookie相关联的值 public String getValue() 此方法获取与cookie相关联的值 public void setPath(String uri) 此方法设置此cookie的应用的路径。如果未指定路径，则会为与当前页面相同的目录中的所有UR以及所有子目录返回cookie public String getPath() 此方法获取cookie适用的路径 public void setSeure(boolean flag) 此方法设置boolean值，指定cookie是否应仅通过加密(即SSL)链接发送 public void setComment(String purpose) 此方法指定描述cookie用途的注释。如果浏览器将cookie提供给用户，注释很有用 public String getComment() 此方法返回描述此cookie用途的注释，如果cookie没有注释，则返回null 使用JSP设置Cookies使用JSP设置cookie包含三个步骤 - Step 1: 创建Cookie对象通过调用Cookie的构造方法来创建cookie对象 - 1Cookie cookie = new Cookie("key", "value"); [注意]: name和value参数字符串中都不可以包含空格和以下任何字符 - 1[ ] ( ) = , &quot; / ? @ : ; Step 2: 设置最大生存时间使用setMaxAge方法来设置cookie对象有效的持续时间。例如下面设置的cookie的有效持续时间为 24小时 - 1cookie.setMaxAge(60*60*24); Step 3: 将Cookie发送到HTTP响应的头部(Header)中使用response.addCookie方法将cookie对象添加到HTTP响应的header中 - 1response.addCookie(cookie); 实例修改之前的读取表单数据示例，将username和msg参数添加到cookie中 - 12345678910111213141516171819202122232425262728293031323334&lt;% // Create cookies for username and msg parameters. Cookie username = new Cookie("username", request.getParameter("username")); Cookie message = new Cookie("msg", request.getParameter("msg")); // Set expiry date after 24 Hrs for both the cookies. username.setMaxAge(60*60*24); lastName.setMaxAge(60*60*24); // Add both the cookies in the response header. response.addCookie( username ); response.addCookie( message );%&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Setting Cookies&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;center&gt; &lt;h1&gt;Setting Cookies&lt;/h1&gt; &lt;/center&gt; &lt;ul&gt; &lt;li&gt;&lt;p&gt;&lt;b&gt;User name&lt;/b&gt; &lt;%= request.getParameter("username")%&gt; &lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;p&gt;&lt;b&gt;Message&lt;/b&gt; &lt;%= request.getParameter("msg")%&gt; &lt;/p&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; 使用JSP读取Cookies为了读取cookie，需要通过调用HttpServletRequest的getCookies()方法创建一个javax.servlet.http.Cookie对象数组。然后遍历数组，并使用getName()和getValue()访问每个cookie和相关值。 实例使用下面的JSP程序可以读取之前设置cookie实例中的cookie - 12345678910111213141516171819202122232425262728293031&lt;html&gt; &lt;head&gt; &lt;title&gt;Reading Cookies&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;center&gt; &lt;h1&gt;Reading Cookies&lt;/h1&gt; &lt;/center&gt; &lt;% Cookie cookie = null; Cookie[] cookies = null; // Get an array of Cookies associated with the this domain cookies = request.getCookies(); if( cookies != null ) &#123; out.println("&lt;h2&gt; Found Cookies Name and Value&lt;/h2&gt;"); for (int i = 0; i &lt; cookies.length; i++) &#123; cookie = cookies[i]; out.print("Name : " + cookie.getName( ) + ", "); out.print("Value: " + cookie.getValue( )+" &lt;br/&gt;"); &#125; &#125; else &#123; out.println("&lt;h2&gt;No cookies founds&lt;/h2&gt;"); &#125; %&gt; &lt;/body&gt; &lt;/html&gt; 使用JSP删除Cookies删除cookies非常简单，要删除一个cookie，只需要执行下面简单的三个步骤即可 - 读取一个现有的cookie并存放到Cookie对象中; 通过使用setMaxAge()将cookie的有效时间设置为0来删除该cookie; 重新将该cookie添加到响应头部(header)中. 实例下面的例子展示了如何删除之前设置的username cookie，再次访问该cookie时将返回null - 123456789101112131415161718192021222324252627282930313233343536373839&lt;html&gt; &lt;head&gt; &lt;title&gt;Reading Cookies&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;center&gt; &lt;h1&gt;Reading Cookies&lt;/h1&gt; &lt;/center&gt; &lt;% Cookie cookie = null; Cookie[] cookies = null; // Get an array of Cookies associated with the this domain cookies = request.getCookies(); if( cookies != null ) &#123; out.println("&lt;h2&gt; Found Cookies Name and Value&lt;/h2&gt;"); for (int i = 0; i &lt; cookies.length; i++) &#123; cookie = cookies[i]; if((cookie.getName( )).compareTo("username") == 0 ) &#123; cookie.setMaxAge(0); response.addCookie(cookie); out.print("Deleted cookie: " + cookie.getName( ) + "&lt;br/&gt;"); &#125; out.print("Name : " + cookie.getName( ) + ", "); out.print("Value: " + cookie.getValue( )+" &lt;br/&gt;"); &#125; &#125; else &#123; out.println( "&lt;h2&gt;No cookies founds&lt;/h2&gt;"); &#125; %&gt; &lt;/body&gt; &lt;/html&gt; 我们还可以在Web浏览器中手动的将cookie删除。 Session 跟踪(Session Tracking)文件上传(File Uploading)日期处理(Handing Date)页面重定向(Page Redirect)自动刷新(Auto Refresh)发送邮件(Sending Mail)]]></content>
      <categories>
        <category>JavaWeb</category>
        <category>JSP</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>jsp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构概述 | 线性数据结构]]></title>
    <url>%2Fposts%2F4e42ec99%2F</url>
    <content type="text"><![CDATA[数据结构是在计算机中组织数据的特定方式，以便计算机可以更有效的使用数据。主要的目的是减少不同任务的空间和时间复杂度。本文主要介绍一些常用的线性数据结构 — 译自 GeeksforGeeks. 下面是一些常用的线性数据结构 - 数组 (Array) 链表 (Linked List) 栈 (Stack) 队列 (Queue) 数组 (Array)数组是一种数据结构，用于在连续相邻位置存储同类元素。在存储数据之前必须确定数组的大小。 假设有一数组的大小为$n$，则: 访问时间(Accessing Time): $O(1)$ - 因为元素存储在连续的位置，可直接以索引方式访问数组元素; 查找时间(Search Time): $O(n)$ - 使用线性查找的情况下,$O(log n)$ - 在数组已经有序的情况下使用二分查找; 插入时间(Insertion Time) $O(n)$ - 最坏情况下，插入位置为0,需要移动所有的元素; 删除时间(Deletion Time) $O(n)$ - 最坏情况下，删除元素的位置为0，需要移动所有元素. 使用数组的示例: 假设我们需要将所有学生数据存放到一个类中，这时我们可以考虑使用一个数组来存放它们。这有助于减少变量的使用，因为我们不需要为每个学生数据引用创建单独的变量。只需要遍历数组即可访问所有学生数据。 链表 (Linked List)链表和数组一样，也是一种线性数据结构，其中每个元素都是一个单独的对象, 称为节点(node)，每个节点都包含数据和对下一个节点的引用。 常见的链表类型 - 单链表 (Singly Linked List)单链表中的每个节点的指针域存放下一个节点的引用地址或null,形如： 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; NULL。 双向链表 (Doubly Linked List)双向链表拥有两个指针域，一个指向上一个节点的引用地址或为null，一个指向写一个节点的引用地址或为null。这种数据结构的优点是我们可以在两个方向上进行遍历，对于删除，不需要显式访问前一个节点。形如 : NULL &lt;- 1 &lt;- -&gt; 2 &lt;- -&gt; 3 &lt;- -&gt; 4 -&gt; NULL。 循环链表 (Circular Linked List)循环链表中的所有节点连接成一个环，没有任何节点的下一个节点或上一个节点是指向NULL的。循环链表可以是单向循环链表，也可以是双向循环链表。该数据结构的优点是可以将任意节点作为起始节点。这种链表在实现循环队列时很有用。例如： 1 -&gt; 2 -&gt; 3 -&gt; 1 最后一个节点指向第一个节点。 访问单个元素时间(Accessing time of an element): $O(n)$ 查找单个元素时间(Search time of an element): $O(n)$ 插入单个元素时间(Insertion of an element): $O(1)$, 获得插入节点的前驱节点即可. 删除单个元素时间(Deletion of an element): $O(1)$, 同样获得删除节点的前驱结点即可. 注释:链表适用于存储的数据大小未知，或者需要频繁插入/删除的数据。链表的一大缺点是不允许随机访问。使用数组，可以在$O(1)$时间访问第$i$个元素。而使用链表，需要$\theta(i)$时间。 栈 (Stack)栈拥有先进后出(FILO)或后进先出(LIFO)的特点。有两个主要的操作: push(进栈)和pop(出栈)。栈的操作都发生顶部的同一端上，它可以通过数组和链表实现。 栈可用于维护函数的调用(最后一个被调用的函数必须先完成执行)，我们总是可以在栈的帮助下删除递归。栈也用于反转字符串，检查平衡括号或者在编辑器中使用撤销操作等。 队列 (Queue)队列有先进先出(FIFO)/后进后出(LILO)的特点。有enqueue(进队列)和dequeue(出队列)两个主要操作。从队尾入队，并从对首出队列。队列和栈一样可以用数组实现，也可以用链表实现。 队列通常使用在资源在多个用户之间进行共享并按先到先得的情况下。例如：CPU调度，磁盘调度。队列还可用于在两个进程之间异步传输数据(数据不一定以与发送的相同速率接受)。如：IO缓冲区，管道，文件IO等。 循环队列 (Circular Queue)循环队列，这种数据结构主要是在使用数组实现队列时，用于减少空间的浪费。]]></content>
      <categories>
        <category>GeeksforGeeks</category>
        <category>Data Structures</category>
        <category>Overview</category>
      </categories>
      <tags>
        <tag>学习笔记，数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Reflection]]></title>
    <url>%2Fposts%2Fd897152e%2F</url>
    <content type="text"><![CDATA[简单了解Java反射的基本内容。 Java反射Class类的使用 A class named Class 1)在面向对象的世界里，万事万物皆对象。 类是对象，类是java.lang.Class类的实例对象 2)任何一个类都是Class的实例对象，这个实例对象有三种表示方式： 123456789101112131415161718192021package com.rovo98.reflect;public class ClassDemo1 &#123; public static void main(String args[]) &#123; //Foo的实例对象如何表示 Foo foo1 = new Foo() ;// foo1就表示出来了. //Foo这个类本身 也是一个实例对象，Class类的实例对象 // 第一种表示方式 --&gt; 任何一个类都有一个隐含的静态成员变量class Class c1 = Foo.class; //第二种表示方式 --&gt; 已经知道该类的对象通过getClass()方法 Class c2 = foo1.getClass() ; /* c1,c2 表示了Foo类的类类型(class type)*/ // 不管c1 or c2 都代表了Foo类的类类型，一个类只可能是Class类的一个实例对象 // 第三种表达方式 Class c3 = null ; c3 = Class.forName("com.rovo98.Foo"); // 我们完全可以通过类的类类型创建该类的对象实例 Foo foo = (Foo)c1.newInstance() ;//需要有无参构造方法 &#125;&#125;class Foo&#123;&#125; Java动态加载类 Class.forName(“类的名称”) 不仅表示了类的类类型，还代表了动态加载类 编译时刻加载类是静态加载类、运行时刻加载类是动态加载类 使用：当有多个功能模块(具体由类实现)时，使用动态加载 12345678910111213141516171819202122232425//动态加载实例interface OfficeAble // 指定接口标准&#123; public void start() ;&#125;class Word implements OfficeAble &#123; public static void start() &#123; System.out.println("Start the Word"); &#125;&#125;class Office&#123; public static void main(String args[]) &#123; try&#123; //实现动态加载，运行时加载类 Class c = Class.forName(args[0]) ; OfficeAble oa = c.newInstance() ; oa.start() ; &#125; catch (Exception e) &#123; e.printStackTrace() ; &#125; &#125;&#125; 通过反射获取方法信息 getMethods() 获取所有public 方法，包括父类继承而来的 getDeclaredMethods() 获取所有自定义的方法，不包含访问权限 1234567891011121314package com.rovo98.reflect;public class ClassDemo2 &#123; public static void main(String args[])&#123; Class c1 = int.class; // int 的类类型 Class c2 = String.class; //String的类类型 Class c3 = double.class ; Class c4 = Double.class ; Class c5 = void.class ; System.out.println(c1.getName()) ; System.out.println(c3.getSimpleName()) ;//打印不包含包名的类信息 &#125;&#125; 案例： 123456789101112131415161718192021222324252627282930313233package com.rovo98.feflect;public class ClassUtil &#123; /** *打印类的信息，包括类的成员变量，成员方法 *@param obj 该对象所属类的信息 */ public static void printClassMessage(Object obj) &#123; //要获取类的信息 首先要获取类的类类型 Class c = obj.getClass() ;//传递的是哪个子类的对象 c就是该子类的类类型 // 获取类名称 System.out.println("类的名称："+c.getName()) ; /* *Method类 ，方法对象 *一个成员方法就是一个Method对象 *getMethods()方法获取的是所有public的函数，包括父类继承而来的 *getDeclaredMethods()获取的是所有该类自己声明的方法，不包含访问权限 */ Method[] ms = c.getMethods() ;//c.getDeclaredMethods() for (int i=0; i&lt;ms.length; i++) &#123; // 得到方法的返回值类型的类类型 Class returnType = ms[i].getReturnType() ; System.out.print(returnType.getName()+" ") ; //得到方法的名称 System.out.print(ms[i].getName()+"("); //获取参数类型 --&gt; 得到的是参数列表的类型的类类型 for (Class class1 : paramTypes) &#123; System.out.print(class1.getName()+","); &#125; System.out.println(")"); &#125; &#125;&#125; 成员变量和构造方法信息的获取 getField()方法获取的是所有的public的成员变量的信息 getDeclaredField()获取的是该类自己声明的成员变量的信息 getConstructors获取所有的public的构造方法 getDeclaredConstructors得到所有的构造方法 12345678910111213141516171819202122232425262728293031323334353637383940414243public static void printClassFieldMessage(Object obj) &#123; /**成员变量也是对象*java.lang.reflect.Field*Field类封装了关于成员变量的操作*getField()方法获取的是所有的public的成员变量的信息*getDeclaredField()获取的是该类自己声明的成员变量的信息*///Field[] fs = c.getDeclaredFields();Filed[] fs = c.getDeclaredFields();for (Field field:fs) &#123; //得到成员变量的类型的类类型 Class fieldType = field.getType(); String typeName = fieldType.getName(); //得到成员变量的名称 String fieldName = field.getName(); System.out.println(typeName+" "+fieldName) ; &#125;&#125;/***打印对象的构造函数的信息*@param obj*/public static void printConMessage(Object obj) &#123; Class c = obj.getClass(); /* *构造方法也是对象 *java.lang.Constructor中封装了构造方法的信息 *getConstructors获取所有的public的构造方法 *getDeclaredConstructors得到所有的构造方法 */ //Constructor[] cs = c.getConstructors(); Construtor() cs = c.getDeclaredConstructors(); for (Constructor constructor : cs) &#123; //打印构造方法信息 System.out.print(constructor.getName()+"("); Class[] paramTypes = constructor.getParameterTypes(); for (Class class1 : paramTypes) &#123; System.out.print(class1.getName+" "); &#125; System.out.println(")"); &#125;&#125; java方法反射的基本操作方法的反射 1)如何获取某个方法方法的名称和方法的参数列表才能唯一决定某个方法 2)方法反射的操作method.invoke(对象,参数列表) 123456789101112131415161718192021222324252627282930313233343536package com.rovo98.reflect;public class MethodDemo1 &#123; public static main(String args[]) &#123; //要获取print(int, int)方法 //1.要先获取类的类类类型 //2.获取类的信息 A a1 = new A() ; Class c = a1.getClass() ; // 3.获取方法 名称和参数列表决定 //getMethod获取的是public的方法 //getDeclaredMethod自己的声明的方法 //c.getMethod(name,parameterTypes); //Method m = c.getMethod("print",new Class[]&#123;int.class,int.class&#125;); try &#123; // 获取print(int,int)方法 Method m = c.getMethod("print",int.class,int.class); //方法的反射操作 //使用m对象来进行方法调用 和a1对象调用一样 //方法如果没有返回值返回null,有则返回具体返回值 //本来是a1.print(10,20); Object o = m.invoke(a1,new Object[]&#123;10,20&#125;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;class A &#123; public vodi print(int a, int b) &#123; System.out.println(a + b) ; &#125; public void print(String a, String b) &#123; System.out.println(a.toUpperCase()+","+b.tolowerCase()) ; &#125;&#125; 通过反射了解集合泛型的本质12345678910111213141516171819202122232425262728293031package com.rovo98.reflect;public class MethodDemo4&#123; public static void main(String args[]) &#123; ArrayList list = new ArrayList() ; ArrayList&lt;String&gt; list1 = new ArrayList&lt;String&gt;(); list1.add("hello"); //list1.add(20); 错误的 Class c1 = list.getClass() ; Class c2 = list1.getClass() ; System.out.println(c1 == c2) ; //反射的操作都是编译之后的操作 /* *c1 == c2 结果返回true说明编译之后集合的泛型是去泛型化的 *java中集合的泛型，是防止错误输入的，只在编译阶段有效 *验证：可以通过方法的反射操作，绕过编译 */ try &#123; Method m = c1.getMethod("add",Object.class) ; // 绕过编译操作，绕过了泛型 Object o = c1.invoke(list1,20) ; System.out.println(list1.size()) ; // list1.size --&gt; 2 // list1 -- &gt; ["hello",20] &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>basic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS 基础学习]]></title>
    <url>%2Fposts%2Fc452f057%2F</url>
    <content type="text"><![CDATA[层叠样式表(Cascading Style Sheets),简称CSS, 是一种简单的设计语言，旨在简化是网页渲染的过程。 CSS处理网页的外观部分。使用CSS，可以控制文本的颜色，字体的样式，段落的间距，列的大小和布局，使用的背景图像和颜色，布局设计，不同的设备的显示变化和屏幕尺寸以及的其他各种影响。 CSS易于学习和理解，但它提供了对HTML文档的强大控制。CSS一般与标记语言HTML或XHTML结合使用。 概述(Introduction)一、CSS 的优点 节省时间 - 我们可以编写一次CSS，然后在多个HTML页面中重复使用相同的样式表。可以为每个HTML元素定义样式，并将其应用于任意数量的Web页面中; 页面加载更快 - 如果使用CSS，则不需要每次都编写HTML的标签属性。只需要编写一个标签的CSS规则并将其应用于该标签的所有实例中。因此代码越少意味着加载的速度会变快; 易于维护 - 要进行全局更改，只需要更改样式，所有网页中的所有元素都将自动更新; HTML的高级风格 - CSS具有比HTML更广泛的属性，因此与HTML属性相比，可以更好地渲染页面; 多设备兼容性 - 样式表允许针对多种类型的设备优化内容。通过使用相同的HTMl文档，可以为诸如PDA和手机之类的手持设备呈现不同版本的网站或用于打印; 全球Web标准 - 现在HTML属性已被弃用，建议使用CSS。因此，最好在所有HTML页面中开始使用CSS,以使它们与未来的浏览器兼容; 离线浏览 - CSS可以在离线catche的帮助下在本地缓存Web应用程序。使用此功能，我们可以查看离线网站。缓存还可以确保更快的加载速度和更好的网站整体性能; 平台独立性 - 脚本提供一致的平台独立性，也可以支持最新的浏览器. 二、谁创建和维护CSS?CSS是由HåkonWiumLie于1994年10月10日发明的，由W3c内的一组人员(称为CSS工作组)维护。CSS工作组创建称为规范(specifications)的文档，当W3C成员讨论并正式批准规范时，它就成为了建议(recommendation)。 NOTE - 万维网联盟(W3C)是一个小组，就互联网如何运作以及互联网如何发展提出建议。 三、CSS 的版本CSS1层叠样式表在1996年1月作为建议(recommendation)出自W3C。该版本描述了CSS语言以及所有HTML标签的简单可视化模型。 CSS2于1998年5月成为W3C建议标准，并以CSS1为基础。此版本增加了对媒体特定样式表的支持，例如打印机和听觉设备，可下载字体，元素定位和表格。 CSS3与1999年6月成为W3C建议，并以旧版CSS为基础。它分为文档，称为模块，这里每个模块都有CSS2中定义的新扩展功能。 CSS3 模块CSS3模块具有旧版的CSS规范以及扩展功能 - 选择器 (Selectors) 盒子模型 (Box Model) 背景和边框 (Backgrounds and Borders) 图像值和替换内容 (Image Values and Replaced Content) 文本效果 (Text Effects) 2D/3D转换 (2D/3D Transformations) 动画 (Animations) 多列布局 (Multiple Column Layout) 用户界面 (User Interface) 语法(Syntax)CSS包含的样式规则由浏览器解释，然后应用于文档中的相对应的元素。样式规则由以下三部分组成 - 选择器(Selector) - 选择器是将要应用样式的HTML标签。可以是&lt;h1&gt;或&lt;table&gt;等任何标签; 属性(Property) - 属性是HTML标签的一种属性。简而言之，所有HTML属性都转换为CSS属性。它们可以是颜色，边框等; 属性值(Value) - 为属性设置的值。例如，color属性可以设置为red或#F1F1F1等。 CSS样式规则语法如下 - 1selector &#123;property: value &#125; 例如：我们可以为表格定义一个边框 - 1table &#123;border: 1px solid #c00; &#125; 一、类型选择器 (Type Selectors)这与我们上面看到的选择器是相同的，以标签的类型作为选择器。我们再看一个例子 - 为所有1级标题提供颜色 123h1 &#123; color: #36CFFF;&#125; 二、通用选择器 (Universal Selectors)通用选择器匹配任何元素类型的名称，即所有HTML元素，而不是选择特定类型的元素 - 1234* &#123; margin: 0px; padding: 0px;&#125; 三、后代选择器 (Descendant Selectors)假设我们希望仅在特定元素位于特定元素内时才将样式规则应用于该元素。如以下所示，样式规则仅在&lt;em&gt;元素位于&lt;ul&gt;元素内时才应用于&lt;em&gt;。 123ul em &#123; color: #000;&#125; 四、类选择器 (Class Selectors)可以根据元素的class属性定义样式规则。具有该类的所有元素将根据定义的规则进行格式化。 123.black &#123; color : #000;&#125; 此规则在文档中将class属性设置为black的每个元素呈现为黑色内容。我们还可以把它变得更特别。例如 - 123h1.black &#123; color: #000;&#125; 上面的规则只适用于将class属性设置为black的&lt;h1&gt;元素。 对于类选择器，一个HTML元素可以使用多个类选择器。例如 - 123&lt;p class = "class1 class2 class3"&gt; This is a para will be styled.&lt;/p&gt; 五、ID选择器 (ID Selectors)根据元素的id属性定义样式规则。具有该id的所有元素将根据定义规则进行格式化。 123#black &#123; color : #000;&#125; 对于文档中的id属性设置为black的每个元素，此规则将它们的内容呈现为黑色。同类选择器一样，我们也可以把它变得特殊化 - 123h1#black &#123; color : #000;&#125; 该规则仅将id属性为black的&lt;h1&gt;元素的内容设置为黑色。id选择器的真正强大之处在于它们被用作后代选择器的基础，例如： 123#black h2 &#123; color: #000;&#125; 在此示例中，当2级标题位于id属性设置为black的标签元素中时，所有的2级标题将以黑色显示。 六、孩子选择器 (Child Selectors)之前我们已经看到了后代选择器。孩子选择器和它非常相似，但具有不同的功能。例如 - 123body &gt; p &#123; color : #000;&#125; 该规则中，&lt;p&gt;只有在是&lt;body&gt;元素的直接子元素的情况下，样式规则才会应用。放在其他元素(如：&lt;div&gt;等)中，则样式规则不会起作用。 七、属性选择器 (Attribute Selectors)我们还可以将样式应用与于具有特定属性的HTML元素上。下面的样式规则将匹配具有type属性值为text的所有&lt;input&gt;元素。 123input[type="text"] &#123; color: #000;&#125; 此方法的优点是&lt;input type=&quot;submit&quot; /&gt;元素不受影响，并且颜色仅应用于所需的文本字段。 下面的规则适用于属性选择器 - p[lang] - 选择所有拥有lang属性的段落元素; p[lang=&quot;fr&quot;] - 选择所有具有lang属性且值为fr的段落元素; p[lang~=&quot;fr&quot;] - 选择所有具有lang属性且值包含fr的段落元素; p[lang|=&quot;en&quot;] - 选择其lang属性包含完全为en值的所有段落元素，或以en-开头的. 八、多样式规则 在实际的情况中，我们可能需要对单个元素定义多个样式规则。例如 - 1234567h1 &#123; color: #36C; font-weight: normal; letter-spacing: .4em; margin-bottom: 1em; text-transform: lowercase;&#125; 这里所有的属性和值对都用冒号:分隔，可以将它们写在同一行上，但是为了更好的可读性，建议是将它们分成不同的行。 九、分组选择器如果需要，我们还可以将样式应用于多个选择器。只需要用逗号分隔选择器，如下所示 - 1234567h1, h2, h3 &#123; color: #36C; font-weight: normal; letter-spacing: .4em; margin-bottom: 1em; text-transform: lowercase;&#125; 此样式规则同时适用于h1,h2和h3元素。它们之间的顺序不重要，选择器中的所有规则都将被应用。 组合多个id选择器 - 12345#content, #footer, #supplement &#123; position: absolute; left: 510px; width: 200px;&#125; CSS使用方式(Inclusion)测量单位(Measurement Units)颜色(Colors)背景(Backgrouds)字体(Fonts)文本(Text)图像(Images)链接(Links)表格(Tables)边框(Borders)外边距(Margins)列表(Lists)内边距(Padding)游标(Cursors)纲要(Outlines)尺寸(Dimension)滚动条(Scrollbars)]]></content>
      <categories>
        <category>JavaWeb</category>
        <category>Web Basic</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>web dev</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5 基础学习]]></title>
    <url>%2Fposts%2F9f461f83%2F</url>
    <content type="text"><![CDATA[HTML5是取代HTML4.01, XHTML 1.0和XHTML 1.1的HTML标准的下一个主要修订版。HTML5是在万维网上构建和呈现内容的标准。 概述 (Overview)HTML5是万维网联盟(World Wide Web Consortium, W3C)和Web超文本应用技术工作组(Web Hypertext Application Technology Working Group, WHATWG)合作的成果。 新标准包含了以前依赖于第三方浏览器插件(如： Adobe Flash, Microsoft Sliverlight 和 Google Gears)的视频播放和拖放等功能。 一、浏览器支持Apple Safari, Google Chrome, Mozilla Firefox和Opera的最新版本都支持许多HTML5功能，Internet explorer 9.0也支持某些HTML5功能。 预装在Iphone, iPad和Android手机上的移动网络浏览器都对HTML5提供了出色的支持。 二、新特性HTML5引入了许多新元素和属性，可以帮助我们构建现代网站。以下是HTML5引入的一些最突出的功能. 新的语义元素(Semantic Elements) - 例如: &lt;header&gt;, &lt;footer&gt;和&lt;section&gt;等； 表单2.0 - 对HTML的网页表单的改进，其中为&lt;input&gt;标签引入了新属性; 持久本地存储(Persistent Local Storage) - 无需借助第三方插件即可实现; WebSocket - 用于Web应用程序的下一代双向通信技术; 服务器发送事件(Server sent Events) - HTML5引入了从Web服务器流向Web浏览器的事件，它们被称为Server-Sent-Events(SSE); 画布(Canvas) - 支持二维绘图，可以使用Javascript进行编程; 声音&amp;视频(Audio&amp;Video) - 不需要使用第三方插件，就可以在网页中嵌入音频或视频; 地理位置(Geolocation) - 网页的浏览者可以选择与Web应用程序共享物理位置; 微数据(Microdata) - 这使得我们可以在HTML5之外创建自己的词汇变,并使用自定义的语义元素来扩展网页; 拖放(Drag&amp;Drop) - 将项目从一个位置拖放到同一网页的另一个位置. 三、向后兼容性HTML5尽可能设计为与现有Web浏览器向后兼容。它的新功能基于现有功能，允许为旧版浏览器提供后背内容。 使用HTML5时，建议使用几行Javascript代码检测对各个HTML5功能的支持。 语法 (Syntax)HTML5具有“自定义”HTML语法，该语法与Web上发布的HTML4和xHTML 1文档兼容，但是与HTML4的更深奥的SGML功能不兼容。 HTML5与XHTML没有相同的语法规则，XHTML需要小写标签名称，属性需要用引号括起来，属性必须有一个值并关闭所有的空元素。 HTML5具有很大的灵活性，它支持以下功能 - 大写标签名称; 引号对于属性是可选的; 属性的值也是可选的; 空元素的关闭也是可选的. 一、DOCTYPE旧版的HTML中DOCTYPE较长，因为HTML是基于SGML的，因此需要引用DTD。HTML5可以使用下面的简单的语法来指定DOCTYPE - 1&lt;!DOCTYPE html&gt; 上面的语法不区分大小写。 二、字符编码在HTML5中可以使用简单的语法指定字符编码 - 1&lt;meta charset = "UTF-8"&gt; 三、&lt;script&gt;标签通过的做法是将一个值为&quot;text/javascript&quot;的type属性添加到脚本元素中，如下所示 - 1&lt;script type = "text/javascript" src = "scriptfile.js"&gt;&lt;/script&gt; 但HTML5删除了除了所需的额外信息，只需要使用以下语法即可 - 1&lt;script src = "scriptfile.js"&gt;&lt;/script&gt; 四、&lt;link&gt;标签以前我们是这样写&lt;link标签元素的 - 1&lt;link rel = "stylesheet" type = "text/css" href = "stylefile.css"&gt; 在HTML5中删除了所需的额外的信息，使用下面的简单的语法即可 - 1&lt;link rel = "stylesheet" href = "stylefile.css"&gt; 五、HTML5 元素HTML5元素使用开始标记和结束标记进行标记。标签是尖括号分隔，标签名称介于两者之间。不同于开始标记，结束标记在标签名名称中多了一个斜杠。下面是使用HTML5元素的语法 - 1&lt;p&gt; ... &lt;/p&gt; HTML5标签名称不区分大小写，可以全部大写或者混合大小写，但最常见的是使用小写。 大多数元素包含一些内容，如&lt;p&gt;...&lt;/p&gt;包含一个段落。但是，有些元素根本不包含任何内容，这些元素称为空元素。例如: br, hr, link, meta等。 六、HTML5 属性元素可能包含用于设置元素的各种属性的属性。某些元素是全局定义的，可以在任何元素上使用，而其他属性仅针对特定元素定义。所有属性都有一个名称和一个值，如下例所示 - 1&lt;div class = "example" id = "wrapper"&gt; ... &lt;/div&gt; HTML5属性同样不区分大小写，可以全部使用大写或混合大小写，但约定俗成的是坚持使用小写。 七、HTML5 文档HTML5中引入了下面的标签来更好的结构化文档 - section - 该标签表示通用文档或应用程序部分。它可以与h1-h6一起使用来指示文档结构; article - 此标签表示文档的独立内容，例如博客条目或报纸文章; aside - 该标签表示一段仅与页面其余部分略有相关的内容; header - 此标签表示section的标题; footer - 该标签表示section的页脚，可以包含有关作者，版权信息等的信息; nav - 此标签表示用于导航的文档的一部分; dialog - 该标签可用于标记对话; figure - 此标签可以将标题与某些嵌入内容(例如图片或视频)相关联. HTML5的文档结构简单例子如下 - 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset = "UTF-8"&gt; &lt;title&gt;...&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;header&gt;...&lt;/header&gt; &lt;nav&gt;...&lt;/nav&gt; &lt;article&gt; &lt;section&gt; ... &lt;/section&gt; &lt;/article&gt; &lt;aside&gt;...&lt;/aside&gt; &lt;footer&gt;...&lt;/footer&gt; &lt;/body&gt;&lt;/html&gt; 属性 (Attributes)之前已经提到，元素可能包含用于设置元素的各种属性的属性。某些元素是全局定义的，可以在任何元素上使用，而其他属性仅针对特定元素定义。所有属性都有一个名称和一个值。属性的设置只能在开始标签中设置。HTML5属性不区分大小写，可以混合大小写，但是约定俗成使用小写。 一、标准属性几乎所有HTML5标签都支持下面列出的属性(常用部分属性) - Attribute Options Function accesskey 用户自定义 指定用于访问元素的键盘快捷方式 align right,left,center 水平对齐标签 backgroud URL 在元素后面放置背景图像 bgcolor 数字，颜色十六进制表示,RGB值 设置元素的背景颜色 class 用户自定义 对用于层叠样式表的元素进行分类 contenteditable true, false 指定用户是否可以编辑元素内容 contextmenu Menu id 指定元素的上下文菜单 data-XXXX 用户自定义 自定义属性。开发人员可以定义自己的属性。必须以data-开头 draggable true, false, auto 指定是否允许用户拖动元素 height 数值 指定表格，图像，表格单元的高度 hidden hidden 指定元素是否可见 id 用户自定义 命名用于层叠样式表的元素 item 元素列表 用于分组元素 itemprop 项目列表 用于分组项目 spellcheck true,false 指定元素是否必须检查拼写或语法 style CSS 样式表 指定元素的行内样式 subject 用户定义的id 指定元素对应的项目 tabindex Tab数字 指定元素的Tab键顺序 title 用户自定义 定义元素的“弹出”标题 valign top,middle,bottom 垂直对齐HTML元素中的标签 width 数值 指定表格，图像，或者表格单元的宽度 二、自定义属性用户可以添加自定义数据属性是HTML5中引入的新功能。自定义的数据属性一data-开头，并根据需求来命名，例如 - 123&lt;div class ="example" data-subject = "physics" data-level = "complext"&gt;...&lt;/div&gt; 上面的代码在HTML5中是完全有效的，其中data-subject和data-level为自定义属性。可以使用JavaScript API或CSS以与标准属性类似的方式获取这些属性的值。 事件 (Events)当用户访问往网站时，他们会执行各种活动，例如单机文本和图像以及链接，将鼠标悬停在已定义的元素上等。这些在Javascript中被称为事件。 我们可以在JavaScript或VBscript中编写事件处理程序，可以将这些事件处理程序指定为事件标记属性的值。HTML5规范定义了下面列出的各种事件属性 - 当任何HTML5元素发生任何事件时，我们可以使用以下属性集来触发作为值给定的任何javascript或vbscript代码。 Attribute Value Description offline script 文档脱机时触发 onabort script 中止事件时触发 onafterprint script 文档打印后触发 onbeforeonload script 文档加载前触发 onbeforeprint script 文档打印前触发 onblur script 窗口失去焦点时触发 oncanplay script 当媒体可以播放时触发，但可能必须停止缓冲 oncanpalythrough script 当媒体可以播放到最后时触发，而不停止缓冲 onchange script 元素内容改变时触发 onclick script 鼠标单击时触发 oncontextmenu script 触发上下文菜单时触发 ondbclick script 双击鼠标时触发 ondrag script 拖动元素时触发 ondragend script 拖动操作结束时触发 ondragenter script 将元素拖动到有效放置目标时触发 ondragleave script 元素离开有效放置目标时触发 ondragstart script 拖动操作开始时触发 ondrop script 放置元素时触发 ondurationchange script 媒体长度发生改变时触发 onemptied script 媒体资源元素突然变空时触发 onended script 媒体到达终点时触发 onerror script 发生错误时触发 onfocus script 窗口获得焦点时触发 onformchange script 表单发生改变时触发 onforminput script 用户输入表单内容时触发 onhaschange script 文档更改时触发 oninput script 元素获得用户输入时触发 oninvalid script 元素无效时触发 onkeydown script 某个键按下时触发 onkeypress script 某个键被按下并释放时触发 onkeyup script 某个键释放时触发 onlaod script 文档加载时触发 onloadeddata script 媒体数据加载时触发 onloadedmetadata script 加载媒体元素的持续时间和其他媒体数据时触发 onlaodstart script 浏览器开始加载媒体数据时触发 onmessage script 触发消息时触发 onmousedown script 按下鼠标按钮时触发 onmousemove script 鼠标指针移动时触发 onmouseout script 鼠标指针移开某个元素时触发 onmouseover script 鼠标指针移动到某个元素上时触发 onmouseup script 鼠标按钮释放时触发 onmousewheel script 鼠标滑轮滚动时触发 onoffline script 文档脱机时触发 ononline script 文档联机时触发 onpagehide script 隐藏窗口时触发 onpause script 媒体暂停时触发 onpageshow script 窗口可视时触发 onplay script 媒体数据即将开始播放时触发 onplaying script 媒体数据开始播放时触发 onpopstate script 窗口历史记录更改时触发 onprogress script 浏览器获取媒体数据时触发 onratechange script 媒体数据的播放速率发生变化时触发 onreadystatechange script 准备状态改变时触发 onredo script 文档执行重做时触发 onresize script 调整窗口大小时触发 onscroll script 滚动元素的滚动条时触发 onseeked script 当媒体元素的搜索属性不再为真时触发，并且搜索已经结束 onseeking script 当媒体元素的搜索属性为真时触发，并且搜索已经开始 onselect script 元素被选中时触发 onstalled script 在获取媒体数据时出现错误事触发 onstorage script 文档加载时触发 onsubmit script 表单提交时触发 onsuspend script 浏览器获取媒体数据时触发，但在获取整个每天文件之前停止 ontimeupdate script 媒体更改其播放位置时触发 onundo script 文档执行撤销时触发 onunload script 用户离开文档时触发 onvolumechange script 媒体更改音量时触发，当音量设置为“mute(静音)”时触发 onwaiting script 当媒体停止播放时触发，当预计会恢复 表单 (Web Forms 2.0)矢量图 (SVG)MathMLWeb 存储Web SQL 数据库服务器发送事件 (Server Sent Events)WebSocketCanvas声音&amp;视频 (Audio&amp;Video)地理位置 (Geolocation)微数据 (Microdata)拖放 (Drag &amp; drop)Web WorkersIndexedDBWeb 通信 (Messaging)CORSRTC]]></content>
      <categories>
        <category>JavaWeb</category>
        <category>Web Basic</category>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>web dev</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式基本使用]]></title>
    <url>%2Fposts%2Ff85f3c07%2F</url>
    <content type="text"><![CDATA[regular expression regex RE 简介 正则表达式是用来简洁表达一组字符串的表达式。 正则表达式——一行胜千言 通用的字符串表达框架 简洁表达一组字符串的表达式 针对字符串表达“简洁”和“特征”思想的工具 判断某一字符串的特征归属 正则表达式在文本处理中十分常用 表达文本类型的特征(病毒、入侵等) 同时查找或替换一组字符串 匹配字符串的全部或部分 正则表达式主要应用在字符串的匹配中 正则表达式的使用 编译：将符合正则表达式语法的字符串转换成正则表达式特征。—— re.compile(regex) 正则表达式的语法正则表达式常用的操作符 操作符 说明 实例 . 表示任何单个字符 [ ] 字符集，对单个字符给出取值范围 [abc]表示a、b、c, [a-z]表示a到z单个字符 [^ ] 非字符集，对单个字符给出排除范围 [^abc]表示非a或b或c的单个字符 * 前一个字符0次或无限次扩展 abc*表示ab、abc、abcc、abcc等 + 前一个字符1次或无限次扩展 abc+表示abc、abcc、abccc等 ? 前一个字符0次或1次扩展 abc?表示ab、abc &#124; 左右表达式任意一个 abc &#124; def表示abc、def {m} 扩展前一个字符m次 ab{2}c表示abbc {m,n} 扩展前一个字符m至n次 ab{1,2}c表示abc、abbc ^ 匹配字符串开头 ^abc表示abc且在一个字符串的开头 $ 匹配字符串结尾 abc$表示abc且在一个字符串的结尾 ( ) 分组标记，内部只能使用 &#124; 操作符 (abc)表示abc ，(abc&#124;def)表示abc、def \d 数字，等价于[0-9] \w 单词字符，等价于[A-Za-z0-9] 经典正则表达式实例 ^[A-Za-z]+$ 由26个字母组成的字符串 ^[A-za-z0-9]+$ 由26个字母及数字组成的字符串 ^-?\d+$ 整数形式的字符串 ^[0-9]\*\[1-9][0-9]*$ 正整数形式的字符串 [1-9]\d{5} 中国境内的邮政编码，6 位 [\u4e00-\u9fa5] 匹配中文字符 \d{3}-\d{8} &#124; \d{4}-\d{7} 国内电话 IP地址: 不精确的写法： \d+.\d+.\d+.\d+ —— 以四个点进行分隔作为特点 \d{1,3}.\d{1,3}.\d{1,3}.\d{1,3} 精确写法：0-99 : [0-9]?\d 100-199 : 1\d{2}200-249 : 2[0-4]\d 250-255 : 25[0-5](([0-9]?\d|1\d{2}|2[0-4]\d|25[0-5]).){3}([0-9]?\d|1\d{2}|2[0-4]\d|25[0-5]) Re库的基本使用Re库介绍Re库是Python的标准库，主要用于字符串匹配。 1import re 正则表达式的表示类型 raw string 类型(原生字符串类型) —— 不包含转义字符re 库采用raw string 类型表示正则表达式，表示为：r’text’ string类型， 更繁琐 —— 需要双重转义 Re库的主要功能函数 函数 说明 re.search() 在一个字符串中搜索匹配正则表达式的第一个位置，返回match对象 re.match() 在一个字符串开始位置起匹配正则表达式，返回match对象 re.findall() 搜索字符串，以列表类型返回全部能匹配的子串 re.spilt() 将一个字符串按照正则表达式匹配结果进行分割，返回列表类型 re.fiinditer() 搜索字符串，返回一个匹配结果的迭代类型，每个迭代元素是match re.sub() 在一个字符串中替换所有匹配正则表达式的子串，返回替换后的字符串 re.search(pattern, string,flags=0) 在一个字符串中搜索匹配正则表达式的第一个位置，返回match对象 pattern: 正则表达式的字符串或者原生字符串 表示 string : 待匹配字符串 flags : 正则表达式使用时的控制标记 常用标记 说明 re.I re.IGNORECASE 忽略正则表达式的大小写，[A-Z]能够匹配小写字符 re.M RE.MULTILINE 正则表达式中的^操作符能够将给定字符串的每行当作匹配开始 re.S RE.DOTALL 正则表达式中的.操作符能够匹配所有字符，默认匹配除换行符外的所有字符 re.match(partern, string, flags=0) 从一个字符串的开始位置起匹配正则表达式，返回match对象 re.findall(pattern, string , flags=0) 搜索字符串，以列表类型返回全部能匹配的子串。 pattern ： 正则表达式的字符串或原生字符串表示 string ： 待匹配字符串 flags: 正则表达式使用时的控制标记 re.split(pattern, string, maxsplit=0, flags=0) 将一个字符串按照正则表达式匹配结果进行分割，返回列表类型。 maxsplit: 最大分割数 re.finditer(patern, string, flags=0) 搜索字符串，返回一个匹配结果的迭代类型，每一个迭代元素是match对象。 re.sub(pattern, repl, string, count=0, flags=0) 在一个字符串中替换所有匹配正则表达式的子串，返回替换后的字符串。 repl: 替换匹配字符串的字符串 count： 替换的最大次数 Re库的另一种等价用法1234567rst = re.search(r'[1-9]\d&#123;5&#125;', 'BIT100081')#函数式用法： 一次性操作#面向对象用法：编译后的多次操作pat = re.compile(r'[1-9]\d&#123;5&#125;')rst = pat.search('BIT100081') regex = re.compile(pattern, flags=0) 将正则表达式的字符串形式编译成正则表达式对象 Re库的match对象Match对象的属性 属性 说明 .string 待匹配文本 .re 匹配时使用的pattern对象()正则表达式 .pos 正则表达式搜索文本的开始位置 .endpos 正则表达式搜索文本的结束位置 Match对象的方法 方法 说明 .group(0) 获得匹配后的字符串 .start() 匹配字符串在原始字符串的开始位置 .end() 匹配字符串在原始字符串的结束位置 .span() 返回(.start(),.end()) — 元组类型 Re库的贪婪匹配和最小匹配 Re库默认采用贪婪匹配 最小匹配操作符 操作符 说明 *? 前一个字符0次或无限次扩展，最小匹配 +? 前一个字符1次或无限次扩展，最小匹配 ?? 前一个字符0次或1次扩展，最小匹配 {m,n}? 扩展前一个字符m至n次(含n)，最小匹配 高效的正则表达式技巧总结误匹配 指正则表达式所匹配的内容范围超过了所需要范围，有些文本命名不符合要求，但是被所写的正则表达式“击中”了。例如：如果使用\d{11}去匹配11位手机号，\d{11}不单单能匹配正确的手机号，它还会匹配98824839344这样明显不是手机号的字符串。我们把这样的匹配称为误匹配。 漏匹配 指正则表达式所匹配的内容所规定的范围太狭窄，有些文本确实是所需要的，但是所写的正则表达式没有将这种情况囊括在内。例如：使用\d{18}来匹配身份证号码，就会漏掉结尾是字母X的情况。 写出一条正则表达式，既可能出现误匹配(条件写得太宽松，范围大于目标文本)，也可能出现漏匹配(只描述了目标文本中多种情况的部分)，还可能既有误匹配又有漏匹配。例如：使用\w+\.com来匹配.com结尾的域名，既会误匹配abc\_.com(合法域名不包含\_,\w包含了这种情况),又会漏掉ab-c.com这样的域名(合法域名可以包含中划线，\w不包含中划线). 应对方法掌握语法细节 正则表达式在各种语言中，其语法大致相同，细节各有千秋。明确所使用语言的正则的语法的细节，是写出正确、高效正则表达式的基础。例如，perl中与\w等效的匹配范围是[a-zA-Z0-9\_];perl正则表达式不支持肯定逆序视中使用可变的重复(variable repetition inside lookbehind,例如( ?&lt;=.* )abc), 但是.Net语法是支持这一特性的；又如，JavaScript连逆序环视(lookbehind,如(?&lt;=ab)c)都不支持，而Perl和Python是支持的。&lt;&lt;精通正则表达式&gt;&gt;第三章&lt;&lt;正则表达式的特性和流派概览&gt;&gt;明确地列出了个大派系的正则表达式的异同。 先粗后精，先减后加 使用正则表达式语法对于目标文本进行描述和界定，可以像画素描一样，先大致勾勒出框架，在逐步在局部实现细节。仍举刚才的手机例子：先界定\d{11},总不会错；再细化为1[358]\d{9},就向前迈了一大步。先消除 漏匹配(刚开始先尽可能多的匹配，做加法)，然后再一点点去除误匹配(做减法)。]]></content>
      <categories>
        <category>Python</category>
        <category>python爬虫</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>regex基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解Requests库的异常和HTTP协议]]></title>
    <url>%2Fposts%2F4ae864e2%2F</url>
    <content type="text"><![CDATA[简单理解Requests库中的异常和HTTP协议。 异常 说明 requests.ConnectionError 网络连接错误异常，如DNS查询失败、拒绝连接等 requests.HTTPError HTTP错误异常 requests.URLRequired URl缺失异常 requests.TooManyRedirects 超过最大重定向次数，产生重定向异常 requests.ConnectTimeout 连接远程服务器超时异常 requests.Timeout 请求URL超时，产生超时异常 Response的异常： 异常 说明 r.raise_for_status() 如果不是200， 产生异常requests.HTTPError 爬取网页的通用代码框架 123456789101112import requestsdef getHTMLText(url) : try: r = requests.get(url, timeout=30) r.raise_for_status() #如果状态不是200， 引发requests.HTTPError异常 r.encoding = r.apparent_encoding #将encoding 设置为'utf-8'，一般用于没有charset的header return r.text except: return '产生异常'if __name__ == '__main__': url = "http://www.baidu.com" print(getHTMLText(url)) HTTP协议HTTP, Hypertext Transfer Protocol, 超文本传输协议 HTTP是一个基于“请求与响应”模式的、无状态的应用层协议。 HTTP协议采用URL作为定位网络资源的标识。 URL格式： http://host[ :port ][ path ] HTTP URL的理解： URL 是通过HTTP协议存取资源的Internet路径，一个URL对应一个数据资源。 HTTP协议对资源的操作 方法 说明 GET 请求获取URL位置的资源 HEAD 请求获取URL位置资源的响应消息报告，即获取该资源的头部信息 POST 请求URL位置的资源后附加新的数据 PUT 请求向URL位置存储一个资源，覆盖原URL位置的资源 PATCH 请求局部更新URL位置的资源，即改变该处资源的部分内容 DELETE 请求删除URL位置存储的资源 理解PATCH和PUT的区别： 假设URL位置有一组数据UserInfo， 包括UserID、UserName等20个字段 需求：用户修改了UserName，其他不变。 采用PATCH，仅向URL提交UserName的更新请求。 采用PUT，必须将所有20个字段一并提交URL，未提交字段被删除。PATCH的好处：节省网络带宽]]></content>
      <categories>
        <category>Python</category>
        <category>python爬虫</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>Requests库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Requests库的7个主要方法]]></title>
    <url>%2Fposts%2Fc671c604%2F</url>
    <content type="text"><![CDATA[Requests库的7个主要方法 方法 说明 requests.request() 构造一个请求，支撑以下各方法的基础方法 requests.get() 获取HTML网页的主要方法，对应于HTTP的GET requests.head() 获取HTML网页头信息的方法，对应于HTTP的HEAD requests.post() 向HTML网页提交POST请求的方法，对应于HTTP的POST requests.put() 向HTML网页提交PUT请求的方法，对应于HTTP的PUT requests.patch() 向HTML网页提交局部修改请求，对应于HTTP的PATCH requests.delete() 向HTML页面提交删除请求，对应HTTP的DELETE requests库的主要方法(基础方法)requests.request(method, url, **kwargs) method:请求方式，对应get/put/post等7种 r = requests.request(&#39;GET&#39;,url, **kwargs) r = requsts.request(&#39;HEAD&#39;,url, **kwargs) r = requests.request(&#39;POST&#39;,url, **kwargs) r = requests.request(&#39;PATCH&#39;,url, **kwargs) r = requests.request(&#39;delete&#39;, url, **kwargs) r = requests.request(&#39;OPTIONS&#39;,url, **kwargs) url:拟获取页面的URL链接 **kwargs: 控制访问的参数，共13个 1)params:字典或字节序列，作为参数增加到URL中 2)data: 字典、字节序列或者文件对象，作为Request的内容 3)json : JSON格式数据，作为Request内容 4)headers : 字典，HTTP定制头 5)cookies : 字典或CookieJar，Request中的cookie 6)auth : 元组，支持HTTP认证功能 7)files : 字典类型，传输文件 8)timeout : 设定的超时时间，秒为单位 9)proxies : 字典类型，设定访问代理服务器，可以增加登录认证 10)allow_redirects : True/False, 默认为True,重定向开关 11)stream : True/False, 默认为True ,获取内容立即下载开关 12)verify : True/False , 默认为True ， 认证SSL证书开关 13) cert : 本地SSL证书路径requests.get()方法： 12r = requests.get(url) #构造一个向服务器请求资源的Request对象#返回一个包含服务器资源的Response对象 完整方法：requests.get(url, params=None, **kwargs) url: 拟获取页面的url链接 params: url中的额外参数， 字典或字节流格式， 可选 **kwargs : 12个控制访问的参数，与request()的一样 实际上是这样的： 12345678910def get(url, params=None, **kwargs): #Sends a GET request. #:param url: URL for the new :class :'Request' object. #:param params: (optional) Dictionary ro bytes to be sent in the query #:return: :class :'Request &lt;Response&gt;' object #:rtype: requests.Response kwargs.setdefault('allow redirect', True) return request('get', url, params=params, **kwargs) 例子： 1234567891011import requestsr = requests.get("http://www.baidu.com")print(r)type(r)r.headers"""输出：200&lt;class 'requests.models.Response'&gt;&#123;'Transfer-Encoding': 'chunked', 'Pragma': 'no-cache', 'Connection': 'Keep-Alive', 'Last-Modified': 'Mon, 23 Jan 2017 13:27:52 GMT', 'Cache-Control': 'private, no-cache, no-store, proxy-revalidate, no-transform', 'Server': 'bfe/1.0.8.18', 'Set-Cookie': 'BDORZ=27315; max-age=86400; domain=.baidu.com; path=/', 'Content-Encoding': 'gzip', 'Date': 'Sat, 15 Jul 2017 13:27:01 GMT', 'Content-Type': 'text/html'&#125;""" Response对象的属性 属性 说明 r.status_code HTTP请求的返回状态，200表示连接成功，404表示失败 r.text HTTP响应内容的字符串形式，即，url对应的页面内容 r.encoding 从HTTP header中猜测的响应内容编码方式 r.apparent_encoding 从内容中分析出的响应内容编码方式(备用编码凡是) r.content HTTP响应内容的二进制形式 [注]：r.encoding: 如果header中不存在charset， 则认为编码为ISO-8859-1 Requests库的head()方法12345678r = requests.head('http://httpbin.org/get')r.headersr.text"""输出：&#123;'Access-Control-Allow-Credentials': 'true', 'X-Processed-Time': '0.000805139541626', 'Via': '1.1 vegur', 'Access-Control-Allow-Origin': '*', 'X-Powered-By': 'Flask', 'Content-Length': '267', 'Server': 'meinheld/0.6.1', 'Content-Type': 'application/json', 'Date': 'Sat, 15 Jul 2017 14:23:41 GMT', 'Connection': 'keep-alive'&#125;'' -- r.text""" Requests库的post()方法123456789101112131415161718192021222324252627payload = &#123;'key1':'value1', 'key2':'value2'&#125;r = requests.post('http://httpbin.org/post', data = payload)r = requests.post('http://httpbin.org/post', data = 'ABC')#向URL POST一个字典自动编码为form(表单)print(r.text)"""输出:&#123; "args": &#123;&#125;, "data": "ABC", --- &gt; 向URLPOST一个字符串，自动编码为data "files": &#123;&#125;, "form": &#123; "key1": "value1", "key2": "value2" &#125;, "headers": &#123; "Accept": "*/*", "Accept-Encoding": "gzip, deflate", "Connection": "close", "Content-Length": "23", "Content-Type": "application/x-www-form-urlencoded", "Host": "httpbin.org", "User-Agent": "python-requests/2.18.1" &#125;, "json": null, "origin": "120.85.181.141", "url": "http://httpbin.org/post"""" Requests库的put()方法1234payload = &#123;'key1':'value1', 'key2':'value2'&#125;r = requests.put('http://httpbin.org/put', data = payload)print(r.text)#此方法与post方法类似，只不过是替换了URL位置上资源的内容]]></content>
      <categories>
        <category>Python</category>
        <category>python爬虫</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>Requests库</tag>
      </tags>
  </entry>
</search>
