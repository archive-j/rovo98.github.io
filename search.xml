<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[解决Github国内访问出现的问题]]></title>
    <url>%2Fposts%2F7e3029b3%2F</url>
    <content type="text"><![CDATA[主要通过修改hosts文件解决Github在国内访问不了、访问慢和页面加载异常的问题(没钱买vpn~)。简单了解一下github, github是目前全球最大的男性同性交友网站(~滑稽~), 使用示例如下：开个玩笑，回归正题。为什么访问不了以及访问速度会很慢？GitHub在中国大陆访问速度慢的问题原因有很多，但最直接和最主要的原因是GitHub的分发加速网络的域名遭到DNS污染。由于GitHub的加速分发CDN域名assets-cdn.github.com遭到DNS污染，导致无法连接使用GitHub的加速分发服务器，才使得中国大陆访问速度很慢。如何解决DNS污染？一般的DNS问题都可以通过修改Hosts文件来解决，GitHub的CDN域名被污染问题也不例外，同样可以通过修改Hosts文件解决。将域名解析直接指向IP地址来绕过DNS的解析，以此解决污染问题。获取被污染域名的实际IP地址访问ipaddress.com,使用ip lookup 工具获得相关域名的ip地址。例如： github.com可以看到，我查出的域名ip地址为： 192.30.254.112 和 192.30.253.113 (任取一个即可)修改host文件，在文件中添加一行：[注] ： windows的hosts文件位置为：C:/windows/system32/drivers/etc/hosts1192.30.253.112 github.com刷新dns缓存打开命令行cmd,输入如下命令：1ipconfig /flushdns此时再刷新页面即可。此时可以正常访问github，但是访问速度还是很慢，我们接着做优化。Github 访问提速在hosts文件中继续加入，如下代码：12345678910111213141516171819# GitHub Start192.30.253.112 github.com192.30.253.119 gist.github.com151.101.228.133 assets-cdn.github.com151.101.228.133 raw.githubusercontent.com151.101.228.133 gist.githubusercontent.com151.101.228.133 cloud.githubusercontent.com151.101.228.133 camo.githubusercontent.com151.101.228.133 avatars0.githubusercontent.com151.101.228.133 avatars1.githubusercontent.com151.101.228.133 avatars2.githubusercontent.com151.101.228.133 avatars3.githubusercontent.com151.101.228.133 avatars4.githubusercontent.com151.101.228.133 avatars5.githubusercontent.com151.101.228.133 avatars6.githubusercontent.com151.101.228.133 avatars7.githubusercontent.com151.101.228.133 avatars8.githubusercontent.com192.30.253.116 api.github.com# GitHub End[notice] : 这里域名对应的ip是通过dns查询工具查询得到的，你应当选择的是延时相对较小且比较稳定的ip。例如，上面的151.101.228.133是对我来说较好的ip:推荐的dns查询检测工具：DNS查询 - 在线工具DNS检测|DNS查询-站长工具你可对单个域名多查询几次，以挑选稳定且速度较快的ip。快速地访问github再次刷新dns缓存后，你已经可以快速地访问github了。参考：https://github.com/chenxuhua/issues-blog/issues/3]]></content>
      <categories>
        <category>tips</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PPP 点对点通信验证]]></title>
    <url>%2Fposts%2F28ff89ad%2F</url>
    <content type="text"><![CDATA[使用Cisco Packet Tracer7 (思科网络模拟器)验证ppp点对点通信。实验内容使用packet Tracer 模拟两台路由器，进行点对点通信测试。实验设计实验设备结构图：均使用思科模拟器中的Generic 泛型路由实验步骤配置路由器由于只需要验证点对点通信，对路由器的配置，相对比较简单，路由器之间使用的是serial DCE 串口线相连。配置Router1的serial 2/0串口为ip: 11.0.0.1 mask: 255.0.0.0,并配置时钟频率为640001234567Router&gt; enableRouter# configure terminalRouter(config) # hostname RARA (config) # interface serial 2/0RA (config) # no shutdownRA (config-if) # ip address 11.0.0.1 255.0.0.0RA (config-if) # clock rate 64000配置Router2的serial 3/0 串口为ip: 11.0.0.2 mask： 255.0.0.0123456Router&gt; enableRouter# configure terminalRouter(config) # hostname RBRB (config) # interface serial 3/0RB (config) # no shutdownRB (config-if) # ip address 11.0.0.2 255.0.0.0查看两个路由的串口状态：RA:RB:可以看到，路由器这里点对点通信默认使用的HDLC(High Level Data Link Control, 面向比特的同步协议)协议。HDLC情况下验证ping：11.0.0.1 ping 11.0.0.2:11.0.0.2 ping 11.0.0.1:ping 测试成功。配置RA,RB使用ppp协议，再做ping测试：先配置RA 使用 ppp协议：123RA # configure terminalRA (config) # interface serial 2/0RA (config-if) # encapsulation ppp可以看到RA当前使用的是ppp写协议，LCP处于Closed,此时，路由器应当无法进行点对点通信。配置RB使用ppp协议：123RB # configure terminalRB (config) # interface serial 3/0RB (config-if) # encapsulation ppp这时，可以看到RB也是使用了ppp协议，且LCP也处于Open状态，路由器之间可以进行通信。给ppp协议添加authentication鉴别先配置RA，使其开启ppp chap (Challenge Handshake Authentication Protocol), 给RB 添加身份验证1234RA # config terminalRA (config) # username RB password passwordRA (config) # interface serial 2/0RA (config-if) # ppp authentication chap此时，虽然RA和RB都是使用ppp协议，但是RA给RB添加了身份认证，而RB则没有，此时LCP处于Closed状态，它们之间无法进行通信。配置RB, 添加对RA的身份验证：1234RB # config terminalRB (config) # username RA password passwordRB (config) # interface serial 2/0RB (config-if) # ppp authentication chap可以看到此时，LCP已经打开，路由器之间可以进行点对点通信。实验结果通过该实验，简单地验证了ppp协议在点对点信道中的使用。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>ppp通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文章加密测试]]></title>
    <url>%2Fposts%2F26ea2038%2F</url>
    <content type="text"><![CDATA[这是被加密的内容.]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用ensp进行简单的路由器互连实验]]></title>
    <url>%2Fposts%2Fcc46ce96%2F</url>
    <content type="text"><![CDATA[简单使用ensp做华为AR1220路由互连的实验。实验内容路由器设置手动设置静态路由实验环境华为路由器AR1220主机Serial设备连接串口线和Copper以太网和千兆以太网连接线备注：所有实验设备均由ensp模拟。路由连接实验设计整体结构如下：1.其中分为六个不同的局域网；12345678910111213141516171819192.168.11.0 网段 -&gt; 主机: 192.168.11.11 192.168.11.12 路由器AR6一个GigabitEthernet接口作为该网段的默认网关(192.168.11.1)192.168.12.0 网段 -&gt; 主机: 192.168.12.11 192.168.12.12 路由器AR4的一个GigabitEthernet接口作为该网段的默认网关(192.168.12.1)192.168.13.0 网段 -&gt; 主机: 192.168.13.11 192.168.13.12 192.168.13.13 路由器AR7的一个GigabitEthernet接口作为该网段的默认网关(192.168.13.1) 1.1.2.0 网段 -&gt; 路由器AR6和路由器AR7之间的接口1.1.1.0 网段 -&gt; 路由器AR6和AR4之间的接口1.1.3.0 网段 -&gt; 路由器AR6和AR7之间的接口2.设备的连接：除了路由器之间连接使用serial串口连接线外，其他均使用Copper连接线。实验步骤配置各个局域网的ip及其网关例如：192.168.11.0网段下的192.168.11.11主机：配置 192.168.11.1作为192.168.11.0网段的网关：所有主机经过配置后，他们应该可以ping通自己网段下的所有主机，如：192.168.11.12 ping 192.168.11.11[需要注意的是]： 由于路由器互连时使用的是Serial串口，所以路由器之间配置的是serial串口的ip。例如：配置AR6的两个serial串口的接口ip为：1.1.1.1和1.1.2.1：123456&lt;Huawei&gt; system-view[Huawei] inter serial 2/0/1[Huawei-Servial2/0/1] ip address 1.1.1.1 255.255.255.0[Huawei-Servial2/0/1] quit[Huawei] inter serial 2/0/0[Huawei-Serial2/0/0] ip address 1.1.2.1 255.255.255.0各个路由器的静态路由：对于路由器AR6,我们希望所有目的网络为192.168.12.0的数据包都交付给AR4,即下一跳为1.1.1.2;所有目的网络为192.168.13.0的都交给AR7,下一跳为1.1.2.2：123&lt;Huawei&gt; system-view[Huawei] ip route-static 192.168.12.0 255.255.255.0 1.1.1.2[Huawei] ip route-static 192.168.13.0 255.255.255.0 1.1.2.2对于路由器AR4，所有目的网络为192.168.11.0的数据包交给AR6，下一跳为：1.1.1.1，目的网络为192.168.13.0的数据包交给AR7，下一跳为：1.1.3.1：123&lt;Huawei&gt; system-view[Huawei] ip route-static 192.168.11.0 255.255.255.0 1.1.1.1[Huawei] ip route-static 192.168.13.0 255.255.255.0 1.1.3.1对于路由器AR7， 所有目的网络为192.168.11.0的数据包都交给AR6，下一跳为：1.1.2.1，所有目的网络为192.168.12.0的数据包都交给AR4，下一跳为：1.1.3.2：123&lt;Huawei&gt; system-view[Huawei] ip route-static 192.168.11.0 255.255.255.0 1.1.2.1[Huawei] ip route-static 192.168.12.0 255.255.255.0 1.1.3.2经过以上对各个路由器的静态路由的配置后，我们可以通过1display ip routing-table来查看各个路由器的路由表：AR6路由表：AR4路由表：AR7路由表：测试实验结果使用任意一个局域网下的主机ping不同局域网下的主机：192.168.11.11 ping 192.168.13.12 和 192.168.12.12:192.168.12.11 ping 192.168.11.12 和 192.168.13.13:192.168.13.11 ping 192.168.11.11 和 192.168.12.11：由以上测试可以看出简单的路由器连接实验成功。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>路由器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7通过yum(yellow dog update modifier) 安装mysql5.7]]></title>
    <url>%2Fposts%2F86d29d2c%2F</url>
    <content type="text"><![CDATA[配置yum源1234# 下载mysql安装源包root @~&gt; wget http://dev.mysql.com/get/mysql57-community-release-el7-8.noarch.rpm# 安装mysql源root @~&gt; yum localinstall mysql57-community-release-el7-8.noarch.rpm检查mysql源是否安装成功:1root @~&gt; yum repolist enabled | grep "mysql.*-community.*"如下图则安装成功:安装mysql1root@ ~&gt; yum install -y mysql-community-server启动MySQL服务并设置开机自动启动1root@ ~&gt; systemctl start mysqld查看MySQL启动状态12root@ ~&gt; systemctl enable mysqldroot@ ~&gt; systemctl daemon-reload修改默认密码刚安装完的mysql会自动给root用户分配一个临时密码，而且必须重新设置密码(从5.5版本开始)先查看root用户的临时密码1root@ ~&gt; grep "temporary password" /var/log/mysqld.log使用临时的密码登录进mysql来设置新的密码1mysql&gt; set PASSWORD = PASSWORD('[YOUR_NEW_PASSWORD]')可能遇到的问题：设置的密码过于简单mysql报错:1Your password does not satisfy the current policy requirements.解决方法：由于刚安装的mysql的密码默认强度是最高的，若想要设置简单的密码就要修改validate_password_policy的值，validate_password_policy有以下取值：PolicyTests Performed0 or LOWLength1 or MEDIUMLength;numeric,lowercase/uppercase,and special characters2 or STRONGLength;numeric,lowercase/uppercase,and special characters; dictionary file操作：设置安全级别1mysql&gt; set global validate_password_policy=0;设置密码长度为8，可以设置为其他值，最小为4位1mysql&gt; set global validate_password_length=4;之后就可以设置简单的密码了。允许root远程登录12mysql&gt; GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY '[YOUR_PASSWORD]' WITH GRANT OPTION;mysql&gt; flush privileges;修改字符集编码为UTF-8查看当前字符编码1mysql&gt; show variables like "char%';检测是否都是utf-8(filesystem除外)，如果不是就需要修改。 character_set_server一般是lantin1。12345678# 停止mysqld服务systemctl stop mysqld# 进入my.cnf文件，一般是/etc/路径下vim /etc/my.cnf# 在[mysqld]下追加character-set-server=utf-8# 在[mysql]下追加default-character-set=utf-8# 启动mysqldsystemctl start mysqld]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql5.7安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java持久化框架基础学习笔记 - ORM]]></title>
    <url>%2Fposts%2F4e7f2cb9%2F</url>
    <content type="text"><![CDATA[对象关系映射(Oject Relational Mapping, ORM)是一种程序技术，用户实现面向对象编程语言中不同类型系统的数据之间的转换。为了更好的了解ORM，我们先要了解一下JDBC。什么是JDBC?JDBC，即Java Database Connectivity(Java数据库连接)。它为Java程序提供了访问关系型数据库(relational database)的Java API集合。这些API使得Java程序可以执行SQL语句并与任何符合SQL的数据库库进行交互。JDBC提供了一种灵活的结构来编写能够和数据库进行交互的应用，且在不做任何修改的情况下，能够运行于不同的平台。JDBC的优点和缺点优点缺点清晰简单的SQL处理在大型的项目中使用时变得异常复杂处理大数据时有良好表现大量编程开销，没有封装非常适合小应用程序难以实现MVC模式语法简单易学查询是DBMS特有的为什么使用对象关系映射(ORM)?当我们使用面向对象系统时，对象模型和关系数据库存在不匹配的现象，RDMSs(关系型数据库) 以表格的形式表示数据，而面向对象编程语言，如java,C# 将数据表示为对象的属性，以及对象之间的关系。例如下面的一个简单的实体类：12345678910111213141516171819202122232425262728public class Employee &#123; private int id; private String firstName; private String lastName; private int salary; public Employee() &#123;&#125; public Employee(String fname, String lname, int sal) &#123; this.firstName = fname; this.lastName = lname; this.salary = sal; &#125; public int getId() &#123; return id; &#125; public String getFirstName() &#123; return firstName; &#125; public String getLastName() &#123; return lastName; &#125; public int getSalary() &#123; return salary; &#125;&#125;上面的对象在关系型数据库中可以这样存储和检索的：1234567create table EMPLOYEE ( id int not null auto_increment, first_name varchar(20) default null, last_name varchar(20) default null, salary int default null, contraint PK_id primary key (id));遇到的问题可能我们开发了几个页面后，要修改数据库的设计，我们应该怎样处理？将对象存储到关系型数据库和从数据库中读取存在以下五个不匹配(mismatch)的问题：不匹配(Mismatch)描述(Description)Granularity(粒度)有时你可能会有一个对象模型，它的类比数据库中的相应的表的数量还要多。Inheritence(继承)RDBMS不定义任何类似继承的东西，但这确是面向对象编程语言中的的自然范式。Identity(标识)RDBMS正好定义了一个“相等”的概念：主键。但是Java定义对象标识(a == b) 和对象相等(a.equals(b))。Associations(关联)面向对象编程语言使用对象引用来表示关联，而RDBMS将关联表示为外键。Navigation(检索)在Java和RDBMS中访问对象的方式根本不同。对象关系映射（ORM）是处理上述所有不匹配问题的解决方案。什么是ORM?ORM 是一项在关系型数据库和面向对象编程语言之间转换数据的编程技术。相比于简单的JDBC，ORM有以下优点：No.Advantages1让业务逻辑代码访问数据对象，而不是数据表2隐藏了业务逻辑的SQL查询的详细信息3无需处理数据库实现问题4基于业务概念而非数据库结构的实体5基于JDBC“底层”6事务管理和自动密钥生成7应用程序快速开发一个 ORM 解决方案由以下四个实体组成：No.Solutions1对持久化类的对象执行基本CRUD操作的API2用于指定引用类和类的属性的查询的语言或API3用于指定映射元数据的可配置工具4一种与事务对象进行交互以执行脏检查，懒惰关联提取以及其他优化功能的技术。Java ORM 框架有许多持久化框架ORM解决方案使用java实现的，如：Enterprise JavaBeans Entity BeansJava Data OjectsCastorTopLinkSpring DAOHibernateMybatis等等。]]></content>
      <categories>
        <category>Java框架学习</category>
      </categories>
      <tags>
        <tag>Java框架基础</tag>
        <tag>ORM</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Struts 2基础学习 - 配置文件]]></title>
    <url>%2Fposts%2F3fe084cc%2F</url>
    <content type="text"><![CDATA[主要了解Struts 2应用的基本配置。看看使用Struts 2的一些重要的配置文件，如：web.xml, struts.xml,strutsconfig.xml和struts.properties，可以对Struts 2应用做哪些配置。其实，我们只要使用web.xml和struts.xml问价就可以使用Struts 2应用。但是我们还是有必要了解一下其他配置文件。web.xml 配置文件web.xml 配置文件是 J2EE 配置文件，它决定了Servlet容器如何处理HTTP请求中的元素。严格上来说，它并不是 Struts 2 的配置文件，但是我们需要通过配置它来使 Struts 2`工作。**毕竟Struts 2 是基于一个Filter做Controller实现的)这个文件为任何一个Web应用提供一个入口点(entry point),而 Struts 2 应用的入口点是定义在 web.xml 文件中的一个过滤器(filter)。因此我们会在 web.xml 中顶一个 FilterDispatcher 类的入口。一个简单的web.xml文件配置例子：1234567891011121314151617181920212223242526&lt;?xml version = "1.0" Encoding = "UTF-8"?&gt;&lt;web-app xmlns:xsi = "http://www.w3.org/2001/XMLSchema-instance" xmlns = "http://java.sun.com/xml/ns/javaee" xmlns:web = "http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" xsi:schemaLocation = "http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd" id = "WebApp_ID" version = "3.0"&gt; &lt;display-name&gt;Struts 2&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt; org.apache.struts2.dispatcher.FilterDispatcher &lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt;【notice】: 这里将Struts 2 Filter映射到 /* ，而不是/*.action, 这意味着所有的url都会被Struts 2的过滤器解析。struts.xml 配置文件struts.xml 文件包含actions开发时需要修改的配置信息。这个文件可以覆盖应用的默认配置，例如：struts.devMode = false，该文件可以放置在WEB-INF/classes目录下。一个hellowordWorld例子的struts.xml配置文件：1234567891011121314151617181920&lt;?xml version = "1.0" Encoding = "UTF-8"?&gt;&lt;!DOCTYPE struts PUBLIC "-//Apache Software Foundation//DTD Struts Configuration 2.0//EN" "http://struts.apache.org/dtds/struts-2.0.dtd"&gt;&lt;struts&gt; &lt;constant name = "struts.devMode" value = "true" /&gt; &lt;package name = "helloworld" extends = "struts-default"&gt; &lt;action name = "hello" class = "com.rovo98.struts2.HelloWorldAction" method = "execute"&gt; &lt;result name = "success"&gt;/HelloWorld.jsp&lt;/result&gt; &lt;/action&gt; &lt;!-- more actions can be listed here --&gt; &lt;/package&gt; &lt;!-- more packages can be listed here --&gt;&lt;/struts&gt;一点需要注意的是 DOCTYPE，所有struts 配置文件都需要有正确的doctype信息，例如上面所展示的。标签是配置文件中的根标签元素，我们可以在里面定义不同的包(package)，使用标签可以使用配置信息模块化，当我们需要把一个大型的项目拆分成不同的模块的时候，它将非常有用。package 标签拥有以下的属性：AttributeDescriptionname(required)包的唯一标识符extends说明包继承于哪个包，默认的，我们使用struts-default作为基包(base package)abstract如果属性值为true,终端用户将无法使用该包namespaceaction类的唯一名称空间constant标签拥有name和value属性，可以重写覆盖定义在default.properites文件中的属性配置，例如我们上面提到的struts.devMode,通过设置struts.devMode属性，我们在日志文件中查看debug信息。我们通过定义一个action标签来映射我们需要访问的链接URL并定义一个实现execute()方法的类，任何时刻，当我们访问对应的链接时，该类的execute()方法都会被执行。result决定了执行action之后，返回浏览器的内容。action返回的String应该是和某个result的name属性值是一致的。result拥有两个可选的属性name和type，name属性的值默认为”success”,type默认为”dispatcher”。struts.xml配置文件在开发中可能会变得非常大，我们可以使用package将它们模块化，当然Struts还提供了另一种方式，我们可以把配置文件分割成多个xml文件，然后通过下面这种方式来将它们导入：123456789&lt;?xml version = "1.0" Encoding = "UTF-8"?&gt;&lt;!DOCTYPE struts PUBLIC "-//Apache Software Foundation//DTD Struts Configuration 2.0//EN" "http://struts.apache.org/dtds/struts-2.0.dtd"&gt;&lt;struts&gt; &lt;include file="my-struts1.xml"/&gt; &lt;include file="my-struts2.xml"/&gt;&lt;/struts&gt;【notice】: 这里有一个配置文件我们过多的提及，是struts-default.xml，该文件包含了Struts 的所有标准配置设置，在我们的开发项目中，我们可能并不会触碰到它。感兴趣的话，可以查看struts2-core-x.x.x.jar包中的default.properties文件。struts-config.xml 配置文件struts-config.xml配置文件是Web客户端中View和Model组件之间的链接，但在我们99%的开发项目中，我们并不会接触到它。配置文件主要包含以下这些主要的元素:InterceptorDescriptionstruts-config配置文件的根节点form-bean可以将ActionForm的子类映射到一个名称(name),并在整个strustconfig.xml文件的其余部分中，甚至在JSP页面上，都可使用这个name作为ActionForm的别名global forwards可以将一个页面映射到一个名称(name),并使用该名称来引用实际页面。这可以避免使用网页上的硬编码(hardcoding)网址action-mapping用来声明表单处理程序，也被成为action映射controller配置Struts的内部结构，很少在实际情况中使用plug-in告诉Struts如何查看你的属性文件(properties files)，其中包含提示和错误信息struts-config.xml配置文件简单实例：1234567891011121314151617181920212223242526272829303132&lt;?xml version = "1.0" Encoding = "ISO-8859-1" ?&gt;&lt;!DOCTYPE struts-config PUBLIC "-//Apache Software Foundation//DTD Struts Configuration 1.0//EN" "http://jakarta.apache.org/struts/dtds/struts-config_1_0.dtd"&gt;&lt;struts-config&gt; &lt;!-- ========== Form Bean Definitions ============ --&gt; &lt;form-beans&gt; &lt;form-bean name = "login" type = "test.struts.LoginForm" /&gt; &lt;/form-beans&gt; &lt;!-- ========== Global Forward Definitions ========= --&gt; &lt;global-forwards&gt; &lt;/global-forwards&gt; &lt;!-- ========== Action Mapping Definitions ======== --&gt; &lt;action-mappings&gt; &lt;action path = "/login" type = "test.struts.LoginAction" &gt; &lt;forward name = "valid" path = "/jsp/MainMenu.jsp" /&gt; &lt;forward name = "invalid" path = "/jsp/LoginView.jsp" /&gt; &lt;/action&gt; &lt;/action-mappings&gt; &lt;!-- ========== Controller Definitions ======== --&gt; &lt;controller contentType = "text/html;charset = UTF-8" debug = "3" maxFileSize = "1.618M" locale = "true" nocache = "true"/&gt;&lt;/struts-config&gt;struts.properties 配置文件该配置文件提供了一种可以改变框架默认行为的机制。实际上，所有包含在struts.properties配置文集中的属性都可以在web.xml中使用init-param标签来配置。也可以在struts.xml配置文件中使用constant标签来进行配置。但是，如果你想将不同的配置信息分开，那么你可以使用struts.properties，它可以放置在WEB-INF/classes**目录下。在该文件中配置的属性值将会覆盖struts2-core.x.y.z.jar包中default.properties文件中配置的默认属性值。下面是我们开发中可能会使用到的属性值：1234567891011### When set to true, Struts will act much more friendly for developersstruts.devMode = true### Enables reloading of internationalization filesstruts.i18n.reload = true### Enables reloading of XML configuration filesstruts.configuration.xml.reload = true### Sets the port that the server is run onstruts.url.http.port = 8080]]></content>
      <categories>
        <category>Java框架学习</category>
        <category>Struts 2</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>Struts 2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Struts 2基础学习 - 架构]]></title>
    <url>%2Fposts%2F4fe73428%2F</url>
    <content type="text"><![CDATA[从高层面来看， Struts 2 是一个纯粹的 MVC (或MVC2)框架，Struts 2使用以下的五个核心部分来实现 Model-View-Controller(MVC) 模式：ActionsInterceptorsValue Stack / OGNLResults / Result typesView technologies概述相比于传统的 MVC 框架， Struts 2 略有不同， 这是因为Struts 2中的 action更多的是扮演model的角色， 而不是 controller,虽然这其中有一些重叠的地方。上面的图描述了Struts 2架构中的Model, View和Controller。controller由Struts 2的dispatch servlet filter(Servlet分发过滤器) 和 interceptors(拦截器)，actions实现Model, 视图view由result types 和 results 实现。值栈(Value Stack)和 OGNL 提供通用线程，链接和启用其他组件之间的集成。除了上述的组件外， 还有大量的关于配置的消息(information)， 对Web 应用程序的配置， 对actions的配置，以及interceptors,results等等的配置。Request 生命周期基于上面的图，我们可以了解到在Struts 2工作流中的用户请求的生命周期是这样的：用户向服务器发送一个资源(例如: 页面)请求；Struts 2 的 Dispatcher Filter 拦截请求，并选择合适Action；执行已配置的interceptors(拦截器)的功能， 例如： 表单验证，文件上传等；基于请求操作，调用并执行已选择的action；同样，如果需要，配置的拦截器可用于进行任意的后期处理；最后，将由view准备的结果(result)返回给用户。]]></content>
      <categories>
        <category>Java框架学习</category>
        <category>Struts 2</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>struts 2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基本查找算法 - basical searching algorithms]]></title>
    <url>%2Fposts%2Fd83777d2%2F</url>
    <content type="text"><![CDATA[引入基本查找算法，我们只谈静态查找的查找算法。线性查找 - linear search特点：从头开始遍历数组，一个一个和key比较，查找成功则返回索引值。不要求数组是有序的。时间复杂度为： $O(n)$.线性查找原始抽象方法实现如下:1234567public static int linearSearch(Comparable[] a, Comparable key) &#123; for (int i = 0; i &lt; a.length; i++) &#123; if (a[i].compareTo(key) == 0) return i; &#125; return -1;&#125;跳跃查找 - jump search特点：要求查找数组有序；主要思想是每次跳跃固定量的元素来确定目标元素所在的区间，再使用线性查找在区间上搜索目标元素。时间复杂度为： $O(\sqrt{n})$.[notice] : 假设我们要在一个有n个元素的数组中搜索某个元素，最坏情况下（当目标元素为最后个元素时），这个算法要跳跃n/m步，在线性搜索时作m-1次比较。令 $f(n) = ((n/m) + m-1$.当m = $\sqrt{n}$时，f(n) 取最小值，所以通常情况下，**跳跃查找所使用的固定跳跃步数为 $\sqrt{n}$.跳跃查找的原始抽象方法实现如下：1234567891011121314151617181920212223public static int jumpSearch(Comparable[] a, Comparable key) &#123; int n = a.length; int block_size = Math.floor(Math.sqrt(n)); int step = block_size; // 查找目标元素可能出现的区间 int prev = 0; while (a[Math.min(step, n) - 1].compareTo(key) &lt; 0) &#123; prev = step; step += block_size; if (prev &gt;= n) return -1; &#125; // 使用线性查找在确定的区间上查找目标元素 while (a[prev].compareTo(key) &lt; 0) &#123; prev++; if (prev == Math.min(step, n)) return -1; &#125; if (a[prev].compareTo(key) == 0) return prev; return -1;&#125;二分查找 - binary search要求数组有序。将已经排好序的数组分为两个区间(interval), 把区间的中间元素与key比较, 若大于则搜索左区间，若小于则搜索右区间，等于则返回元素的索引。当区间长度为0时（key没出现在数组中),返回-1。时间复杂度为 ： $O(nlogn)$.二分查找原始抽象方法实现如下:12345678910111213141516171819202122232425262728// 非递归实现public static int binarySearch(Comparable[] a, Comparable key) &#123; int lo = 0; int hi = a.length - 1; while (lo &lt;= hi) &#123; int mid = lo + (hi - lo) / 2; if (a[mid].compareTo(key) == 0) return mid; else if (a[mid].compareTo(key) &gt; 0) hi = mid - 1; else lo = mid + 1; &#125; return -1;&#125;// 递归实现public static int binarySearchRecursion(Comparable[] a, Comparable key, int lo, int hi) &#123; if (lo &lt;= hi) &#123; int mid = lo + (hi - lo) / 2; if (a[mid].compareTo(key) == 0) return mid; else if (a[mid].compareTo(key) &lt; 0) return binarySearchRecursion(a, key, mid+1, hi); else return binarySearchRecursion(a, key, lo, mid-1); &#125; return -1;&#125;三分查找 - ternary search特点：三分查找是二分查找的扩展；时间复杂度为 ： $O(nlog_3n)$.[notice]: 虽然看似三分查找的时间复杂度比二分查找的时间复杂度小，但是在最坏情况下，二分查找需要$2Log_2n + 1$次比较，而三分查找需要$4Log_{3}n + 1$次比较三分查找原始抽象方法实现如下：特点：类似二分查找，将查找数组划分为三个部分来进行查找；时间复杂度： $Log_3n$.12345678910111213141516171819202122// 递归实现.public static int ternarySearch(Comparable[] a, Comparable key, int lo, int hi) &#123; if (lo &lt;= hi) &#123; int mid1 = lo + (hi - lo) / 3; int mid2 = mid1 + (hi - lo) / 3; if (a[mid1].compareTo(key) == 0) return mid1; if (a[mid2].compareTo(key) == 0) return mid2; // 目标元素只可能出现在第一部分. if (a[mid1].compareTo(key) &gt; 0) return ternarySearch(a, key, lo, mid1-1); // 目标元素只可能出现在第三部分. if (a[mid2].compareTo(key) &lt; 0) return ternarySearch(a, key, mid2+1, hi); // 目标元素只可能出现在第二部分. return ternarySearch(a, key, mid1+1, mid2-1); &#125; // 查找失败. return -1;&#125;指数搜索 - exponential search特点：找到目标元素可能出现的区间；使用二分查找在区间上查找目标元素;时间复杂度： $logn$;[notice]:适用于目标数组元素大小趋向于无限大的情况；当目标出现在目标数组左边时，指数搜索速度比二分查找快。12345678public static int exponentialSearch(Comparable[] a, Comparable key) &#123; int n = a.length; int i = 1; while (i &lt; n &amp;&amp; a[i].compareTo(key) &lt; 0) &#123; i = i * 2; &#125; return binarySearch(a, key, i/2, Math.min(i, n-1));&#125;插值搜索 - interpolation search特点：原理： 假设查找数组的元素是均匀分布的，使用直线插值搜索，不像二分查找那样每次都是搜索区间中间元素。它能够快速的接近目标元素。当元素均匀分布的情况，时间复杂度为: $O(log(log n))$, 最坏情况: $O(n)$.12345678910111213141516// java program to implement interpolatoin search.public static int interpolationSearch(Comparable[] a, Comparable key) &#123; int lo = 0; int hi = a.length - 1; while (lo &lt;= hi &amp;&amp; less(key, a[hi]) &amp;&amp; less(a[lo], key)) &#123; int pos = lo + (hi - lo) * (key - a[lo]) / (a[hi] - a[lo]); if (a[pos].compareTo(key) == 0) return pos; else if (a[pos].compareTo(key) &gt; 0) hi = pos - 1; else lo = pos + 1; &#125; return -1;&#125;NOTICE本文中，涉及的算法详细实现和使用，请移步到github查看。]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>searching algs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速排序 - quickSort]]></title>
    <url>%2Fposts%2Fd9de8e4c%2F</url>
    <content type="text"><![CDATA[引入快速排序的主要特点是：原地排序 (in-place);将长度为 N 的数组排序所需的时间和NlgN成正比；排序内循环比大多数排序算法都要短小，意味着无论是在理论上还是实际中都要更快。缺点：快速排序非常的脆弱，在实现时要非常小心才能避免低劣的性能。基本算法快速排序是一种分治排序算法，它将一个数组分成两个子数组，将两部分独立地排序。不同于归并排序，快速排序的递归调用发生在处理子数之前。快速排序方法抽象实现如下：12345678910111213141516171819202122232425262728293031public class Quick &#123; // quick sort java implement. public static void quickSort(Comparable[] a) &#123; sort(a, 0, a.length-1); assert isSorted(a); &#125; private static void sort(Comparable[] a, int lo, int hi) &#123; if (hi &lt;= lo) return; int j = partition(a, lo, hi); sort(a, lo, j-1); sort(a, j+1, hi); &#125; private static void partition(Comparable[] a, int lo, int hi) &#123; int i = lo; int j = hi + 1; Comparable v = a[lo]; while (true) &#123; while (less(a[++i], v)) &#123; if (lo == hi) break; &#125; while (less(v, a[--j])) &#123; if (j == lo) break; // redundant since a[lo] is sentinel. &#125; // Check if pointers cross. if (j &lt;= i) break; exch(a, i, j); &#125; exch(a, lo, j); return j; &#125;&#125;上述切分方法示意图: [from algs4]切分轨迹图: [from algs4]12命题 K： 将长度为N的无重复的数组排序，快速排序平均需要 ~2NlnN 次比较(以及1/6的交换)[notice]: 尽管快速排序有很多优点，它的基本实现仍有一个潜在的缺点：在切分不平衡时该算法可能及其低效。例如： 如果第一个次从最小的元素切分，第二次从第二小的元素切分，则这样每次只会移除一个元素。[solution] : 在快速排序之前将数组随机排序可以避免这种情况的发生。算法改进1.切换到插入排序和大多数递归排序算法一样(如归并)，改进快速排序的简单方法基于以下两点：对于小数组，快速排序比插入排序慢；以为递归，快速排序的sort()方法在小数组中也会调用自己。改进 ： 将sort()方法中的1if (hi &lt;= lo) return;改为：1234if (hi &lt;= lo + M) &#123; insertion.sort(a, lo, hi); return;&#125;[notice] : 这里的切换参数 M 的最佳值是和系统相关的，但是5 ~ 15 之间的任意值在大多数情况下都能令人满意。2. 三取样切分改进快速排序性能的第二个方法是使用子数组的一小部分的中位数来切分数组。这样的切分的效果更好，但代价是需要计算中位数。人们发现将取样设为 3 并用大小居中的元素切分效果最好； 我们还可以将取样元素放在数组末尾作为哨兵(sentinel)。三取样切分抽象实现 : 详细查看1234567891011121314151617181920212223242526272829303132333435363738public static void quickSortImproved(Comparable[] a) &#123; sort(a, 0, a.length-1); assert isSorted(a);&#125;private staic void sort(Comparable[] a, int lo, int hi) &#123; dealPivot(a, lo, hi); int i = lo; int j = hi - 1; Comparable v = a[hi - 1]; // set the pivot at hi -1 as a sentinel. while (true) &#123; while (less(a[++i], v)) &#123; if (i == hi-1) break; // redundant since a[hi - 1] is sentinel. &#125; while (j &gt; lo &amp;&amp; less(v, a[--j])) &#123; &#125; // check if pointers cross. if (j &lt;= i) break; exch(a, i, j); &#125; if (i &lt; hi-1) &#123; exch(a, i, hi - 1); &#125; sort(a, lo, i - 1); sort(a, i + 1, hi);&#125;// 三取样并将切分元素放在数组末尾private static void dealPivot(Comparable[] a, int lo, int hi) &#123; int mid = lo + (hi - lo) / 2; if (less(a[mid], a[lo])) exch(a, lo, mid); if (less(a[hi], a[lo])) exch(a, lo, hi); if (less(a[hi], a[mid])) exch(a, mid, hi); // put the pivot to hi - 1 as a sentinel. exch(a, mid, hi - 1);&#125;熵最优的排序实际应用中经常会出现含有大量重复元素的数组，我们实现的快速排序性能尚可，但是还有巨大的改进空间。例如：一个元素全部重复的子数组就不需要继续排序了，但我们的快速排序还是会继续将它切分为更小的数组。[solution] : 一个简单想法是将数组切分为三个部分，分别为小于、等于和大于切分元素的数组元素。DIjkstra 解法 ： 从左到右遍历数组一次，维护一个指针 lt 使得 a[lo .. lt-1]中的元素都小于v, 一个 gt 使得a[gt+1 .. hi]中的元素都大于v, 一个指针 i 使得a[lt .. i-1]中的元素都等于v, a[i .. gt]中的元素都未确定。a[i] 小于 v, 将a[lt]和a[i]交换，将lt 和 i加一；a[i] 大于 v, 将a[gt]和a[i]交换， 将gt减一；a[i] 等于 v, i++.熵最优排序抽象实现： 详细查看123456789101112131415161718192021public static void quickSort(Comparable[] a) &#123; sort(a, 0, a.length-1); assert isSorted(a);&#125;private static void sort(Comparable[] a, int lo, int hi) &#123; if (hi &lt;= lo) return; Comparable v = a[lo]; int lt = lo; int i = lo + 1; int gt = hi; while (i &lt;= gt) &#123; if (less(a[i], v)) exch(a, i++, lt++); else if (less(v, a[i])) exch(a, gt--, i); else i++; &#125; // since a[lt .. i-1] is sorted. // sort the other subarrays recursively. sort(a, lo, lt-1); sort(a, gt+1, hi);&#125;[notice] : 三向切分的最坏情况是所有主键均不相同。对于标准的快速排序，随着数组规模的增大其运行时间会趋于平均时间，大幅偏离的情况是非常罕见的，因此可以肯定三向切分的快速排序运行时间和输入的信息量的N倍是成正比的。 ———— 因为对于包含大量重复元素的数组，它将排序时间从线性对数级降到了线性级别。NOTICE本文中，涉及的算法详细实现和使用，请移步到github查看。]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>sorting algs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基本排序算法 - basial sorting algorithms with java implementation]]></title>
    <url>%2Fposts%2F57d02cec%2F</url>
    <content type="text"><![CDATA[我们关注的主要对象是重新排列数组元素的算法， 其中每个元素都有一个主键。排序算法的目的就是将所有元素的主键按照某种方式排列(通常按照大小或是字母顺序)。在java中元素通常都是对象，对主键的抽象描述则是通过一种内置的机制(Comparable接口)来完成的。排序算法类模板1234567891011121314151617181920212223242526272829303132333435public class Example &#123; public static void exch(Comparable[] a, int i, int j) &#123; Comparable temp = a[i]; a[i] = a[j]; a[j] = temp; &#125; public static void sort(Comparable[] a) &#123; /*排序算法，如InsertionSort、BubbleSort、 SelectionSort、ShellSort等*/ &#125; private static void show(Comparable[] a) &#123; for (int i = 0; i &lt; a.length; i++) &#123; System.out.print(a[i] + " "); &#125; System.out.println(); &#125; public static boolean less(Comparable v, Comparable w) &#123; return v.compareTo(w) &lt; 0; &#125; public static boolean isSorted(Comparable[] a) &#123; for (int i = 1; i &lt; a.length; i++) &#123; if (less(a[i], a[i-1]) &#123; return false; &#125; &#125; return true; &#125; /** * Unit tests the &#123;@code Example&#125; sorting algorithm. * @args command-line arguments. */ public static void main(String[] args) &#123; // 测试代码... &#125;&#125;这个类展示的是数组排序实现的框架。代码中实现的排序方法适用于任意实现了Comparable接口的数据类型。验证无论数组的初始状态是什么，我们都无法确保排序算法都能成功。所以谨慎起见，我们会在测试代码中添加一条语句1assert isSorted(a);来确保排序后的数组都是有序的。运行时间评估算法的性能。首先，要计算各个排序算法在不同的随机输入下的基本操作的次数(包括比较和交换，或者是读写数组的次数)。12排序成本模型 : 在研究排序算法时，我们需要计算比较和交换的数量。对于不交换元素的算法，我们会计算访问数组的次数。额外的内存使用排序算法的额外内存开销和运行时间是同等重要的。排序算法可以分为两类:除了函数调用所需的栈和固定数目的实例变量之外无需额外内存的原地排序算法。需要额外内存空间来存储另一份数组副本的其他排序算法。数据类型上面的排序模板适用于实现了Comparable接口的数据类型。例如, java中封装数字类型的Integer、Double、以及String和其他许多高级数据类型。而对于自己创建的数据类型，我们是要实现Comparable接口就能够保证能够使用排序算法进行排序。自定义数据类型样例:123456789101112131415161718192021222324public class Date implements Comparable&lt;Date&gt; &#123; private final int day; private final int month; private final int year; public Date(int d, int m, int y) &#123; day = d; month = m; year = y; &#125; public int day() &#123; return day; &#125; public int month() &#123; return month; &#125; public int year() &#123; return year; &#125; public int compareTo(Date that) &#123; if (this.year &gt; that.year) return +1; if (this.year &lt; that.year) return -1; if (this.month &gt; that.month) return +1; if (this.month &lt; that.month) return -1; if (this.day &gt; that.day) return +1 if (this.day &lt; that.day) return -1; return 0; &#125; public String toString() &#123; return month + "/" + day + "/" + year; &#125;&#125;选择排序首先，找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置(如果第一个元素就是最小的元素那么它就和自己交换)。 再次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到整个数组排序完成。不断地选择剩余元素中的最小者。12345678命题 A: 对于长度为 N 的数组，选择排序需要大约 N^2/2 次比较和 N 次交换。证明： 可以通过算法的排序轨迹来证明，用一张N X N的表格来表示排序的轨迹，其中每个非灰色字符都表示一次比较。表格中大约有一半的元素不是灰色的 —— 即对角线和其上部分的元素。对角巷上的每个元素都对应真一次交换。通过查看代码我们可以更精确地得到，0 到 N-1 的任意 i 都会进行一次交换和 N-1-i 次比较，因此总共有 N 次交换以及 $(N-1)+（N-2)+...+2+1 = N(N-1)/2 ~ N^2/2$。算法轨迹图示（from algs4)：算法实现:123456789101112131415public class Selection &#123; /* 其他的方法同排序算法模板*/ public static void sort(Comparable[] a) &#123; int n = a.length; for (int i = 0; i &lt; n; i++) &#123; int min = i; for (int j = i+1; j &lt; n; j++) &#123; if (less(a[j], a[min]) &#123; min = j; &#125; &#125; exch(a, i, min); &#125; &#125;&#125;插入排序与选择排序一样，当前索引左边的所有元素都是有序的，但他们的最终位置不确定，为了给更小的元素腾出空间，它们可能会移动。当索引到达数组的右端时，数组排序就完成了。和选择排序不同的是，插入排序所需的时间取决于输入中元素的初始顺序。例如对于一个很大且其中的元素已经有序（或接近有序）的数组进行插入排序将会比对随机数组或逆序数组进行排序要快得多。12345678910111213命题 B : 对于随机排列的长度为 N 且主键不重复的数组， 平均情况下插入排序需要 ~ $N^2/4$次比较以及 $~N^2/4$次交换。最坏情况下需要 ~N^2/2 次比较和 ~ $N^2/2$次交换，最好情况下需要$N-1$次比较和0次交换。证明： 和证明命题A一样，通过一个$N X N$的算法轨迹表可以很容易就得到交换和比较的次数。最坏的情况下对角线之下所有元素都需要移动位置，最好情况下都不需要。对于随机排列的数组，在平均情况下每个元素都可能向后移动半个数组的长度，因此交换总数是对角线之下的元素总数的二分之一。比较的总次数是交换的次数加上一个额外的项，该项为 N 减去被插入的元素正好是已知的最小元素的次数。在最坏情况下（逆序数组），这一项相对于总数可以忽略不计；在最好的情况下（数组已经有序），这一项等于N-1。插入排序算法轨迹图示（from algs4):算法实现:1234567891011public class Insertion &#123; /*其他的方法同排序算法模板*/ public static void sort(Comparable[] a) &#123; int n = a.length; for (int i = 1; i &lt; n; i++) &#123; for (int j = i; j&gt;0&amp;&amp;less(a[j], a[j-1]; j--) &#123; exch(a, j, j-1); &#125; &#125; &#125;&#125;附加：对于插入排序，我们要考虑的更一般情况是部分有序的数组。倒置指的是数组中的两个顺序颠倒的元素。比如EXAMPLE中有11对倒置：12E-A X-A X-M X-P X-L X-EM-L M-E P-L P-E L-E如果数组中倒置的数量小于数组大小的某个倍数，那么我们说这个数组是部分有序的。几种典型的部分有序的数组:数组中每个元素距离它的最终位置不远；一个有序数组接一个小数组；数组中只有几个元素位置不正确。插入排序对这样的数组很有效，而选择排序则不然。当倒置的数量很少时，插入排序比大部分的其他排序算法都要快。123456命题 C: 插入排序需要的交换的操作和数组的中倒置的数量相同，需要的比较次数大于等于倒置的数量，小于等于倒置的数量加上数组的大小再减一。证明： 每次交换都改变了两个顺序颠倒的元素的位置，相当于减少了一对倒置，当倒置数量为0时，排序就完成了。每次交换都对应着一次比较，且1到N-1之间的每个i都可能需要一次额外的比较(在a[i]没有达到数组的左端时)。[算法改进] : 大幅提高插入排序的速度，在内循环中将较大的元素都向右移动而不是总是交换两个元素(这样访问数组的次数就能减半)。1234567891011public static void sort(Comparable[] a) &#123; int n = a.length; for (int i = 1; i &lt; n; i++) &#123; Comparable key = a[i]; int j; for (j = i-1; j &gt;= 0&amp;&amp;less(key, a[j]); j--) &#123; a[j+1] = a[j]; &#125; a[j+1] = key; &#125;&#125;希尔排序希尔排序是基于插入排序的快速排序算法.对于规模乱序数组插入排序很慢，因为它只会交换相邻的元素，因此元素只能一点一点地从数组的一端移动到另外一端。希尔排序为了加快速度简单地改进了插入排序 —— 交换不相邻的元素以对数组的局部进行排序，并最终使用插入排序将局部有序的数组排序。希尔排序的思想:使任意间隔为h的元素都是有序的。这样的数组称为h有序数组。对于任意以1为结尾的h序列（递增序列），我们使用它都能将数组排序。算法实现： —— 使用的递增序列来自 algs4.12345678910111213141516public class Shell &#123; /*其他排序算法方法同模板*/ public static void sort(Comparable[] a) &#123; int n = a.length; int h = 1; while (h &lt; n/3) h = 3 * h + 1; // 1， 4， 13， 40， 121， ... while (h &gt;= 1) &#123; for (int i = h; i &lt; n; i++) &#123; for (int j = i; j &gt;= h&amp;&amp;less(a[j], a[j-h]); j -= h) &#123; exch(a, j, j-h); &#125; &#125; h /= 3; &#125; &#125; &#125;[递增序列的选择] : 算法的性能不仅取决于h，还取决与h之间的数学性质。目前还没有人能证明某个递增序列是”最好的”。以上算法实现使用的递增序列（使用序列 $1/2(3^k-1)$,从N/3开始递减至1.）的计算和使用都很简单且和复杂的递增序列的性能接近。算法轨迹图例 — example (from algs4):实际应用: 对于中等大小的数组它的运行时间是可以接受的且它的代码量小，不需要额外的内存空间。所以在面临一个排序问题而没有系统排序函数可用时，可先用希尔排序，然后再考虑是否将它替换为更加复杂的排序算法。[算法改进] : 由于希尔排序是基于插入排序，所以我们可以参照插入排序的改进，对希尔排序进行改进 — 把内循环中较大的元素右移而不是交换两个元素。123456789101112131415public static void sort(Comparable[] a) &#123; int n = a.length; int h = 1; while (h &lt; n/3) h = 3 * h + 1; while (h &gt;= 1) &#123; for (int i = h; i &lt; n; i++) &#123; Comparable key = a[i]; int j; for (j = i-h; j &gt;= 0&amp;&amp;less(key, a[j]); j -= h) &#123; a[j+h] = a[j]; &#125; a[j+h] = key; &#125; &#125;&#125;附加 —— 冒泡排序冒泡排序相对比较简单，这里直接给出它的实现:12345678910111213141516public class Bubble &#123; /*其他排序算法方法同排序算法模板*/ public static void sort(Comparable[] a) &#123; int n = a.length; boolean flag = true; for (int i = 1; i &lt; n&amp;&amp;flag == true; i++) &#123; flag = false; for (int j = 0; j &lt; n-i; j++) &#123; if (less(a[j+1], a[j]) &#123; exch(a, j+1, j); flag = true; &#125; &#125; &#125; &#125; &#125;算法分析: 对于冒泡排序，最坏情况下，算法需要进行N-1趟排序，总的数组元素比较的次数为$(N-1)+(N-2)+…+1$ ~ $N^2/2$， 总的交换次数为数组中倒置的数量。NOTICE本文中，涉及的算法详细实现和使用，请移步到github查看。]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>sorting algs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[归并排序 - mergeSort]]></title>
    <url>%2Fposts%2F1368334%2F</url>
    <content type="text"><![CDATA[引入归并排序属于分治算法(Divide and Conquer)。通过递归不断把待排序数组分成两个部分，将有序的两部分再重新归并一起来实现对数组的排序。[pseudo code for 2-way merge sort]:12345678910MergeSort(arr[], aux[], lo, hi)If hi &gt; lo 1. Find the middle point to divide the array into two halves; int mid = lo + (hi - lo) / 2; 2. Call MergeSort for first half; MergeSort(arr, aux, lo, mid); 3. Call MergeSort for second half; MergeSort(arr, aux, mid+1, hi); 4. Merge the two halves sorted in step 2 and 3; Call merge(arr, aux, lo, mid, hi);原地归并的抽象方法要实现上述的归并方法 — merge()很简单，创建一个数组将需要归并的原数组的两个部分中的元素放到这个数组中，然后再归并按大小顺序放回原数组。但是，这里我们要考虑一个问题，当我们用归并排序对一个比较大的数组进行排序时，我们需要进行很多次归并，因此在每一次归并时都创建一个新的数组来存储排序结果会带来问题。我们可以考虑只创建一个辅助数组aux[], 在每一个归并时，将原数组需要归并的两个部分复制到aux[]中，再把归并结果放回原数组。123456789101112131415161718192021public static void merge(Comparable[] a, Comparable[] aux, int lo, int mid, int hi) &#123; // precondition: a[lo .. mid] and a[mid+1 .. hi] is sorted. assert isSorted(a, lo, mid); assert isSorted(a, mid+1, hi); // copy a[lo .. hi] to aux[lo .. hi]. for (int k = lo; k &lt;= hi; k++) &#123; aux[k] = a[k]; &#125; int i = lo; int j = mid+1; for (int k = lo; k &lt;= hi; k++) &#123; if (i &gt; mid) a[k] = aux[j++]; else if (j &gt; hi) a[k] = aux[i++]; else if (less(aux[j], aux[i])) a[k] = aux[j++]; else a[k] = aux[i++]; &#125; // postcondition: a[lo .. hi] is sorted. assert isSorted(a, lo, hi);&#125;[说明] : 该方法先将原数组两个需要归并的部分复制到aux[]中，然后从两个部分的起始位置开始取元素，一直选择两个部分中较小的元素放回原数组中，当有一部分元素取完了，则将另一部分剩余的元素全部放回原数组。原地归并抽象方法轨迹： [from algs4]自顶向下的归并排序1234567891011121314151617public static void mergeSort(Comparable[] a) &#123; int n = a.length; Comparable[] aux = new Comparable[n]; sort(a, aux, 0, a.length-1);&#125;private static void sort(Comparable[] a, Comparable[] aux, int lo, int hi) &#123; // If array size is 1 then return. if (hi &lt;= lo) return; // Find the middle point to divide array into two halves. int mid = lo + (hi - lo) / 2; // Call the mergeSort for first half. sort(a, aux, lo, mid); // Call the mergeSort for second half. sort(a, aux, mid+1, hi); // Merge two halves sorted. merge(a, aux, lo, mid, hi);&#125;自顶向下归并结果轨迹 : [from algs4]自顶向下归并排序调用轨迹 : [from algs4]1234命题 F: 对于长度为 N 的任意数组， 自顶向下归并排序需要 1/2NlgN 至 NlgN 次比较。自顶向下的所需时间表达式为 : $T(N) = 2T(N/2) + O(n)$使用解决递归式的 Master method 解得 T(N) = $\Theta(n log n)$我们可以通过下图来理解命题F, 每个节点都表示一个sort()方法通过merge()方法归并而成的子数组。这棵树正好有 n 层。对于0 ~ n-1 之间的任意 k, 自顶向下的第 k 层有 $2^k$个子数组，每个数组长度为 $2^{n-k}$, 归并最多需要 $2^{n-k}$ 次比较。因此每层的比较次数为$2^k X 2^{n-k} = 2^n$, n 层总共为 $n2^n = NlgN$。子数组树状图 : [from algs4]123456命题 G : 对于长度为 N 的任意数组，自顶向下的归并排序最多需要访问数组 6NlgN 次。证明： 每次归并最多需要访问数组 6N 次（2N 次用来复制， 2N次用来将排好序的元素移动回去，另外最多比较2N次），根据命题F即可得到这个命题的结果。[小结]: 归并排序排序算法的缺点是辅助数组所使用的额外空间和N的大小成正比。一些能够大幅度缩短归并排序的运行时间的想法：对小规模子数组进行插入排序；测试数组是否已经有序；不将元素复制到辅助数组中。自底向上的归并排序实现归并排序另外一种方法是先归并那些微型数组， 然后再成对归并得到的子数组，直到将整个数组归并在一起。12345678910public static void MergeBU(Comparable[] a) &#123; int n = a.length; Comparable[] aux = new Comparable[n]; for (int sz = 1; sz &lt; n; sz += sz) &#123; for (int lo = sz; lo &lt; n-sz; lo += sz+sz) &#123; merge(a, aux, lo, lo+sz-1, Math.min(lo+sz+sz-1, n-1)); &#125; &#125;&#123;[注] : 自底向上的归并排序会多次遍历整个数组，根据子数组大小进行两两归并。子数组的大小 sz 的初始值为 1， 每次加倍。最后一个子数组的大小只有在数组大小是 sz 的偶数倍的时候才会等于 sz(否则它会比sz小)。自底向上归并排序结果轨迹 ： [from algs4]123456命题 H : 对于长度为 N 的任意数组， 自底向上的归并排序需要 1/2NlgN 至 NlgN次比较，最多访问数组 6NlgN 次。证明 ： 处理一个数组的遍数正好是 [lgN] (即 2^n &lt;= N &lt;2^n+1 中的 n)。每一遍会访问数组6N次。比较次数在 N/2 和 N 之间。【补充】： 当数组长度为 2 的幂时，自顶向下和自底向上的归并排序所用的比较次数和数组访问次数正好相同，只是顺序不同。其他时候，两种方法的比较和数组访问的次序会有所不同。NOTICE本文中，涉及的算法详细实现和使用，请移步到github查看。]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>sorting algs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jsp基础学习笔记 - 概览]]></title>
    <url>%2Fposts%2F67d7cfb7%2F</url>
    <content type="text"><![CDATA[Java 服务器页面(jsp) 是用来开发动态页面的一项技术。JSP 允许开发人员使用指定的 JSP 标签来向html页面中插入java源代码，标签通常是以 &lt;% 开头并以 %&gt; 结束。为什么使用 JSP？使用Java服务器页面(jsp)与使用实现 Common Gateway Interface(CGI)的程序目的是大致相同的。但对比CGI，jsp有以下优点：性能较好。因为JSP允许直接在html页面中嵌入动态元素，而不需要独立持有CGI文件；JSP在服务器处理前都会进行预编译，不像 CGI/Perl, 每次页面被请求时，服务器都需要加在一个解释器(interperter) 以及目标脚本(target script);JSP是基于 Java Servlets API 构建的，因此，和Servlets一样，JSP也可以使用这些强大的Enterprise Java API, ：JDBC, JNDI, EJB, JAXP, 等等；JSP 页面可以和处理业务逻辑的servlets结合使用，该模型由[java servlet 模板引擎提供支持。最后，JSP是JavaEE(企业级应用程序的完整平台)的一个组成部分。这意味着JSP可以在最简单的应用程序中扮演最复杂和最苛刻的角色。使用JSP的优势下面通过对比不同的技术来体现使用JSP的优点：vs. Active Server Pages (ASP)对比ASP, JSP有两大优点：第一是页面的动态部分是用java写的，而不是Visual Basic或其他MS特定的语言编写，所以它更强有力且易于使用；第二是它可以移植到其他的操作系统和非Microsoft的Web 服务器上，这使它更加健壮。vs. Pure Servets（纯Servlets)使用JSP可以更容易编写和修改常规的html代码，而不是使用大量的 println语句来生成HTML。vs. Server-Side Includes (SSI)SSI 实际上只适用于处理简单内容的程序，而不适用于使用表单数据，进行数据库连接等的程序。vs. JavascriptJavaScript 可以在客户端生成HTML，但很难和Web 服务器实现复杂任务的交互，例如：数据库访问以及图像处理等。vs. 静态HTML常规的HTML不能包含动态的内容，无法动态地改变页面展示的数据。]]></content>
      <categories>
        <category>jsp基础学习</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>jsp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式基本使用]]></title>
    <url>%2Fposts%2Ff85f3c07%2F</url>
    <content type="text"><![CDATA[regular expression regex RE简介正则表达式是用来简洁表达一组字符串的表达式。正则表达式——一行胜千言通用的字符串表达框架简洁表达一组字符串的表达式针对字符串表达“简洁”和“特征”思想的工具判断某一字符串的特征归属正则表达式在文本处理中十分常用表达文本类型的特征(病毒、入侵等)同时查找或替换一组字符串匹配字符串的全部或部分正则表达式主要应用在字符串的匹配中正则表达式的使用编译：将符合正则表达式语法的字符串转换成正则表达式特征。—— re.compile(regex)正则表达式的语法正则表达式常用的操作符操作符说明实例.表示任何单个字符[ ]字符集，对单个字符给出取值范围[abc]表示a、b、c, [a-z]表示a到z单个字符[^ ]非字符集，对单个字符给出排除范围[^abc]表示非a或b或c的单个字符*前一个字符0次或无限次扩展abc*表示ab、abc、abcc、abcc等+前一个字符1次或无限次扩展abc+表示abc、abcc、abccc等?前一个字符0次或1次扩展abc?表示ab、abc&#124;左右表达式任意一个abc &#124; def表示abc、def操作符说明实例{m}扩展前一个字符m次ab{2}c表示abbc{m,n}扩展前一个字符m至n次ab{1,2}c表示abc、abbc^匹配字符串开头^abc表示abc且在一个字符串的开头$匹配字符串结尾abc$表示abc且在一个字符串的结尾( )分组标记，内部只能使用 &#124; 操作符(abc)表示abc ，(abc&#124;def)表示abc、def\d数字，等价于[0-9]\w单词字符，等价于[A-Za-z0-9]经典正则表达式实例^[A-Za-z]+$由26个字母组成的字符串^[A-za-z0-9]+$由26个字母及数字组成的字符串^-?\d+$整数形式的字符串^[0-9]*[1-9][0-9]*$正整数形式的字符串[1-9]\d{5}中国境内的邮政编码，6 位[\u4e00-\u9fa5]匹配中文字符\d{3}-\d{8} &#124; \d{4}-\d{7}国内电话IP地址:不精确的写法：\d+.\d+.\d+.\d+ —— 以四个点进行分隔作为特点\d{1,3}.\d{1,3}.\d{1,3}.\d{1,3}精确写法：0-99 : [0-9]?\d 100-199 : 1\d{2}200-249 : 2[0-4]\d 250-255 : 25[0-5](([0-9]?\d|1\d{2}|2[0-4]\d|25[0-5]).){3}([0-9]?\d|1\d{2}|2[0-4]\d|25[0-5])Re库的基本使用Re库介绍Re库是Python的标准库，主要用于字符串匹配。1import re正则表达式的表示类型raw string 类型(原生字符串类型) —— 不包含转义字符re 库采用raw string 类型表示正则表达式，表示为：r’text’string类型， 更繁琐 —— 需要双重转义Re库的主要功能函数函数说明re.search()在一个字符串中搜索匹配正则表达式的第一个位置，返回match对象re.match()在一个字符串开始位置起匹配正则表达式，返回match对象re.findall()搜索字符串，以列表类型返回全部能匹配的子串re.spilt()将一个字符串按照正则表达式匹配结果进行分割，返回列表类型re.fiinditer()搜索字符串，返回一个匹配结果的迭代类型，每个迭代元素是matchre.sub()在一个字符串中替换所有匹配正则表达式的子串，返回替换后的字符串re.search(pattern, string,flags=0)在一个字符串中搜索匹配正则表达式的第一个位置，返回match对象pattern: 正则表达式的字符串或者原生字符串 表示string : 待匹配字符串flags : 正则表达式使用时的控制标记常用标记说明re.I re.IGNORECASE忽略正则表达式的大小写，[A-Z]能够匹配小写字符re.M RE.MULTILINE正则表达式中的^操作符能够将给定字符串的每行当作匹配开始re.S RE.DOTALL正则表达式中的.操作符能够匹配所有字符，默认匹配除换行符外的所有字符re.match(partern, string, flags=0)从一个字符串的开始位置起匹配正则表达式，返回match对象re.findall(pattern, string , flags=0)搜索字符串，以列表类型返回全部能匹配的子串。pattern ： 正则表达式的字符串或原生字符串表示string ： 待匹配字符串flags: 正则表达式使用时的控制标记re.split(pattern, string, maxsplit=0, flags=0)将一个字符串按照正则表达式匹配结果进行分割，返回列表类型。maxsplit: 最大分割数re.finditer(patern, string, flags=0)搜索字符串，返回一个匹配结果的迭代类型，每一个迭代元素是match对象。re.sub(pattern, repl, string, count=0, flags=0)在一个字符串中替换所有匹配正则表达式的子串，返回替换后的字符串。repl: 替换匹配字符串的字符串count： 替换的最大次数Re库的另一种等价用法1234567rst = re.search(r'[1-9]\d&#123;5&#125;', 'BIT100081')#函数式用法： 一次性操作#面向对象用法：编译后的多次操作pat = re.compile(r'[1-9]\d&#123;5&#125;')rst = pat.search('BIT100081')regex = re.compile(pattern, flags=0)将正则表达式的字符串形式编译成正则表达式对象Re库的match对象Match对象的属性属性说明.string待匹配文本.re匹配时使用的pattern对象()正则表达式.pos正则表达式搜索文本的开始位置.endpos正则表达式搜索文本的结束位置Match对象的方法方法说明.group(0)获得匹配后的字符串.start()匹配字符串在原始字符串的开始位置.end()匹配字符串在原始字符串的结束位置.span()返回(.start(),.end()) — 元组类型Re库的贪婪匹配和最小匹配Re库默认采用贪婪匹配最小匹配操作符操作符说明*?前一个字符0次或无限次扩展，最小匹配+?前一个字符1次或无限次扩展，最小匹配??前一个字符0次或1次扩展，最小匹配{m,n}?扩展前一个字符m至n次(含n)，最小匹配高效的正则表达式技巧总结误匹配指正则表达式所匹配的内容范围超过了所需要范围，有些文本命名不符合要求，但是被所写的正则表达式“击中”了。例如：如果使用\d{11}去匹配11位手机号，\d{11}不单单能匹配正确的手机号，它还会匹配98824839344这样明显不是手机号的字符串。我们把这样的匹配称为误匹配。漏匹配指正则表达式所匹配的内容所规定的范围太狭窄，有些文本确实是所需要的，但是所写的正则表达式没有将这种情况囊括在内。例如：使用\d{18}来匹配身份证号码，就会漏掉结尾是字母X的情况。写出一条正则表达式，既可能出现误匹配(条件写得太宽松，范围大于目标文本)，也可能出现漏匹配(只描述了目标文本中多种情况的部分)，还可能既有误匹配又有漏匹配。例如：使用\w+.com来匹配.com结尾的域名，既会误匹配abc_.com(合法域名不包含_,\w包含了这种情况),又会漏掉ab-c.com这样的域名(合法域名可以包含中划线，\w不包含中划线).应对方法掌握语法细节正则表达式在各种语言中，其语法大致相同，细节各有千秋。明确所使用语言的正则的语法的细节，是写出正确、高效正则表达式的基础。例如，perl中与\w等效的匹配范围是[a-zA-Z0-9_];perl正则表达式不支持肯定逆序视中使用可变的重复(variable repetition inside lookbehind,例如( ?&lt;=.* )abc), 但是.Net语法是支持这一特性的；又如，JavaScript连逆序环视(lookbehind,如(?&lt;=ab)c)都不支持，而Perl和Python是支持的。&lt;&lt;精通正则表达式&gt;&gt;第三章&lt;&lt;正则表达式的特性和流派概览&gt;&gt;明确地列出了个大派系的正则表达式的异同。先粗后精，先减后加使用正则表达式语法对于目标文本进行描述和界定，可以像画素描一样，先大致勾勒出框架，在逐步在局部实现细节。仍举刚才的手机例子：先界定\d{11},总不会错；再细化为1[358]\d{9},就向前迈了一大步。先消除 漏匹配(刚开始先尽可能多的匹配，做加法)，然后再一点点去除误匹配(做减法)。]]></content>
      <categories>
        <category>Python爬虫</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>regex基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解Requests库的异常和HTTP协议]]></title>
    <url>%2Fposts%2F4ae864e2%2F</url>
    <content type="text"><![CDATA[简单理解Requests库中的异常和HTTP协议。异常说明requests.ConnectionError网络连接错误异常，如DNS查询失败、拒绝连接等requests.HTTPErrorHTTP错误异常requests.URLRequiredURl缺失异常requests.TooManyRedirects超过最大重定向次数，产生重定向异常requests.ConnectTimeout连接远程服务器超时异常requests.Timeout请求URL超时，产生超时异常Response的异常：异常说明r.raise_for_status()如果不是200， 产生异常requests.HTTPError爬取网页的通用代码框架123456789101112import requestsdef getHTMLText(url) : try: r = requests.get(url, timeout=30) r.raise_for_status() #如果状态不是200， 引发requests.HTTPError异常 r.encoding = r.apparent_encoding #将encoding 设置为'utf-8'，一般用于没有charset的header return r.text except: return '产生异常'if __name__ == '__main__': url = "http://www.baidu.com" print(getHTMLText(url))HTTP协议HTTP, Hypertext Transfer Protocol, 超文本传输协议HTTP是一个基于“请求与响应”模式的、无状态的应用层协议。HTTP协议采用URL作为定位网络资源的标识。URL格式：http://host\[:port][path]HTTP URL的理解：URL 是通过HTTP协议存取资源的Internet路径，一个URL对应一个数据资源。HTTP协议对资源的操作方法说明GET请求获取URL位置的资源HEAD请求获取URL位置资源的响应消息报告，即获取该资源的头部信息POST请求URL位置的资源后附加新的数据PUT请求向URL位置存储一个资源，覆盖原URL位置的资源PATCH请求局部更新URL位置的资源，即改变该处资源的部分内容DELETE请求删除URL位置存储的资源理解PATCH和PUT的区别：假设URL位置有一组数据UserInfo， 包括UserID、UserName等20个字段需求：用户修改了UserName，其他不变。采用PATCH，仅向URL提交UserName的剧本更新请求。采用PUT，必须将所有20个字段一并提交URL，未提交字段被删除。PATCH的好处：节省网络带宽]]></content>
      <categories>
        <category>python爬虫</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>Requests库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Requests库的7个主要方法]]></title>
    <url>%2Fposts%2Fc671c604%2F</url>
    <content type="text"><![CDATA[Requests库的7个主要方法方法说明requests.request()构造一个请求，支撑以下各方法的基础方法requests.get()获取HTML网页的主要方法，对应于HTTP的GETrequests.head()获取HTML网页头信息的方法，对应于HTTP的HEADrequests.post()向HTML网页提交POST请求的方法，对应于HTTP的POSTrequests.put()向HTML网页提交PUT请求的方法，对应于HTTP的PUTrequests.patch()向HTML网页提交局部修改请求，对应于HTTP的PATCHrequests.delete()向HTML页面提交删除请求，对应HTTP的DELETErequests库的主要方法(基础方法)requests.request(method, url, **kwargs)method:请求方式，对应get/put/post等7种r = requests.request(‘GET’,url, **kwargs)r = requsts.request(‘HEAD’,url, **kwargs)r = requests.request(‘POST’,url, **kwargs)r = requests.request(‘PATCH’,url, **kwargs)r = requests.request(‘delete’, url, **kwargs)r = requests.request(‘OPTIONS’,url, **kwargs)url:拟获取页面的URL链接**kwargs: 控制访问的参数，共13个1)params:字典或字节序列，作为参数增加到URL中2)data: 字典、字节序列或者文件对象，作为Request的内容3)json : JSON格式数据，作为Request内容4)headers : 字典，HTTP定制头5)cookies : 字典或CookieJar，Request中的cookie6)auth : 元组，支持HTTP认证功能7)files : 字典类型，传输文件8)timeout : 设定的超时时间，秒为单位9)proxies : 字典类型，设定访问代理服务器，可以增加登录认证10)allow_redirects : True/False, 默认为True,重定向开关11)stream : True/False, 默认为True ,获取内容立即下载开关12)verify : True/False , 默认为True ， 认证SSL证书开关13) cert : 本地SSL证书路径requests.get()方法：12r = requests.get(url) #构造一个向服务器请求资源的Request对象#返回一个包含服务器资源的Response对象完整方法：requests.get(==url, params=None, **kwargs==)url: 拟获取页面的url链接params: url中的额外参数， 字典或字节流格式， 可选**kwargs : 12个控制访问的参数，与request()的一样实际上是这样的：12345678910def get(url, params=None, **kwargs): #Sends a GET request. #:param url: URL for the new :class :'Request' object. #:param params: (optional) Dictionary ro bytes to be sent in the query #:return: :class :'Request &lt;Response&gt;' object #:rtype: requests.Response kwargs.setdefault('allow redirect', True) return request('get', url, params=params, **kwargs)例子：1234567891011import requestsr = requests.get("http://www.baidu.com")print(r)type(r)r.headers"""输出：200&lt;class 'requests.models.Response'&gt;&#123;'Transfer-Encoding': 'chunked', 'Pragma': 'no-cache', 'Connection': 'Keep-Alive', 'Last-Modified': 'Mon, 23 Jan 2017 13:27:52 GMT', 'Cache-Control': 'private, no-cache, no-store, proxy-revalidate, no-transform', 'Server': 'bfe/1.0.8.18', 'Set-Cookie': 'BDORZ=27315; max-age=86400; domain=.baidu.com; path=/', 'Content-Encoding': 'gzip', 'Date': 'Sat, 15 Jul 2017 13:27:01 GMT', 'Content-Type': 'text/html'&#125;"""Response对象的属性属性说明r.status_codeHTTP请求的返回状态，200表示连接成功，404表示失败r.textHTTP响应内容的字符串形式，即，url对应的页面内容r.encoding从HTTP header中猜测的响应内容编码方式r.apparent_encoding从内容中分析出的响应内容编码方式(备用编码凡是)r.contentHTTP响应内容的二进制形式[注]：r.encoding: 如果header中不存在charset， 则认为编码为ISO-8859-1Requests库的head()方法12345678r = requests.head('http://httpbin.org/get')r.headersr.text"""输出：&#123;'Access-Control-Allow-Credentials': 'true', 'X-Processed-Time': '0.000805139541626', 'Via': '1.1 vegur', 'Access-Control-Allow-Origin': '*', 'X-Powered-By': 'Flask', 'Content-Length': '267', 'Server': 'meinheld/0.6.1', 'Content-Type': 'application/json', 'Date': 'Sat, 15 Jul 2017 14:23:41 GMT', 'Connection': 'keep-alive'&#125;'' -- r.text"""Requests库的post()方法123456789101112131415161718192021222324252627payload = &#123;'key1':'value1', 'key2':'value2'&#125;r = requests.post('http://httpbin.org/post', data = payload)r = requests.post('http://httpbin.org/post', data = 'ABC')#向URL POST一个字典自动编码为form(表单)print(r.text)"""输出:&#123; "args": &#123;&#125;, "data": "ABC", --- &gt; 向URLPOST一个字符串，自动编码为data "files": &#123;&#125;, "form": &#123; "key1": "value1", "key2": "value2" &#125;, "headers": &#123; "Accept": "*/*", "Accept-Encoding": "gzip, deflate", "Connection": "close", "Content-Length": "23", "Content-Type": "application/x-www-form-urlencoded", "Host": "httpbin.org", "User-Agent": "python-requests/2.18.1" &#125;, "json": null, "origin": "120.85.181.141", "url": "http://httpbin.org/post""""Requests库的put()方法1234payload = &#123;'key1':'value1', 'key2':'value2'&#125;r = requests.put('http://httpbin.org/put', data = payload)print(r.text)#此方法与post方法类似，只不过是替换了URL位置上资源的内容]]></content>
      <categories>
        <category>python爬虫</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>Requests库</tag>
      </tags>
  </entry>
</search>
