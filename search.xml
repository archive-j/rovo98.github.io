<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[解决Github国内访问出现的问题]]></title>
    <url>%2Fposts%2F7e3029b3%2F</url>
    <content type="text"><![CDATA[主要通过修改hosts文件解决Github在国内访问不了、访问慢和页面加载异常的问题(没钱买vpn~)。简单了解一下github, github是目前全球最大的男性同性交友网站(~滑稽~), 使用示例如下：开个玩笑，回归正题。为什么访问不了以及访问速度会很慢？GitHub在中国大陆访问速度慢的问题原因有很多，但最直接和最主要的原因是GitHub的分发加速网络的域名遭到DNS污染。由于GitHub的加速分发CDN域名assets-cdn.github.com遭到DNS污染，导致无法连接使用GitHub的加速分发服务器，才使得中国大陆访问速度很慢。如何解决DNS污染？一般的DNS问题都可以通过修改Hosts文件来解决，GitHub的CDN域名被污染问题也不例外，同样可以通过修改Hosts文件解决。将域名解析直接指向IP地址来绕过DNS的解析，以此解决污染问题。获取被污染域名的实际IP地址访问ipaddress.com,使用ip lookup 工具获得相关域名的ip地址。例如： github.com可以看到，我查出的域名ip地址为： 192.30.254.112 和 192.30.253.113 (任取一个即可)修改host文件，在文件中添加一行：[注] ： windows的hosts文件位置为：C:/windows/system32/drivers/etc/hosts1192.30.253.112 github.com刷新dns缓存打开命令行cmd,输入如下命令：1ipconfig /flushdns此时再刷新页面即可。此时可以正常访问github，但是访问速度还是很慢，我们接着做优化。Github 访问提速在hosts文件中继续加入，如下代码：12345678910111213141516171819# GitHub Start192.30.253.112 github.com192.30.253.119 gist.github.com151.101.228.133 assets-cdn.github.com151.101.228.133 raw.githubusercontent.com151.101.228.133 gist.githubusercontent.com151.101.228.133 cloud.githubusercontent.com151.101.228.133 camo.githubusercontent.com151.101.228.133 avatars0.githubusercontent.com151.101.228.133 avatars1.githubusercontent.com151.101.228.133 avatars2.githubusercontent.com151.101.228.133 avatars3.githubusercontent.com151.101.228.133 avatars4.githubusercontent.com151.101.228.133 avatars5.githubusercontent.com151.101.228.133 avatars6.githubusercontent.com151.101.228.133 avatars7.githubusercontent.com151.101.228.133 avatars8.githubusercontent.com192.30.253.116 api.github.com# GitHub End[notice] : 这里域名对应的ip是通过dns查询工具查询得到的，你应当选择的是延时相对较小且比较稳定的ip。例如，上面的151.101.228.133是对我来说较好的ip:推荐的dns查询检测工具：DNS查询 - 在线工具DNS检测|DNS查询-站长工具你可对单个域名多查询几次，以挑选稳定且速度较快的ip。快速地访问github再次刷新dns缓存后，你已经可以快速地访问github了。参考：https://github.com/chenxuhua/issues-blog/issues/3]]></content>
      <categories>
        <category>tips</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PPP 点对点通信验证]]></title>
    <url>%2Fposts%2F28ff89ad%2F</url>
    <content type="text"><![CDATA[使用Cisco Packet Tracer7 (思科网络模拟器)验证ppp点对点通信。实验内容使用packet Tracer 模拟两台路由器，进行点对点通信测试。实验设计实验设备结构图：均使用思科模拟器中的Generic 泛型路由实验步骤配置路由器由于只需要验证点对点通信，对路由器的配置，相对比较简单，路由器之间使用的是serial DCE 串口线相连。配置Router1的serial 2/0串口为ip: 11.0.0.1 mask: 255.0.0.0,并配置时钟频率为640001234567Router&gt; enableRouter# configure terminalRouter(config) # hostname RARA (config) # interface serial 2/0RA (config) # no shutdownRA (config-if) # ip address 11.0.0.1 255.0.0.0RA (config-if) # clock rate 64000配置Router2的serial 3/0 串口为ip: 11.0.0.2 mask： 255.0.0.0123456Router&gt; enableRouter# configure terminalRouter(config) # hostname RBRB (config) # interface serial 3/0RB (config) # no shutdownRB (config-if) # ip address 11.0.0.2 255.0.0.0查看两个路由的串口状态：RA:RB:可以看到，路由器这里点对点通信默认使用的HDLC(High Level Data Link Control, 面向比特的同步协议)协议。HDLC情况下验证ping：11.0.0.1 ping 11.0.0.2:11.0.0.2 ping 11.0.0.1:ping 测试成功。配置RA,RB使用ppp协议，再做ping测试：先配置RA 使用 ppp协议：123RA # configure terminalRA (config) # interface serial 2/0RA (config-if) # encapsulation ppp可以看到RA当前使用的是ppp写协议，LCP处于Closed,此时，路由器应当无法进行点对点通信。配置RB使用ppp协议：123RB # configure terminalRB (config) # interface serial 3/0RB (config-if) # encapsulation ppp这时，可以看到RB也是使用了ppp协议，且LCP也处于Open状态，路由器之间可以进行通信。给ppp协议添加authentication鉴别先配置RA，使其开启ppp chap (Challenge Handshake Authentication Protocol), 给RB 添加身份验证1234RA # config terminalRA (config) # username RB password passwordRA (config) # interface serial 2/0RA (config-if) # ppp authentication chap此时，虽然RA和RB都是使用ppp协议，但是RA给RB添加了身份认证，而RB则没有，此时LCP处于Closed状态，它们之间无法进行通信。配置RB, 添加对RA的身份验证：1234RB # config terminalRB (config) # username RA password passwordRB (config) # interface serial 2/0RB (config-if) # ppp authentication chap可以看到此时，LCP已经打开，路由器之间可以进行点对点通信。实验结果通过该实验，简单地验证了ppp协议在点对点信道中的使用。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>ppp通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用ensp进行简单的路由器互连实验]]></title>
    <url>%2Fposts%2Fcc46ce96%2F</url>
    <content type="text"><![CDATA[简单使用ensp做华为AR1220路由互连的实验。实验内容路由器设置手动设置静态路由实验环境华为路由器AR1220主机Serial设备连接串口线和Copper以太网和千兆以太网连接线备注：所有实验设备均由ensp模拟。路由连接实验设计整体结构如下：1.其中分为六个不同的局域网；12345678910111213141516171819192.168.11.0 网段 -&gt; 主机: 192.168.11.11 192.168.11.12 路由器AR6一个GigabitEthernet接口作为该网段的默认网关(192.168.11.1)192.168.12.0 网段 -&gt; 主机: 192.168.12.11 192.168.12.12 路由器AR4的一个GigabitEthernet接口作为该网段的默认网关(192.168.12.1)192.168.13.0 网段 -&gt; 主机: 192.168.13.11 192.168.13.12 192.168.13.13 路由器AR7的一个GigabitEthernet接口作为该网段的默认网关(192.168.13.1) 1.1.2.0 网段 -&gt; 路由器AR6和路由器AR7之间的接口1.1.1.0 网段 -&gt; 路由器AR6和AR4之间的接口1.1.3.0 网段 -&gt; 路由器AR6和AR7之间的接口2.设备的连接：除了路由器之间连接使用serial串口连接线外，其他均使用Copper连接线。实验步骤配置各个局域网的ip及其网关例如：192.168.11.0网段下的192.168.11.11主机：配置 192.168.11.1作为192.168.11.0网段的网关：所有主机经过配置后，他们应该可以ping通自己网段下的所有主机，如：192.168.11.12 ping 192.168.11.11[需要注意的是]： 由于路由器互连时使用的是serial串口，所以路由器之间配置的是serial串口的ip。例如：配置AR6的两个serial串口的接口ip为：1.1.1.1和1.1.2.1：123456&lt;Huawei&gt; system-view[Huawei] inter serial 2/0/1[Huawei-Servial2/0/1] ip address 1.1.1.1 255.255.255.0[Huawei-Servial2/0/1] quit[Huawei] inter serial 2/0/0[Huawei-Serial2/0/0] ip address 1.1.2.1 255.255.255.0各个路由器的静态路由：对于路由器AR6,我们希望所有目的网络为192.168.12.0的数据包都交付给AR4,即下一跳为1.1.1.2;所有目的网络为192.168.13.0的都交给AR7,下一跳为1.1.2.2：123&lt;Huawei&gt; system-view[Huawei] ip route-static 192.168.12.0 255.255.255.0 1.1.1.2[Huawei] ip route-static 192.168.13.0 255.255.255.0 1.1.2.2对于路由器AR4，所有目的网络为192.168.11.0的数据包交给AR6，下一跳为：1.1.1.1，目的网络为192.168.13.0的数据包交给AR7，下一跳为：1.1.3.1：123&lt;Huawei&gt; system-view[Huawei] ip route-static 192.168.11.0 255.255.255.0 1.1.1.1[Huawei] ip route-static 192.168.13.0 255.255.255.0 1.1.3.1对于路由器AR7， 所有目的网络为192.168.11.0的数据包都交给AR6，下一跳为：1.1.2.1，所有目的网络为192.168.12.0的数据包都交给AR4，下一跳为：1.1.3.2：123&lt;Huawei&gt; system-view[Huawei] ip route-static 192.168.11.0 255.255.255.0 1.1.2.1[Huawei] ip route-static 192.168.12.0 255.255.255.0 1.1.3.2经过以上对各个路由器的静态路由的配置后，我们可以通过1display ip routing-table来查看各个路由器的路由表：AR6路由表：AR4路由表：AR7路由表：测试实验结果使用任意一个局域网下的主机ping不同局域网下的主机：192.168.11.11 ping 192.168.13.12 和 192.168.12.12:192.168.12.11 ping 192.168.11.12 和 192.168.13.13:192.168.13.11 ping 192.168.11.11 和 192.168.12.11：由以上测试可以看出简单的路由器连接实验成功。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>路由器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7通过yum(yellow dog update modifier) 安装mysql5.7]]></title>
    <url>%2Fposts%2F86d29d2c%2F</url>
    <content type="text"><![CDATA[配置yum源1234# 下载mysql安装源包root @~&gt; wget http://dev.mysql.com/get/mysql57-community-release-el7-8.noarch.rpm# 安装mysql源root @~&gt; yum localinstall mysql57-community-release-el7-8.noarch.rpm检查mysql源是否安装成功:1root @~&gt; yum repolist enabled | grep "mysql.*-community.*"如下图则安装成功:安装mysql1root@ ~&gt; yum install -y mysql-community-server启动MySQL服务并设置开机自动启动1root@ ~&gt; systemctl start mysqld查看MySQL启动状态12root@ ~&gt; systemctl enable mysqldroot@ ~&gt; systemctl daemon-reload修改默认密码刚安装完的mysql会自动给root用户分配一个临时密码，而且必须重新设置密码(从5.5版本开始)先查看root用户的临时密码1root@ ~&gt; grep "temporary password" /var/log/mysqld.log使用临时的密码登录进mysql来设置新的密码1mysql&gt; set PASSWORD = PASSWORD('[YOUR_NEW_PASSWORD]')可能遇到的问题：设置的密码过于简单mysql报错:1Your password does not satisfy the current policy requirements.解决方法：由于刚安装的mysql的密码默认强度是最高的，若想要设置简单的密码就要修改validate_password_policy的值，validate_password_policy有以下取值：PolicyTests Performed0 or LOWLength1 or MEDIUMLength;numeric,lowercase/uppercase,and special characters2 or STRONGLength;numeric,lowercase/uppercase,and special characters; dictionary file操作：设置安全级别1mysql&gt; set global validate_password_policy=0;设置密码长度为8，可以设置为其他值，最小为4位1mysql&gt; set global validate_password_length=4;之后就可以设置简单的密码了。允许root远程登录12mysql&gt; GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY '[YOUR_PASSWORD]' WITH GRANT OPTION;mysql&gt; flush privileges;修改字符集编码为UTF-8查看当前字符编码1mysql&gt; show variables like "char%';检测是否都是utf-8(filesystem除外)，如果不是就需要修改。 character_set_server一般是lantin1。12345678# 停止mysqld服务systemctl stop mysqld# 进入my.cnf文件，一般是/etc/路径下vim /etc/my.cnf# 在[mysqld]下追加character-set-server=utf-8# 在[mysql]下追加default-character-set=utf-8# 启动mysqldsystemctl start mysqld]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql5.7安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hibernate基础学习]]></title>
    <url>%2Fposts%2Fb19895ed%2F</url>
    <content type="text"><![CDATA[Hibernate是一个对象关系映射(Object-Relational Mapping, ORM)的JAVA解决方案。是在2001年由 Gavin King创建的开源持久化框架。适用于任何使用Java应用程序的功能强大的高性能对象关系持久化和查询服务。概述Hibernate将Java类映射到数据表并将Java数据类型映射到SQL数据类型，使开发人员从95%的常见数据持久化相关编程任务中解脱出来。Hibernate位于传统的Java对象和数据库服务器之间，以适应基于适当$O/R$机制和模式的持久化对象的保存工作。Hibernate 优势Hibernate使用XML文件来将Java类映射到数据表，不需要写任何代码。提供简单的APIs直接将java对象保存到数据库中，或从数据库中检索出来。数据库或数据表发生改变时，只需要修改XML文件。不采用不熟悉的SQL类型，而提供一中方法来解决熟悉的Java对象。Hibernate不需要应用服务器来操作。可以操纵数据库对象的复杂关联。使用智能检索策略来最小化数据库的访问。提供简单的数据查询。支持的数据库Hibernate支持所有主流的关系型数据库(RDBMS)。下面简单地列出Hibernate支持的数据库:HSQL Database EngineDB2/NTMySQLPostgreSQLFrontBaseOracleMicrosoft SQL Server DatabaseSybase SQL ServerInfomix Dynamic Server支持的技术Hibernate支持很多其他的技术，包括XDoclet SpringJ2EEEclipse plug-insMaven架构Hibernate拥有一个分层的架构，可以使用户在不了解底层APIs的情况下使用它。Hibernate使用数据库和配置数据来向应用提供持久化服务。下面是从宏观角度看Hibernate的视图：从细节视角看Hibernate以及它的核心类：Hibernate使用很多现有的Java API, 例如： JDBC, Java Transaction API(JTA)以及 Java Naming and Directory Interface(JNDI)。JDBC提供了关系数据库通用功能的基本抽象级别，使Hibernate支持几乎所有具有JDBC驱动程序的数据库。JNDI和JTA使J2EE可以集成Hibernate。下面是针对上面架构图中出现的核心类给出的简单解释。Configuration ObjectConfiguration(配置对象)是在Hibernate应用中第一个被创建的对象，且在Hibernate应用初始化时，只创建一次。它通常代表着Hibernate所需的配置信息或属性。Configuartion包含一下两个关键的组件:Database Connection(数据库连接) - 通过hibernate支持的一个或多个配置文件来处理的，例如： hibernate.properties和hibernate.cfg.xml。Class Mapping Setup(类映射设置) - 该组件负责创建Java类和数据表之间的连接。SessionFactory ObjectSessionFactory对象是通过使用Configuration对象创建生成的，该对象可以使用提供的配置文件为应用程序配置Hibernate，并能够实例化Session对象。SessionFactory是一个线程安全对象，并被应用程序的所有线程使用。Sessionfactory是一个重量级对象，通常在应用程序启动时创建并保留以备后续使用。每个数据库使用单独的配置文件都需要一个SessionFactory对象。因此，如果使用多个数据库，我们可能需要创建多个SessionFactory对象。Session ObjectSession对象主要用来从数据库中获取物理连接。Session是轻量级对象，当每次需要与数据库交互时都可以实例化该对象。持久化对象(persistent Objects)就是通过它来实现保存和检索的。Session对象一般不会保留很长一段时间，因为它并不是线程安全对象，只能在需要使用的时候创建和销毁。Transaction ObjectTransaction对象代表了数据库的一个工作单元，大多数RDBMS都支持事务功能。Hibernate中的事务由underlying transaction manager(基础事务管理器)以及transaction(事务，来自JDBC或者JTA)。这是一个可选对象，Hibernate应用程序可以选择不使用此接口，而是使用自己的应用程序的代码来管理事务。Query ObjectQuery对象使用SQL或者Hibernate查询语言（HQL)字符串来从数据库中检索数据以及创建对象。一个Query实例一般是用来绑定查询参数，限制返回结果行数，并执行查询操作的。Criteria ObjectCriteria对象用于创建和执行面向对象的条件查询来检索对象。Hibernate 配置Hibernate需要事先知道在哪里可以找到定义Java类和数据表的关系的映射信息。Hibernate还需哟啊一组与数据库和其他相关参数相关的配置设置。所有这些信息通常由标准Java属性文件(hibernate.properties)或XML文件(hibernate.cfg.xml)提供。这里我们只需要考虑hibernate.cfg.xml配置文件的配置。大多数的属性一般都采用默认值，并且不需要在属性文件(hibernate.properties)中制定它们，除非真的需要。配置文件只能保存在应用程序的类路径的根目录中。Hibernate 属性下面列出的使一些重要的属性，当我们在配置数据库时可能会用到：PropertiesDescriptionhibernate.dialect数据库方言，该属性能够是Hibernate为选择的数据库生成合适的SQLhibernate.connection.driver_classJDBC 驱动类hibernate.connection.url数据库实例的JDBC URLhibernate.connection.username数据库用户名hibernate.connection.password数据库密码hibernate.connection.pool_size限制Hibernate数据库连接池中等待的连接数hibernate.connection.autocommit允许JDBC连接自动提交如果使用应用程序服务器和JNDI,则必须配置以下属性：PropertiesDescriptionhibernate.connection.datasource在应用服务器上下文中定义JNDI名称hibernate.jndi.classJNDI的InitialContext类hibernate.jndi.&lt; JNDIpropertyname &gt;向JNDI InitialContext传递的属性hibernate.jndi.urlJNDI URLhibernate.connection.username数据库用户名hibernate.connection.password数据库密码在Hibernate中配置 MySQL 数据库MySQL是目前最受欢的开源数据库系统之一。下面通过配置hibernate.cfg.xml文件来配置MySQL数据库，在此之前，确保在MySQL中创建一个testdb数据库，以及test用户。[notice] : XML配置文件必须符合Hibernate 2 配置 DTD标准。hibernate.cfg.xml:123456789101112131415161718192021222324252627282930313233&lt;?xml version = "1.0" encoding = "utf-8"?&gt;&lt;!DOCTYPE hibernate-configuration SYSTEM "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd"&gt;&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;property name = "hibernate.dialect"&gt; org.hibernate.dialect.MySQL5Dialect &lt;/property&gt; &lt;property name = "hibernate.connection.driver_class"&gt; com.mysql.jdbc.Driver &lt;/property&gt; &lt;!-- Assume test is the database name --&gt; &lt;property name = "hibernate.connection.url"&gt; jdbc:mysql://localhost/test &lt;/property&gt; &lt;property name = "hibernate.connection.username"&gt; root &lt;/property&gt; &lt;property name = "hibernate.connection.password"&gt; root &lt;/property&gt; &lt;!-- List of XML mapping files --&gt; &lt;mapping resource = "Employee.hbm.xml"/&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt;上面配置文件中&lt;mapping&gt;标签与hibernate mapping(映射文件)相关。以下是一些重要的数据库方言属性类型：DatabaseDialect PropertyDB 2org.hibernate.dialect.DB2DialectHSQLDBorg.hibernate.dialect.HSQLDialectHypersonicSQLorg.hibernate.dialect.HSQLDialectInformixorg.hibernate.dialect.InformixDialectIngresorg.hibernate.dialect.IngresDialectInterbaseorg.hibernate.dialect.InterbaseDialectMicrosoft SQL Server 2000org.hibernate.dialect.SQLServerDialectMicrosoft SQL Server 2005org.hibernate.dialect.SQLServer2005DialectMicrosoft SQL Server 2008org.hibernate.dialect.SQLServer2008DialectMySQLorg.hibernate.dialect.MySQLDialectOracle(any versionorg.hibernate.dialect.OracleDialectOracle 11gorg.hibernate.dialect.Oracle10gDialectOracle 10gorg.hibernate.dialect.Oracle10gDialectOracle 9iorg.hibernate.dialect.Oracle9iDialectPostgreSQLorg.hibernate.dialect.PostgreSQLDialectProgressorg.hibernate.dialect.ProgressDialectSAP DBorg.hibernate.dialect.SAPDBDialectSybaseorg.hibernate.dialect.SybaseDialectSybase anywhereorg.hibernate.dialect.SybaseAnywhereDialectSessions前面我们已经提到Session使用来获取数据库物理连接的，为轻量级对象，只有需要和数据库发生交互时才进行对象实例化。持久化对象的保存和检索就是通过它来完成的。Session不能维持太长时间，毕竟它们不是线程安全对象， 只能在需要的时候创建和销毁。Session的主要功能是为映射实体类提供创建、读取和删除操作。在给定的时间点中，实例可能有下面的这些状态：transient(暂时的) - 一个持久类的新实例，与Session没有关联，并且在数据库中没有表示以及没有标识符值，被Hibernate认为是暂时的。persistent(持久的) - 我们可以通过将暂时的实例(transient)与Session关联来将它进行持久化。detached(独立的) - 一旦关闭Hibernate Session对象，持久化对象将转化为独立的对象(detached instance)。当Session对象中的持久类(persistent classes)是可序列化时，Session也是可序列化的。下面是典型的事务处理代码：1234567891011121314Session session = factory.openSession();Transaction tx = null;try &#123; tx = session.beginTransaction(); // do some work ... tx.commit();&#125; catch (Exception e) &#123; if (tx != null) tx.rollback(); e.printStackTrace();&#125; finally &#123; session.close();&#125;[notice] : 如果Session抛出异常，事务必须回滚(rollback)并且Session需要丢弃。Session 接口方法Session接口提供了很多方法，下面列出的是其中一些中重要的方法。更多的信息可以查看Hibernate文档中与Session以及SessionFactory相关的完整方法信息。Session MethodDescriptionTransaction beginTransaction()开启一个工作单元并返回已经关联的事务对象。void cancelQuery()取消执行当前查询操作void clear()完全清除回话(session)Connection close()结束回话并释放JDBC连接资源Criteria createCriteria(Class persistentClass)为指定的实体类或者实体类的超类创建一个条件查询(Criteria)对象Criteria createCriteria(String entityName)根据实体类的名称创建Criteria对象Serializable getIdentifier(Object Object)返回与此回话关联的给定实体的标识符值Query createFilter(Object collection, String queryString)根据给定的集合(collection)以及过滤字符串创建一个新的Query实例SQLQuery createSQLQuery(String queryString)根据给定的SQL查询语句创建一个SQLQuery对象void delete(Object object)从数据存储(datastore)中移除持久实例void delete(String entityName, Object object)从数据存储中移除持久实例Session get(String entityName, Serializable id)根据给定的标识符(identifier)以及实体名返回持久化实例；如果没有该实例，则返回nullSessionFactory getSessionFactory()获取创建该Session实例的SessionFactory对象void refresh(Object object)从底层数据库重新读取给定实例的状态Transaction getTransaction()获取与该Session关联的Transaction实例boolean isConnected()返回当前Session的连接状态boolean isDirty()判断Session中是否存在未同步到数据库的脏数据(已经修改过的数据)boolean isOpen()判断Session是否打开Serializable save(Object object)持久化给定的暂时实例，分配一个生成的标识符void saveOrUpdate(Object object)对给定的实例执行save(Object)或者update(Object)操作void update(Object object)根据给定的独立实例的标识符更新持久化实例void update(String entityName, Object object)根据给定的独立实例的标识符更新持久化实例Hibernate 持久化类Hibernate的整体理念是从Java类属性中取值并将它们保存到数据表中。Hibernate使用给定的映射文件来获取Java类中的属性值，并将它们映射到数据表和相关字段。在Hibernate中，我们把那些对象或实例将被保存到数据表中的Java类成为持久化类，持久类。一般这些遵循这样的一些简单的规则，即符合Plain Ordinary Java Object(POJO)编程模型。下面给出的就是持久化类需要遵循的规则，但这并不是硬性要求：所有的持久化类都需要有一个默认的构造方法；所有类都需要包含一个ID属性，以便在Hibernate和数据库中轻松识别对象，该属性一般映射到数据表中的主键；所有需要持久化的属性都应该声明为private并定义getXXX和setXXX方法；Hibernate的一个中心特性是代理，因此依赖的持久化类不能是final类或者实现声明所有公共方法的接口；所有类不继承或实现EJB框架所需的特定类和接口。POJO是用来强调给定的对象是一个原始的Java对象，而不是一个特殊的类，也不是一个Enterprise JavaBean。简单POJO例子基于上面提到的规则，定义了下面的一个简单POJO类：123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Employee &#123; private int id; private String firstName; private String lastName; private int salary; public Employee() &#123;&#125; public Employee(String fname, String lname, int salary) &#123; this.firstName = fname; this.lastName = lname; this.salary = salary; &#125; public int getId() &#123; return id; &#125; public void setId( int id ) &#123; this.id = id; &#125; public String getFirstName() &#123; return firstName; &#125; public void setFirstName( String first_name ) &#123; this.firstName = first_name; &#125; public String getLastName() &#123; return lastName; &#125; public void setLastName( String last_name ) &#123; this.lastName = last_name; &#125; public int getSalary() &#123; return salary; &#125; public void setSalary( int salary ) &#123; this.salary = salary; &#125;&#125;Hibernate 映射文件对象关系映射通常都是定义在一个XML文档中。该映射文件告诉Hibernate如果将定义的Java类映射到数据库中的数据表。尽管很多Hibernate用户都选择使用人工方式来写XML文档。但是现在有很多现有的工具可以用来生成映射文档，其中包含供Hibernate高级用户使用的XDoclet, Middlegen以及AndroMDA。对于之前给出的简单的POJO类，假设它需要保存到下面的RDBMS数据表中，以及从中检索数据:1234567create table EMPLOYEE ( id int not null auto_increment, first_name varchar(20) default null, last_name varchar(20) default null, salaary int default null, primary key (id));定义映射文件:12345678910111213141516171819202122&lt;?xml version = "1.0" encoding = "utf-8"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD//EN""http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt; &lt;hibernate-mapping&gt; &lt;class name = "Employee" table = "EMPLOYEE"&gt; &lt;meta attribute = "class-description"&gt; This class contains the employee detail. &lt;/meta&gt; &lt;id name = "id" type = "int" column = "id"&gt; &lt;generator class="native"/&gt; &lt;/id&gt; &lt;property name = "firstName" column = "first_name" type = "string"/&gt; &lt;property name = "lastName" column = "last_name" type = "string"/&gt; &lt;property name = "salary" column = "salary" type = "int"/&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt;一般映射文件的文件名格式为: &lt;classname&gt;.hbm.xml。例如上面的映射文件我们可以命名为: Employee.hbm.xml。下面是针对映射文件中涉及到的标签元素给出的具体解释:映射文件使用&lt;hibernate-mapping&gt;标签作为根标签元素，它包含所有的&lt;class&gt;标签元素；&lt;class&gt;标签是用来定义java类到数据表的映射关系的。Java类名和数据表名称分别由标签的name和table属性指定；&lt;meta&gt;标签用于创建类的描述信息，是可选标签；&lt;id&gt;标签映射Java类的唯一id属性到数据表的主键。该标签的name属性指定类的属性名，column则指定数据表的字段名。type属性为hibernate映射类型，将Java数据类型转化为SQL数据类型。&lt;generator&gt;标签元素是&lt;id&gt;标签的子元素，用来自动生成主键值。其中class属性设置为native，以使Hibernate根据底层数据库的功能选择identity,sequence或hilo算法来生成主键；&lt;property&gt;标签则用来将java类中的属性映射到数据表中的字段。name属性指定java类的属性名，相应的，column指定数据表对应的字段名称。type为hibernate映射类型。除了上面提到的这些标签元素和属性外，其实还有其他的标签元素和属性。这里只不过是简单地给出了常用的标签元素及其属性的解释。Hibernate 映射类型当我们配置Hibernate映射文件时，我们需要将Java数据类型映射转化为RDBMS数据类型。在映射文件中生命的类型(types)既不是java数据类型，也不是SQL 数据据数据类型。我们一般称其为Hibernate mapping types(hibernate映射类型),它们能够将java数据类型转化为SQL数据类型，反之亦然。下面给出了所有基本的，日期和时间，大对象以及其他各种内置映射类型。原始类型(Primitive Types)Mapping typeJava typeANSI SQL Typeintegerint or java.lang.IntegerINTEGERlonglong or java.lang.LongBIGINTshortshort or java.lang.ShortSMALLINTfloatfloat or java.lang.FloatFLOATdoubledouble or java.lang.DoubleDOUBLEbig_decimaljava.math.BigDecimalNUMERICcharacterjava.lang.StringCHAR(1)stringjava.lang.StringVARCHARbytebyte or java.lang.ByteTINYINTbooleanboolean or java.lang.BooleanBITyes/noboolean or java.lang.BooleanCHAR(1)(‘Y’ or ‘N’)true/falseboolean or java.lang.BooleanCHAR(1)(‘Y’ or ‘N’)日期和时间类型Mapping TypeJava TypeANSI SQL Typedatejava..util.Date or java.sql.DateDATEtimejava.util.Date or java.sql.DateTIMEtimestampjava.util.Date or java.sql.TimestampTIMESTAMPcalendarjava.util.CalendarTIMESTAMPcalendar_datejava.util.CalendarDATE二进制和大对象类型Mapping TypeJava TypeANSI SQL Typebinarybyte[]VARBINARY(or BLOB)textjava.lang.StringCLOBserializable任何实现java.io.Serializable接口的类VARBIANRY(or BLOBclobjava.sql.ClobCLOBblobjava.sql.BlobBLOBJDK相关类型Mapping TypeJava TypeANSI SQL Typeclassjava.lang.ClassVARCHARlocalejava.util.LocaleVARCHARtimezonejava.util.TimeZoneVARCHARcurrencyjava.util.CurrencyVARCHARHibernate 使用实例接下来我们将通过一个简单的例子来了解Hiberate是如何为独立应用程序提供持久化服务的。下面使用Hibernate技术分几个不同的步骤来创建一个Java应用程序。创建POJO类创建应用程序的第一步就是创建Java POJO类，这取决与应用程序中需要保留到数据库的类。这里我们创建一个拥有getter和setter方法的Employee类，并让它成为JavaBean兼容类。123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Employee &#123; private int id; private String firstName; private String lastName; private int salary; public Employee() &#123;&#125; public Employee(String fname, String lname, int salary) &#123; this.firstName = fname; this.lastName = lname; this.salary = salary; &#125; public int getId() &#123; return id; &#125; public void setId( int id ) &#123; this.id = id; &#125; public String getFirstName() &#123; return firstName; &#125; public void setFirstName( String first_name ) &#123; this.firstName = first_name; &#125; public String getLastName() &#123; return lastName; &#125; public void setLastName( String last_name ) &#123; this.lastName = last_name; &#125; public int getSalary() &#123; return salary; &#125; public void setSalary( int salary ) &#123; this.salary = salary; &#125;&#125;创建数据表第二步，就是要在数据库中创建数据表。一张数据表对应一个持久化类。定义EMPLOYEE表来对应Employee持久化类。1234567create table EMPLOYEE ( id INT NOT NULL auto_increment, first_name VARCHAR(20) default NULL, last_name VARCHAR(20) default NULL, salary INT default NULL, PRIMARY KEY (id));创建映射文件创建一个映射文件来告诉Hibernate如何将持久化类映射到数据表。Employee.hbm.xml:12345678910111213141516171819202122&lt;?xml version = "1.0" encoding = "utf-8"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD//EN""http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt; &lt;hibernate-mapping&gt; &lt;class name = "Employee" table = "EMPLOYEE"&gt; &lt;meta attribute = "class-description"&gt; This class contains the employee detail. &lt;/meta&gt; &lt;id name = "id" type = "int" column = "id"&gt; &lt;generator class="native"/&gt; &lt;/id&gt; &lt;property name = "firstName" column = "first_name" type = "string"/&gt; &lt;property name = "lastName" column = "last_name" type = "string"/&gt; &lt;property name = "salary" column = "salary" type = "int"/&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt;创建应用程序类最后，我们创建一个应用程序类来做简单的测试。例如：保存一些Employee数据，执行CRUD操作等。ManageEmployee.java:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121import java.util.List; import java.util.Date;import java.util.Iterator; import org.hibernate.HibernateException; import org.hibernate.Session; import org.hibernate.Transaction;import org.hibernate.SessionFactory;import org.hibernate.cfg.Configuration;public class ManageEmployee &#123; private static SessionFactory factory; public static void main(String[] args) &#123; try &#123; factory = new Configuration().configure().buildSessionFactory(); &#125; catch (Throwable ex) &#123; System.err.println("Failed to create sessionFactory object." + ex); throw new ExceptionInInitializerError(ex); &#125; ManageEmployee ME = new ManageEmployee(); /* Add few employee records in database */ Integer empID1 = ME.addEmployee("Zara", "Ali", 1000); Integer empID2 = ME.addEmployee("Daisy", "Das", 5000); Integer empID3 = ME.addEmployee("John", "Paul", 10000); /* List down all the employees */ ME.listEmployees(); /* Update employee's records */ ME.updateEmployee(empID1, 5000); /* Delete an employee from the database */ ME.deleteEmployee(empID2); /* List down new list of the employees */ ME.listEmployees(); &#125; /* Method to CREATE an employee in the database */ public Integer addEmployee(String fname, String lname, int salary)&#123; Session session = factory.openSession(); Transaction tx = null; Integer employeeID = null; try &#123; tx = session.beginTransaction(); Employee employee = new Employee(fname, lname, salary); employeeID = (Integer) session.save(employee); tx.commit(); &#125; catch (HibernateException e) &#123; if (tx!=null) tx.rollback(); e.printStackTrace(); &#125; finally &#123; session.close(); &#125; return employeeID; &#125; /* Method to READ all the employees */ public void listEmployees( )&#123; Session session = factory.openSession(); Transaction tx = null; try &#123; tx = session.beginTransaction(); List employees = session.createQuery("FROM Employee").list(); for (Iterator iterator = employees.iterator(); iterator.hasNext();)&#123; Employee employee = (Employee) iterator.next(); System.out.print("First Name: " + employee.getFirstName()); System.out.print(" Last Name: " + employee.getLastName()); System.out.println(" Salary: " + employee.getSalary()); &#125; tx.commit(); &#125; catch (HibernateException e) &#123; if (tx!=null) tx.rollback(); e.printStackTrace(); &#125; finally &#123; session.close(); &#125; &#125; /* Method to UPDATE salary for an employee */ public void updateEmployee(Integer EmployeeID, int salary )&#123; Session session = factory.openSession(); Transaction tx = null; try &#123; tx = session.beginTransaction(); Employee employee = (Employee)session.get(Employee.class, EmployeeID); employee.setSalary( salary ); session.update(employee); tx.commit(); &#125; catch (HibernateException e) &#123; if (tx!=null) tx.rollback(); e.printStackTrace(); &#125; finally &#123; session.close(); &#125; &#125; /* Method to DELETE an employee from the records */ public void deleteEmployee(Integer EmployeeID)&#123; Session session = factory.openSession(); Transaction tx = null; try &#123; tx = session.beginTransaction(); Employee employee = (Employee)session.get(Employee.class, EmployeeID); session.delete(employee); tx.commit(); &#125; catch (HibernateException e) &#123; if (tx!=null) tx.rollback(); e.printStackTrace(); &#125; finally &#123; session.close(); &#125; &#125;&#125;编译执行通过编译执行，我们可以得到下面的测试结果：12345678$java ManageEmployee.......VARIOUS LOG MESSAGES WILL DISPLAY HERE........First Name: Zara Last Name: Ali Salary: 1000First Name: Daisy Last Name: Das Salary: 5000First Name: John Last Name: Paul Salary: 10000First Name: Zara Last Name: Ali Salary: 5000First Name: John Last Name: Paul Salary: 10000EMPLOYEE表中的数据：12345678910mysql&gt; select * from EMPLOYEE;+----+------------+-----------+--------+| id | first_name | last_name | salary |+----+------------+-----------+--------+| 29 | Zara | Ali | 5000 || 31 | John | Paul | 10000 |+----+------------+-----------+--------+2 rows in set (0.00 secmysql&gt;Hibernate O/R 映射之前，我们已经熟悉了Hibernate的基本O/R映射的使用，但是还有很多映射我们还需要进一步的了解。如：集合的映射实体类之间的关联映射组件映射集合映射如果持久化类中包含某个属性为集合类型，我们也需要将集合类型值映射到数据表中。Hibernate能够持久化的集合实例有java.util.Map、java.util.Set、java.util.SortedMap、java.util.SortedSet、java.util.List以及持久化实例中的数组(array)。Collection TypeMapping Descriptionjava.util.Set使用&lt;set&gt;标签元素进行映射并使用java.util.HashSet进行初始化java.util.SortedSet使用&lt;set&gt;标签进行映射并用java.util.TreeSet初始化，属性sort可以设置为comparator或者natural orderingjava.util.List使用&lt;list&gt;标签进行映射，并用java.util.ArrayList初始化java.util.Collection使用&lt;bag&gt;或&lt;ibag&gt;标签进行映射配置并使用java.util.ArrayList初始化java.util.Map使用&lt;map标签进行映射并使用java.util.HashMap初始化java.util.SortedMap使用&lt;map标签进行映射并用java.util.TreeMap初始化。属性sort可以设置为comparator或natural ordering对于数组类型的映射，针对Java原始值类型使用&lt;primitive-array&gt;标签，其他的数组类型则使用&lt;array&gt;。但是一般很少使用到。[notice]:如果需要映射用户自定义的集合接口，切该集合接口不是Hiberate直接支持的，就需要告诉Hibernate定义集合的语义，通常是很难实现的，一般不推荐使用。Set-MappingSortedSet-MappingList-MappingCollection-MappingMap-MappingSortedMap-Mapping关联映射实体类和数据表之间的映射是ORM的灵魂。以下是可以表示对象之间关系的四种方式。关联映射可以是单向的，也可以是双向的。Mapping TypeDescriptionMany-to-One多对一关系的映射One-to-One一对一关系的映射One-to-Many一对多关系的映射Many-to-Many多对多关系的映射Many-to-OneOne-to-OneOne-to-ManyMany-to-Many组件映射在应用程序中，有很大的可能性一个实体类会持有另一个实体的引用最为成员变量。如果别引用的类没有自己的申明周期并且完全依赖与拥有的实体类的生命周期，那么所引用的类称为组件类。组件的映射可以以类似集合映射的方式进行，但有点不同与常规的集合映射：Mapping TypeDescriptionComponent Mappings对持有另一个类作为成员变量的实体类进行映射]]></content>
      <categories>
        <category>Java框架学习</category>
        <category>Hibernate</category>
      </categories>
      <tags>
        <tag>Java框架基础</tag>
        <tag>hibernate</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java持久化框架基础学习笔记 - ORM]]></title>
    <url>%2Fposts%2F4e7f2cb9%2F</url>
    <content type="text"><![CDATA[对象关系映射(Oject Relational Mapping, ORM)是一种程序技术，用户实现面向对象编程语言中不同类型系统的数据之间的转换。为了更好的了解ORM，我们先要了解一下JDBC。什么是JDBC?JDBC，即Java Database Connectivity(Java数据库连接)。它为Java程序提供了访问关系型数据库(relational database)的Java API集合。这些API使得Java程序可以执行SQL语句并与任何符合SQL的数据库库进行交互。JDBC提供了一种灵活的结构来编写能够和数据库进行交互的应用，且在不做任何修改的情况下，能够运行于不同的平台。JDBC的优点和缺点优点缺点清晰简单的SQL处理在大型的项目中使用时变得异常复杂处理大数据时有良好表现大量编程开销，没有封装非常适合小应用程序难以实现MVC模式语法简单易学查询是DBMS特有的为什么使用对象关系映射(ORM)?当我们使用面向对象系统时，对象模型和关系数据库存在不匹配的现象，RDMSs(关系型数据库) 以表格的形式表示数据，而面向对象编程语言，如java,C# 将数据表示为对象的属性，以及对象之间的关系。例如下面的一个简单的实体类：12345678910111213141516171819202122232425262728public class Employee &#123; private int id; private String firstName; private String lastName; private int salary; public Employee() &#123;&#125; public Employee(String fname, String lname, int sal) &#123; this.firstName = fname; this.lastName = lname; this.salary = sal; &#125; public int getId() &#123; return id; &#125; public String getFirstName() &#123; return firstName; &#125; public String getLastName() &#123; return lastName; &#125; public int getSalary() &#123; return salary; &#125;&#125;上面的对象在关系型数据库中可以这样存储和检索的：1234567create table EMPLOYEE ( id int not null auto_increment, first_name varchar(20) default null, last_name varchar(20) default null, salary int default null, contraint PK_id primary key (id));遇到的问题可能我们开发了几个页面后，要修改数据库的设计，我们应该怎样处理？将对象存储到关系型数据库和从数据库中读取存在以下五个不匹配(mismatch)的问题：不匹配(Mismatch)描述(Description)Granularity(粒度)有时你可能会有一个对象模型，它的类比数据库中的相应的表的数量还要多。Inheritence(继承)RDBMS不定义任何类似继承的东西，但这确是面向对象编程语言中的的自然范式。Identity(标识)RDBMS正好定义了一个“相等”的概念：主键。但是Java定义对象标识(a == b) 和对象相等(a.equals(b))。Associations(关联)面向对象编程语言使用对象引用来表示关联，而RDBMS将关联表示为外键。Navigation(检索)在Java和RDBMS中访问对象的方式根本不同。对象关系映射（ORM）是处理上述所有不匹配问题的解决方案。什么是ORM?ORM 是一项在关系型数据库和面向对象编程语言之间转换数据的编程技术。相比于简单的JDBC，ORM有以下优点：No.Advantages1让业务逻辑代码访问数据对象，而不是数据表2隐藏了业务逻辑的SQL查询的详细信息3无需处理数据库实现问题4基于业务概念而非数据库结构的实体5基于JDBC“底层”6事务管理和自动密钥生成7应用程序快速开发一个 ORM 解决方案由以下四个实体组成：No.Solutions1对持久化类的对象执行基本CRUD操作的API2用于指定引用类和类的属性的查询的语言或API3用于指定映射元数据的可配置工具4一种与事务对象进行交互以执行脏检查，懒惰关联提取以及其他优化功能的技术。Java ORM 框架有许多持久化框架ORM解决方案使用java实现的，如：Enterprise JavaBeans Entity BeansJava Data OjectsCastorTopLinkSpring DAOHibernateMybatis等等。]]></content>
      <categories>
        <category>Java框架学习</category>
      </categories>
      <tags>
        <tag>Java框架基础</tag>
        <tag>学习笔记</tag>
        <tag>ORM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Struts 2基础学习 - Interceptors]]></title>
    <url>%2Fposts%2F5e817364%2F</url>
    <content type="text"><![CDATA[Interceptors(拦截器)在概念上同servlet过滤器以及JDK动态代理类一样。拦截器可以透切(crosscutting)action以及框架来实现一些特定的功能。例如：在action调用执行前，预先执行某些代码；在action调用和执行后，再次执行你指定的代码；用来捕捉异常，以便可以执行替代处理(alternate processing)。事实上，Struts 2框架的许多特性都是使用拦截器实现的。例如： exception handling, file uploading, lifecycle callbacks等等。因为Struts 2在拦截器上强调了它的大部分功能，因此不太可能为单个action分配7或8个拦截器。Struts 2框架拦截器Struts 2框架提供了许多预先配置并且可以开箱即用的拦截器。下面是一些比较重要的拦截器：InterceptorDescriptionalias允许参数(parameters)跨请求拥有不同的别名checkbox通过为未选中的复选框(check box)添加参数值false来协助管理复选框conversionError将字符串转换为参数类型的错误信息放入Action的字段错误中createSession自动创建一个HTTP session如果它没有存在debugging为开发人员提供几个不同的调式界面execAndWait当action在后台执行时，给用户提供一个等待页面exception将action引发的异常映射到result,并通过重定向自动处理异常fileUpload便于文件上传i18n在用户回话期间跟踪所选的语言环境logger通过输出被执行的action的名字来提供简单的日志信息params允许在action中设置request的参数prepare这是一个用来的做预处理工作的典型代表，例如：建立数据库连接profile允许为action记录简单的分析信息scope在session或application域中存储和检索action的状态ServletConfig提供可以访问各种基于servlet信息的actiontimer为action需要执行多少时间提供一个简单的分析信息token检查有效标记的action以防止重复的表单提交validation为action的提供验证支持如何使用拦截器？我们可以直接在struts.xml配置文件中配置Struts 2已经提供的拦截器，例如使用timer拦截器来打印执行action所需要的时间，同时还可以使用params拦截器来将request参数传递给action。1234567891011121314151617&lt;?xml version = "1.0" Encoding = "UTF-8"?&gt;&lt;!DOCTYPE struts PUBLIC "-//Apache Software Foundation//DTD Struts Configuration 2.0//EN" "http://struts.apache.org/dtds/struts-2.0.dtd"&gt;&lt;struts&gt; &lt;constant name = "struts.devMode" value = "true" /&gt; &lt;package name = "helloworld" extends = "struts-default"&gt; &lt;action name = "hello" class = "com.rovo98.struts2.HelloWorldAction" method = "execute"&gt; &lt;interceptor-ref name = "params"/&gt; &lt;interceptor-ref name = "timer" /&gt; &lt;result name = "success"&gt;/HelloWorld.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt;创建自定义拦截器在我们的应用程序中使用拦截器来透切(crosscutting)应用使用一种优雅的方式。创建自定义的拦截器很容易，只需要实现Interceptor接口就行了。12345public interface Interceptor extends Serializable &#123; void destroy(); void init(); String intercept(ActionInvocation invocation) throws Exception;&#125;其中init()方法用来初始化拦截器，destroy()方法被用来销毁拦截器。不像action，拦截器request中被重复使用，所以它需要考虑线程安全问题，特别是intercept()方法。ActionInvocation对象提供的运行环境的访问。它允许访问action本身和调用action的方法并确定action是否已经被调用。如果你不需要实现初始化和销毁拦截器的代码，可以直接继承AbstractInterceptor类，它不需要实现init()和destroy()方法。12345678910111213141516171819202122package com.rovo98.struts2;import java.util.*;import com.opensymphony.xwork2.ActionInvocation;import com.opensymphony.xwork2.interceptor.AbstractInterceptor;public class MyInterceptor extends AbstractInterceptor &#123; public String intercept(ActionInvocation invocation) throws Exception &#123; /* let us do some pre-processing */ String output = "Pre-Processing"; System.out.println(output); /* let us call action or next interceptor */ String result = invocation.invoke(); /* let us do some post-processing */ output = "Post-Processing"; System.out.println(output); return result; &#125;&#125;实际的action将通过拦截器调用invocation.invoke()方法来执行。因此我们action执行前或执行后加入我们的处理代码。框架本身通过对ActionInvocation对象的invoke()方法的第一次调用来启动该过程。每次调用invoke()，ActionInvocation都会查询其状态并执行下一个拦截器。当所有的配置的拦截器都执行完了之后，action才会被执行。下面是其工作流程图：拦截器栈不难想象，当我们为单个action配置多个拦截器时，它们很快会变得很难管理。所以Struts 2引入了拦截器栈的概念来管理。下面是一个在sturtsdefault.xml配置文件中的一个拦截器栈：12345678&lt;interceptor-stack name = "basicStack"&gt; &lt;interceptor-ref name = "exception"/&gt; &lt;interceptor-ref name = "servlet-config"/&gt; &lt;interceptor-ref name = "prepare"/&gt; &lt;interceptor-ref name = "checkbox"/&gt; &lt;interceptor-ref name = "params"/&gt; &lt;interceptor-ref name = "conversionError"/&gt;&lt;/interceptor-stack&gt;上面的拦截器栈拥有唯一标识basicStack,当我们使用这个拦截器栈时，实际上和之前配置单个拦截器使用的是同样的语法：1234&lt;action name= "hello" class= "com.rovo98.struts2.MyActoin" &gt; &lt;interceptor-ref name = "basicStack" /&gt; &lt;result&gt;/view.jsp&lt;/result&gt;&lt;/action&gt;通过上面的配置，为helloaction 配置了六个拦截器，且这六个拦截器在action被执行前将被按顺序执行。]]></content>
      <categories>
        <category>Java框架学习</category>
        <category>Struts 2</category>
      </categories>
      <tags>
        <tag>Java框架基础</tag>
        <tag>学习笔记</tag>
        <tag>Struts 2基础学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Struts 2基础学习 - Actions]]></title>
    <url>%2Fposts%2F338c78b5%2F</url>
    <content type="text"><![CDATA[action是Struts 2 框架的核心，它们适用于任何MVC框架。每个URL都映射到一个具体的action，action提供了业务逻辑处理来响应用户发起的请求。但是，action拥有另外两个重要的职能。第一， action在数据(data)从request中传递到视图(view,无论是jsp还是其他的result)的过程扮演着一个重要的角色。第二，action帮助Struts 2 来确定哪个result对应的视图(view)将被返回去响应用户的请求。创建Action创建和使用action类的唯一要求就是必须要有一个无参方法(noargument method)返回String或Result对象，并且必须是POJO(Plain Ordinary Java Object).如果该方法没有给出，默认的，execute()方法将会被执行。另外，我们可以通过继承实现了六个接口(其中包含Action interface)的ActionSupport类来创建我们的action类。 Action接口的定义如下：12345678public interface Action &#123; public static final String SUCCESS = "success"; public static final String NONE = "none"; public static final String ERROR = "error"; public static final String INPUT = "input"; public static final String LOGIN = "login"; public String execute() throws Exception;&#125;下面是一个简单的普通的 action：1234567891011121314151617package com.rovo98.struts2;public class HelloWorldAction &#123; private String name; public String execute() throws Exception &#123; return "success"; &#125; public String getNane() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125;我们说过action可以控制视图，为了验证这一点，我们对上面的action的execute()方法做简单的修改，以及继承ActionSupport类：12345678910111213141516171819202122package com.rovo98.struts2;import com.opensymphony.xwork2.ActionSupport;public class HelloWorldAction extends ActionSupport &#123; private String name; public String execute() throws Exception &#123; if ("SECRET".equals(name)) &#123; return SUCCESS; &#125; else &#123; return ERROR; &#125; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125;使用Action在struts.xml 配置文件中配置action在上面的action中，我们执行execute()方法的业务逻辑是从request对象中获取的name的值如果是&quot;SECRET&quot;的话，返回SUCCESS,否则返回ERROR。struts.xml配置文件如下：123456789101112131415&lt;?xml version = "1.0" Encoding = "UTF-8"?&gt;&lt;!DOCTYPE struts PUBLIC "-//Apache Software Foundation//DTD Struts Configuration 2.0//EN" "http://struts.apache.org/dtds/struts-2.0.dtd"&gt;&lt;struts&gt; &lt;constant name = "struts.devMode" value = "true" /&gt; &lt;package name = "helloworld" extends = "struts-default"&gt; &lt;action name = "hello" class = "com.rovo98.struts2.HelloWorldAction" method = "execute"&gt; &lt;result name = "success"&gt;/HelloWorld.jsp&lt;/result&gt; &lt;result name = "error"&gt;/AccessDenied.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt;从上面的配置文件看，当用户请求helloaction映射的URL时，HelloworldAction的execute()方法将会被执行，返回SUCCESS时，将以HelloWorld.jsp去响应用户的请求，否则以AccessDenied.jsp来响应用户的请求。]]></content>
      <categories>
        <category>Java框架学习</category>
        <category>Struts 2</category>
      </categories>
      <tags>
        <tag>Java框架基础</tag>
        <tag>学习笔记</tag>
        <tag>Struts 2基础学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Struts 2基础学习 - 配置文件]]></title>
    <url>%2Fposts%2F3fe084cc%2F</url>
    <content type="text"><![CDATA[主要了解Struts 2应用的基本配置。看看使用Struts 2的一些重要的配置文件，如：web.xml, struts.xml,struts-config.xml和struts.properties，可以对Struts 2应用做哪些配置。其实，我们只要使用web.xml和struts.xml问价就可以使用Struts 2应用。但是我们还是有必要了解一下其他配置文件。web.xml 配置文件web.xml 配置文件是 J2EE 配置文件，它决定了Servlet容器如何处理HTTP请求中的元素。严格上来说，它并不是 Struts 2 的配置文件，但是我们需要通过配置它来使 Struts 2工作。毕竟Struts 2 是基于一个Filter做Controller实现的)这个文件为任何一个Web应用提供一个入口点(entry point),而 Struts 2 应用的入口点是定义在 web.xml 文件中的一个过滤器(filter)。因此我们会在 web.xml 中顶一个 FilterDispatcher 类的入口。一个简单的web.xml文件配置例子：1234567891011121314151617181920212223242526&lt;?xml version = "1.0" Encoding = "UTF-8"?&gt;&lt;web-app xmlns:xsi = "http://www.w3.org/2001/XMLSchema-instance" xmlns = "http://java.sun.com/xml/ns/javaee" xmlns:web = "http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" xsi:schemaLocation = "http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd" id = "WebApp_ID" version = "3.0"&gt; &lt;display-name&gt;Struts 2&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt; org.apache.struts2.dispatcher.FilterDispatcher &lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt;【notice】: 这里将Struts 2 Filter映射到 /* ，而不是/*.action, 这意味着所有的url都会被Struts 2的过滤器解析。struts.xml 配置文件struts.xml 文件包含actions开发时需要修改的配置信息。这个文件可以覆盖应用的默认配置，例如：struts.devMode = false，该文件可以放置在WEB-INF/classes目录下。一个hellowordWorld例子的struts.xml配置文件：1234567891011121314151617181920&lt;?xml version = "1.0" Encoding = "UTF-8"?&gt;&lt;!DOCTYPE struts PUBLIC "-//Apache Software Foundation//DTD Struts Configuration 2.0//EN" "http://struts.apache.org/dtds/struts-2.0.dtd"&gt;&lt;struts&gt; &lt;constant name = "struts.devMode" value = "true" /&gt; &lt;package name = "helloworld" extends = "struts-default"&gt; &lt;action name = "hello" class = "com.rovo98.struts2.HelloWorldAction" method = "execute"&gt; &lt;result name = "success"&gt;/HelloWorld.jsp&lt;/result&gt; &lt;/action&gt; &lt;!-- more actions can be listed here --&gt; &lt;/package&gt; &lt;!-- more packages can be listed here --&gt;&lt;/struts&gt;一点需要注意的是 DOCTYPE，所有struts 配置文件都需要有正确的doctype信息，例如上面所展示的。标签是配置文件中的根标签元素，我们可以在里面定义不同的包(package)，使用标签可以使用配置信息模块化，当我们需要把一个大型的项目拆分成不同的模块的时候，它将非常有用。package 标签拥有以下的属性：AttributeDescriptionname(required)包的唯一标识符extends说明包继承于哪个包，默认的，我们使用struts-default作为基包(base package)abstract如果属性值为true,终端用户将无法使用该包namespaceaction类的唯一名称空间constant标签拥有name和value属性，可以重写覆盖定义在default.properites文件中的属性配置，例如我们上面提到的struts.devMode,通过设置struts.devMode属性，我们在日志文件中查看debug信息。我们通过定义一个action标签来映射我们需要访问的链接URL并定义一个实现execute()方法的类，任何时刻，当我们访问对应的链接时，该类的execute()方法都会被执行。result决定了执行action之后，返回浏览器的内容。action返回的String应该是和某个result的name属性值是一致的。result拥有两个可选的属性name和type，name属性的值默认为”success”,type默认为”dispatcher”。struts.xml配置文件在开发中可能会变得非常大，我们可以使用package将它们模块化，当然Struts还提供了另一种方式，我们可以把配置文件分割成多个xml文件，然后通过下面这种方式来将它们导入：123456789&lt;?xml version = "1.0" Encoding = "UTF-8"?&gt;&lt;!DOCTYPE struts PUBLIC "-//Apache Software Foundation//DTD Struts Configuration 2.0//EN" "http://struts.apache.org/dtds/struts-2.0.dtd"&gt;&lt;struts&gt; &lt;include file="my-struts1.xml"/&gt; &lt;include file="my-struts2.xml"/&gt;&lt;/struts&gt;【notice】: 这里有一个配置文件我们过多的提及，是struts-default.xml，该文件包含了Struts 的所有标准配置设置，在我们的开发项目中，我们可能并不会触碰到它。感兴趣的话，可以查看struts2-core-x.x.x.jar包中的default.properties文件。struts-config.xml 配置文件struts-config.xml配置文件是Web客户端中View和Model组件之间的链接，但在我们99%的开发项目中，我们并不会接触到它。配置文件主要包含以下这些主要的元素:InterceptorDescriptionstruts-config配置文件的根节点form-bean可以将ActionForm的子类映射到一个名称(name),并在整个struts-config.xml文件的其余部分中，甚至在JSP页面上，都可使用这个name作为ActionForm的别名global forwards可以将一个页面映射到一个名称(name),并使用该名称来引用实际页面。这可以避免使用网页上的硬编码(hardcoding)网址action-mapping用来声明表单处理程序，也被成为action映射controller配置Struts的内部结构，很少在实际情况中使用plug-in告诉Struts如何查看你的属性文件(properties files)，其中包含提示和错误信息struts-config.xml配置文件简单实例：1234567891011121314151617181920212223242526272829303132&lt;?xml version = "1.0" Encoding = "ISO-8859-1" ?&gt;&lt;!DOCTYPE struts-config PUBLIC "-//Apache Software Foundation//DTD Struts Configuration 1.0//EN" "http://jakarta.apache.org/struts/dtds/struts-config_1_0.dtd"&gt;&lt;struts-config&gt; &lt;!-- ========== Form Bean Definitions ============ --&gt; &lt;form-beans&gt; &lt;form-bean name = "login" type = "test.struts.LoginForm" /&gt; &lt;/form-beans&gt; &lt;!-- ========== Global Forward Definitions ========= --&gt; &lt;global-forwards&gt; &lt;/global-forwards&gt; &lt;!-- ========== Action Mapping Definitions ======== --&gt; &lt;action-mappings&gt; &lt;action path = "/login" type = "test.struts.LoginAction" &gt; &lt;forward name = "valid" path = "/jsp/MainMenu.jsp" /&gt; &lt;forward name = "invalid" path = "/jsp/LoginView.jsp" /&gt; &lt;/action&gt; &lt;/action-mappings&gt; &lt;!-- ========== Controller Definitions ======== --&gt; &lt;controller contentType = "text/html;charset = UTF-8" debug = "3" maxFileSize = "1.618M" locale = "true" nocache = "true"/&gt;&lt;/struts-config&gt;struts.properties 配置文件该配置文件提供了一种可以改变框架默认行为的机制。实际上，所有包含在struts.properties配置文集中的属性都可以在web.xml中使用init-param标签来配置。也可以在struts.xml配置文件中使用constant标签来进行配置。但是，如果你想将不同的配置信息分开，那么你可以使用struts.properties，它可以放置在WEB-INF/classes**目录下。在该文件中配置的属性值将会覆盖struts2-core.x.y.z.jar包中default.properties文件中配置的默认属性值。下面是我们开发中可能会使用到的属性值：1234567891011### When set to true, Struts will act much more friendly for developersstruts.devMode = true### Enables reloading of internationalization filesstruts.i18n.reload = true### Enables reloading of XML configuration filesstruts.configuration.xml.reload = true### Sets the port that the server is run onstruts.url.http.port = 8080]]></content>
      <categories>
        <category>Java框架学习</category>
        <category>Struts 2</category>
      </categories>
      <tags>
        <tag>Java框架基础</tag>
        <tag>学习笔记</tag>
        <tag>Struts 2基础学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Struts 2基础学习 - 架构]]></title>
    <url>%2Fposts%2F4fe73428%2F</url>
    <content type="text"><![CDATA[从高层面来看， Struts 2 是一个纯粹的 MVC (或MVC2)框架，Struts 2使用以下的五个核心部分来实现 Model-View-Controller(MVC) 模式：ActionsInterceptorsValue Stack / OGNLResults / Result typesView technologies概述相比于传统的 MVC 框架， Struts 2 略有不同， 这是因为Struts 2中的 action更多的是扮演model的角色， 而不是 controller,虽然这其中有一些重叠的地方。上面的图描述了Struts 2架构中的Model, View和Controller。controller由Struts 2的dispatch servlet filter(Servlet分发过滤器) 和 interceptors(拦截器)，actions实现Model, 视图view由result types 和 results 实现。值栈(Value Stack)和 OGNL 提供通用线程，链接和启用其他组件之间的集成。除了上述的组件外， 还有大量的关于配置的消息(information)， 对Web 应用程序的配置， 对actions的配置，以及interceptors,results等等的配置。Request 生命周期基于上面的图，我们可以了解到在Struts 2工作流中的用户请求的生命周期是这样的：用户向服务器发送一个资源(例如: 页面)请求；Struts 2 的 Dispatcher Filter 拦截请求，并选择合适Action；执行已配置的interceptors(拦截器)的功能， 例如： 表单验证，文件上传等；基于请求操作，调用并执行已选择的action；同样，如果需要，配置的拦截器可用于进行任意的后期处理；最后，将由view准备的结果(result)返回给用户。]]></content>
      <categories>
        <category>Java框架学习</category>
        <category>Struts 2</category>
      </categories>
      <tags>
        <tag>Java框架基础</tag>
        <tag>学习笔记</tag>
        <tag>Struts 2基础学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基本查找算法 - basical searching algorithms]]></title>
    <url>%2Fposts%2Fd83777d2%2F</url>
    <content type="text"><![CDATA[引入基本查找算法，我们只谈静态查找的查找算法。线性查找 - linear search特点：从头开始遍历数组，一个一个和key比较，查找成功则返回索引值。不要求数组是有序的。时间复杂度为： $O(n)$.线性查找原始抽象方法实现如下:1234567public static int linearSearch(Comparable[] a, Comparable key) &#123; for (int i = 0; i &lt; a.length; i++) &#123; if (a[i].compareTo(key) == 0) return i; &#125; return -1;&#125;跳跃查找 - jump search特点：要求查找数组有序；主要思想是每次跳跃固定量的元素来确定目标元素所在的区间，再使用线性查找在区间上搜索目标元素。时间复杂度为： $O(\sqrt{n})$.[notice] : 假设我们要在一个有n个元素的数组中搜索某个元素，最坏情况下（当目标元素为最后个元素时），这个算法要跳跃n/m步，在线性搜索时作m-1次比较。令 $f(n) = ((n/m) + m-1$.当m = $\sqrt{n}$时，f(n) 取最小值，所以通常情况下，跳跃查找所使用的固定跳跃步数为 $\sqrt{n}$.跳跃查找的原始抽象方法实现如下：1234567891011121314151617181920212223public static int jumpSearch(Comparable[] a, Comparable key) &#123; int n = a.length; int block_size = Math.floor(Math.sqrt(n)); int step = block_size; // 查找目标元素可能出现的区间 int prev = 0; while (a[Math.min(step, n) - 1].compareTo(key) &lt; 0) &#123; prev = step; step += block_size; if (prev &gt;= n) return -1; &#125; // 使用线性查找在确定的区间上查找目标元素 while (a[prev].compareTo(key) &lt; 0) &#123; prev++; if (prev == Math.min(step, n)) return -1; &#125; if (a[prev].compareTo(key) == 0) return prev; return -1;&#125;二分查找 - binary search要求数组有序。将已经排好序的数组分为两个区间(interval), 把区间的中间元素与key比较, 若大于则搜索左区间，若小于则搜索右区间，等于则返回元素的索引。当区间长度为0时（key没出现在数组中),返回-1。时间复杂度为 ： $O(nlogn)$.二分查找原始抽象方法实现如下:12345678910111213141516171819202122232425262728// 非递归实现public static int binarySearch(Comparable[] a, Comparable key) &#123; int lo = 0; int hi = a.length - 1; while (lo &lt;= hi) &#123; int mid = lo + (hi - lo) / 2; if (a[mid].compareTo(key) == 0) return mid; else if (a[mid].compareTo(key) &gt; 0) hi = mid - 1; else lo = mid + 1; &#125; return -1;&#125;// 递归实现public static int binarySearchRecursion(Comparable[] a, Comparable key, int lo, int hi) &#123; if (lo &lt;= hi) &#123; int mid = lo + (hi - lo) / 2; if (a[mid].compareTo(key) == 0) return mid; else if (a[mid].compareTo(key) &lt; 0) return binarySearchRecursion(a, key, mid+1, hi); else return binarySearchRecursion(a, key, lo, mid-1); &#125; return -1;&#125;三分查找 - ternary search特点：三分查找是二分查找的扩展；时间复杂度为 ： $O(nlog_3n)$.[notice]: 虽然看似三分查找的时间复杂度比二分查找的时间复杂度小，但是在最坏情况下，二分查找需要$2Log_2n + 1$次比较，而三分查找需要$4Log_{3}n + 1$次比较三分查找原始抽象方法实现如下：特点：类似二分查找，将查找数组划分为三个部分来进行查找；时间复杂度： $Log_3n$.12345678910111213141516171819202122// 递归实现.public static int ternarySearch(Comparable[] a, Comparable key, int lo, int hi) &#123; if (lo &lt;= hi) &#123; int mid1 = lo + (hi - lo) / 3; int mid2 = mid1 + (hi - lo) / 3; if (a[mid1].compareTo(key) == 0) return mid1; if (a[mid2].compareTo(key) == 0) return mid2; // 目标元素只可能出现在第一部分. if (a[mid1].compareTo(key) &gt; 0) return ternarySearch(a, key, lo, mid1-1); // 目标元素只可能出现在第三部分. if (a[mid2].compareTo(key) &lt; 0) return ternarySearch(a, key, mid2+1, hi); // 目标元素只可能出现在第二部分. return ternarySearch(a, key, mid1+1, mid2-1); &#125; // 查找失败. return -1;&#125;指数搜索 - exponential search特点：找到目标元素可能出现的区间；使用二分查找在区间上查找目标元素;时间复杂度： $logn$;[notice]:适用于目标数组元素大小趋向于无限大的情况；当目标出现在目标数组左边时，指数搜索速度比二分查找快。12345678public static int exponentialSearch(Comparable[] a, Comparable key) &#123; int n = a.length; int i = 1; while (i &lt; n &amp;&amp; a[i].compareTo(key) &lt; 0) &#123; i = i * 2; &#125; return binarySearch(a, key, i/2, Math.min(i, n-1));&#125;插值搜索 - interpolation search特点：原理： 假设查找数组的元素是均匀分布的，使用直线插值搜索，不像二分查找那样每次都是搜索区间中间元素。它能够快速的接近目标元素。当元素均匀分布的情况，时间复杂度为: $O(log(log n))$, 最坏情况: $O(n)$.12345678910111213141516// java program to implement interpolatoin search.public static int interpolationSearch(Comparable[] a, Comparable key) &#123; int lo = 0; int hi = a.length - 1; while (lo &lt;= hi &amp;&amp; less(key, a[hi]) &amp;&amp; less(a[lo], key)) &#123; int pos = lo + (hi - lo) * (key - a[lo]) / (a[hi] - a[lo]); if (a[pos].compareTo(key) == 0) return pos; else if (a[pos].compareTo(key) &gt; 0) hi = pos - 1; else lo = pos + 1; &#125; return -1;&#125;NOTICE本文中，涉及的算法详细实现和使用，请移步到github查看。]]></content>
      <categories>
        <category>Algorithms</category>
        <category>searching algs</category>
      </categories>
      <tags>
        <tag>basical searching algs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速排序 - quickSort]]></title>
    <url>%2Fposts%2Fd9de8e4c%2F</url>
    <content type="text"><![CDATA[引入快速排序的主要特点是：原地排序 (in-place);将长度为 N 的数组排序所需的时间和NlgN成正比；排序内循环比大多数排序算法都要短小，意味着无论是在理论上还是实际中都要更快。缺点：快速排序非常的脆弱，在实现时要非常小心才能避免低劣的性能。基本算法快速排序是一种分治排序算法，它将一个数组分成两个子数组，将两部分独立地排序。不同于归并排序，快速排序的递归调用发生在处理子数之前。快速排序方法抽象实现如下：12345678910111213141516171819202122232425262728293031public class Quick &#123; // quick sort java implement. public static void quickSort(Comparable[] a) &#123; sort(a, 0, a.length-1); assert isSorted(a); &#125; private static void sort(Comparable[] a, int lo, int hi) &#123; if (hi &lt;= lo) return; int j = partition(a, lo, hi); sort(a, lo, j-1); sort(a, j+1, hi); &#125; private static void partition(Comparable[] a, int lo, int hi) &#123; int i = lo; int j = hi + 1; Comparable v = a[lo]; while (true) &#123; while (less(a[++i], v)) &#123; if (lo == hi) break; &#125; while (less(v, a[--j])) &#123; if (j == lo) break; // redundant since a[lo] is sentinel. &#125; // Check if pointers cross. if (j &lt;= i) break; exch(a, i, j); &#125; exch(a, lo, j); return j; &#125;&#125;上述切分方法示意图: [from algs4]切分轨迹图: [from algs4]12命题 K： 将长度为N的无重复的数组排序，快速排序平均需要 ~2NlnN 次比较(以及1/6的交换)[notice]: 尽管快速排序有很多优点，它的基本实现仍有一个潜在的缺点：在切分不平衡时该算法可能及其低效。例如： 如果第一个次从最小的元素切分，第二次从第二小的元素切分，则这样每次只会移除一个元素。[solution] : 在快速排序之前将数组随机排序可以避免这种情况的发生。算法改进1.切换到插入排序和大多数递归排序算法一样(如归并)，改进快速排序的简单方法基于以下两点：对于小数组，快速排序比插入排序慢；以为递归，快速排序的sort()方法在小数组中也会调用自己。改进 ： 将sort()方法中的1if (hi &lt;= lo) return;改为：1234if (hi &lt;= lo + M) &#123; insertion.sort(a, lo, hi); return;&#125;[notice] : 这里的切换参数 M 的最佳值是和系统相关的，但是5 ~ 15 之间的任意值在大多数情况下都能令人满意。2. 三取样切分改进快速排序性能的第二个方法是使用子数组的一小部分的中位数来切分数组。这样的切分的效果更好，但代价是需要计算中位数。人们发现将取样设为 3 并用大小居中的元素切分效果最好； 我们还可以将取样元素放在数组末尾作为哨兵(sentinel)。三取样切分抽象实现 : 详细查看1234567891011121314151617181920212223242526272829303132333435363738public static void quickSortImproved(Comparable[] a) &#123; sort(a, 0, a.length-1); assert isSorted(a);&#125;private staic void sort(Comparable[] a, int lo, int hi) &#123; dealPivot(a, lo, hi); int i = lo; int j = hi - 1; Comparable v = a[hi - 1]; // set the pivot at hi -1 as a sentinel. while (true) &#123; while (less(a[++i], v)) &#123; if (i == hi-1) break; // redundant since a[hi - 1] is sentinel. &#125; while (j &gt; lo &amp;&amp; less(v, a[--j])) &#123; &#125; // check if pointers cross. if (j &lt;= i) break; exch(a, i, j); &#125; if (i &lt; hi-1) &#123; exch(a, i, hi - 1); &#125; sort(a, lo, i - 1); sort(a, i + 1, hi);&#125;// 三取样并将切分元素放在数组末尾private static void dealPivot(Comparable[] a, int lo, int hi) &#123; int mid = lo + (hi - lo) / 2; if (less(a[mid], a[lo])) exch(a, lo, mid); if (less(a[hi], a[lo])) exch(a, lo, hi); if (less(a[hi], a[mid])) exch(a, mid, hi); // put the pivot to hi - 1 as a sentinel. exch(a, mid, hi - 1);&#125;熵最优的排序实际应用中经常会出现含有大量重复元素的数组，我们实现的快速排序性能尚可，但是还有巨大的改进空间。例如：一个元素全部重复的子数组就不需要继续排序了，但我们的快速排序还是会继续将它切分为更小的数组。[solution] : 一个简单想法是将数组切分为三个部分，分别为小于、等于和大于切分元素的数组元素。DIjkstra 解法 ： 从左到右遍历数组一次，维护一个指针 lt 使得 a[lo .. lt-1]中的元素都小于v, 一个 gt 使得a[gt+1 .. hi]中的元素都大于v, 一个指针 i 使得a[lt .. i-1]中的元素都等于v, a[i .. gt]中的元素都未确定。a[i] 小于 v, 将a[lt]和a[i]交换，将lt 和 i加一；a[i] 大于 v, 将a[gt]和a[i]交换， 将gt减一；a[i] 等于 v, i++.熵最优排序抽象实现： 详细查看123456789101112131415161718192021public static void quickSort(Comparable[] a) &#123; sort(a, 0, a.length-1); assert isSorted(a);&#125;private static void sort(Comparable[] a, int lo, int hi) &#123; if (hi &lt;= lo) return; Comparable v = a[lo]; int lt = lo; int i = lo + 1; int gt = hi; while (i &lt;= gt) &#123; if (less(a[i], v)) exch(a, i++, lt++); else if (less(v, a[i])) exch(a, gt--, i); else i++; &#125; // since a[lt .. i-1] is sorted. // sort the other subarrays recursively. sort(a, lo, lt-1); sort(a, gt+1, hi);&#125;[notice] : 三向切分的最坏情况是所有主键均不相同。对于标准的快速排序，随着数组规模的增大其运行时间会趋于平均时间，大幅偏离的情况是非常罕见的，因此可以肯定三向切分的快速排序运行时间和输入的信息量的N倍是成正比的。 ———— 因为对于包含大量重复元素的数组，它将排序时间从线性对数级降到了线性级别。NOTICE本文中，涉及的算法详细实现和使用，请移步到github查看。]]></content>
      <categories>
        <category>Algorithms</category>
        <category>sorting algs</category>
      </categories>
      <tags>
        <tag>sorting algs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[归并排序 - mergeSort]]></title>
    <url>%2Fposts%2F1368334%2F</url>
    <content type="text"><![CDATA[引入归并排序属于分治算法(Divide and Conquer)。通过递归不断把待排序数组分成两个部分，将有序的两部分再重新归并一起来实现对数组的排序。[pseudo code for 2-way merge sort]:12345678910MergeSort(arr[], aux[], lo, hi)If hi &gt; lo 1. Find the middle point to divide the array into two halves; int mid = lo + (hi - lo) / 2; 2. Call MergeSort for first half; MergeSort(arr, aux, lo, mid); 3. Call MergeSort for second half; MergeSort(arr, aux, mid+1, hi); 4. Merge the two halves sorted in step 2 and 3; Call merge(arr, aux, lo, mid, hi);原地归并的抽象方法要实现上述的归并方法 — merge()很简单，创建一个数组将需要归并的原数组的两个部分中的元素放到这个数组中，然后再归并按大小顺序放回原数组。但是，这里我们要考虑一个问题，当我们用归并排序对一个比较大的数组进行排序时，我们需要进行很多次归并，因此在每一次归并时都创建一个新的数组来存储排序结果会带来问题。我们可以考虑只创建一个辅助数组aux[], 在每一个归并时，将原数组需要归并的两个部分复制到aux[]中，再把归并结果放回原数组。123456789101112131415161718192021public static void merge(Comparable[] a, Comparable[] aux, int lo, int mid, int hi) &#123; // precondition: a[lo .. mid] and a[mid+1 .. hi] is sorted. assert isSorted(a, lo, mid); assert isSorted(a, mid+1, hi); // copy a[lo .. hi] to aux[lo .. hi]. for (int k = lo; k &lt;= hi; k++) &#123; aux[k] = a[k]; &#125; int i = lo; int j = mid+1; for (int k = lo; k &lt;= hi; k++) &#123; if (i &gt; mid) a[k] = aux[j++]; else if (j &gt; hi) a[k] = aux[i++]; else if (less(aux[j], aux[i])) a[k] = aux[j++]; else a[k] = aux[i++]; &#125; // postcondition: a[lo .. hi] is sorted. assert isSorted(a, lo, hi);&#125;[说明] : 该方法先将原数组两个需要归并的部分复制到aux[]中，然后从两个部分的起始位置开始取元素，一直选择两个部分中较小的元素放回原数组中，当有一部分元素取完了，则将另一部分剩余的元素全部放回原数组。原地归并抽象方法轨迹： [from algs4]自顶向下的归并排序1234567891011121314151617public static void mergeSort(Comparable[] a) &#123; int n = a.length; Comparable[] aux = new Comparable[n]; sort(a, aux, 0, a.length-1);&#125;private static void sort(Comparable[] a, Comparable[] aux, int lo, int hi) &#123; // If array size is 1 then return. if (hi &lt;= lo) return; // Find the middle point to divide array into two halves. int mid = lo + (hi - lo) / 2; // Call the mergeSort for first half. sort(a, aux, lo, mid); // Call the mergeSort for second half. sort(a, aux, mid+1, hi); // Merge two halves sorted. merge(a, aux, lo, mid, hi);&#125;自顶向下归并结果轨迹 : [from algs4]自顶向下归并排序调用轨迹 : [from algs4]1234命题 F: 对于长度为 N 的任意数组， 自顶向下归并排序需要 1/2NlgN 至 NlgN 次比较。自顶向下的所需时间表达式为 : $T(N) = 2T(N/2) + O(n)$使用解决递归式的 Master method 解得 T(N) = $\Theta(n log n)$我们可以通过下图来理解命题F, 每个节点都表示一个sort()方法通过merge()方法归并而成的子数组。这棵树正好有 n 层。对于0 ~ n-1 之间的任意 k, 自顶向下的第 k 层有 $2^k$个子数组，每个数组长度为 $2^{n-k}$, 归并最多需要 $2^{n-k}$ 次比较。因此每层的比较次数为$2^k X 2^{n-k} = 2^n$, n 层总共为 $n2^n = NlgN$。子数组树状图 : [from algs4]123456命题 G : 对于长度为 N 的任意数组，自顶向下的归并排序最多需要访问数组 6NlgN 次。证明： 每次归并最多需要访问数组 6N 次（2N 次用来复制， 2N次用来将排好序的元素移动回去，另外最多比较2N次），根据命题F即可得到这个命题的结果。[小结]: 归并排序排序算法的缺点是辅助数组所使用的额外空间和N的大小成正比。一些能够大幅度缩短归并排序的运行时间的想法：对小规模子数组进行插入排序；测试数组是否已经有序；不将元素复制到辅助数组中。自底向上的归并排序实现归并排序另外一种方法是先归并那些微型数组， 然后再成对归并得到的子数组，直到将整个数组归并在一起。12345678910public static void MergeBU(Comparable[] a) &#123; int n = a.length; Comparable[] aux = new Comparable[n]; for (int sz = 1; sz &lt; n; sz += sz) &#123; for (int lo = sz; lo &lt; n-sz; lo += sz+sz) &#123; merge(a, aux, lo, lo+sz-1, Math.min(lo+sz+sz-1, n-1)); &#125; &#125;&#123;[注] : 自底向上的归并排序会多次遍历整个数组，根据子数组大小进行两两归并。子数组的大小 sz 的初始值为 1， 每次加倍。最后一个子数组的大小只有在数组大小是 sz 的偶数倍的时候才会等于 sz(否则它会比sz小)。自底向上归并排序结果轨迹 ： [from algs4]123456命题 H : 对于长度为 N 的任意数组， 自底向上的归并排序需要 1/2NlgN 至 NlgN次比较，最多访问数组 6NlgN 次。证明 ： 处理一个数组的遍数正好是 [lgN] (即 2^n &lt;= N &lt;2^n+1 中的 n)。每一遍会访问数组6N次。比较次数在 N/2 和 N 之间。【补充】： 当数组长度为 2 的幂时，自顶向下和自底向上的归并排序所用的比较次数和数组访问次数正好相同，只是顺序不同。其他时候，两种方法的比较和数组访问的次序会有所不同。NOTICE本文中，涉及的算法详细实现和使用，请移步到github查看。]]></content>
      <categories>
        <category>Algorithms</category>
        <category>sorting algs</category>
      </categories>
      <tags>
        <tag>sorting algs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基本排序算法 - basial sorting algorithms with java implementation]]></title>
    <url>%2Fposts%2F57d02cec%2F</url>
    <content type="text"><![CDATA[我们关注的主要对象是重新排列数组元素的算法， 其中每个元素都有一个主键。排序算法的目的就是将所有元素的主键按照某种方式排列(通常按照大小或是字母顺序)。在java中元素通常都是对象，对主键的抽象描述则是通过一种内置的机制(Comparable接口)来完成的。排序算法类模板1234567891011121314151617181920212223242526272829303132333435public class Example &#123; public static void exch(Comparable[] a, int i, int j) &#123; Comparable temp = a[i]; a[i] = a[j]; a[j] = temp; &#125; public static void sort(Comparable[] a) &#123; /*排序算法，如InsertionSort、BubbleSort、 SelectionSort、ShellSort等*/ &#125; private static void show(Comparable[] a) &#123; for (int i = 0; i &lt; a.length; i++) &#123; System.out.print(a[i] + " "); &#125; System.out.println(); &#125; public static boolean less(Comparable v, Comparable w) &#123; return v.compareTo(w) &lt; 0; &#125; public static boolean isSorted(Comparable[] a) &#123; for (int i = 1; i &lt; a.length; i++) &#123; if (less(a[i], a[i-1]) &#123; return false; &#125; &#125; return true; &#125; /** * Unit tests the &#123;@code Example&#125; sorting algorithm. * @args command-line arguments. */ public static void main(String[] args) &#123; // 测试代码... &#125;&#125;这个类展示的是数组排序实现的框架。代码中实现的排序方法适用于任意实现了Comparable接口的数据类型。验证无论数组的初始状态是什么，我们都无法确保排序算法都能成功。所以谨慎起见，我们会在测试代码中添加一条语句assert isSorted(a);来确保排序后的数组都是有序的。运行时间评估算法的性能。首先，要计算各个排序算法在不同的随机输入下的基本操作的次数(包括比较和交换，或者是读写数组的次数)。排序成本模型 : 在研究排序算法时，我们需要计算比较和交换的数量。对于不交换元素的算法，我们会计算访问数组的次数。额外的内存使用排序算法的额外内存开销和运行时间是同等重要的。排序算法可以分为两类:除了函数调用所需的栈和固定数目的实例变量之外无需额外内存的原地排序算法。需要额外内存空间来存储另一份数组副本的其他排序算法。数据类型上面的排序模板适用于实现了Comparable接口的数据类型。例如, java中封装数字类型的Integer、Double、以及String和其他许多高级数据类型。而对于自己创建的数据类型，我们是要实现Comparable接口就能够保证能够使用排序算法进行排序。自定义数据类型样例:123456789101112131415161718192021222324public class Date implements Comparable&lt;Date&gt; &#123; private final int day; private final int month; private final int year; public Date(int d, int m, int y) &#123; day = d; month = m; year = y; &#125; public int day() &#123; return day; &#125; public int month() &#123; return month; &#125; public int year() &#123; return year; &#125; public int compareTo(Date that) &#123; if (this.year &gt; that.year) return +1; if (this.year &lt; that.year) return -1; if (this.month &gt; that.month) return +1; if (this.month &lt; that.month) return -1; if (this.day &gt; that.day) return +1 if (this.day &lt; that.day) return -1; return 0; &#125; public String toString() &#123; return month + "/" + day + "/" + year; &#125;&#125;选择排序首先，找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置(如果第一个元素就是最小的元素那么它就和自己交换)。 再次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到整个数组排序完成。不断地选择剩余元素中的最小者。命题 A: 对于长度为 $N$ 的数组，选择排序需要大约 $N^2/2$ 次比较和 $N$ 次交换。证明： 可以通过算法的排序轨迹来证明，用一张$N X N$的表格来表示排序的轨迹，其中每个非灰色字符都表示一次比较。表格中大约有一半的元素不是 灰色的 — 即对角线和其上部分的元素。对角巷上的每个元素都对应真一次交换。通过查看代码我们可以更精确地得到，$0$ 到 $N-1$ 的任意 $i$ 都会 进行一次交换和 $N-1-i$ 次比较，因此 总共有$N$次交换以及 $(N-1)+（N-2)+…+2+1 = N(N-1)/2 ~ N^2/2$。算法轨迹图示（from algs4)：算法实现:123456789101112131415public class Selection &#123; /* 其他的方法同排序算法模板*/ public static void sort(Comparable[] a) &#123; int n = a.length; for (int i = 0; i &lt; n; i++) &#123; int min = i; for (int j = i+1; j &lt; n; j++) &#123; if (less(a[j], a[min]) &#123; min = j; &#125; &#125; exch(a, i, min); &#125; &#125;&#125;插入排序与选择排序一样，当前索引左边的所有元素都是有序的，但他们的最终位置不确定，为了给更小的元素腾出空间，它们可能会移动。当索引到达数组的右端时，数组排序就完成了。和选择排序不同的是，插入排序所需的时间取决于输入中元素的初始顺序。例如对于一个很大且其中的元素已经有序（或接近有序）的数组进行插入排序将会比对随机数组或逆序数组进行排序要快得多。命题 B : 对于随机排列的长度为 $N$ 且主键不重复的数组, 平均情况下插入排序需要 ~ $N^2/4$次比较以及 $~N^2/4$次交换。最坏情况下需要 ~N^2 /2 次比较和 ~ $N^2/2$次交换，最好情况下需要$N-1$次比较和$0$次交换。证明： 和证明命题A一样，通过一个$N X N$的算法轨迹表可以很容易就得到交换和比较的次数。最坏的情况下对角线之下所有元素都需要移动位置，最 好情况下都不需要。对于随机排列的数组，在平均情况下每个元素都可能向后移动半个数组的长度 ，因此交换总数是对角线之下的元素总数的二分之。 比较的总次数是交换的次数加上一个额外的项，该项为 $N$ 减去被插入的元素正好是已知的最小 元 素的次数。在最坏情况下（逆序数组），这一 项相对于总数可以忽略不计；在最好的情况下（数组已经有序），这一项等于$N-1$。插入排序算法轨迹图示（from algs4):算法实现:1234567891011public class Insertion &#123; /*其他的方法同排序算法模板*/ public static void sort(Comparable[] a) &#123; int n = a.length; for (int i = 1; i &lt; n; i++) &#123; for (int j = i; j&gt;0&amp;&amp;less(a[j], a[j-1]; j--) &#123; exch(a, j, j-1); &#125; &#125; &#125;&#125;附加：对于插入排序，我们要考虑的更一般情况是部分有序的数组。倒置指的是数组中的两个顺序颠倒的元素。比如EXAMPLE中有11对倒置：12E-A X-A X-M X-P X-L X-EM-L M-E P-L P-E L-E如果数组中倒置的数量小于数组大小的某个倍数，那么我们说这个数组是部分有序的。几种典型的部分有序的数组:数组中每个元素距离它的最终位置不远；一个有序数组接一个小数组；数组中只有几个元素位置不正确。插入排序对这样的数组很有效，而选择排序则不然。当倒置的数量很少时，插入排序比大部分的其他排序算法都要快。命题 C: 插入排序需要的交换的操作和数组的中倒置的数量相同，需要的比较次数大于等于倒置的数量，小于等于倒置的数量加上数组的大小再减一。证明： 每次交换都改变了两个顺序颠倒的元素的位置，相当于减少了一对倒置，当倒置数量为0时，排序就完成了。每次交换都对应着一次比较，且$1$ 到$N -1$之间的每个$i$都可能需要一次额外的比较(在a[i]没有达到数组的左端时)。[算法改进] : 大幅提高插入排序的速度，在内循环中将较大的元素都向右移动而不是总是交换两个元素(这样访问数组的次数就能减半)。1234567891011public static void sort(Comparable[] a) &#123; int n = a.length; for (int i = 1; i &lt; n; i++) &#123; Comparable key = a[i]; int j; for (j = i-1; j &gt;= 0&amp;&amp;less(key, a[j]); j--) &#123; a[j+1] = a[j]; &#125; a[j+1] = key; &#125;&#125;希尔排序希尔排序是基于插入排序的快速排序算法.对于规模乱序数组插入排序很慢，因为它只会交换相邻的元素，因此元素只能一点一点地从数组的一端移动到另外一端。希尔排序为了加快速度简单地改进了插入排序 —— 交换不相邻的元素以对数组的局部进行排序，并最终使用插入排序将局部有序的数组排序。希尔排序的思想:使任意间隔为h的元素都是有序的。这样的数组称为h有序数组。对于任意以1为结尾的h序列（递增序列），我们使用它都能将数组排序。算法实现： —— 使用的递增序列来自 algs4.12345678910111213141516public class Shell &#123; /*其他排序算法方法同模板*/ public static void sort(Comparable[] a) &#123; int n = a.length; int h = 1; while (h &lt; n/3) h = 3 * h + 1; // 1， 4， 13， 40， 121， ... while (h &gt;= 1) &#123; for (int i = h; i &lt; n; i++) &#123; for (int j = i; j &gt;= h&amp;&amp;less(a[j], a[j-h]); j -= h) &#123; exch(a, j, j-h); &#125; &#125; h /= 3; &#125; &#125; &#125;[递增序列的选择] : 算法的性能不仅取决于h，还取决与h之间的数学性质。目前还没有人能证明某个递增序列是”最好的”。以上算法实现使用的递增序列（使用序列 $1/2(3^k-1)$,从N/3开始递减至1.）的计算和使用都很简单且和复杂的递增序列的性能接近。算法轨迹图例 — example (from algs4):实际应用: 对于中等大小的数组它的运行时间是可以接受的且它的代码量小，不需要额外的内存空间。所以在面临一个排序问题而没有系统排序函数可用时，可先用希尔排序，然后再考虑是否将它替换为更加复杂的排序算法。[算法改进] : 由于希尔排序是基于插入排序，所以我们可以参照插入排序的改进，对希尔排序进行改进 — 把内循环中较大的元素右移而不是交换两个元素。123456789101112131415public static void sort(Comparable[] a) &#123; int n = a.length; int h = 1; while (h &lt; n/3) h = 3 * h + 1; while (h &gt;= 1) &#123; for (int i = h; i &lt; n; i++) &#123; Comparable key = a[i]; int j; for (j = i-h; j &gt;= 0&amp;&amp;less(key, a[j]); j -= h) &#123; a[j+h] = a[j]; &#125; a[j+h] = key; &#125; &#125;&#125;附加 —— 冒泡排序冒泡排序相对比较简单，这里直接给出它的实现:12345678910111213141516public class Bubble &#123; /*其他排序算法方法同排序算法模板*/ public static void sort(Comparable[] a) &#123; int n = a.length; boolean flag = true; for (int i = 1; i &lt; n&amp;&amp;flag == true; i++) &#123; flag = false; for (int j = 0; j &lt; n-i; j++) &#123; if (less(a[j+1], a[j]) &#123; exch(a, j+1, j); flag = true; &#125; &#125; &#125; &#125; &#125;算法分析: 对于冒泡排序，最坏情况下，算法需要进行N-1趟排序，总的数组元素比较的次数为$(N-1)+(N-2)+…+1$ ~ $N^2/2$， 总的交换次数为数组中倒置的数量。NOTICE本文中，涉及的算法详细实现和使用，请移步到github查看。]]></content>
      <categories>
        <category>Algorithms</category>
        <category>sorting algs</category>
      </categories>
      <tags>
        <tag>sorting algs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jsp基础学习]]></title>
    <url>%2Fposts%2F67d7cfb7%2F</url>
    <content type="text"><![CDATA[Java 服务器页面(jsp) 是用来开发动态页面的一项技术。概述JSP 允许开发人员使用指定的 JSP 标签来向html页面中插入java源代码，标签通常是以 &lt;% 开头并以 %&gt; 结束。为什么使用 JSP？使用Java服务器页面(jsp)与使用实现 Common Gateway Interface(CGI)的程序目的是大致相同的。但对比CGI，jsp有以下优点：性能较好。因为JSP允许直接在html页面中嵌入动态元素，而不需要独立持有CGI文件；JSP在服务器处理前都会进行预编译，不像 CGI/Perl, 每次页面被请求时，服务器都需要加在一个解释器(interperter) 以及目标脚本(target script);JSP是基于 Java Servlets API 构建的，因此，和Servlets一样，JSP也可以使用这些强大的Enterprise Java API, ：JDBC, JNDI, EJB, JAXP, 等等**；JSP 页面可以和处理业务逻辑的servlets结合使用，该模型由java servlet 模板引擎提供支持。最后，JSP是JavaEE(企业级应用程序的完整平台)的一个组成部分。这意味着JSP可以在最简单的应用程序中扮演最复杂和最苛刻的角色。使用JSP的优势下面通过对比不同的技术来体现使用JSP的优点：vs. Active Server Pages (ASP)对比ASP, JSP有两大优点：第一是页面的动态部分是用java写的，而不是Visual Basic或其他MS特定的语言编写，所以它更强有力且易于使用；第二是它可以移植到其他的操作系统和非Microsoft的Web 服务器上，这使它更加健壮。vs. Pure Servets（纯Servlets)使用JSP可以更容易编写和修改常规的html代码，而不是使用大量的 println语句来生成HTML。vs. Server-Side Includes (SSI)SSI 实际上只适用于处理简单内容的程序，而不适用于使用表单数据，进行数据库连接等的程序。vs. JavascriptJavaScript 可以在客户端生成HTML，但很难和Web 服务器实现复杂任务的交互，例如：数据库访问以及图像处理等。vs. 静态HTML常规的HTML不能包含动态的内容，无法动态地改变页面展示的数据。架构Web服务器需要JSP引擎（容器）才能处理JSP页面。JSP容器负责拦截JSP页面的请求。JSP容器和Web服务器一起可以为JSP提供运行环境和其他服务。使服务器可以识别JSP中的特殊元素。下面展示的是JSP容器和JSP文件在Web应用程序中的位置：JSP处理过程下面的步骤是Web服务器处理JSP生成Web页面的过程：和普通的页面一样，客户端的浏览器会向Web服务器发起一个HTTP请求。Web服务器识别出该HTTP请求是JSP请求，然后将请求转发给JSP引擎处理。即请求链接是以.jsp结尾的URL。JSP引擎从硬盘中加载JSP页面并将它转换为Servlet文件。该转换过程非常简单，将所有的模板内容都转换为println()语句，所有的JSP元素都转换为Java代码。这些Java代码实现了页面中的动态行为。JSP引擎将Servlet文件编译成可执行class文件，并将原始请求转发给servlet引擎。Servlet引擎加载Servletclass文件并执行。执行期间，生成HTML文件并放在HTTP response中，随后通过servlet引擎移交给Web服务器。Web服务器将包含静态HTML内容的HTTP响应转发到客户端浏览器。最后，客户端浏览器HTTP响应中由服务器动态生成的静态HTML内容。以上的步骤的流程图示：通常，JSP引擎会检查JSP文件对应的Servlet文件是否已经存在，若是，如果JSP文件的修改日期旧于对应的Servlet文件，JSP引擎则认为JSP没有改变且已经的生成的Servlet文件仍然匹配JSP文件的内容。这中处理使得JSP的处理和运行速度比其他的脚本语言(如：PHP）更高效、更快。其实，JSP页面是编写servlet的另外一种方式，不需要Java编程。除了上述的JSP处理过程中的翻译转换过程，JSP和一般的servlet处理方式一样。生命周期理解JSP低级功能的关键就是简单了解JSP的生命周期。JSP的生命周期就是jsp从创建到销毁的过程。该过程与servlet的生命周期类似，不过多了一个将JSP编译转换为servlet文件的步骤。JSP遵循的过程编译 (Compilation)初始化 (Initialization)执行 (Execution)销毁 (Cleanup)JSP生命周期的四个主要阶段：JSP编译阶段当浏览器请求JSP页面时，JSP引擎首先检查是否需要编译该JSP页面。如果页面还为编译过，或者JSP文件被修改，JSP引擎就编译该页面。编译阶段包含下面三个步骤：解析JSP页面将JSP转换为servlet编译servlet为class文件JSP初始化阶段当JSP容器加载JSP时，它会在处理任何请求之前调用jspInit()方法。如果需要执行特定的JSP初始化，直接覆盖jspInit()方法就行：123public void jspInit() &#123; // Initialization code...&#125;通常，和servlet的init()方法一样，该初始化方法只执行一次，一般是初始化数据库连接，打开文件和创建查找表格(look-up table)。JSP执行阶段这一阶段表示在销毁JSP之前与请求的所有交互。每当浏览器请求JSP并且页面已加载以及初始化时，JSP引擎就会调用JSP的_jspService()方法。_jspService()方法拥有两个参数HttpServletRequest和HttpServletResponse:123public void _jspService(HttpServletRequest request, HttpServletResponse response) &#123; // Service handling code...&#125;_jspService()方法在request的基础上调用。主要负责生成请求的响应，同时也可以生成所有的七种HTTP请求方式对应的响应，GET, POST, DELETE 等。JSP销毁阶段JSP生命周期的销毁阶段表示从容器中移除JSP。JSP中的jspDestroy()方法等价于servlet中的destroy()方法。通过覆盖jspDestroy()方法可以实现特定的销毁需求，例如：释放数据库连接， 关闭文件等。123public void jspDestroy() &#123; // cleanup code goes here.&#125;语法简单了解JSP开发中涉及到的语法(JSP元素的使用)。小脚本(Scriptlet)元素小脚本可以包含任意多行Java语句，变量， 方法申明，以及表达式。使用Scriptlet的语法：1&lt;% code fragment %&gt;XML方式语法的等价表达方式:123&lt;jsp:scriptlet&gt; code fragment&lt;/jsp:scriptlet&gt;其他编写的任何文本，HTML标签或JSP元素都必须为与Scriptlet之外。下面是JSP使用Scriptlet的简单示例:12345678910&lt;html&gt; &lt;head&gt;&lt;title&gt;Hello World&lt;/title&gt;&lt;/head&gt; &lt;body&gt; Hello World!&lt;br /&gt; &lt;% out.println("Your IP address is " + request.getRemoteAddr()); %&gt; &lt;/body&gt;&lt;/html&gt;申明(Declarations)元素一个申明(declaration)可以的申明一个或多个变量，方法，以便在后续的Java代码中使用。在我们是使用Scriptlet编写Java代码之前，应该申明变量或方法。JSP申明语法：1&lt;%! declaration; [declaration; ] + ... %&gt;XML等价于语法：123&lt;jsp:declaration&gt; declarations define here.&lt;/jsp:declaration&gt;简单例子：123&lt;%! int i = 0; %&gt;&lt;%! int a, b, c; %&gt;&lt;%! Circle a = new Circle(2.0); %&gt;JSP表达式元素一个JSP表达式元素可以包含一个脚本语言表达式，该表达式可以通过计算，转换为String，并插入表达式出现在JSP文件中的位置。因为表达式中的值最终是转换为String，所以我们可以在JSP文件中使用一行文本编写表达式，无论是否使用HTML标签都可以。表达式可以包含Java语言规范有效的任何表达式，但不能使用分号来结束表达式。使用JSP表达式的语法:1&lt;%= expression %&gt;XML语法等价表达方式:123&lt;jsp:expression&gt; expression&lt;/jsp:expression&gt;使用JSP表达式例子:123456&lt;html&gt;&lt;head&gt;&lt;title&gt;A Comment Test&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Today's date: &lt;%= (new java.util.Date()).toLocaleString()%&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;上面例子的运行结果可能是:1Today&apos;s date: 11-Sep-2017 21:24:11JSP注释元素JSP容器会忽略使用JSP注释标记的文本和语句。使用语法:1&lt;%-- This is JSP comment --%&gt;简单使用例子：1234567&lt;html&gt;&lt;head&gt;&lt;title&gt;A Comment Test! &lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;A Test of Comments&lt;/h2&gt;&lt;%-- This comment will not be visible in the page source --%&gt;&lt;/body&gt;&lt;/html&gt;我们可以在各种情况下使用少量的特殊结构来插入注释和字符，否则这些注释或字符将被特殊处理.SyntaxPurpose&lt;%-- comment --%&gt;JSP注释，文本内容被JSP引擎忽略&lt;!-- comment --&gt;HTML注释，文本内容被浏览器忽略&lt;\%表示静态的字符&lt;%%\&gt;表示静态的字符%&gt;\&#39;在属性中使用单引号\&quot;在属性中使用双引号JSP指令(Directives)元素JSP指令元素会影响Servletclass文件的整体结构。使用方式:1&lt;%@ directive attribute="value" %&gt;JSP中的三种指令元素：DirectiveDescription&lt;%@ page ... %&gt;定义页面相关属性，例如使用脚本语言，错误页面和缓冲请求等&lt;%@ include ... %&gt;在翻译转换阶段导入文件&lt;%@taglib ... %&gt;申明包含页面中使用的自定义标签的标签库page 指令元素page指令用于向容器提供指令。这些指令适用于当前的JSP页面。我们可以在JSP页面中的任何位置编写page指令，但是按照惯例，该指令一般写在JSP的顶部。使用page指令的基本语法:1&lt;%@ page attribute = "value" %&gt;XML语法等价表达方式:1&lt;jsp:directive.page attribute = "value" /&gt;page 指令属性下面的表格列出的是跟page指令相关的属性:AttributePurposebuffer指定输出流的缓冲模式autoFlush控制servlet输出缓冲区的行为contentType定义字符编码模式errorPage定义报告Java未检查的运行时异常的另一个JSP的URLisErrorPage指示此JSP页面是否由另一个JSP页面的errorPage属性指定extends指定生成的servlet需要继承的超类import指定JSP中是使用的包或类的列表，如Javaimport语句那样info定义一个能被servlet的getServletInfo()方法访问的字符串isThreadSafe定义生成的servlet的线程模式language定义JSP页面中使用的编程语言，默认javasession指定JSP页面是否使用HTTPsessionisELIgnored指定JSP页面内的EL表达式是否忽略isScriptingEnabled确定是否允许使用脚本元素include 指令元素include指令用于告诉容器在翻译阶段将其他的外部文件与当前JSP文件合并。我们可能在JSP页面中任何位置使用该指令元素。普通的语法:1&lt;%@ include file = "relative url" &gt;XML语法等价表达方式：1&lt;jsp:directive.include file = "relative url" /&gt;include指令中的文件名实际上是一个相对URL。如果文件名没有指定关联路径的话，JSP编译器会认为文件与当前JSP页面在同一目录下。taglib 指令元素JSPAPI允许我们定义像HTML或XML标签那样的自定义标签，标签库就是实现用户行为的自定义标签的集合。常规使用语法:1&lt;%@ taglib uri = "uri" prefix = "prefixOfTag" &gt;这里的uri属性值解析为容器能够理解的位置，prefix属性告诉容器哪些标记是自定义的。同样它也是可以使用XML语法的形式的：1&lt;jsp:directive.taglib uri = "uri" prefix = "prefixOfTag" /&gt;JSP动作(Actions)元素JSP动作元素使用XML语法结构，可以控制servlet引擎的行为。通过它，我们可以动态插入一个文件，服用JavaBeans，跳转到另一个页面，或者为Java插件生成HTML。使用JSP动作元素只用一种语法，符合XML标准:1&lt;jsp:action_name attribute="value" /&gt;动作元素其实预定义的基础函数，下面的表格展示了我们可以使用的JSP动作元素:SyntaxPurposejsp:include在页面被请求时，动态导入一个文件jsp:useBean查找或实例化一个JavaBeanjsp:setproperty为一个JavaBean设置属性jsp:getProperty将JavaBean的属性插入到输出中jsp:forward将用户转发到一个新的页面jsp:plugin用于生成特定的浏览器代码，为Java插件生成OBJECT或EMBED标记jsp:element动态定义一个XML元素jsp:attribute定义动态定义的XML元素的属性jsp:body定义动态定义的XML元素的主体(body)jsp:text用于在JSP页面和文档中写模板文本共同属性(Common Attributes)对于所有的动作元素, 它们都有两个共同的属性, 即id和scope属性。Id 属性id属性用于唯一标识动作元素，并允许在JSP页面中因引用该动作元素。如果动作元素创建某个对象的实例，则可以使用id值通过隐式对象PageContext来引用它。Scope 属性scope属性申明了动作元素的生命周期。id属性和scope属性是直接相关的，因为scope属性确定了与id相关联的对象的生命周期。scope属性有四种取值:pagerequestsessionapplication&lt;jsp:include&gt;动作元素该动作元素允许我们将文件插入到正在生成的页面中。使用语法如下：1&lt;jsp:include page = "relative URL" flush = "true" /&gt;[notice]:不像include指令元素，只在JSP页面的翻译阶段插入文件，该动作元素是在每次页面被请求时都将文件进行插入。下面的表格列出的是与include动作元素相关的属性:AttributeDescriptionpage需要被包含的页面的相对路径flush确定包含的资源是否在其被包含之前刷新其缓冲区例子：定义两个JSP页面，date.jsp和main.jsp， 并将date.jsp插入main.jsp中.date.jsp:1&lt;p&gt;Today's date: &lt;%= (new java.util.Date()).toLocaleString()%&gt;main.jsp:1234567891011&lt;html&gt; &lt;head&gt; &lt;title&gt;The include Action Example&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;center&gt; &lt;h2&gt;The include action Example&lt;/h2&gt; &lt;jsp:include page = "data.jsp" flush = "true" /&gt; &lt;/center&gt; &lt;/body&gt;&lt;/html&gt;&lt;jsp:useBean&gt;动作元素useBean动作元素非常常用，它首先使用id和scope变量搜索现有对象，如果找不到对象，则会尝试创建指定的对象。使用语法:1&lt;jsp:useBean id = "name" class = "package.class" /&gt;一旦bean类被加载后，就可以通过jsp:setProperty和jsp:getProperty动作元素来修改和检索bean的属性。下面的表格列出了与jsp;useBean相关的属性:AttributeDescriptionclass指定bean的完整包名称type指定引用该对象的变量类型beanName给出java.beans.Beans类中instantiate()方法指定的bean的名称&lt;jsp:setProperty&gt;动作元素jsp:setProperty动作元素用于设置bean的属性。在使用该动作元素之前，bean类必须预先定义。下面是使用jsp:setProperty动作元素的两种方式。1.我们可以在jsp:useBean之后，且在其元素外使用jsp:setProperty动作元素。如：123&lt;jsp:useBean id = "myName" ... /&gt;...&lt;jsp:setProperty name = "myName" property = "someProperty" ... /&gt;在上面的例子的情况下，无论是否实例化新bean或找到现有bean，都会执行jsp:setProperty动作元素。第二种方式是jsp:setProperty可以出现在jsp:useBean元素的主体中。1234&lt;jsp:useBean id = "myName" &gt; ... &lt;jsp:setProperty name = "myName" property = "someProperty" ... /&gt;&lt;/jsp:useBean&gt;这种情况下，jsp:setProperty元素只有在创建新的bean时，才会被执行。下面是与jsp:setProperty元素相关的属性:AttributeDescriptionname指定设置属性的bean，bean必须预先定义property申明想要设置的属性。取值*的话，则表示名称与bean属性匹配的所有请求参数将传递给相应的setter方法value要分配给指定属性的值。参数值为null，或者参数不存在，将忽略jsp:setProperty操作paramparam属性是请求参数的名称，该属性将接受其值。不能同时使用value和param属性jsp:getProperty动作元素jsp:getProperty动作元素用于检索给定属性的值，并将它转换为String字符串，最后插入到输出中。该动作元素只有两个属性，且它们都是必须的。使用语法如下:123&lt;jsp:useBean id = "myName" ... /&gt;...&lt;jsp:getProperty name = "myName" property = "someProperty" ... /&gt;下面的表格给出了与getProperty元素的相关属性:AttributeDescriptionname要检索属性的bean的名称。bean必须预先定义property要检索的属性名称jsp:setProperty和jsp:getProperty使用例子：定义一个简单的TestBean.java:1234567891011package test.beans;public class TestBean &#123; private String message = "No message specified"; public String getMessage() &#123; return message; &#125; public vodi setMessage(String message) &#123; this.message = message; &#125;&#125;在main.jsp页面中做测试：12345678910111213141516&lt;html&gt; &lt;head&gt; &lt;title&gt;Using JavaBeans in JSP&lt;/title&gt; &lt;body&gt; &lt;center&gt; &lt;h2&gt;using JavaBeans in JSP&lt;/h2&gt; &lt;jsp:useBean id = "test" class = "test.beans.TestBean" /&gt; &lt;jsp:setProperty name = "test" property = "message" value = "Hello JSP" /&gt; &lt;p&gt;Got message....&lt;/p&gt; &lt;jsp:getProperty name = "test" property = "message" /&gt; &lt;/center&gt; &lt;/body&gt; &lt;/head&gt;&lt;/html&gt;jsp:forward动作元素jsp:forward动作元素会终止当前页面的操作，并将请求转发到另一个资源，例如：静态页面，另一个JSP页面或Java Servlet。使用jsp:forward动作元素的语法：1&lt;jsp:forward page = "Relative URL" /&gt;下面的表格给出了与该动作元素相关的必须属性:AttributeDescriptionpage另一个资源的相对URL，例如：静态页面，另一个JSP页面，或者一个Java Servlet使用例子: 定义date.jsp和main.jsp，并使用在main.jsp页面中跳转到date.jsp页面:date.jsp:1&lt;p&gt;Today's date: &lt;%= (new java.util.Date()).toLocaleString()%&gt;&lt;/p&gt;main.jsp:123456789101112&lt;html&gt; &lt;head&gt; &lt;title&gt;The include Action Example&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;center&gt; &lt;h2&gt;The include action Example&lt;/h2&gt; &lt;jsp:forward page = "date.jsp" /&gt; &lt;/center&gt; &lt;/body&gt;&lt;/html&gt;运行结果可能是:1Today&apos;s date: 12-July-2017 14:54:22jsp:plugin动作元素jsp:plugin动作元素用于在JSP页面中插入Java组件。它确定浏览器的类型，并根据需要插入的&lt;object&gt;或&lt;embed&gt;标签。如果所需的插件不存在，则下载插件然后执行Java组件。Java组件可以是Applet或JavaBean。该动作元素有几个属性，对应用于格式化java组件的常用HTML标签元素。&lt;param&gt;元素也可用于将参数发送到Applet或Bean中。以下是使用jsp:plugin元素的语法：12345678&lt;jsp:plugin type = "applet" codebase = "dirname" code = "MyApplet.class" width = "60" height = "80" &gt; &lt;jsp:param name = "fontcolor" value = "red" /&gt; &lt;jsp:param name = "background" value = "black" /&gt; &lt;jsp:fallback&gt; Unable to initialize Java Plugin &lt;/jsp:fallback&gt;&lt;/jsp:plugin&gt;上面的&lt;jsp:fallback&gt;元素可用于指定在组件发生故障时要发送给用户的错误字符串。&lt;jsp:element&gt;, &lt;jsp:attribute&gt;和&lt;jsp:body&gt;动作元素主要用于动态定义XML元素。这意味着XML元素可以在请求时动态生成，而不是在编译时静态生成。下面是动态定义XML元素的一个简单例子:12345678910111213141516171819&lt;%@page language = "java" contentType = "text/html"%&gt;&lt;html xmlns = "http://www.w3c.org/1999/xhtml" xmlns:jsp = "http://java.sun.com/JSP/Page"&gt; &lt;head&gt;&lt;title&gt;Generate XML Element&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;jsp:element name = "xmlElement"&gt; &lt;jsp:attribute name = "xmlElementAttr"&gt; Value for the attribute &lt;/jsp:attribute&gt; &lt;jsp:body&gt; Body for XML element &lt;/jsp:body&gt; &lt;/jsp:element&gt; &lt;/body&gt;&lt;/html&gt;在运行时就会生成下面的HTML代码；123456789&lt;html xmlns = "http://www.w3c.org/1999/xhtml" xmlns:jsp = "http://java.sun.com/JSP/Page"&gt; &lt;head&gt;&lt;title&gt;Generate XML Element&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;xmlElement xmlElementAttr = "Value for the attribute"&gt; Body for XML element &lt;/xmlElement&gt; &lt;/body&gt;&lt;/html&gt;jsp:text动作元素&lt;jsp:text&gt;动作元素主要用于在JSP页面中编写模板文本。使用语法如下:1&lt;jsp:text&gt;Tempate data &lt;/jsp:text&gt;模板的主体不能包含其他元素，只能包含EL表达式。在XML文件中，不能使用${whatever &gt; 0}, 因为&gt;在这里是不允许的，需要书写成${whatever gt 0}，另一种方法是将值嵌入CDATA部分。1&lt;jsp:text&gt;&lt;![CDATA[&lt;br&gt;]]&gt;&lt;/jsp:text&gt;如果需要包含DOCTYPE申明(例如XHTML)，可以使用&lt;jsp:text&gt;元素，如下所示:1234567891011&lt;jsp:text&gt;&lt;![CDATA[&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd"&gt;]]&gt;&lt;/jsp:text&gt; &lt;head&gt;&lt;title&gt;jsp:text action&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;books&gt;&lt;book&gt;&lt;jsp:text&gt; Welcome to JSP Programming &lt;/jsp:text&gt;&lt;/book&gt;&lt;/books&gt; &lt;/body&gt;&lt;/html&gt;JSP隐式(Implicit)对象JSP支持九个自动定义的变量，它们被称为隐式对象。ObjectDescriptionrequest与请求关联的HttpServletRequest对象response与客户端响应关联的HttpServletResponse对象outPrintWriter对象，用于输出文本到客户端session与请求关联的HttpSession对象application与应用程序上下文(application context)关联的ServletContext对象config与页面关联的ServletConfig对象pageContext封装了特定的服务器功能，如性能更高的JspWriterspage与Java中的this一样，主要用于调用已转换为servlet类中定义的方法ExceptionException对象允许指定的JSP访问异常数据request对象request对象是javax.servlet.http.HttpServletRequest对象的一个实例。每次客户端发起请求时，JSP引擎都会创建一个新的request对象来表示请求。request提供获取HTTP头部信息（如：表单数据、cookies、HTTP方法等）的方法。response对象response对象是javax.servlet.http.HttpServletResponse对象的实例。和request一样，服务器也会创建response来代表客户端响应。response对象还定义了处理创建新HTTP头部的接口。通过这个对象，JSP开发人员可以添加新的cookie或者时间戳，HTTP状态码等。out对象out隐式对象是javax.servlet.jsp.JspWriter对象的一个实例。用于向response发送内容。初始的JspWriter兑现过的实例化取决于页面是否缓冲。通过使用page指令元素的buffered=&#39;false&#39;属性，可以轻松关闭缓冲。JspWriter对象包含很多和java.io.PrintWriter类相同的方法。但是，JspWriter拥有额外的方法用于处理缓冲(buffering)。不同与PrintWriter对象，JspWriter还会抛出IOExceptions。下面的表格列出了使用out对象写入char, int, double, object, String等的重要方法。MethodDescriptionout.print(dataType dt)打印数据类型值out.println(dataType dt)打印数据类型值，并换行out.flush()刷新流，清楚缓冲区session对象session对象是javax.servlet.http.HttpSession对象的一个实例，其行为和Java Servlets下的Session对象行为完全相同。session对象主要用于跟踪客户端请求之间的客户端回话。application对象application对象是生成servlet的ServletContext对象的直接包装器(direct wrapper),实际上是javax.servlet.ServletContext对象的实例。该对象是JSP页面整个生命周期的表示。初始化JSP页面时会创建对象，并且在jspDestroy()方法执行删除JSP页面时，该对象也会被删除。通过向application添加属性，可以使Web应用程序中所有JSP页面都可以访问该属性。config对象config对象是javax.servlet.ServletConfig对象的实例，是生成servlet的ServletConfig对象的直接包装器。使用该对象可以使JSP开发人员访问Servlets或JSP引擎的初始化参数（如：文件路径等）。下面是config对象中我们唯一会使用到的方法，用法也很简单:1config.getServletName();该方法返回servlet的名字，这些名字一般定义在WEB-INF\web.xml中的&lt;servlet-name&gt;的元素内。pageContext对象pageContext对象是javax.servlet.jsp.PageContext对象的一个实例。pageContext对象用于表示整个JSP页面。该对象旨在获取有关页面的相关信息，同时避免大多数的实现细节。pageContext会保存每个请求对应的request和response对象的引用。application, config, session以及out对象都是通过访问该对象的属性派生的。pageContext对象还包含有关发布到JSP页面的指令的信息，包括缓冲信息，errorPageURL和page Scope。PageContext类中定义了许多属性，其中包含PAGE_SCOPE, REQUEST_SCOPE, SESSION_SCOPE和APPLICATION_SCOPE,这些刚好对应页面的页面范围(scope)。它还拥有40多种方法，大约一一半是从javax.servlet.jsp.JspContext类继承来的。其中一个重要的方法是 :removeAttribute，该方法接受一个或两个参数。例如：pageContext.removeAttribute(&quot;attrName&quot;);从所有范围中删除该属性，下面的代码是从指定范围中移除属性:1pageContext.removeAttribute("attrName", PAGE_SCOPE);page对象page对象是对页面的实际引用。它可以被认为是代表整体JSP页面的对象。page对象实际上是this对象的直接同义词。exception对象exception对象是一个包装器(wrapper),包含从上一个页面抛出的异常。它通常用于生成针对特定错误的response对象。控制流语句 (Control-Flow Statements)我们可以在JSP编程中使用Java的所有API，例如：流程控制语句等。决策语句 (Decision-Making Statements)if ... else块像普通的Scriptlet一样开始，但Scriptlet在每一行都关闭，Scriptlet标签之间包含有HTML文本。12345678910111213&lt;%! int day = 3; %&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;IF ... ELSE Example&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;% if (day == 1 || day == 7) &#123; %&gt; &lt;p&gt;Today is weekend&lt;/p&gt; &lt;% &#125; else &#123; %&gt; &lt;p&gt;Today is not weekend&lt;/p&gt; &lt;% &#125; %&gt;&lt;/body&gt;&lt;/html&gt;上面的程序代码输出结果为：1Today is not weekend下面看一下如何使用switch ... case块并使用out.println()：12345678910111213141516171819202122232425262728293031&lt;%! int day = 3; %&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;SWITCH .. CASE Example&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;% switch(day) &#123; case 0: out.println("It\'s Sunday."); break; case 1: out.println("it\'s Mondya."); break; case 2: out.println("It\'s Tuesday."); break; case 3: out.println("it\'s WEdnesday."); break; case 4: out.println("It\' Thursday."); break; case 5: out.println("It\'s Friday."); break; default: out.println("it\'s Saturday."); &#125; %&gt;&lt;/body&gt;&lt;/html&gt;运行结果为：1It&apos;s Wednesday.循环语句同样在JSP中使用循环语句块也是可以的，例如：for, while,以及do ... while。简单的使用for循环语句的例子：12345678910111213&lt;%! int fontSize; %&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;FOR LOOP Example&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;% for (fontSize = 1; fontSize &lt; - 3; fontSize++) &#123; %&gt; &lt;font color = "green" size = &lt;%= fontSize %&gt;"&gt; JSP Test &lt;/font&gt;&lt;br /&gt; &lt;% &#125; %&gt;&lt;/body&gt;&lt;/html&gt;JSP数据类型 (Literals)JSP表达式定义了下面的数据类型:Boolean — true 或者 falseInteger — 与Java中一样Floating point — 与Java中一样String — 以单引号或双引号包围起来的字符串Null — null客户端请求(Client Request)当浏览器请求网页时，它会向Web服务器发送大量的信息。一般无法直接读取这些信息，因为它们是作为HTTP请求的头部的一部分来发送的。下面的表格列出了来自浏览器的重要头部信息。它们经常用于Web编程:HeaderDescriptionAccept此header指定浏览器或其他客户端可以处理的MIME类型。image/png或image/jpeg是两种常见的取值Accept-Charset此header指定浏览器可用于显示信息的字符集, 例如: ISO-8859-1Accept-Encoding此header指定浏览器能够处理的编码类型, gizp和compress是两种常见的取值Accept-Language此header指定客户端的首选语言，servlet可以使用多种语言来生成结果。例如：en, en-us, ru等Authorization在访问受密码保护的网页时，浏览器使用此header来标识自己Connection此header指定客户端是否可以处理持久HTTP连接。使用持久连接可以使客户端或其他浏览器在单个请求内检索多个文件。取值keep-Alive表示使用持久连接Content-Length此header只适用于POST请求，并以字节为单位给出POST数据的大小Cookie此header将cookie返回给先前已将其发送到浏览器的服务器Host此header指定原始URL中给出的主机和端口If-Modified-Since此header申明客户端仅在指定日期之后更改页面时才需要该页面。如果没有可用的更新结果，服务器会发送代码304，意味着header 为Not ModifiedIf-Unmodified-Since此header与If-Modified-Since相反，它指定仅当文档早于指定日期时操作才会成功Referer此header指定引用网页的URL。例如，如果在网页1中并单机指向网页2的链接，则当浏览器请求网页2时，网页1的URL将包含在Referer header中User-Agent该header用于标识发出请求的浏览器或者其他客户端，可用于将不同内容返回到不同类型的浏览器HttpServletRequest对象之前已经了解到，request对象是HttpServletRequest对象的实例。每次客户端发起请求时，JSP引擎都会创建一个request对象来表示该请求。request对象提供了获取HTTP header信息的方法。header信息包括form data, cookie, HTTP methods等等。下面的表格列出了JSP程序用于读取HTTP header信息的重要方法。这些方法适用于HttpServletRequest对象。MethodDescriptionCookie[] getCookies()返回一个包含客户端使用该请求发送的所有Cookie对象Enumeration getAttributeNames()返回包含此请求中所有可用属性名称的Enumeration对象Enumeration getHeaderNames()返回包含此请求中包含的所有header名称的Enumeration对象Enumeration getParameterNames()返回String对象的Enumeration对象，其中包含此请求中包含的参数的名称HttpSession getSession()返回与当前请求相关联的HttpSession对象，如果该请求没有对应的session对象，则创建一个HttpSession getSession(boolean create)返回与此请求关联的当前的HttpSession对象，如果没有当前session且create为true，则返回一个新HttpSession对象Locale getLocale()根据Accept-Language header返回客户端将接受内容的的首选语言环境Object getAttribute(String name)以Object形式返回指定属性的值，如果不存在给定名称的属性，则返回nullServletInputStream getInputStream()使用ServletInputeStream以二进制数据的形式检索请求的主体String getAuthType()返回用于保护servlet的身份验证方案的名称，例如&quot;BASIC&quot;或&quot;SSL&quot;,如果JSP未受保护，则返回nullString getCharacterEncoding()返回该请求正文中使用的字符编码的名称String getContentType()返回请求正文的MIME类型，如果类型未知，则返回nullString getContextPath()返回请求URI的一部分，代表请求的上下文String getHeader(String name)以String的形式返回指定header的值String getMethod()返回用于发出该请求的HTTP方法的名称，例如:GET, POST, PUTString getParameter(String name)以String形式返回请求中的参数的值，如果参数不存在，则返回nullString getPathInfo()返回与客户端发出此请求时发送的URL关联的任何额外的路径信息String getProtocol()返回请求使用的协议的名称和版本String getQueryString()返回路径后面请求URL中包含的查询字符串String getRemoteAddr()返回发送请求的客户端的Internet协议(IP)地址String getRemoteHost()返回发送请求的客户端的完全限定名称String getRemoteUser()如果用户已通过身份验证，则返回发出此请求的用户的登录名； 如果用户尚未通过身份验证，则返回nullString getRequestURI()从协议名称到HTTP请求第一行中的查询字符串返回此请求的URL部分String getRequestedSessionId()返回客户端指定的回话(session)IDString getServletPath()返回该请求中调用的JSP的URL的一部分String[] getParameterValues(String name)返回包含给定请求参数所具有的所有值的String对象数组，如果参数不存在，则返回nullboolean isSecure()返回一个boolean值，表示该请求是否使用安全隧道, 如HTTPSint getContentLength()返回请求正文的长度(以字节为单位)，并使输入流能够访问，如果长度未知，则返回-1int getIntHeader(String name)以int形式返回指定header的值int getServerPort()返回接受该请求的端口号HTTP Header请求示例下面的例子，使用HttpServletRequest的getHeaderNames()方法来读取HTTP的头部信息。该方法返回一个Enumeration对象，其中包含与当前HTTP请求关联的header的信息。一旦我们有了Enumeration对象，我们就可以使用标准方式循环打印其中的信息。这里使用hasMoreElement()来判断什么时候停止循环，并用nextElement()返回获取每个参数对应的值。123456789101112131415161718192021222324252627282930&lt;%@ page import = "java.io.*,java.util.*" %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;HTTP Header Request Example&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;center&gt; &lt;h2&gt;HTTP Header Request Example&lt;/h2&gt; &lt;table width = "100%" border = "1" align = "center"&gt; &lt;tr bgcolor = "#949494"&gt; &lt;th&gt;Header Name&lt;/th&gt; &lt;th&gt;Header Value(s)&lt;/th&gt; &lt;/tr&gt; &lt;% Enumeration headerNames = request.getHeaderNames(); while(headerNames.hasMoreElements()) &#123; String paramName = (String)headerNames.nextElement(); out.print("&lt;tr&gt;&lt;td&gt;" + paramName + "&lt;/td&gt;\n"); String paramValue = request.getHeader(paramName); out.println("&lt;td&gt; " + paramValue + "&lt;/td&gt;&lt;/tr&gt;\n"); &#125; %&gt; &lt;/table&gt; &lt;/center&gt; &lt;/body&gt;&lt;/html&gt;运行结果：服务器响应(Server Response)Http 状态码(Status Codes)表单处理(Form Handling)过滤器(Filters)Cookies 处理(Cookies Handing)Session 跟踪(Session Tracking)文件上传(File Uploading)日期处理(Handing Date)页面重定向(Page Redirect)自动刷新(Auto Refresh)发送邮件(Sending Mail)]]></content>
      <categories>
        <category>JavaWeb</category>
        <category>JSP</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>jsp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式基本使用]]></title>
    <url>%2Fposts%2Ff85f3c07%2F</url>
    <content type="text"><![CDATA[regular expression regex RE简介正则表达式是用来简洁表达一组字符串的表达式。正则表达式——一行胜千言通用的字符串表达框架简洁表达一组字符串的表达式针对字符串表达“简洁”和“特征”思想的工具判断某一字符串的特征归属正则表达式在文本处理中十分常用表达文本类型的特征(病毒、入侵等)同时查找或替换一组字符串匹配字符串的全部或部分正则表达式主要应用在字符串的匹配中正则表达式的使用编译：将符合正则表达式语法的字符串转换成正则表达式特征。—— re.compile(regex)正则表达式的语法正则表达式常用的操作符操作符说明实例.表示任何单个字符[ ]字符集，对单个字符给出取值范围[abc]表示a、b、c, [a-z]表示a到z单个字符[^ ]非字符集，对单个字符给出排除范围[^abc]表示非a或b或c的单个字符*前一个字符0次或无限次扩展abc*表示ab、abc、abcc、abcc等+前一个字符1次或无限次扩展abc+表示abc、abcc、abccc等?前一个字符0次或1次扩展abc?表示ab、abc&#124;左右表达式任意一个abc &#124; def表示abc、def{m}扩展前一个字符m次ab{2}c表示abbc{m,n}扩展前一个字符m至n次ab{1,2}c表示abc、abbc^匹配字符串开头^abc表示abc且在一个字符串的开头$匹配字符串结尾abc$表示abc且在一个字符串的结尾( )分组标记，内部只能使用 &#124; 操作符(abc)表示abc ，(abc&#124;def)表示abc、def\d数字，等价于[0-9]\w单词字符，等价于[A-Za-z0-9]经典正则表达式实例^[A-Za-z]+$由26个字母组成的字符串^[A-za-z0-9]+$由26个字母及数字组成的字符串^-?\d+$整数形式的字符串^[0-9]\*\[1-9][0-9]*$正整数形式的字符串[1-9]\d{5}中国境内的邮政编码，6 位[\u4e00-\u9fa5]匹配中文字符\d{3}-\d{8} &#124; \d{4}-\d{7}国内电话IP地址:不精确的写法：\d+.\d+.\d+.\d+ —— 以四个点进行分隔作为特点\d{1,3}.\d{1,3}.\d{1,3}.\d{1,3}精确写法：0-99 : [0-9]?\d 100-199 : 1\d{2}200-249 : 2[0-4]\d 250-255 : 25[0-5](([0-9]?\d|1\d{2}|2[0-4]\d|25[0-5]).){3}([0-9]?\d|1\d{2}|2[0-4]\d|25[0-5])Re库的基本使用Re库介绍Re库是Python的标准库，主要用于字符串匹配。1import re正则表达式的表示类型raw string 类型(原生字符串类型) —— 不包含转义字符re 库采用raw string 类型表示正则表达式，表示为：r’text’string类型， 更繁琐 —— 需要双重转义Re库的主要功能函数函数说明re.search()在一个字符串中搜索匹配正则表达式的第一个位置，返回match对象re.match()在一个字符串开始位置起匹配正则表达式，返回match对象re.findall()搜索字符串，以列表类型返回全部能匹配的子串re.spilt()将一个字符串按照正则表达式匹配结果进行分割，返回列表类型re.fiinditer()搜索字符串，返回一个匹配结果的迭代类型，每个迭代元素是matchre.sub()在一个字符串中替换所有匹配正则表达式的子串，返回替换后的字符串re.search(pattern, string,flags=0)在一个字符串中搜索匹配正则表达式的第一个位置，返回match对象pattern: 正则表达式的字符串或者原生字符串 表示string : 待匹配字符串flags : 正则表达式使用时的控制标记常用标记说明re.I re.IGNORECASE忽略正则表达式的大小写，[A-Z]能够匹配小写字符re.M RE.MULTILINE正则表达式中的^操作符能够将给定字符串的每行当作匹配开始re.S RE.DOTALL正则表达式中的.操作符能够匹配所有字符，默认匹配除换行符外的所有字符re.match(partern, string, flags=0)从一个字符串的开始位置起匹配正则表达式，返回match对象re.findall(pattern, string , flags=0)搜索字符串，以列表类型返回全部能匹配的子串。pattern ： 正则表达式的字符串或原生字符串表示string ： 待匹配字符串flags: 正则表达式使用时的控制标记re.split(pattern, string, maxsplit=0, flags=0)将一个字符串按照正则表达式匹配结果进行分割，返回列表类型。maxsplit: 最大分割数re.finditer(patern, string, flags=0)搜索字符串，返回一个匹配结果的迭代类型，每一个迭代元素是match对象。re.sub(pattern, repl, string, count=0, flags=0)在一个字符串中替换所有匹配正则表达式的子串，返回替换后的字符串。repl: 替换匹配字符串的字符串count： 替换的最大次数Re库的另一种等价用法1234567rst = re.search(r'[1-9]\d&#123;5&#125;', 'BIT100081')#函数式用法： 一次性操作#面向对象用法：编译后的多次操作pat = re.compile(r'[1-9]\d&#123;5&#125;')rst = pat.search('BIT100081')regex = re.compile(pattern, flags=0)将正则表达式的字符串形式编译成正则表达式对象Re库的match对象Match对象的属性属性说明.string待匹配文本.re匹配时使用的pattern对象()正则表达式.pos正则表达式搜索文本的开始位置.endpos正则表达式搜索文本的结束位置Match对象的方法方法说明.group(0)获得匹配后的字符串.start()匹配字符串在原始字符串的开始位置.end()匹配字符串在原始字符串的结束位置.span()返回(.start(),.end()) — 元组类型Re库的贪婪匹配和最小匹配Re库默认采用贪婪匹配最小匹配操作符操作符说明*?前一个字符0次或无限次扩展，最小匹配+?前一个字符1次或无限次扩展，最小匹配??前一个字符0次或1次扩展，最小匹配{m,n}?扩展前一个字符m至n次(含n)，最小匹配高效的正则表达式技巧总结误匹配指正则表达式所匹配的内容范围超过了所需要范围，有些文本命名不符合要求，但是被所写的正则表达式“击中”了。例如：如果使用\d{11}去匹配11位手机号，\d{11}不单单能匹配正确的手机号，它还会匹配98824839344这样明显不是手机号的字符串。我们把这样的匹配称为误匹配。漏匹配指正则表达式所匹配的内容所规定的范围太狭窄，有些文本确实是所需要的，但是所写的正则表达式没有将这种情况囊括在内。例如：使用\d{18}来匹配身份证号码，就会漏掉结尾是字母X的情况。写出一条正则表达式，既可能出现误匹配(条件写得太宽松，范围大于目标文本)，也可能出现漏匹配(只描述了目标文本中多种情况的部分)，还可能既有误匹配又有漏匹配。例如：使用\w+\.com来匹配.com结尾的域名，既会误匹配abc\_.com(合法域名不包含\_,\w包含了这种情况),又会漏掉ab-c.com这样的域名(合法域名可以包含中划线，\w不包含中划线).应对方法掌握语法细节正则表达式在各种语言中，其语法大致相同，细节各有千秋。明确所使用语言的正则的语法的细节，是写出正确、高效正则表达式的基础。例如，perl中与\w等效的匹配范围是[a-zA-Z0-9\_];perl正则表达式不支持肯定逆序视中使用可变的重复(variable repetition inside lookbehind,例如( ?&lt;=.* )abc), 但是.Net语法是支持这一特性的；又如，JavaScript连逆序环视(lookbehind,如(?&lt;=ab)c)都不支持，而Perl和Python是支持的。&lt;&lt;精通正则表达式&gt;&gt;第三章&lt;&lt;正则表达式的特性和流派概览&gt;&gt;明确地列出了个大派系的正则表达式的异同。先粗后精，先减后加使用正则表达式语法对于目标文本进行描述和界定，可以像画素描一样，先大致勾勒出框架，在逐步在局部实现细节。仍举刚才的手机例子：先界定\d{11},总不会错；再细化为1[358]\d{9},就向前迈了一大步。先消除 漏匹配(刚开始先尽可能多的匹配，做加法)，然后再一点点去除误匹配(做减法)。]]></content>
      <categories>
        <category>Python</category>
        <category>python爬虫</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>regex基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解Requests库的异常和HTTP协议]]></title>
    <url>%2Fposts%2F4ae864e2%2F</url>
    <content type="text"><![CDATA[简单理解Requests库中的异常和HTTP协议。异常说明requests.ConnectionError网络连接错误异常，如DNS查询失败、拒绝连接等requests.HTTPErrorHTTP错误异常requests.URLRequiredURl缺失异常requests.TooManyRedirects超过最大重定向次数，产生重定向异常requests.ConnectTimeout连接远程服务器超时异常requests.Timeout请求URL超时，产生超时异常Response的异常：异常说明r.raise_for_status()如果不是200， 产生异常requests.HTTPError爬取网页的通用代码框架123456789101112import requestsdef getHTMLText(url) : try: r = requests.get(url, timeout=30) r.raise_for_status() #如果状态不是200， 引发requests.HTTPError异常 r.encoding = r.apparent_encoding #将encoding 设置为'utf-8'，一般用于没有charset的header return r.text except: return '产生异常'if __name__ == '__main__': url = "http://www.baidu.com" print(getHTMLText(url))HTTP协议HTTP, Hypertext Transfer Protocol, 超文本传输协议HTTP是一个基于“请求与响应”模式的、无状态的应用层协议。HTTP协议采用URL作为定位网络资源的标识。URL格式： http://host[ :port ][ path ]HTTP URL的理解：URL 是通过HTTP协议存取资源的Internet路径，一个URL对应一个数据资源。HTTP协议对资源的操作方法说明GET请求获取URL位置的资源HEAD请求获取URL位置资源的响应消息报告，即获取该资源的头部信息POST请求URL位置的资源后附加新的数据PUT请求向URL位置存储一个资源，覆盖原URL位置的资源PATCH请求局部更新URL位置的资源，即改变该处资源的部分内容DELETE请求删除URL位置存储的资源理解PATCH和PUT的区别：假设URL位置有一组数据UserInfo， 包括UserID、UserName等20个字段需求：用户修改了UserName，其他不变。采用PATCH，仅向URL提交UserName的更新请求。采用PUT，必须将所有20个字段一并提交URL，未提交字段被删除。PATCH的好处：节省网络带宽]]></content>
      <categories>
        <category>Python</category>
        <category>python爬虫</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>Requests库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Requests库的7个主要方法]]></title>
    <url>%2Fposts%2Fc671c604%2F</url>
    <content type="text"><![CDATA[Requests库的7个主要方法方法说明requests.request()构造一个请求，支撑以下各方法的基础方法requests.get()获取HTML网页的主要方法，对应于HTTP的GETrequests.head()获取HTML网页头信息的方法，对应于HTTP的HEADrequests.post()向HTML网页提交POST请求的方法，对应于HTTP的POSTrequests.put()向HTML网页提交PUT请求的方法，对应于HTTP的PUTrequests.patch()向HTML网页提交局部修改请求，对应于HTTP的PATCHrequests.delete()向HTML页面提交删除请求，对应HTTP的DELETErequests库的主要方法(基础方法)requests.request(method, url, **kwargs)method:请求方式，对应get/put/post等7种r = requests.request(&#39;GET&#39;,url, **kwargs)r = requsts.request(&#39;HEAD&#39;,url, **kwargs)r = requests.request(&#39;POST&#39;,url, **kwargs)r = requests.request(&#39;PATCH&#39;,url, **kwargs)r = requests.request(&#39;delete&#39;, url, **kwargs)r = requests.request(&#39;OPTIONS&#39;,url, **kwargs)url:拟获取页面的URL链接**kwargs: 控制访问的参数，共13个1)params:字典或字节序列，作为参数增加到URL中2)data: 字典、字节序列或者文件对象，作为Request的内容3)json : JSON格式数据，作为Request内容4)headers : 字典，HTTP定制头5)cookies : 字典或CookieJar，Request中的cookie6)auth : 元组，支持HTTP认证功能7)files : 字典类型，传输文件8)timeout : 设定的超时时间，秒为单位9)proxies : 字典类型，设定访问代理服务器，可以增加登录认证10)allow_redirects : True/False, 默认为True,重定向开关11)stream : True/False, 默认为True ,获取内容立即下载开关12)verify : True/False , 默认为True ， 认证SSL证书开关13) cert : 本地SSL证书路径requests.get()方法：12r = requests.get(url) #构造一个向服务器请求资源的Request对象#返回一个包含服务器资源的Response对象完整方法：requests.get(url, params=None, **kwargs)url: 拟获取页面的url链接params: url中的额外参数， 字典或字节流格式， 可选**kwargs : 12个控制访问的参数，与request()的一样实际上是这样的：12345678910def get(url, params=None, **kwargs): #Sends a GET request. #:param url: URL for the new :class :'Request' object. #:param params: (optional) Dictionary ro bytes to be sent in the query #:return: :class :'Request &lt;Response&gt;' object #:rtype: requests.Response kwargs.setdefault('allow redirect', True) return request('get', url, params=params, **kwargs)例子：1234567891011import requestsr = requests.get("http://www.baidu.com")print(r)type(r)r.headers"""输出：200&lt;class 'requests.models.Response'&gt;&#123;'Transfer-Encoding': 'chunked', 'Pragma': 'no-cache', 'Connection': 'Keep-Alive', 'Last-Modified': 'Mon, 23 Jan 2017 13:27:52 GMT', 'Cache-Control': 'private, no-cache, no-store, proxy-revalidate, no-transform', 'Server': 'bfe/1.0.8.18', 'Set-Cookie': 'BDORZ=27315; max-age=86400; domain=.baidu.com; path=/', 'Content-Encoding': 'gzip', 'Date': 'Sat, 15 Jul 2017 13:27:01 GMT', 'Content-Type': 'text/html'&#125;"""Response对象的属性属性说明r.status_codeHTTP请求的返回状态，200表示连接成功，404表示失败r.textHTTP响应内容的字符串形式，即，url对应的页面内容r.encoding从HTTP header中猜测的响应内容编码方式r.apparent_encoding从内容中分析出的响应内容编码方式(备用编码凡是)r.contentHTTP响应内容的二进制形式[注]：r.encoding: 如果header中不存在charset， 则认为编码为ISO-8859-1Requests库的head()方法12345678r = requests.head('http://httpbin.org/get')r.headersr.text"""输出：&#123;'Access-Control-Allow-Credentials': 'true', 'X-Processed-Time': '0.000805139541626', 'Via': '1.1 vegur', 'Access-Control-Allow-Origin': '*', 'X-Powered-By': 'Flask', 'Content-Length': '267', 'Server': 'meinheld/0.6.1', 'Content-Type': 'application/json', 'Date': 'Sat, 15 Jul 2017 14:23:41 GMT', 'Connection': 'keep-alive'&#125;'' -- r.text"""Requests库的post()方法123456789101112131415161718192021222324252627payload = &#123;'key1':'value1', 'key2':'value2'&#125;r = requests.post('http://httpbin.org/post', data = payload)r = requests.post('http://httpbin.org/post', data = 'ABC')#向URL POST一个字典自动编码为form(表单)print(r.text)"""输出:&#123; "args": &#123;&#125;, "data": "ABC", --- &gt; 向URLPOST一个字符串，自动编码为data "files": &#123;&#125;, "form": &#123; "key1": "value1", "key2": "value2" &#125;, "headers": &#123; "Accept": "*/*", "Accept-Encoding": "gzip, deflate", "Connection": "close", "Content-Length": "23", "Content-Type": "application/x-www-form-urlencoded", "Host": "httpbin.org", "User-Agent": "python-requests/2.18.1" &#125;, "json": null, "origin": "120.85.181.141", "url": "http://httpbin.org/post""""Requests库的put()方法1234payload = &#123;'key1':'value1', 'key2':'value2'&#125;r = requests.put('http://httpbin.org/put', data = payload)print(r.text)#此方法与post方法类似，只不过是替换了URL位置上资源的内容]]></content>
      <categories>
        <category>Python</category>
        <category>python爬虫</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>Requests库</tag>
      </tags>
  </entry>
</search>
